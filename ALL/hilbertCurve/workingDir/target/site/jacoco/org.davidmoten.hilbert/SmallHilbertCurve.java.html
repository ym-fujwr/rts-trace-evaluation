<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SmallHilbertCurve.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hilbert-curve</a> &gt; <a href="index.source.html" class="el_package">org.davidmoten.hilbert</a> &gt; <span class="el_source">SmallHilbertCurve.java</span></div><h1>SmallHilbertCurve.java</h1><pre class="source lang-java linenums">package org.davidmoten.hilbert;

import java.util.ArrayList;
import java.util.List;
import java.util.SortedSet;
import java.util.TreeSet;

import com.github.davidmoten.guavamini.Preconditions;

/**
 * Converts between Hilbert index ({@code BigInteger}) and N-dimensional points.
 * 
 * &lt;p&gt;
 * Note: This algorithm is derived from work done by John Skilling and published
 * in &quot;Programming the Hilbert curve&quot;. (c) 2004 American Institute of Physics.
 * With thanks also to Paul Chernoch who published a C# algorithm for Skilling's
 * work on StackOverflow and
 * &lt;a href=&quot;https://github.com/paulchernoch/HilbertTransformation&quot;&gt;GitHub&lt;/a&gt;).
 */
public final class SmallHilbertCurve {

    private final int bits;
    private final int dimensions;
    private final int length;

<span class="fc" id="L26">    private SmallHilbertCurve(int bits, int dimensions) {</span>
<span class="fc" id="L27">        this.bits = bits;</span>
<span class="fc" id="L28">        this.dimensions = dimensions;</span>
<span class="fc" id="L29">        this.length = bits * dimensions;</span>
<span class="fc" id="L30">    }</span>

    /**
     * Converts a point to its Hilbert curve index.
     * 
     * @param point an array of {@code long}. Each coordinate can be between 0 and
     *              2&lt;sup&gt;bits&lt;/sup&gt;-1.
     * @return index {@code long} in the range 0 to 2&lt;sup&gt;bits * dimensions&lt;/sup&gt; -
     *         1
     * @throws IllegalArgumentException if length of point array is not equal to the
     *                                  number of dimensions.
     */
    public long index(long... point) {
<span class="fc bfc" id="L43" title="All 2 branches covered.">        Preconditions.checkArgument(point.length == dimensions);</span>
<span class="fc" id="L44">        return toIndex(HilbertCurve.transposedIndex(bits, point));</span>
    }

    /**
     * Converts a {@code long} index (distance along the Hilbert Curve from 0) to a
     * point of dimensions defined in the constructor of {@code this}.
     * 
     * @param index index along the Hilbert Curve from 0. Maximum value 2 &lt;sup&gt;bits
     *              * dimensions&lt;/sup&gt;-1.
     * @return array of longs being the point
     * @throws IllegalArgumentException if index is negative
     */
    public long[] point(long index) {
<span class="fc" id="L57">        return HilbertCurve.transposedIndexToPoint(bits, transposeLong(index));</span>
    }

    public void point(long index, long[] x) {
<span class="fc" id="L61">        Util.zero(x);</span>
<span class="fc" id="L62">        transposeLong(index, x);</span>
<span class="fc" id="L63">        HilbertCurve.transposedIndexToPoint(bits, x);</span>
<span class="fc" id="L64">    }</span>

    // untranspose
    private long toIndex(long... transposedIndex) {
<span class="fc" id="L68">        long b = 0;</span>
<span class="fc" id="L69">        int bIndex = length - 1;</span>
<span class="fc" id="L70">        long mask = 1L &lt;&lt; (bits - 1);</span>
<span class="fc bfc" id="L71" title="All 2 branches covered.">        for (int i = 0; i &lt; bits; i++) {</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">            for (int j = 0; j &lt; transposedIndex.length; j++) {</span>
<span class="fc bfc" id="L73" title="All 2 branches covered.">                if ((transposedIndex[j] &amp; mask) != 0) {</span>
<span class="fc" id="L74">                    b |= 1L &lt;&lt; bIndex;</span>
                }
<span class="fc" id="L76">                bIndex--;</span>
            }
<span class="fc" id="L78">            mask &gt;&gt;= 1;</span>
        }
        // b is expected to be BigEndian
<span class="fc" id="L81">        return b;</span>
    }

    private void transposeLong(long index, long[] x) {
<span class="fc bfc" id="L85" title="All 2 branches covered.">        for (int idx = 0; idx &lt; 64; idx++) {</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">            if ((index &amp; (1L &lt;&lt; idx)) != 0) {</span>
<span class="fc" id="L87">                int dim = (length - idx - 1) % dimensions;</span>
<span class="fc" id="L88">                int shift = (idx / dimensions) % bits;</span>
<span class="fc" id="L89">                x[dim] |= 1L &lt;&lt; shift;</span>
            }
        }
<span class="fc" id="L92">    }</span>

    private long[] transposeLong(long index) {
<span class="fc" id="L95">        long[] x = new long[dimensions];</span>
<span class="fc" id="L96">        transposeLong(index, x);</span>
<span class="fc" id="L97">        return x;</span>
    }

    /////////////////////////////////////////////////
    // Query support
    ////////////////////////////////////////////////

    public Ranges query(long[] a, long[] b, int maxRanges) {
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">        Preconditions.checkArgument(maxRanges &gt;= 0);</span>
        // TODO optimise this by joining ranges as they are found
        // instead of joining them at the end
<span class="fc" id="L108">        Ranges ranges = query(a, b);</span>
<span class="pc bpc" id="L109" title="1 of 4 branches missed.">        if (maxRanges &gt;= ranges.size() || maxRanges == 0) {</span>
<span class="fc" id="L110">            return ranges;</span>
        } else {
<span class="fc" id="L112">            return ranges.join(ranges.size() - maxRanges);</span>
        }
    }

    /**
     * Returns a list of index ranges exactly covering the region bounded by
     * {@code a} and {@code b}.
     * 
     * @param a one vertex of the region
     * @param b the opposing vertex to a
     */
    public Ranges query(long[] a, long[] b) {
<span class="fc" id="L124">        Box box = new Box(a, b);</span>
<span class="fc" id="L125">        SortedSet&lt;Long&gt; set = new TreeSet&lt;&gt;();</span>
<span class="fc" id="L126">        box.visitPerimeter(cell -&gt; {</span>
<span class="fc" id="L127">            long n = index(cell);</span>
<span class="fc" id="L128">            set.add(n);</span>
<span class="fc" id="L129">        });</span>
<span class="fc" id="L130">        List&lt;Long&gt; list = new ArrayList&lt;&gt;(set);</span>
<span class="fc" id="L131">        int i = 0;</span>
<span class="fc" id="L132">        List&lt;Range&gt; ranges = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L133">        long rangeStart = -1;</span>
        while (true) {
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">            if (i == list.size()) {</span>
<span class="nc" id="L136">                break;</span>
            }
<span class="fc bfc" id="L138" title="All 2 branches covered.">            if (rangeStart == -1) {</span>
<span class="fc" id="L139">                rangeStart = list.get(i);</span>
            }
<span class="fc bfc" id="L141" title="All 4 branches covered.">            while (i &lt; list.size() - 1 &amp;&amp; list.get(i + 1) == list.get(i) + 1) {</span>
<span class="fc" id="L142">                i++;</span>
            }
<span class="fc bfc" id="L144" title="All 2 branches covered.">            if (i == list.size() - 1) {</span>
<span class="fc" id="L145">                ranges.add(Range.create(rangeStart, list.get(i)));</span>
<span class="fc" id="L146">                break;</span>
            }
<span class="fc" id="L148">            long[] point = point(list.get(i) + 1);</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">            if (box.contains(point)) {</span>
                // is not on the perimeter (would have been caught in previous while loop)
                // so is internal to the box which means the next value in the sorted hilbert
                // curve indexes for the perimiter must be where it exits
<span class="fc" id="L153">                i += 1;</span>
            } else {
<span class="fc" id="L155">                ranges.add(Range.create(rangeStart, list.get(i)));</span>
<span class="fc" id="L156">                rangeStart = -1;</span>
<span class="fc" id="L157">                i++;</span>
            }
<span class="fc" id="L159">        }</span>
<span class="fc" id="L160">        return new Ranges(ranges);</span>
    }

    public Ranges2 query2(long[] a, long[] b, int maxRanges) {
<span class="nc" id="L164">        Box box = new Box(a, b);</span>
<span class="nc" id="L165">        SortedSet&lt;Long&gt; set = new TreeSet&lt;&gt;();</span>
<span class="nc" id="L166">        box.visitPerimeter(cell -&gt; {</span>
<span class="nc" id="L167">            long n = index(cell);</span>
<span class="nc" id="L168">            set.add(n);</span>
<span class="nc" id="L169">        });</span>
<span class="nc" id="L170">        List&lt;Long&gt; list = new ArrayList&lt;&gt;(set);</span>
<span class="nc" id="L171">        int i = 0;</span>
<span class="nc" id="L172">        Ranges2 ranges = new Ranges2(maxRanges);</span>
<span class="nc" id="L173">        long rangeStart = -1;</span>
        while (true) {
<span class="nc bnc" id="L175" title="All 2 branches missed.">            if (i == list.size()) {</span>
<span class="nc" id="L176">                break;</span>
            }
<span class="nc bnc" id="L178" title="All 2 branches missed.">            if (rangeStart == -1) {</span>
<span class="nc" id="L179">                rangeStart = list.get(i);</span>
            }
<span class="nc bnc" id="L181" title="All 4 branches missed.">            while (i &lt; list.size() - 1 &amp;&amp; list.get(i + 1) == list.get(i) + 1) {</span>
<span class="nc" id="L182">                i++;</span>
            }
<span class="nc bnc" id="L184" title="All 2 branches missed.">            if (i == list.size() - 1) {</span>
<span class="nc" id="L185">                ranges.add(Range.create(rangeStart, list.get(i)));</span>
<span class="nc" id="L186">                break;</span>
            }
<span class="nc" id="L188">            long[] point = point(list.get(i) + 1);</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">            if (box.contains(point)) {</span>
                // is not on the perimeter (would have been caught in previous while loop)
                // so is internal to the box which means the next value in the sorted hilbert
                // curve indexes for the perimiter must be where it exits
<span class="nc" id="L193">                i += 1;</span>
            } else {
<span class="nc" id="L195">                ranges.add(Range.create(rangeStart, list.get(i)));</span>
<span class="nc" id="L196">                rangeStart = -1;</span>
<span class="nc" id="L197">                i++;</span>
            }
<span class="nc" id="L199">        }</span>
<span class="nc" id="L200">        return ranges;</span>
    }
    
    public static final class Builder {
        private int bits;

<span class="fc" id="L206">        Builder() {</span>
            // private instantiation
<span class="fc" id="L208">        }</span>

        public Builder bits(int bits) {
<span class="fc" id="L211">            this.bits = bits;</span>
<span class="fc" id="L212">            return this;</span>
        }

        public SmallHilbertCurve dimensions(int dimensions) {
<span class="fc bfc" id="L216" title="All 2 branches covered.">            Preconditions.checkArgument(bits * dimensions &lt;= 63,</span>
                    &quot;bits * dimensions must be less than or equal to 63&quot;);
<span class="fc" id="L218">            return new SmallHilbertCurve(bits, dimensions);</span>
        }

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>