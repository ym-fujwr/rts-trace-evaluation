<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ToXmlGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jackson-dataformat-XML</a> &gt; <a href="index.source.html" class="el_package">com.fasterxml.jackson.dataformat.xml.ser</a> &gt; <span class="el_source">ToXmlGenerator.java</span></div><h1>ToXmlGenerator.java</h1><pre class="source lang-java linenums">package com.fasterxml.jackson.dataformat.xml.ser;

import java.io.*;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.*;

import javax.xml.XMLConstants;
import javax.xml.namespace.QName;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamWriter;

import com.fasterxml.jackson.dataformat.xml.XmlNameProcessor;
import org.codehaus.stax2.XMLStreamWriter2;
import org.codehaus.stax2.ri.Stax2WriterAdapter;

import com.fasterxml.jackson.core.*;
import com.fasterxml.jackson.core.base.GeneratorBase;
import com.fasterxml.jackson.core.io.IOContext;
import com.fasterxml.jackson.core.json.JsonWriteContext;
import com.fasterxml.jackson.core.util.JacksonFeatureSet;
import com.fasterxml.jackson.dataformat.xml.XmlPrettyPrinter;
import com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter;
import com.fasterxml.jackson.dataformat.xml.util.StaxUtil;

/**
 * {@link JsonGenerator} that outputs JAXB-style XML output instead of JSON content.
 * Operation requires calling code (usually either standard Jackson serializers,
 * or in some cases (like &lt;code&gt;BeanSerializer&lt;/code&gt;) customized ones) to do
 * additional configuration calls beyond regular {@link JsonGenerator} API,
 * mostly to pass namespace information.
 */
public class ToXmlGenerator
// non-final since 2.12 but only sub-class if you really know what you are doing...
    extends GeneratorBase
{
    /**
     * If we support optional definition of element names, this is the element
     * name to use...
     */
    protected final static String DEFAULT_UNKNOWN_ELEMENT = &quot;unknown&quot;;

    /**
     * Enumeration that defines all togglable extra XML-specific features
     */
<span class="fc" id="L46">    public enum Feature implements FormatFeature</span>
    {
        /**
         * Feature that controls whether XML declaration should be written before
         * when generator is initialized (true) or not (false)
         */
<span class="fc" id="L52">        WRITE_XML_DECLARATION(false),</span>

        /**
         * Feature that controls whether output should be done as XML 1.1; if so,
         * certain aspects may differ from default (1.0) processing: for example,
         * XML declaration will be automatically added (regardless of setting
         * &lt;code&gt;WRITE_XML_DECLARATION&lt;/code&gt;) as this is required for reader to
         * know to use 1.1 compliant handling. XML 1.1 can be used to allow quoted
         * control characters (Ascii codes 0 through 31) as well as additional linefeeds
         * and name characters.
         */
<span class="fc" id="L63">        WRITE_XML_1_1(false),</span>

        /**
         * Feature that controls whether serialization of Java {@code null} values adds
         * XML attribute of `xsi:nil`, as defined by XML Schema (see
         * &lt;a href=&quot;https://www.oreilly.com/library/view/xml-in-a/0596007647/re166.html&quot;&gt;this article&lt;/a&gt;
         * for details) or not.
         * If enabled, `xsi:nil` attribute will be added to the empty element; if disabled,
         * it will not.
         *&lt;p&gt;
         * Feature is disabled by default for backwards compatibility.
         *
         * @since 2.10
         */
<span class="fc" id="L77">        WRITE_NULLS_AS_XSI_NIL(false),</span>

        /**
         * Feature that determines writing of root values of type {@code ObjectNode}
         * ({@code JsonNode} subtype that represents Object content values),
         * regarding XML output.
         * If enabled and {@code ObjectNode} has exactly one entry (key/value pair),
         * then key of that entry is used as the root element name (and value
         * is written as contents. Otherwise (if feature disabled, or if root
         * {@code ObjectNode} has any other number of key/value entries,
         * root element name is determined using normal logic (either explicitly
         * configured, or {@code ObjectNode} otherwise).
         *&lt;p&gt;
         * Default setting is {@code disabled} in Jackson 2.x, for backwards compatibility:
         * likely to be changed in 3.0 to {@code enabled}.
         *
         * @since 2.13
         */
<span class="fc" id="L95">        UNWRAP_ROOT_OBJECT_NODE(false),</span>
        ;

        final boolean _defaultState;
        final int _mask;

        /**
         * Method that calculates bit set (flags) of all features that
         * are enabled by default.
         */
        public static int collectDefaults()
        {
<span class="fc" id="L107">            int flags = 0;</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">            for (Feature f : values()) {</span>
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">                if (f.enabledByDefault()) {</span>
<span class="nc" id="L110">                    flags |= f.getMask();</span>
                }
            }
<span class="fc" id="L113">            return flags;</span>
        }

<span class="fc" id="L116">        private Feature(boolean defaultState) {</span>
<span class="fc" id="L117">            _defaultState = defaultState;</span>
<span class="fc" id="L118">            _mask = (1 &lt;&lt; ordinal());</span>
<span class="fc" id="L119">        }</span>

<span class="fc" id="L121">        @Override public boolean enabledByDefault() { return _defaultState; }</span>
<span class="fc" id="L122">        @Override public int getMask() { return _mask; }</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">        @Override public boolean enabledIn(int flags) { return (flags &amp; getMask()) != 0; }</span>
    }

    /*
    /**********************************************************
    /* Configuration
    /**********************************************************
     */

    protected final XMLStreamWriter2 _xmlWriter;

    protected final XMLStreamWriter _originalXmlWriter;
    
    /**
     * Marker flag set if the underlying stream writer has to emulate
     * Stax2 API: this is problematic if trying to use {@link #writeRaw} calls.
     */
    protected final boolean _stax2Emulation;

    /**
     * @since 2.16
     */
    protected final StreamWriteConstraints _streamWriteConstraints;

    /**
     * Bit flag composed of bits that indicate which
     * {@link ToXmlGenerator.Feature}s
     * are enabled.
     */
    protected int _formatFeatures;

    /**
     * We may need to use XML-specific indentation as well
     */
    protected XmlPrettyPrinter _xmlPrettyPrinter;

    /**
     * Escapes names with invalid XML characters
     *
     * @since 2.14
     */
    protected XmlNameProcessor _nameProcessor;

    /*
    /**********************************************************
    /* XML Output state
    /**********************************************************
     */

    /**
     * Marker set when {@link #initGenerator()} has been called or not.
     * 
     * @since 2.2
     */
    protected boolean _initialized;

    /**
     * Element or attribute name to use for next output call.
     * Assigned by either code that initiates serialization
     * or bean serializer.
     */
<span class="fc" id="L184">    protected QName _nextName = null;</span>

    /**
     * Marker flag that indicates whether next name to write
     * implies an attribute (true) or element (false)
     */
<span class="fc" id="L190">    protected boolean _nextIsAttribute = false;</span>

    /**
     * Marker flag used to indicate that the next write of a (property)
     * value should be done without using surrounding start/end
     * elements. Flag is to be cleared once unwrapping has been triggered
     * once.
     */
<span class="fc" id="L198">    protected boolean _nextIsUnwrapped = false;</span>

    /**
     * Marker flag used to indicate that the next write of a (property)
     * value should be as CData
     */
<span class="fc" id="L204">    protected boolean _nextIsCData = false;</span>

    /**
     * To support proper serialization of arrays it is necessary to keep
     * stack of element names, so that we can &quot;revert&quot; to earlier 
     */
<span class="fc" id="L210">    protected LinkedList&lt;QName&gt; _elementNameStack = new LinkedList&lt;QName&gt;();</span>

    /**
     * Reusable internal value object
     *
     * @since 2.14
     */
<span class="fc" id="L217">    protected XmlNameProcessor.XmlName _nameToEncode = new XmlNameProcessor.XmlName();</span>

    /*
    /**********************************************************
    /* Life-cycle
    /**********************************************************
     */

    public ToXmlGenerator(IOContext ctxt, int stdFeatures, int xmlFeatures,
            ObjectCodec codec, XMLStreamWriter sw, XmlNameProcessor nameProcessor)
    {
<span class="fc" id="L228">        super(stdFeatures, codec, ctxt);</span>
<span class="fc" id="L229">        _formatFeatures = xmlFeatures;</span>
<span class="fc" id="L230">        _streamWriteConstraints = ctxt.streamWriteConstraints();</span>
<span class="fc" id="L231">        _originalXmlWriter = sw;</span>
<span class="fc" id="L232">        _xmlWriter = Stax2WriterAdapter.wrapIfNecessary(sw);</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">        _stax2Emulation = (_xmlWriter != sw);</span>
<span class="fc" id="L234">        _nameProcessor = nameProcessor;</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">        _xmlPrettyPrinter = (_cfgPrettyPrinter instanceof XmlPrettyPrinter) ?</span>
<span class="pc" id="L236">        		(XmlPrettyPrinter) _cfgPrettyPrinter : null;</span>
<span class="fc" id="L237">    }</span>

    /**
     * Method called before writing any other output, to optionally
     * output XML declaration.
     */
    public void initGenerator()  throws IOException
    {
<span class="fc bfc" id="L245" title="All 2 branches covered.">        if (_initialized) {</span>
<span class="fc" id="L246">            return;</span>
        }
<span class="fc" id="L248">        _initialized = true;</span>
        try {
<span class="fc bfc" id="L250" title="All 2 branches covered.">            if (Feature.WRITE_XML_1_1.enabledIn(_formatFeatures)) {</span>
<span class="fc" id="L251">                _xmlWriter.writeStartDocument(&quot;UTF-8&quot;, &quot;1.1&quot;);</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">            } else if (Feature.WRITE_XML_DECLARATION.enabledIn(_formatFeatures)) {</span>
<span class="fc" id="L253">                _xmlWriter.writeStartDocument(&quot;UTF-8&quot;, &quot;1.0&quot;);</span>
            } else {
<span class="fc" id="L255">                return;</span>
            }
            // as per [dataformat-xml#172], try adding indentation
<span class="fc bfc" id="L258" title="All 2 branches covered.">            if (_xmlPrettyPrinter != null) {</span>
                // ... but only if it is likely to succeed:
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">                if (!_stax2Emulation) {</span>
<span class="fc" id="L261">                    _xmlPrettyPrinter.writePrologLinefeed(_xmlWriter);</span>
                }
            }
<span class="nc" id="L264">        } catch (XMLStreamException e) {</span>
<span class="nc" id="L265">            StaxUtil.throwAsGenerationException(e, this);</span>
<span class="fc" id="L266">        }</span>
<span class="fc" id="L267">    }</span>

    /*
    /**********************************************************
    /* Overridden methods, configuration
    /**********************************************************
     */

    @Override
    protected PrettyPrinter _constructDefaultPrettyPrinter() {
<span class="nc" id="L277">        return new DefaultXmlPrettyPrinter();</span>
    }

    @Override
    public JsonGenerator setPrettyPrinter(PrettyPrinter pp) {
<span class="fc" id="L282">        _cfgPrettyPrinter = pp;</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">        _xmlPrettyPrinter = (pp instanceof XmlPrettyPrinter) ?</span>
<span class="pc" id="L284">               (XmlPrettyPrinter) pp : null;</span>
<span class="fc" id="L285">        return this;</span>
    }

    @Override
    public Object getOutputTarget() {
        // Stax2 does not expose underlying target, so best we can do is to return
        // the Stax XMLStreamWriter instance:
<span class="nc" id="L292">        return _originalXmlWriter;</span>
    }

    /**
     * Stax2 does not expose buffered content amount, so we can only return
     * &lt;code&gt;-1&lt;/code&gt; from here
     */
    @Override
    public int getOutputBuffered() {
<span class="nc" id="L301">        return -1;</span>
    }

    @Override
    public int getFormatFeatures() {
<span class="nc" id="L306">        return _formatFeatures;</span>
    }

    @Override // since 2.7
    public JsonGenerator overrideFormatFeatures(int values, int mask)
    {
<span class="fc" id="L312">        int oldF = _formatFeatures;</span>
<span class="fc" id="L313">        int newF = (_formatFeatures &amp; ~mask) | (values &amp; mask);</span>

<span class="fc bfc" id="L315" title="All 2 branches covered.">        if (oldF != newF) {</span>
<span class="fc" id="L316">            _formatFeatures = newF;</span>
        }
<span class="fc" id="L318">        return this;</span>
    }

    /*
    /**********************************************************
    /* Extended API, configuration
    /**********************************************************
     */

    @Override
    public StreamWriteConstraints streamWriteConstraints() {
<span class="fc" id="L329">        return _streamWriteConstraints;</span>
    }

    public ToXmlGenerator enable(Feature f) {
<span class="nc" id="L333">        _formatFeatures |= f.getMask();</span>
<span class="nc" id="L334">        return this;</span>
    }

    public ToXmlGenerator disable(Feature f) {
<span class="nc" id="L338">        _formatFeatures &amp;= ~f.getMask();</span>
<span class="nc" id="L339">        return this;</span>
    }

    public final boolean isEnabled(Feature f) {
<span class="fc bfc" id="L343" title="All 2 branches covered.">        return (_formatFeatures &amp; f.getMask()) != 0;</span>
    }

    public ToXmlGenerator configure(Feature f, boolean state) {
<span class="nc bnc" id="L347" title="All 2 branches missed.">        if (state) {</span>
<span class="nc" id="L348">            enable(f);</span>
        } else {
<span class="nc" id="L350">            disable(f);</span>
        }
<span class="nc" id="L352">        return this;</span>
    }

    @Override
<span class="nc" id="L356">    public boolean canWriteFormattedNumbers() { return true; }</span>

    @Override // @since 2.12
    public JacksonFeatureSet&lt;StreamWriteCapability&gt; getWriteCapabilities() {
<span class="nc" id="L360">        return DEFAULT_TEXTUAL_WRITE_CAPABILITIES;</span>
    }

    // @since 2.7.5
    public boolean inRoot() {
<span class="fc" id="L365">        return _writeContext.inRoot();</span>
    }

    /*
    /**********************************************************
    /* Extended API, access to some internal components
    /**********************************************************
     */

    /**
     * Method that allows application direct access to underlying
     * Stax {@link XMLStreamWriter}. Note that use of writer is
     * discouraged, and may interfere with processing of this writer;
     * however, occasionally it may be necessary.
     *&lt;p&gt;
     * Note: writer instance will always be of type
     * {@link org.codehaus.stax2.XMLStreamWriter2} (including
     * Typed Access API) so upcasts are safe.
     */
    public XMLStreamWriter getStaxWriter() {
<span class="fc" id="L385">        return _xmlWriter;</span>
    }
    
    /*
    /**********************************************************
    /* Extended API, passing XML specific settings
    /**********************************************************
     */

    public void setNextIsAttribute(boolean isAttribute)
    {
<span class="fc" id="L396">        _nextIsAttribute = isAttribute;</span>
<span class="fc" id="L397">    }</span>

    public void setNextIsUnwrapped(boolean isUnwrapped)
    {
<span class="fc" id="L401">        _nextIsUnwrapped = isUnwrapped;</span>
<span class="fc" id="L402">    }</span>

    public void setNextIsCData(boolean isCData)
    {
<span class="fc" id="L406">        _nextIsCData = isCData;</span>
<span class="fc" id="L407">    }</span>
    
    public final void setNextName(QName name)
    {
<span class="fc" id="L411">        _nextName = name;</span>
<span class="fc" id="L412">    }</span>

    /**
     * Method that does same as {@link #setNextName}, unless
     * a name has already been set.
     * 
     * @since 2.1.2
     */
    public final boolean setNextNameIfMissing(QName name)
    {
<span class="fc bfc" id="L422" title="All 2 branches covered.">        if (_nextName == null) {</span>
<span class="fc" id="L423">            _nextName = name;</span>
<span class="fc" id="L424">            return true;</span>
        }
<span class="fc" id="L426">        return false;</span>
    }
    
    /**
     * Methdod called when a structured (collection, array, map) is being
     * output.
     * 
     * @param wrapperName Element used as wrapper around elements, if any (null if none)
     * @param wrappedName Element used around individual content items (can not
     *   be null)
     */
    public void startWrappedValue(QName wrapperName, QName wrappedName) throws IOException
    {
<span class="pc bpc" id="L439" title="1 of 2 branches missed.">        if (wrapperName != null) {</span>
            try {
<span class="fc bfc" id="L441" title="All 2 branches covered.">                if (_xmlPrettyPrinter != null) {</span>
<span class="fc" id="L442">                    _xmlPrettyPrinter.writeStartElement(_xmlWriter,</span>
<span class="fc" id="L443">                            wrapperName.getNamespaceURI(), wrapperName.getLocalPart());</span>
                } else {
<span class="fc" id="L445">                    _xmlWriter.writeStartElement(wrapperName.getNamespaceURI(), wrapperName.getLocalPart());</span>
                }
<span class="nc" id="L447">            } catch (XMLStreamException e) {</span>
<span class="nc" id="L448">                StaxUtil.throwAsGenerationException(e, this);</span>
<span class="fc" id="L449">            }</span>
        }
<span class="fc" id="L451">        this.setNextName(wrappedName);</span>
<span class="fc" id="L452">    }</span>

    /**
     * Method called after a structured collection output has completed
     */
    public void finishWrappedValue(QName wrapperName, QName wrappedName) throws IOException
    {
        // First: wrapper to close?
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">        if (wrapperName != null) {</span>
            try {
<span class="fc bfc" id="L462" title="All 2 branches covered.">                if (_xmlPrettyPrinter != null) {</span>
<span class="fc" id="L463">                    _xmlPrettyPrinter.writeEndElement(_xmlWriter, _writeContext.getEntryCount());</span>
                } else {
<span class="fc" id="L465">                    _xmlWriter.writeEndElement();</span>
                }
<span class="nc" id="L467">            } catch (XMLStreamException e) {</span>
<span class="nc" id="L468">                StaxUtil.throwAsGenerationException(e, this);</span>
<span class="fc" id="L469">            }</span>
        }
<span class="fc" id="L471">    }</span>

    /**
     * Trivial helper method called when to add a replicated wrapper name
     * 
     * @since 2.2
     */
    public void writeRepeatedFieldName() throws IOException
    {
<span class="nc bnc" id="L480" title="All 2 branches missed.">        if (_writeContext.writeFieldName(_nextName.getLocalPart()) == JsonWriteContext.STATUS_EXPECT_VALUE) {</span>
<span class="nc" id="L481">            _reportError(&quot;Can not write a field name, expecting a value&quot;);</span>
        }
<span class="nc" id="L483">    }</span>
    
    /*
    /**********************************************************
    /* JsonGenerator method overrides
    /**********************************************************
     */
    
    /* Most overrides in this section are just to make methods final,
     * to allow better inlining...
     */

    @Override
    public final void writeFieldName(String name) throws IOException
    {
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">        if (_writeContext.writeFieldName(name) == JsonWriteContext.STATUS_EXPECT_VALUE) {</span>
<span class="nc" id="L499">            _reportError(&quot;Can not write a field name, expecting a value&quot;);</span>
        }
        // Should this ever get called?
<span class="pc bpc" id="L502" title="1 of 2 branches missed.">        String ns = (_nextName == null) ? &quot;&quot; : _nextName.getNamespaceURI();</span>
<span class="fc" id="L503">        _nameToEncode.namespace = ns;</span>
<span class="fc" id="L504">        _nameToEncode.localPart = name;</span>
<span class="fc" id="L505">        _nameProcessor.encodeName(_nameToEncode);</span>
<span class="fc" id="L506">        setNextName(new QName(_nameToEncode.namespace, _nameToEncode.localPart));</span>
<span class="fc" id="L507">    }</span>

    @Override
    public final void writeStringField(String fieldName, String value) throws IOException
    {
<span class="fc" id="L512">        writeFieldName(fieldName);</span>
<span class="fc" id="L513">        writeString(value);</span>
<span class="fc" id="L514">    }</span>

    // 03-Aug-2017, tatu: We could use this as mentioned in comment below BUT
    //    since there is no counterpart for deserialization this will not
    //    help us. Approaches that could/would help probably require different
    //    handling...
    //
    //    See [dataformat-xml#4] for more context.
    
    /*
    // @since 2.9
    public WritableTypeId writeTypePrefix(WritableTypeId typeIdDef) throws IOException
    {
        // 03-Aug-2017, tatu: Due to XML oddities, we do need to massage things
        //     a bit: specifically, change WRAPPER_ARRAY into WRAPPER_OBJECT, always
        if (typeIdDef.include == WritableTypeId.Inclusion.WRAPPER_ARRAY) {
            typeIdDef.include = WritableTypeId.Inclusion.WRAPPER_OBJECT;
        }
        return super.writeTypePrefix(typeIdDef);
    }
    */

    /*
    /**********************************************************
    /* JsonGenerator output method implementations, structural
    /**********************************************************
     */

    @Override
    public final void writeStartArray() throws IOException
    {
<span class="fc" id="L545">        _verifyValueWrite(&quot;start an array&quot;);</span>
<span class="fc" id="L546">        _writeContext = _writeContext.createChildArrayContext();</span>
<span class="fc" id="L547">        streamWriteConstraints().validateNestingDepth(_writeContext.getNestingDepth());</span>
<span class="fc bfc" id="L548" title="All 2 branches covered.">        if (_cfgPrettyPrinter != null) {</span>
<span class="fc" id="L549">            _cfgPrettyPrinter.writeStartArray(this);</span>
        } else {
            // nothing to do here; no-operation
        }
<span class="fc" id="L553">    }</span>
    
    @Override
    public final void writeEndArray() throws IOException
    {
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">        if (!_writeContext.inArray()) {</span>
<span class="nc" id="L559">            _reportError(&quot;Current context not Array but &quot;+_writeContext.typeDesc());</span>
        }
<span class="fc bfc" id="L561" title="All 2 branches covered.">        if (_cfgPrettyPrinter != null) {</span>
<span class="fc" id="L562">            _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());</span>
        } else {
            // nothing to do here; no-operation
        }
<span class="fc" id="L566">        _writeContext = _writeContext.getParent();</span>
<span class="fc" id="L567">    }</span>

    @Override
    public final void writeStartObject() throws IOException
    {
<span class="fc" id="L572">        _verifyValueWrite(&quot;start an object&quot;);</span>
<span class="fc" id="L573">        _writeContext = _writeContext.createChildObjectContext();</span>
<span class="fc" id="L574">        streamWriteConstraints().validateNestingDepth(_writeContext.getNestingDepth());</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">        if (_cfgPrettyPrinter != null) {</span>
<span class="fc" id="L576">            _cfgPrettyPrinter.writeStartObject(this);</span>
        } else {
<span class="fc" id="L578">            _handleStartObject();</span>
        }
<span class="fc" id="L580">    }</span>

    @Override
    public final void writeEndObject() throws IOException
    {
<span class="pc bpc" id="L585" title="1 of 2 branches missed.">        if (!_writeContext.inObject()) {</span>
<span class="nc" id="L586">            _reportError(&quot;Current context not Object but &quot;+_writeContext.typeDesc());</span>
        }
<span class="fc" id="L588">        _writeContext = _writeContext.getParent();</span>
<span class="fc bfc" id="L589" title="All 2 branches covered.">        if (_cfgPrettyPrinter != null) {</span>
            // as per [Issue#45], need to suppress indentation if only attributes written:
<span class="fc bfc" id="L591" title="All 2 branches covered.">            int count = _nextIsAttribute ? 0 : _writeContext.getEntryCount();</span>
<span class="fc" id="L592">            _cfgPrettyPrinter.writeEndObject(this, count);</span>
<span class="fc" id="L593">        } else {</span>
<span class="fc" id="L594">            _handleEndObject();</span>
        }
<span class="fc" id="L596">    }</span>

    // note: public just because pretty printer needs to make a callback
    public final void _handleStartObject() throws IOException
    {
<span class="pc bpc" id="L601" title="1 of 2 branches missed.">        if (_nextName == null) {</span>
<span class="nc" id="L602">            handleMissingName();</span>
        }
        // Need to keep track of names to make Lists work correctly
<span class="fc" id="L605">        _elementNameStack.addLast(_nextName);</span>
        try {
<span class="fc" id="L607">            _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());</span>
<span class="nc" id="L608">        } catch (XMLStreamException e) {</span>
<span class="nc" id="L609">            StaxUtil.throwAsGenerationException(e, this);</span>
<span class="fc" id="L610">        }</span>
<span class="fc" id="L611">    }</span>
    
    // note: public just because pretty printer needs to make a callback
    public final void _handleEndObject() throws IOException
    {
        // We may want to repeat same element, so:
<span class="pc bpc" id="L617" title="1 of 2 branches missed.">        if (_elementNameStack.isEmpty()) {</span>
<span class="nc" id="L618">            throw new JsonGenerationException(&quot;Can not write END_ELEMENT without open START_ELEMENT&quot;, this);</span>
        }
<span class="fc" id="L620">        _nextName = _elementNameStack.removeLast();</span>
        try {
            // note: since attributes don't nest, can only have one attribute active, so:
<span class="fc" id="L623">            _nextIsAttribute = false;</span>
<span class="fc" id="L624">            _xmlWriter.writeEndElement();</span>
            // [databind-xml#172]: possibly also need indentation
<span class="fc bfc" id="L626" title="All 4 branches covered.">            if (_elementNameStack.isEmpty() &amp;&amp; (_xmlPrettyPrinter != null)) {</span>
                // ... but only if it is likely to succeed:
<span class="pc bpc" id="L628" title="1 of 2 branches missed.">                if (!_stax2Emulation) {</span>
<span class="fc" id="L629">                    _xmlPrettyPrinter.writePrologLinefeed(_xmlWriter);</span>
                }
            }
<span class="nc" id="L632">        } catch (XMLStreamException e) {</span>
<span class="nc" id="L633">            StaxUtil.throwAsGenerationException(e, this);</span>
<span class="fc" id="L634">        }</span>
<span class="fc" id="L635">    }</span>
    
    /*
    /**********************************************************
    /* Output method implementations, textual
    /**********************************************************
     */

    @Override
    public void writeFieldName(SerializableString name) throws IOException
    {
<span class="fc" id="L646">        writeFieldName(name.getValue());</span>
<span class="fc" id="L647">    }</span>

    @Override
    public void writeString(String text) throws IOException
    {
<span class="fc bfc" id="L652" title="All 2 branches covered.">        if (text == null) { // [dataformat-xml#413]</span>
<span class="fc" id="L653">            writeNull();</span>
<span class="fc" id="L654">            return;</span>
        }
<span class="fc" id="L656">        _verifyValueWrite(&quot;write String value&quot;);</span>
<span class="pc bpc" id="L657" title="1 of 2 branches missed.">        if (_nextName == null) {</span>
<span class="nc" id="L658">            handleMissingName();</span>
        }
        try {
<span class="fc bfc" id="L661" title="All 2 branches covered.">            if (_nextIsAttribute) { // must write attribute name and value with one call</span>
<span class="fc" id="L662">                _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), text);</span>
<span class="fc bfc" id="L663" title="All 2 branches covered.">            } else if (checkNextIsUnwrapped()) {</span>
                // [dataformat-xml#56] Should figure out how to prevent indentation for end element
                //   but for now, let's just make sure structure is correct
                //if (_xmlPrettyPrinter != null) { ... }
<span class="pc bpc" id="L667" title="1 of 2 branches missed.">                if(_nextIsCData) {</span>
<span class="nc" id="L668">                    _xmlWriter.writeCData(text);</span>
                } else {
<span class="fc" id="L670">                    _xmlWriter.writeCharacters(text);</span>
                }
<span class="fc bfc" id="L672" title="All 2 branches covered.">            } else if (_xmlPrettyPrinter != null) {</span>
<span class="fc" id="L673">                _xmlPrettyPrinter.writeLeafElement(_xmlWriter,</span>
<span class="fc" id="L674">                        _nextName.getNamespaceURI(), _nextName.getLocalPart(),</span>
                        text, _nextIsCData);
            } else {
<span class="fc" id="L677">                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());</span>
<span class="fc bfc" id="L678" title="All 2 branches covered.">                if(_nextIsCData) {</span>
<span class="fc" id="L679">                    _xmlWriter.writeCData(text);</span>
                } else {
<span class="fc" id="L681">                    _xmlWriter.writeCharacters(text);</span>
                }
<span class="fc" id="L683">                _xmlWriter.writeEndElement();</span>
            } 
<span class="nc" id="L685">        } catch (XMLStreamException e) {</span>
<span class="nc" id="L686">            StaxUtil.throwAsGenerationException(e, this);</span>
<span class="fc" id="L687">        }</span>
<span class="fc" id="L688">    }    </span>
    
    @Override
    public void writeString(char[] text, int offset, int len) throws IOException
    {
<span class="nc" id="L693">        _verifyValueWrite(&quot;write String value&quot;);</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">        if (_nextName == null) {</span>
<span class="nc" id="L695">            handleMissingName();</span>
        }
        try {
<span class="nc bnc" id="L698" title="All 2 branches missed.">            if (_nextIsAttribute) {</span>
<span class="nc" id="L699">                _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), new String(text, offset, len));</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">            } else if (checkNextIsUnwrapped()) {</span>
            	// should we consider pretty-printing or not?
<span class="nc bnc" id="L702" title="All 2 branches missed.">                if(_nextIsCData) {</span>
<span class="nc" id="L703">                    _xmlWriter.writeCData(text, offset, len);</span>
                } else {
<span class="nc" id="L705">                    _xmlWriter.writeCharacters(text, offset, len);</span>
                }
<span class="nc bnc" id="L707" title="All 2 branches missed.">            } else if (_xmlPrettyPrinter != null) {</span>
<span class="nc" id="L708">                _xmlPrettyPrinter.writeLeafElement(_xmlWriter,</span>
<span class="nc" id="L709">                        _nextName.getNamespaceURI(), _nextName.getLocalPart(),</span>
                        text, offset, len, _nextIsCData);
            } else {
<span class="nc" id="L712">                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">                if(_nextIsCData) {</span>
<span class="nc" id="L714">                    _xmlWriter.writeCData(text, offset, len);</span>
                } else {
<span class="nc" id="L716">                    _xmlWriter.writeCharacters(text, offset, len);</span>
                }
<span class="nc" id="L718">                _xmlWriter.writeEndElement();</span>
            }
<span class="nc" id="L720">        } catch (XMLStreamException e) {</span>
<span class="nc" id="L721">            StaxUtil.throwAsGenerationException(e, this);</span>
<span class="nc" id="L722">        }</span>
<span class="nc" id="L723">    }</span>

    @Override
    public void writeString(SerializableString text) throws IOException {
<span class="fc" id="L727">        writeString(text.getValue());</span>
<span class="fc" id="L728">    }</span>
    
    @Override
    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException
    {
        // could add support for this case if we really want it (and can make Stax2 support it)
<span class="nc" id="L734">        _reportUnsupportedOperation();</span>
<span class="nc" id="L735">    }</span>

    @Override
    public void writeUTF8String(byte[] text, int offset, int length) throws IOException
    {
        // could add support for this case if we really want it (and can make Stax2 support it)
<span class="nc" id="L741">        _reportUnsupportedOperation();</span>
<span class="nc" id="L742">    }</span>

    /*
    /**********************************************************
    /* Output method implementations, unprocessed (&quot;raw&quot;)
    /**********************************************************
     */

    @Override
    public void writeRawValue(String text) throws IOException {
        // [dataformat-xml#39]
<span class="pc bpc" id="L753" title="1 of 2 branches missed.">        if (_stax2Emulation) {</span>
<span class="nc" id="L754">            _reportUnimplementedStax2(&quot;writeRawValue&quot;);</span>
        }
        try {
<span class="fc" id="L757">            _verifyValueWrite(&quot;write raw value&quot;);</span>
<span class="pc bpc" id="L758" title="1 of 2 branches missed.">            if (_nextName == null) {</span>
<span class="nc" id="L759">                handleMissingName();</span>
            }

<span class="fc bfc" id="L762" title="All 2 branches covered.">            if (_nextIsAttribute) {</span>
<span class="fc" id="L763">                _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), text);</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">            } else if (checkNextIsUnwrapped()) {</span>
<span class="fc" id="L765">                _xmlWriter.writeRaw(text);</span>
            } else {
<span class="fc" id="L767">                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());</span>
<span class="fc" id="L768">                _xmlWriter.writeRaw(text);</span>
<span class="fc" id="L769">                _xmlWriter.writeEndElement();</span>
            }
<span class="nc" id="L771">        } catch (XMLStreamException e) {</span>
<span class="nc" id="L772">            StaxUtil.throwAsGenerationException(e, this);</span>
<span class="fc" id="L773">        }</span>
<span class="fc" id="L774">    }</span>

    @Override
    public void writeRawValue(String text, int offset, int len) throws IOException {
        // [dataformat-xml#39]
<span class="pc bpc" id="L779" title="1 of 2 branches missed.">        if (_stax2Emulation) {</span>
<span class="nc" id="L780">            _reportUnimplementedStax2(&quot;writeRawValue&quot;);</span>
        }
        try {
<span class="fc" id="L783">            _verifyValueWrite(&quot;write raw value&quot;);</span>
<span class="pc bpc" id="L784" title="1 of 2 branches missed.">            if (_nextName == null) {</span>
<span class="nc" id="L785">                handleMissingName();</span>
            }

<span class="fc bfc" id="L788" title="All 2 branches covered.">            if (_nextIsAttribute) {</span>
<span class="fc" id="L789">                _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), text.substring(offset, offset + len));</span>
<span class="fc bfc" id="L790" title="All 2 branches covered.">            } else if (checkNextIsUnwrapped()) {</span>
<span class="fc" id="L791">                _xmlWriter.writeRaw(text, offset, len);</span>
            } else {
<span class="fc" id="L793">                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());</span>
<span class="fc" id="L794">                _xmlWriter.writeRaw(text, offset, len);</span>
<span class="fc" id="L795">                _xmlWriter.writeEndElement();</span>
            }
<span class="nc" id="L797">        } catch (XMLStreamException e) {</span>
<span class="nc" id="L798">            StaxUtil.throwAsGenerationException(e, this);</span>
<span class="fc" id="L799">        }</span>
<span class="fc" id="L800">    }</span>

    @Override
    public void writeRawValue(char[] text, int offset, int len) throws IOException {
        // [dataformat-xml#39]
<span class="pc bpc" id="L805" title="1 of 2 branches missed.">        if (_stax2Emulation) {</span>
<span class="nc" id="L806">            _reportUnimplementedStax2(&quot;writeRawValue&quot;);</span>
        }
<span class="fc" id="L808">        _verifyValueWrite(&quot;write raw value&quot;);</span>
<span class="pc bpc" id="L809" title="1 of 2 branches missed.">        if (_nextName == null) {</span>
<span class="nc" id="L810">            handleMissingName();</span>
        }
        try {
<span class="fc bfc" id="L813" title="All 2 branches covered.">            if (_nextIsAttribute) {</span>
<span class="fc" id="L814">                _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), new String(text, offset, len));</span>
<span class="fc bfc" id="L815" title="All 2 branches covered.">            } else if (checkNextIsUnwrapped()) {</span>
<span class="fc" id="L816">                _xmlWriter.writeRaw(text, offset, len);</span>
            } else {
<span class="fc" id="L818">                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());</span>
<span class="fc" id="L819">                _xmlWriter.writeRaw(text, offset, len);</span>
<span class="fc" id="L820">                _xmlWriter.writeEndElement();</span>
            }
<span class="nc" id="L822">        } catch (XMLStreamException e) {</span>
<span class="nc" id="L823">            StaxUtil.throwAsGenerationException(e, this);</span>
<span class="fc" id="L824">        }</span>
<span class="fc" id="L825">    }</span>

    @Override
    public void writeRawValue(SerializableString text) throws IOException {
<span class="nc" id="L829">        _reportUnsupportedOperation();</span>
<span class="nc" id="L830">    }</span>

    @Override
    public void writeRaw(String text) throws IOException
    {
        // [dataformat-xml#39]
<span class="pc bpc" id="L836" title="1 of 2 branches missed.">        if (_stax2Emulation) {</span>
<span class="nc" id="L837">            _reportUnimplementedStax2(&quot;writeRaw&quot;);</span>
        }
        try {
<span class="fc" id="L840">            _xmlWriter.writeRaw(text);</span>
<span class="nc" id="L841">        } catch (XMLStreamException e) {</span>
<span class="nc" id="L842">            StaxUtil.throwAsGenerationException(e, this);</span>
<span class="fc" id="L843">        }</span>
<span class="fc" id="L844">    }</span>

    @Override
    public void writeRaw(String text, int offset, int len) throws IOException
    {
        // [dataformat-xml#39]
<span class="nc bnc" id="L850" title="All 2 branches missed.">        if (_stax2Emulation) {</span>
<span class="nc" id="L851">            _reportUnimplementedStax2(&quot;writeRaw&quot;);</span>
        }
        try {
<span class="nc" id="L854">            _xmlWriter.writeRaw(text, offset, len);</span>
<span class="nc" id="L855">        } catch (XMLStreamException e) {</span>
<span class="nc" id="L856">            StaxUtil.throwAsGenerationException(e, this);</span>
<span class="nc" id="L857">        }</span>
<span class="nc" id="L858">    }</span>

    @Override
    public void writeRaw(char[] text, int offset, int len) throws IOException
    {
        // [dataformat-xml#39]
<span class="pc bpc" id="L864" title="1 of 2 branches missed.">        if (_stax2Emulation) {</span>
<span class="nc" id="L865">            _reportUnimplementedStax2(&quot;writeRaw&quot;);</span>
        }
        try {
<span class="fc" id="L868">            _xmlWriter.writeRaw(text, offset, len);</span>
<span class="nc" id="L869">        } catch (XMLStreamException e) {</span>
<span class="nc" id="L870">            StaxUtil.throwAsGenerationException(e, this);</span>
<span class="fc" id="L871">        }</span>
<span class="fc" id="L872">    }</span>

    @Override
    public void writeRaw(char c) throws IOException
    {
<span class="nc" id="L877">        writeRaw(String.valueOf(c));</span>
<span class="nc" id="L878">    }</span>
    
    /*
    /**********************************************************
    /* Output method implementations, base64-encoded binary
    /**********************************************************
     */

    @Override
    public void writeBinary(Base64Variant b64variant,
    		byte[] data, int offset, int len) throws IOException
    {
<span class="pc bpc" id="L890" title="1 of 2 branches missed.">        if (data == null) {</span>
<span class="nc" id="L891">            writeNull();</span>
<span class="nc" id="L892">            return;</span>
        }
<span class="fc" id="L894">        _verifyValueWrite(&quot;write Binary value&quot;);</span>
<span class="pc bpc" id="L895" title="1 of 2 branches missed.">        if (_nextName == null) {</span>
<span class="nc" id="L896">            handleMissingName();</span>
        }
<span class="fc" id="L898">        final org.codehaus.stax2.typed.Base64Variant stax2base64v = StaxUtil.toStax2Base64Variant(b64variant);</span>
        try {
<span class="pc bpc" id="L900" title="1 of 2 branches missed.">            if (_nextIsAttribute) {</span>
                // Stax2 API only has 'full buffer' write method:
<span class="nc" id="L902">                byte[] fullBuffer = toFullBuffer(data, offset, len);</span>
<span class="nc" id="L903">                _xmlWriter.writeBinaryAttribute(stax2base64v,</span>
<span class="nc" id="L904">                        &quot;&quot;, _nextName.getNamespaceURI(), _nextName.getLocalPart(), fullBuffer);</span>
<span class="pc bpc" id="L905" title="1 of 2 branches missed.">            } else if (checkNextIsUnwrapped()) {</span>
            	// should we consider pretty-printing or not?
<span class="nc" id="L907">                _xmlWriter.writeBinary(stax2base64v, data, offset, len);</span>
            } else {
<span class="fc bfc" id="L909" title="All 2 branches covered.">                if (_xmlPrettyPrinter != null) {</span>
<span class="fc" id="L910">                    _xmlPrettyPrinter.writeLeafElement(_xmlWriter,</span>
<span class="fc" id="L911">                            _nextName.getNamespaceURI(), _nextName.getLocalPart(),</span>
                            stax2base64v, data, offset, len);
                } else {
<span class="fc" id="L914">                    _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());</span>
<span class="fc" id="L915">                    _xmlWriter.writeBinary(stax2base64v, data, offset, len);</span>
<span class="fc" id="L916">                    _xmlWriter.writeEndElement();</span>
                }
            }
<span class="nc" id="L919">        } catch (XMLStreamException e) {</span>
<span class="nc" id="L920">            StaxUtil.throwAsGenerationException(e, this);</span>
<span class="fc" id="L921">        }</span>
<span class="fc" id="L922">    }</span>

    @Override
    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException
    {
<span class="pc bpc" id="L927" title="1 of 2 branches missed.">        if (data == null) {</span>
<span class="nc" id="L928">            writeNull();</span>
<span class="nc" id="L929">            return 0;</span>
        }
<span class="fc" id="L931">        _verifyValueWrite(&quot;write Binary value&quot;);</span>
<span class="pc bpc" id="L932" title="1 of 2 branches missed.">        if (_nextName == null) {</span>
<span class="nc" id="L933">            handleMissingName();</span>
        }
<span class="fc" id="L935">        final org.codehaus.stax2.typed.Base64Variant stax2base64v = StaxUtil.toStax2Base64Variant(b64variant);</span>
        try {
<span class="pc bpc" id="L937" title="1 of 2 branches missed.">            if (_nextIsAttribute) {</span>
                // Stax2 API only has 'full buffer' write method:
<span class="nc" id="L939">                byte[] fullBuffer = toFullBuffer(data, dataLength);</span>
<span class="nc" id="L940">                _xmlWriter.writeBinaryAttribute(stax2base64v,</span>
<span class="nc" id="L941">                        &quot;&quot;, _nextName.getNamespaceURI(), _nextName.getLocalPart(), fullBuffer);</span>
<span class="pc bpc" id="L942" title="1 of 2 branches missed.">            } else if (checkNextIsUnwrapped()) {</span>
              // should we consider pretty-printing or not?
<span class="nc" id="L944">                writeStreamAsBinary(stax2base64v, data, dataLength);</span>

            } else {
<span class="pc bpc" id="L947" title="1 of 2 branches missed.">                if (_xmlPrettyPrinter != null) {</span>
<span class="nc" id="L948">                    _xmlPrettyPrinter.writeLeafElement(_xmlWriter,</span>
<span class="nc" id="L949">                            _nextName.getNamespaceURI(), _nextName.getLocalPart(),</span>
<span class="nc" id="L950">                            stax2base64v, toFullBuffer(data, dataLength), 0, dataLength);</span>
                } else {
<span class="fc" id="L952">                    _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());</span>
<span class="fc" id="L953">                    writeStreamAsBinary(stax2base64v, data, dataLength);</span>
<span class="fc" id="L954">                    _xmlWriter.writeEndElement();</span>
                }
            }
<span class="nc" id="L957">        } catch (XMLStreamException e) {</span>
<span class="nc" id="L958">            StaxUtil.throwAsGenerationException(e, this);</span>
<span class="fc" id="L959">        }</span>

<span class="fc" id="L961">        return dataLength;</span>
    }

    private void writeStreamAsBinary(org.codehaus.stax2.typed.Base64Variant stax2base64v,
            InputStream data, int len) throws IOException, XMLStreamException 
    {
        // base64 encodes up to 3 bytes into a 4 bytes string
<span class="fc" id="L968">        byte[] tmp = new byte[3];</span>
<span class="fc" id="L969">        int offset = 0;</span>
        int read;
<span class="fc bfc" id="L971" title="All 2 branches covered.">        while((read = data.read(tmp, offset, Math.min(3 - offset, len))) != -1) {</span>
<span class="fc" id="L972">            offset += read;</span>
<span class="fc" id="L973">            len -= read;</span>
<span class="fc bfc" id="L974" title="All 2 branches covered.">            if(offset == 3) {</span>
<span class="fc" id="L975">                offset = 0;</span>
<span class="fc" id="L976">                _xmlWriter.writeBinary(stax2base64v, tmp, 0, 3);</span>
            }
<span class="fc bfc" id="L978" title="All 2 branches covered.">            if (len == 0) {</span>
<span class="fc" id="L979">                break;</span>
            }
        }

        // we still have &lt; 3 bytes in the buffer
<span class="fc bfc" id="L984" title="All 2 branches covered.">        if(offset &gt; 0) {</span>
<span class="fc" id="L985">            _xmlWriter.writeBinary(stax2base64v, tmp, 0, offset);</span>
        }
<span class="fc" id="L987">    }</span>

    private byte[] toFullBuffer(byte[] data, int offset, int len)
    {
        // might already be ok:
<span class="nc bnc" id="L992" title="All 4 branches missed.">        if (offset == 0 &amp;&amp; len == data.length) {</span>
<span class="nc" id="L993">            return data;</span>
        }
<span class="nc" id="L995">        byte[] result = new byte[len];</span>
<span class="nc bnc" id="L996" title="All 2 branches missed.">        if (len &gt; 0) {</span>
<span class="nc" id="L997">            System.arraycopy(data, offset, result, 0, len);</span>
        }
<span class="nc" id="L999">        return result;</span>
    }

    private byte[] toFullBuffer(InputStream data, final int len) throws IOException 
    {
<span class="nc" id="L1004">        byte[] result = new byte[len];</span>
<span class="nc" id="L1005">        int offset = 0;</span>

<span class="nc bnc" id="L1007" title="All 2 branches missed.">        for (; offset &lt; len; ) {</span>
<span class="nc" id="L1008">            int count = data.read(result, offset, len - offset);</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">            if (count &lt; 0) {</span>
<span class="nc" id="L1010">                _reportError(&quot;Too few bytes available: missing &quot;+(len - offset)+&quot; bytes (out of &quot;+len+&quot;)&quot;);</span>
            }
<span class="nc" id="L1012">            offset += count;</span>
<span class="nc" id="L1013">        }</span>
<span class="nc" id="L1014">        return result;</span>
    }

    /*
    /**********************************************************
    /* Output method implementations, primitive
    /**********************************************************
     */

    @Override
    public void writeBoolean(boolean value) throws IOException
    {
<span class="fc" id="L1026">        _verifyValueWrite(&quot;write boolean value&quot;);</span>
<span class="pc bpc" id="L1027" title="1 of 2 branches missed.">        if (_nextName == null) {</span>
<span class="nc" id="L1028">            handleMissingName();</span>
        }
        try {
<span class="pc bpc" id="L1031" title="1 of 2 branches missed.">            if (_nextIsAttribute) {</span>
<span class="nc" id="L1032">                _xmlWriter.writeBooleanAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), value);</span>
<span class="pc bpc" id="L1033" title="1 of 2 branches missed.">            } else if (checkNextIsUnwrapped()) {</span>
            	// should we consider pretty-printing or not?
<span class="nc" id="L1035">                _xmlWriter.writeBoolean(value);</span>
            } else {
<span class="pc bpc" id="L1037" title="1 of 2 branches missed.">                if (_xmlPrettyPrinter != null) {</span>
<span class="nc" id="L1038">                	_xmlPrettyPrinter.writeLeafElement(_xmlWriter,</span>
<span class="nc" id="L1039">                			_nextName.getNamespaceURI(), _nextName.getLocalPart(),</span>
                			value);
                } else {
<span class="fc" id="L1042">	                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());</span>
<span class="fc" id="L1043">	                _xmlWriter.writeBoolean(value);</span>
<span class="fc" id="L1044">	                _xmlWriter.writeEndElement();</span>
                }
            }
<span class="nc" id="L1047">        } catch (XMLStreamException e) {</span>
<span class="nc" id="L1048">            StaxUtil.throwAsGenerationException(e, this);</span>
<span class="fc" id="L1049">        }</span>
<span class="fc" id="L1050">    }</span>

    @Override
    public void writeNull() throws IOException
    {
<span class="fc" id="L1055">        _verifyValueWrite(&quot;write null value&quot;);</span>
<span class="pc bpc" id="L1056" title="1 of 2 branches missed.">        if (_nextName == null) {</span>
<span class="nc" id="L1057">            handleMissingName();</span>
        }
        try {
<span class="fc bfc" id="L1060" title="All 2 branches covered.">            if (_nextIsAttribute) {</span>
                // With attributes, best just leave it out, right? (since there's no way
                // to use 'xsi:nil')
<span class="pc bpc" id="L1063" title="1 of 2 branches missed.">            } else if (checkNextIsUnwrapped()) {</span>
            	// as with above, best left unwritten?
            } else {
<span class="fc" id="L1066">                final boolean asXsiNil = isEnabled(Feature.WRITE_NULLS_AS_XSI_NIL);</span>
<span class="fc bfc" id="L1067" title="All 2 branches covered.">                if (_xmlPrettyPrinter != null) {</span>
                    // 12-Nov-2020, tatu: Not clean, due to backwards-compat challenges..
                    //    but has to do
<span class="pc bpc" id="L1070" title="1 of 4 branches missed.">                    if (asXsiNil &amp;&amp; (_xmlPrettyPrinter instanceof DefaultXmlPrettyPrinter)) {</span>
<span class="fc" id="L1071">                        ((DefaultXmlPrettyPrinter) _xmlPrettyPrinter).writeLeafXsiNilElement(_xmlWriter,</span>
<span class="fc" id="L1072">                                _nextName.getNamespaceURI(), _nextName.getLocalPart());</span>
                    } else {
<span class="fc" id="L1074">                        _xmlPrettyPrinter.writeLeafNullElement(_xmlWriter,</span>
<span class="fc" id="L1075">                                _nextName.getNamespaceURI(), _nextName.getLocalPart());</span>
                    }
                } else {
<span class="fc bfc" id="L1078" title="All 2 branches covered.">                    if (asXsiNil) {</span>
<span class="fc" id="L1079">                        _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());</span>
<span class="fc" id="L1080">                        _xmlWriter.writeAttribute(&quot;xsi&quot;, XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI, &quot;nil&quot;, &quot;true&quot;);</span>
<span class="fc" id="L1081">                        _xmlWriter.writeEndElement();</span>
                    } else {
<span class="fc" id="L1083">                        _xmlWriter.writeEmptyElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());</span>
                    }
                }
            }
<span class="nc" id="L1087">        } catch (XMLStreamException e) {</span>
<span class="nc" id="L1088">            StaxUtil.throwAsGenerationException(e, this);</span>
<span class="fc" id="L1089">        }</span>
<span class="fc" id="L1090">    }</span>

    @Override
    public void writeNumber(int i) throws IOException
    {
<span class="fc" id="L1095">        _verifyValueWrite(&quot;write number&quot;);</span>
<span class="pc bpc" id="L1096" title="1 of 2 branches missed.">        if (_nextName == null) {</span>
<span class="nc" id="L1097">            handleMissingName();</span>
        }
        try {
<span class="fc bfc" id="L1100" title="All 2 branches covered.">            if (_nextIsAttribute) {</span>
<span class="fc" id="L1101">                _xmlWriter.writeIntAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), i);</span>
<span class="pc bpc" id="L1102" title="1 of 2 branches missed.">            } else if (checkNextIsUnwrapped()) {</span>
            	// should we consider pretty-printing or not?
<span class="nc" id="L1104">                _xmlWriter.writeInt(i);</span>
            } else {
<span class="fc bfc" id="L1106" title="All 2 branches covered.">                if (_xmlPrettyPrinter != null) {</span>
<span class="fc" id="L1107">                	_xmlPrettyPrinter.writeLeafElement(_xmlWriter,</span>
<span class="fc" id="L1108">                			_nextName.getNamespaceURI(), _nextName.getLocalPart(),</span>
                			i);
                } else {
<span class="fc" id="L1111">	                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());</span>
<span class="fc" id="L1112">	                _xmlWriter.writeInt(i);</span>
<span class="fc" id="L1113">	                _xmlWriter.writeEndElement();</span>
                }
            }
<span class="nc" id="L1116">        } catch (XMLStreamException e) {</span>
<span class="nc" id="L1117">            StaxUtil.throwAsGenerationException(e, this);</span>
<span class="fc" id="L1118">        }</span>
<span class="fc" id="L1119">    }</span>

    @Override
    public void writeNumber(long l) throws IOException
    {
<span class="fc" id="L1124">        _verifyValueWrite(&quot;write number&quot;);</span>
<span class="pc bpc" id="L1125" title="1 of 2 branches missed.">        if (_nextName == null) {</span>
<span class="nc" id="L1126">            handleMissingName();</span>
        }
        try {
<span class="fc bfc" id="L1129" title="All 2 branches covered.">            if (_nextIsAttribute) {</span>
<span class="fc" id="L1130">                _xmlWriter.writeLongAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), l);</span>
<span class="pc bpc" id="L1131" title="1 of 2 branches missed.">            } else if (checkNextIsUnwrapped()) {</span>
<span class="nc" id="L1132">                _xmlWriter.writeLong(l);</span>
            } else {
<span class="fc bfc" id="L1134" title="All 2 branches covered.">                if (_xmlPrettyPrinter != null) {</span>
<span class="fc" id="L1135">                	_xmlPrettyPrinter.writeLeafElement(_xmlWriter,</span>
<span class="fc" id="L1136">                			_nextName.getNamespaceURI(), _nextName.getLocalPart(),</span>
                			l);
                } else {
<span class="fc" id="L1139">	                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());</span>
<span class="fc" id="L1140">	                _xmlWriter.writeLong(l);</span>
<span class="fc" id="L1141">	                _xmlWriter.writeEndElement();</span>
                }
            }
<span class="nc" id="L1144">        } catch (XMLStreamException e) {</span>
<span class="nc" id="L1145">            StaxUtil.throwAsGenerationException(e, this);</span>
<span class="fc" id="L1146">        }</span>
<span class="fc" id="L1147">    }</span>

    @Override
    public void writeNumber(double d) throws IOException
    {
<span class="fc" id="L1152">        _verifyValueWrite(&quot;write number&quot;);</span>
<span class="pc bpc" id="L1153" title="1 of 2 branches missed.">        if (_nextName == null) {</span>
<span class="nc" id="L1154">            handleMissingName();</span>
        }
        try {
<span class="pc bpc" id="L1157" title="1 of 2 branches missed.">            if (_nextIsAttribute) {</span>
<span class="nc" id="L1158">                _xmlWriter.writeDoubleAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), d);</span>
<span class="pc bpc" id="L1159" title="1 of 2 branches missed.">            } else if (checkNextIsUnwrapped()) {</span>
<span class="nc" id="L1160">                _xmlWriter.writeDouble(d);</span>
            } else {
<span class="pc bpc" id="L1162" title="1 of 2 branches missed.">                if (_xmlPrettyPrinter != null) {</span>
<span class="nc" id="L1163">                	_xmlPrettyPrinter.writeLeafElement(_xmlWriter,</span>
<span class="nc" id="L1164">                			_nextName.getNamespaceURI(), _nextName.getLocalPart(),</span>
                			d);
                } else {
<span class="fc" id="L1167">	                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());</span>
<span class="fc" id="L1168">	                _xmlWriter.writeDouble(d);</span>
<span class="fc" id="L1169">	                _xmlWriter.writeEndElement();</span>
                }
            }
<span class="nc" id="L1172">        } catch (XMLStreamException e) {</span>
<span class="nc" id="L1173">            StaxUtil.throwAsGenerationException(e, this);</span>
<span class="fc" id="L1174">        }</span>
<span class="fc" id="L1175">    }</span>

    @Override
    public void writeNumber(float f) throws IOException
    {
<span class="nc" id="L1180">        _verifyValueWrite(&quot;write number&quot;);</span>
<span class="nc bnc" id="L1181" title="All 2 branches missed.">        if (_nextName == null) {</span>
<span class="nc" id="L1182">            handleMissingName();</span>
        }
        try {
<span class="nc bnc" id="L1185" title="All 2 branches missed.">            if (_nextIsAttribute) {</span>
<span class="nc" id="L1186">                _xmlWriter.writeFloatAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), f);</span>
<span class="nc bnc" id="L1187" title="All 2 branches missed.">            } else if (checkNextIsUnwrapped()) {</span>
<span class="nc" id="L1188">                _xmlWriter.writeFloat(f);</span>
            } else {
<span class="nc bnc" id="L1190" title="All 2 branches missed.">                if (_xmlPrettyPrinter != null) {</span>
<span class="nc" id="L1191">                	_xmlPrettyPrinter.writeLeafElement(_xmlWriter,</span>
<span class="nc" id="L1192">                			_nextName.getNamespaceURI(), _nextName.getLocalPart(),</span>
                			f);
                } else {
<span class="nc" id="L1195">	                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());</span>
<span class="nc" id="L1196">	                _xmlWriter.writeFloat(f);</span>
<span class="nc" id="L1197">	                _xmlWriter.writeEndElement();</span>
                }
            }
<span class="nc" id="L1200">        } catch (XMLStreamException e) {</span>
<span class="nc" id="L1201">            StaxUtil.throwAsGenerationException(e, this);</span>
<span class="nc" id="L1202">        }</span>
<span class="nc" id="L1203">    }</span>

    @Override
    public void writeNumber(BigDecimal dec) throws IOException
    {
<span class="pc bpc" id="L1208" title="1 of 2 branches missed.">        if (dec == null) {</span>
<span class="nc" id="L1209">            writeNull();</span>
<span class="nc" id="L1210">            return;</span>
        }
<span class="fc" id="L1212">        _verifyValueWrite(&quot;write number&quot;);</span>
<span class="pc bpc" id="L1213" title="1 of 2 branches missed.">        if (_nextName == null) {</span>
<span class="nc" id="L1214">            handleMissingName();</span>
        }
<span class="fc" id="L1216">        boolean usePlain = isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);</span>
        try {
<span class="pc bpc" id="L1218" title="1 of 2 branches missed.">            if (_nextIsAttribute) {</span>
<span class="nc bnc" id="L1219" title="All 2 branches missed.">                if (usePlain) {</span>
<span class="nc" id="L1220">                    _xmlWriter.writeAttribute(&quot;&quot;, _nextName.getNamespaceURI(), _nextName.getLocalPart(),</span>
<span class="nc" id="L1221">                            dec.toPlainString());</span>
                } else {
<span class="nc" id="L1223">                    _xmlWriter.writeDecimalAttribute(&quot;&quot;, _nextName.getNamespaceURI(), _nextName.getLocalPart(), dec);</span>
                }
<span class="pc bpc" id="L1225" title="1 of 2 branches missed.">            } else if (checkNextIsUnwrapped()) {</span>
<span class="nc bnc" id="L1226" title="All 2 branches missed.">                if (usePlain) {</span>
<span class="nc" id="L1227">                    _xmlWriter.writeCharacters(dec.toPlainString());</span>
                } else {
<span class="nc" id="L1229">                    _xmlWriter.writeDecimal(dec);</span>
                }
            } else {
<span class="pc bpc" id="L1232" title="1 of 2 branches missed.">                if (_xmlPrettyPrinter != null) {</span>
<span class="nc bnc" id="L1233" title="All 2 branches missed.">                    if (usePlain) {</span>
<span class="nc" id="L1234">                        _xmlPrettyPrinter.writeLeafElement(_xmlWriter,</span>
<span class="nc" id="L1235">                                _nextName.getNamespaceURI(), _nextName.getLocalPart(),</span>
<span class="nc" id="L1236">                                dec.toPlainString(), false);</span>
                    } else {
<span class="nc" id="L1238">                        _xmlPrettyPrinter.writeLeafElement(_xmlWriter,</span>
<span class="nc" id="L1239">                                _nextName.getNamespaceURI(), _nextName.getLocalPart(),</span>
                                dec);
                    }
                } else {
<span class="fc" id="L1243">	                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());</span>
<span class="pc bpc" id="L1244" title="1 of 2 branches missed.">	                if (usePlain) {</span>
<span class="nc" id="L1245">                         _xmlWriter.writeCharacters(dec.toPlainString());</span>
	                } else {
<span class="fc" id="L1247">                         _xmlWriter.writeDecimal(dec);</span>
	                }
<span class="fc" id="L1249">	                _xmlWriter.writeEndElement();</span>
                }
            }
<span class="nc" id="L1252">        } catch (XMLStreamException e) {</span>
<span class="nc" id="L1253">            StaxUtil.throwAsGenerationException(e, this);</span>
<span class="fc" id="L1254">        }</span>
<span class="fc" id="L1255">    }</span>

    @Override
    public void writeNumber(BigInteger value) throws IOException
    {
<span class="pc bpc" id="L1260" title="1 of 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L1261">            writeNull();</span>
<span class="nc" id="L1262">            return;</span>
        }
<span class="fc" id="L1264">        _verifyValueWrite(&quot;write number&quot;);</span>
<span class="pc bpc" id="L1265" title="1 of 2 branches missed.">        if (_nextName == null) {</span>
<span class="nc" id="L1266">            handleMissingName();</span>
        }
        try {
<span class="pc bpc" id="L1269" title="1 of 2 branches missed.">            if (_nextIsAttribute) {</span>
<span class="nc" id="L1270">                _xmlWriter.writeIntegerAttribute(&quot;&quot;,</span>
<span class="nc" id="L1271">                		_nextName.getNamespaceURI(), _nextName.getLocalPart(), value);</span>
<span class="pc bpc" id="L1272" title="1 of 2 branches missed.">            } else if (checkNextIsUnwrapped()) {</span>
<span class="nc" id="L1273">                _xmlWriter.writeInteger(value);</span>
            } else {
<span class="pc bpc" id="L1275" title="1 of 2 branches missed.">                if (_xmlPrettyPrinter != null) {</span>
<span class="nc" id="L1276">                	_xmlPrettyPrinter.writeLeafElement(_xmlWriter,</span>
<span class="nc" id="L1277">                			_nextName.getNamespaceURI(), _nextName.getLocalPart(),</span>
                			value);
                } else {
<span class="fc" id="L1280">	                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());</span>
<span class="fc" id="L1281">	                _xmlWriter.writeInteger(value);</span>
<span class="fc" id="L1282">	                _xmlWriter.writeEndElement();</span>
                }
            }
<span class="nc" id="L1285">        } catch (XMLStreamException e) {</span>
<span class="nc" id="L1286">            StaxUtil.throwAsGenerationException(e, this);</span>
<span class="fc" id="L1287">        }</span>
<span class="fc" id="L1288">    }</span>

    @Override
    public void writeNumber(String encodedValue) throws IOException, UnsupportedOperationException
    {
<span class="nc" id="L1293">        writeString(encodedValue);</span>
<span class="nc" id="L1294">    }</span>

    /*
    /**********************************************************
    /* Implementations, overrides for other methods
    /**********************************************************
     */

    @Override
    protected final void _verifyValueWrite(String typeMsg) throws IOException
    {
<span class="fc" id="L1305">        int status = _writeContext.writeValue();</span>
<span class="pc bpc" id="L1306" title="1 of 2 branches missed.">        if (status == JsonWriteContext.STATUS_EXPECT_NAME) {</span>
<span class="nc" id="L1307">            _reportError(&quot;Can not &quot;+typeMsg+&quot;, expecting field name&quot;);</span>
        }
<span class="fc" id="L1309">    }</span>

    /*
    /**********************************************************
    /* Low-level output handling
    /**********************************************************
     */

    @Override
    public void flush() throws IOException
    {
<span class="pc bpc" id="L1320" title="1 of 2 branches missed.">        if (isEnabled(JsonGenerator.Feature.FLUSH_PASSED_TO_STREAM)) {</span>
            try {
<span class="fc" id="L1322">                _xmlWriter.flush();</span>
<span class="nc" id="L1323">            } catch (XMLStreamException e) {</span>
<span class="nc" id="L1324">                StaxUtil.throwAsGenerationException(e, this);</span>
<span class="fc" id="L1325">            }</span>
        }
<span class="fc" id="L1327">    }</span>

    @Override
    public void close() throws IOException
    {
<span class="pc bpc" id="L1332" title="1 of 2 branches missed.">        if (!isClosed()) {</span>

            // First: let's see that we still have buffers...
<span class="fc bfc" id="L1335" title="All 2 branches covered.">            if (isEnabled(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT)) {</span>
                try {
                    while (true) {
                        /* 28-May-2016, tatu: To work around incompatibility introduced by
                         *     `jackson-core` 2.8 where return type of `getOutputContext()`
                         *     changed, let's do direct access here.
                         */
//                    JsonStreamContext ctxt = getOutputContext();
<span class="fc" id="L1343">                        JsonStreamContext ctxt = _writeContext;</span>
<span class="pc bpc" id="L1344" title="1 of 2 branches missed.">                        if (ctxt.inArray()) {</span>
<span class="nc" id="L1345">                            writeEndArray();</span>
<span class="pc bpc" id="L1346" title="1 of 2 branches missed.">                        } else if (ctxt.inObject()) {</span>
<span class="nc" id="L1347">                            writeEndObject();</span>
                        } else {
                            break;
                        }
<span class="nc" id="L1351">                    }</span>
<span class="nc" id="L1352">                } catch (ArrayIndexOutOfBoundsException e) {</span>
                    /* 29-Nov-2010, tatu: Stupid, stupid SJSXP doesn't do array checks, so we get
                     *   hit by this as a collateral problem in some cases. Yuck.
                     */
<span class="nc" id="L1356">                    throw new JsonGenerationException(e, this);</span>
<span class="fc" id="L1357">                }</span>
            }
            try {
<span class="pc bpc" id="L1360" title="1 of 4 branches missed.">                if (_ioContext.isResourceManaged() || isEnabled(JsonGenerator.Feature.AUTO_CLOSE_TARGET)) {</span>
<span class="fc" id="L1361">                    _xmlWriter.closeCompletely();</span>
                } else {
<span class="nc" id="L1363">                    _xmlWriter.close();</span>
                }
<span class="nc" id="L1365">            } catch (XMLStreamException e) {</span>
<span class="nc" id="L1366">                StaxUtil.throwAsGenerationException(e, this);</span>
<span class="fc" id="L1367">            }</span>
<span class="fc" id="L1368">            super.close();</span>
        }
<span class="fc" id="L1370">    }</span>

    @Override
    protected void _releaseBuffers() {
        // Nothing to do here, as we have no buffers
<span class="nc" id="L1375">    }</span>

    /*
    /**********************************************************
    /* Internal methods
    /**********************************************************
     */

    /**
     * Method called to see if unwrapping is required; and if so,
     * clear the flag (so further calls will return 'false' unless
     * state is re-set)
     */
    protected boolean checkNextIsUnwrapped()
    {
<span class="fc bfc" id="L1390" title="All 2 branches covered.">        if (_nextIsUnwrapped) {</span>
<span class="fc" id="L1391">    		    _nextIsUnwrapped = false;</span>
<span class="fc" id="L1392">    		    return true;</span>
        }
<span class="fc" id="L1394">        return false;</span>
    }
    
    protected void handleMissingName() {
<span class="nc" id="L1398">        throw new IllegalStateException(&quot;No element/attribute name specified when trying to output element&quot;);</span>
    }

    /**
     * Method called in case access to native Stax2 API implementation is required.
     */
    protected void  _reportUnimplementedStax2(String missingMethod) throws IOException
    {
<span class="nc" id="L1406">        throw new JsonGenerationException(&quot;Underlying Stax XMLStreamWriter (of type &quot;</span>
<span class="nc" id="L1407">                +_originalXmlWriter.getClass().getName()</span>
                +&quot;) does not implement Stax2 API natively and is missing method '&quot;
                +missingMethod+&quot;': this breaks functionality such as indentation that relies on it. &quot;
                +&quot;You need to upgrade to using compliant Stax implementation like Woodstox or Aalto&quot;,
                this);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>