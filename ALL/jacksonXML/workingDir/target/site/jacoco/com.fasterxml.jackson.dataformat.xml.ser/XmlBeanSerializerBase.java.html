<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>XmlBeanSerializerBase.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jackson-dataformat-XML</a> &gt; <a href="index.source.html" class="el_package">com.fasterxml.jackson.dataformat.xml.ser</a> &gt; <span class="el_source">XmlBeanSerializerBase.java</span></div><h1>XmlBeanSerializerBase.java</h1><pre class="source lang-java linenums">package com.fasterxml.jackson.dataformat.xml.ser;

import java.io.IOException;
import java.util.BitSet;
import java.util.Set;

import javax.xml.namespace.QName;

import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.core.*;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.jsontype.TypeSerializer;
import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;
import com.fasterxml.jackson.databind.ser.PropertyFilter;
import com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;
import com.fasterxml.jackson.databind.ser.impl.WritableObjectId;
import com.fasterxml.jackson.databind.ser.std.BeanSerializerBase;
import com.fasterxml.jackson.databind.util.NameTransformer;
import com.fasterxml.jackson.dataformat.xml.util.XmlInfo;

/**
 * Specific sub-class of {@link BeanSerializerBase} needed to take care
 * of some xml-specific aspects, such as distinction between attributes
 * and elements.
 */
@SuppressWarnings(&quot;serial&quot;)
public abstract class XmlBeanSerializerBase extends BeanSerializerBase
{
    /**
     * Marker used for storing associated internal data with {@link BeanPropertyWriter}
     * instances; to mark instances that are to be written out as attributes.
     * Created as separate non-interned String to ensure there are no collisions.
     */
<span class="fc" id="L35">    public final static String KEY_XML_INFO = new String(&quot;xmlInfo&quot;);</span>

    /**
     * Number of attributes to write; these will have been ordered to be the first
     * properties to write.
     */
    protected final int _attributeCount;

    /**
     * Index of &quot;text value&quot; property we have, if any; can have at most
     * one such property.
     */
    protected final int _textPropertyIndex;

    /**
     * Array that contains namespace URIs associated with properties, if any;
     * null if no namespace definitions have been assigned
     */
    protected final QName[] _xmlNames;

    /**
     * Optional set of indexes of properties that should be serialized as CDATA,
     * instead of regular XML text segment. Left as null in cases where none of
     * element values are to be written in such a way.
     */
    protected final BitSet _cdata;
    
    public XmlBeanSerializerBase(BeanSerializerBase src)
    {
<span class="fc" id="L64">        super(src);</span>

        // Then make sure attributes are sorted before elements, keep track
        // of how many there are altogether
<span class="fc" id="L68">        int attrCount = 0;</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">        for (BeanPropertyWriter bpw : _props) {</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then</span>
<span class="fc" id="L71">                attrCount = _orderAttributesFirst(_props, _filteredProps);</span>
<span class="fc" id="L72">                break;</span>
            }
        }
<span class="fc" id="L75">        _attributeCount = attrCount;</span>

        // also: pre-compute need, if any, for CDATA handling:
<span class="fc" id="L78">        BitSet cdata = null;</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">        for (int i = 0, len = _props.length; i &lt; len; ++i) {</span>
<span class="fc" id="L80">            BeanPropertyWriter bpw = _props[i];</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">            if (_isCData(bpw)) {</span>
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">                if (cdata == null) {</span>
<span class="fc" id="L83">                    cdata = new BitSet(len);</span>
                }
<span class="fc" id="L85">                cdata.set(i);</span>
            }
        }
<span class="fc" id="L88">        _cdata = cdata;</span>
        
        // And then collect namespace information
<span class="fc" id="L91">        _xmlNames = new QName[_props.length];</span>
<span class="fc" id="L92">        int textIndex = -1;</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">        for (int i = 0, len = _props.length; i &lt; len; ++i) {</span>
<span class="fc" id="L94">            BeanPropertyWriter bpw = _props[i];</span>
<span class="fc" id="L95">            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);</span>
<span class="fc" id="L96">            String ns = null;</span>
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">            if (info != null) {</span>
<span class="fc" id="L98">                ns = info.getNamespace();</span>
<span class="fc bfc" id="L99" title="All 4 branches covered.">                if (textIndex &lt; 0 &amp;&amp; info.isText()) {</span>
<span class="fc" id="L100">                    textIndex = i;</span>
                }
            }
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">            _xmlNames[i] = new QName((ns == null) ? &quot;&quot; : ns, bpw.getName());</span>
        }
<span class="fc" id="L105">        _textPropertyIndex = textIndex;</span>
<span class="fc" id="L106">    }</span>

    protected XmlBeanSerializerBase(XmlBeanSerializerBase src, ObjectIdWriter objectIdWriter)
    {
<span class="nc" id="L110">        super(src, objectIdWriter);</span>
<span class="nc" id="L111">        _attributeCount = src._attributeCount;</span>
<span class="nc" id="L112">        _textPropertyIndex = src._textPropertyIndex;</span>
<span class="nc" id="L113">        _xmlNames = src._xmlNames;</span>
<span class="nc" id="L114">        _cdata = src._cdata;</span>
<span class="nc" id="L115">    }</span>

    protected XmlBeanSerializerBase(XmlBeanSerializerBase src, ObjectIdWriter objectIdWriter, Object filterId)
    {
<span class="fc" id="L119">        super(src, objectIdWriter, filterId);</span>
<span class="fc" id="L120">        _attributeCount = src._attributeCount;</span>
<span class="fc" id="L121">        _textPropertyIndex = src._textPropertyIndex;</span>
<span class="fc" id="L122">        _xmlNames = src._xmlNames;</span>
<span class="fc" id="L123">        _cdata = src._cdata;</span>
<span class="fc" id="L124">    }</span>

    protected XmlBeanSerializerBase(XmlBeanSerializerBase src,
            Set&lt;String&gt; toIgnore, Set&lt;String&gt; toInclude)
    {
<span class="nc" id="L129">        super(src, toIgnore, toInclude);</span>
<span class="nc" id="L130">        _attributeCount = src._attributeCount;</span>
<span class="nc" id="L131">        _textPropertyIndex = src._textPropertyIndex;</span>
<span class="nc" id="L132">        _xmlNames = src._xmlNames;</span>
<span class="nc" id="L133">        _cdata = src._cdata;</span>
<span class="nc" id="L134">    }</span>
    
    public XmlBeanSerializerBase(XmlBeanSerializerBase src, NameTransformer transformer)
    {
<span class="fc" id="L138">        super(src, transformer);</span>
<span class="fc" id="L139">        _attributeCount = src._attributeCount;</span>
<span class="fc" id="L140">        _textPropertyIndex = src._textPropertyIndex;</span>
<span class="fc" id="L141">        _xmlNames = src._xmlNames;</span>
<span class="fc" id="L142">        _cdata = src._cdata;</span>
<span class="fc" id="L143">    }</span>

    // @since 2.11.1
    protected XmlBeanSerializerBase(XmlBeanSerializerBase src,
            BeanPropertyWriter[] properties, BeanPropertyWriter[] filteredProperties) {
<span class="nc" id="L148">        super(src, properties, filteredProperties);</span>
<span class="nc" id="L149">        _attributeCount = src._attributeCount;</span>
<span class="nc" id="L150">        _textPropertyIndex = src._textPropertyIndex;</span>
<span class="nc" id="L151">        _xmlNames = src._xmlNames;</span>
<span class="nc" id="L152">        _cdata = src._cdata;</span>
<span class="nc" id="L153">    }</span>

    /*
    /**********************************************************
    /* Overridden serialization methods
    /**********************************************************
     */

    /**
     * Main serialization method needs to be overridden to allow XML-specific
     * extra handling, such as indication of whether to write attributes or
     * elements.
     */
    @Override
    protected void serializeFields(Object bean, JsonGenerator gen0, SerializerProvider provider)
        throws IOException
    {
        // 19-Aug-2013, tatu: During 'convertValue()', need to skip
<span class="fc bfc" id="L171" title="All 2 branches covered.">        if (!(gen0 instanceof ToXmlGenerator)) {</span>
<span class="fc" id="L172">            super.serializeFields(bean, gen0, provider);</span>
<span class="fc" id="L173">            return;</span>
        }
<span class="fc" id="L175">        final ToXmlGenerator xgen = (ToXmlGenerator) gen0;</span>
        final BeanPropertyWriter[] props;
<span class="pc bpc" id="L177" title="1 of 4 branches missed.">        if (_filteredProps != null &amp;&amp; provider.getActiveView() != null) {</span>
<span class="fc" id="L178">            props = _filteredProps;</span>
        } else {
<span class="fc" id="L180">            props = _props;</span>
        }

<span class="fc" id="L183">        final int attrCount = _attributeCount;</span>
<span class="fc" id="L184">        final boolean isAttribute = xgen._nextIsAttribute;</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">        if (attrCount &gt; 0) {</span>
<span class="fc" id="L186">            xgen.setNextIsAttribute(true);</span>
        }
<span class="fc" id="L188">        final int textIndex = _textPropertyIndex;</span>
<span class="fc" id="L189">        final QName[] xmlNames = _xmlNames;</span>
<span class="fc" id="L190">        int i = 0;</span>
<span class="fc" id="L191">        final BitSet cdata = _cdata;</span>

        try {
<span class="fc bfc" id="L194" title="All 2 branches covered.">            for (final int len = props.length; i &lt; len; ++i) {</span>
                // 28-jan-2014, pascal: we don't want to reset the attribute flag if we are an unwrapping serializer 
                // that started with nextIsAttribute to true because all properties should be unwrapped as attributes too.
<span class="fc bfc" id="L197" title="All 6 branches covered.">                if (i == attrCount &amp;&amp; !(isAttribute &amp;&amp; isUnwrappingSerializer())) {</span>
<span class="fc" id="L198">                    xgen.setNextIsAttribute(false);</span>
                }
                // also: if this is property to write as text (&quot;unwrap&quot;), need to:
<span class="fc bfc" id="L201" title="All 2 branches covered.">                if (i == textIndex) {</span>
<span class="fc" id="L202">                    xgen.setNextIsUnwrapped(true);</span>
                }
<span class="fc" id="L204">                xgen.setNextName(xmlNames[i]);</span>
<span class="fc" id="L205">                BeanPropertyWriter prop = props[i];</span>
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">                if (prop != null) { // can have nulls in filtered list</span>
<span class="pc bpc" id="L207" title="1 of 4 branches missed.">                    if ((cdata != null) &amp;&amp; cdata.get(i)) {</span>
<span class="fc" id="L208">                        xgen.setNextIsCData(true);</span>
<span class="fc" id="L209">                        prop.serializeAsField(bean, xgen, provider);</span>
<span class="fc" id="L210">                        xgen.setNextIsCData(false);</span>
                    } else {
<span class="fc" id="L212">                        prop.serializeAsField(bean, xgen, provider);</span>
                    }
                }
                // Reset to avoid next value being written as unwrapped, 
                // for example when property is suppressed
<span class="fc bfc" id="L217" title="All 2 branches covered.">                if (i == textIndex) {</span>
<span class="fc" id="L218">                    xgen.setNextIsUnwrapped(false);</span>
                }
            }
<span class="fc bfc" id="L221" title="All 2 branches covered.">            if (_anyGetterWriter != null) {</span>
                // For [#117]: not a clean fix, but with @JsonTypeInfo, we'll end up
                // with accidental attributes otherwise
<span class="fc" id="L224">                xgen.setNextIsAttribute(false);</span>
<span class="fc" id="L225">                _anyGetterWriter.getAndSerialize(bean, xgen, provider);</span>
            }
<span class="nc" id="L227">        } catch (Exception e) {</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">            String name = (i == props.length) ? &quot;[anySetter]&quot; : props[i].getName();</span>
<span class="nc" id="L229">            wrapAndThrow(provider, e, bean, name);</span>
<span class="nc" id="L230">        } catch (StackOverflowError e) { // Bit tricky, can't do more calls as stack is full; so:</span>
<span class="nc" id="L231">            JsonMappingException mapE = JsonMappingException.from(gen0,</span>
                    &quot;Infinite recursion (StackOverflowError)&quot;);
<span class="nc bnc" id="L233" title="All 2 branches missed.">            String name = (i == props.length) ? &quot;[anySetter]&quot; : props[i].getName();</span>
<span class="nc" id="L234">            mapE.prependPath(new JsonMappingException.Reference(bean, name));</span>
<span class="nc" id="L235">            throw mapE;</span>
<span class="pc" id="L236">        }</span>
<span class="fc" id="L237">    }</span>

    @Override
    protected void serializeFieldsFiltered(Object bean, JsonGenerator gen0,
            SerializerProvider provider)
        throws IOException
    {
        // 19-Aug-2013, tatu: During 'convertValue()', need to skip
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">        if (!(gen0 instanceof ToXmlGenerator)) {</span>
<span class="nc" id="L246">            super.serializeFieldsFiltered(bean, gen0, provider);</span>
<span class="nc" id="L247">            return;</span>
        }
        
<span class="fc" id="L250">        final ToXmlGenerator xgen = (ToXmlGenerator) gen0;</span>
        
        final BeanPropertyWriter[] props;
<span class="pc bpc" id="L253" title="3 of 4 branches missed.">        if (_filteredProps != null &amp;&amp; provider.getActiveView() != null) {</span>
<span class="nc" id="L254">            props = _filteredProps;</span>
        } else {
<span class="fc" id="L256">            props = _props;</span>
        }
<span class="fc" id="L258">        final PropertyFilter filter = findPropertyFilter(provider, _propertyFilterId, bean);</span>
        // better also allow missing filter actually..
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">        if (filter == null) {</span>
<span class="nc" id="L261">            serializeFields(bean, gen0, provider);</span>
<span class="nc" id="L262">            return;</span>
        }

<span class="fc" id="L265">        final boolean isAttribute = xgen._nextIsAttribute;</span>
<span class="fc" id="L266">        final int attrCount = _attributeCount;</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">        if (attrCount &gt; 0) {</span>
<span class="fc" id="L268">            xgen.setNextIsAttribute(true);</span>
        }
<span class="fc" id="L270">        final int textIndex = _textPropertyIndex;</span>
<span class="fc" id="L271">        final QName[] xmlNames = _xmlNames;</span>
<span class="fc" id="L272">        final BitSet cdata = _cdata;</span>

<span class="fc" id="L274">        int i = 0;</span>
        try {
<span class="fc bfc" id="L276" title="All 2 branches covered.">            for (final int len = props.length; i &lt; len; ++i) {</span>
                // 28-jan-2014, pascal: we don't want to reset the attribute flag if we are an unwrapping serializer 
                // that started with nextIsAttribute to true because all properties should be unwrapped as attributes too.
<span class="pc bpc" id="L279" title="3 of 6 branches missed.">                if (i == attrCount &amp;&amp; !(isAttribute &amp;&amp; isUnwrappingSerializer())) {</span>
<span class="fc" id="L280">                    xgen.setNextIsAttribute(false);</span>
                }
                // also: if this is property to write as text (&quot;unwrap&quot;), need to:
<span class="fc bfc" id="L283" title="All 2 branches covered.">                if (i == textIndex) {</span>
<span class="fc" id="L284">                    xgen.setNextIsUnwrapped(true);</span>
                }
<span class="fc" id="L286">                xgen.setNextName(xmlNames[i]);</span>
<span class="fc" id="L287">                BeanPropertyWriter prop = props[i];</span>
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">                if (prop != null) { // can have nulls in filtered list</span>
<span class="pc bpc" id="L289" title="3 of 4 branches missed.">                    if ((cdata != null) &amp;&amp; cdata.get(i)) {</span>
<span class="nc" id="L290">                        xgen.setNextIsCData(true);</span>
<span class="nc" id="L291">                        filter.serializeAsField(bean, xgen, provider, prop);</span>
<span class="nc" id="L292">                        xgen.setNextIsCData(false);</span>
                    } else {
<span class="fc" id="L294">                        filter.serializeAsField(bean, xgen, provider, prop);</span>
                    }
                }
                // Reset to avoid next value being written as unwrapped,
                // for example when property is suppressed
<span class="fc bfc" id="L299" title="All 2 branches covered.">                if (i == textIndex) {</span>
<span class="fc" id="L300">                    xgen.setNextIsUnwrapped(false);</span>
                }
            }
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">            if (_anyGetterWriter != null) {</span>
                // For [#117]: not a clean fix, but with @JsonTypeInfo, we'll end up
                // with accidental attributes otherwise
<span class="nc" id="L306">                xgen.setNextIsAttribute(false);</span>
                // 24-Jul-2019, tatu: Fixed for [dataformat-xml#351]
<span class="nc" id="L308">                _anyGetterWriter.getAndFilter(bean, xgen, provider, filter);</span>
            }
<span class="nc" id="L310">        } catch (Exception e) {</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">            String name = (i == props.length) ? &quot;[anySetter]&quot; : props[i].getName();</span>
<span class="nc" id="L312">            wrapAndThrow(provider, e, bean, name);</span>
<span class="nc" id="L313">        } catch (StackOverflowError e) {</span>
<span class="nc" id="L314">            JsonMappingException mapE = JsonMappingException.from(gen0, &quot;Infinite recursion (StackOverflowError)&quot;, e);</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">            String name = (i == props.length) ? &quot;[anySetter]&quot; : props[i].getName();</span>
<span class="nc" id="L316">            mapE.prependPath(new JsonMappingException.Reference(bean, name));</span>
<span class="nc" id="L317">            throw mapE;</span>
<span class="pc" id="L318">        }</span>
<span class="fc" id="L319">    }</span>
    
    @Override
    public void serializeWithType(Object bean, JsonGenerator gen, SerializerProvider provider,
            TypeSerializer typeSer)
        throws IOException
    {
<span class="fc bfc" id="L326" title="All 2 branches covered.">        if (_objectIdWriter != null) {</span>
<span class="fc" id="L327">            _serializeWithObjectId(bean, gen, provider, typeSer);</span>
<span class="fc" id="L328">            return;</span>
        }
        /* Ok: let's serialize type id as attribute, but if (and only if!)
         * we are using AS_PROPERTY
         */
<span class="fc bfc" id="L333" title="All 2 branches covered.">        if (typeSer.getTypeInclusion() == JsonTypeInfo.As.PROPERTY) {</span>
<span class="fc" id="L334">            ToXmlGenerator xgen = (ToXmlGenerator)gen;</span>
<span class="fc" id="L335">            xgen.setNextIsAttribute(true);</span>
<span class="fc" id="L336">            super.serializeWithType(bean, gen, provider, typeSer);</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">            if (_attributeCount == 0) { // if no attributes, need to reset</span>
<span class="fc" id="L338">                xgen.setNextIsAttribute(false);</span>
            }
<span class="fc" id="L340">        } else {</span>
<span class="fc" id="L341">            super.serializeWithType(bean, gen, provider, typeSer);</span>
        }
<span class="fc" id="L343">    }</span>
    
    @Override
    protected void _serializeObjectId(Object bean, JsonGenerator gen, SerializerProvider provider,
            TypeSerializer typeSer, WritableObjectId objectId) throws IOException
    {
        // Ok: let's serialize type id as attribute, but if (and only if!) we are using AS_PROPERTY
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">        if (typeSer.getTypeInclusion() == JsonTypeInfo.As.PROPERTY) {</span>
<span class="fc" id="L351">            ToXmlGenerator xgen = (ToXmlGenerator)gen;</span>
<span class="fc" id="L352">            xgen.setNextIsAttribute(true);</span>
<span class="fc" id="L353">            super._serializeObjectId(bean, gen, provider, typeSer, objectId);</span>
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">            if (_attributeCount == 0) { // if no attributes, need to reset</span>
<span class="fc" id="L355">                xgen.setNextIsAttribute(false);</span>
            }
<span class="fc" id="L357">        } else {</span>
<span class="nc" id="L358">            super._serializeObjectId(bean, gen, provider, typeSer, objectId);</span>
        }
<span class="fc" id="L360">    }</span>

    /*
    /**********************************************************
    /* Helper methods
    /**********************************************************
     */

    protected static boolean _isAttribute(BeanPropertyWriter bpw)
    {
<span class="fc" id="L370">        XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);</span>
<span class="pc bpc" id="L371" title="1 of 4 branches missed.">        return (info != null) &amp;&amp; info.isAttribute();</span>
    }

    protected static boolean _isCData(BeanPropertyWriter bpw)
    {
<span class="fc" id="L376">        XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);</span>
<span class="pc bpc" id="L377" title="1 of 4 branches missed.">        return (info != null) &amp;&amp; info.isCData();</span>
    }

    /**
     * Method for re-sorting lists of bean properties such that attributes are strictly
     * written before elements.
     */
    protected static int _orderAttributesFirst(BeanPropertyWriter[] properties,
            BeanPropertyWriter[] filteredProperties)
    {
<span class="fc" id="L387">        int attrCount = 0;</span>

<span class="fc bfc" id="L389" title="All 2 branches covered.">        for (int i = 0, len = properties.length; i &lt; len; ++i) {</span>
<span class="fc" id="L390">            BeanPropertyWriter bpw = properties[i];</span>
            
<span class="fc bfc" id="L392" title="All 2 branches covered.">            if (!_isAttribute(bpw)) {</span>
<span class="fc" id="L393">                continue;</span>
            }
            
            // Move attribute a few places down as necessary
<span class="fc" id="L397">            int moveBy = i - attrCount;</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">            if (moveBy &gt; 0) {</span>
<span class="fc" id="L399">                System.arraycopy(properties, attrCount, properties, attrCount + 1, moveBy);</span>
<span class="fc" id="L400">                properties[attrCount] = bpw;</span>
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">                if (filteredProperties != null) {</span>
<span class="nc" id="L402">                    BeanPropertyWriter fbpw = filteredProperties[i];</span>
<span class="nc" id="L403">                    System.arraycopy(filteredProperties, attrCount, filteredProperties, attrCount+1, moveBy);</span>
<span class="nc" id="L404">                    filteredProperties[attrCount] = fbpw;</span>
                }
            }
<span class="fc" id="L407">            ++attrCount;</span>
        }
<span class="fc" id="L409">        return attrCount;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>