package
org
.
apache
.
commons
.
jxpath
.
ri
.
compiler
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
Compiler
;
public
class
Step
{
private
int
axis
;
private
NodeTest
nodeTest
;
private
Expression
[
]
predicates
;
protected
Step
(
int
axis
,
NodeTest
nodeTest
,
Expression
[
]
predicates
)
{
this
.
axis
=
axis
;
this
.
nodeTest
=
nodeTest
;
this
.
predicates
=
predicates
;
}
public
int
getAxis
(
)
{
return
axis
;
}
public
NodeTest
getNodeTest
(
)
{
return
nodeTest
;
}
public
Expression
[
]
getPredicates
(
)
{
return
predicates
;
}
public
boolean
isContextDependent
(
)
{
if
(
predicates
!=
null
)
{
for
(
int
i
=
0
;
i
<
predicates
.
length
;
i
++
)
{
if
(
predicates
[
i
]
.
isContextDependent
(
)
)
{
return
true
;
}
}
}
return
false
;
}
public
String
toString
(
)
{
StringBuffer
buffer
=
new
StringBuffer
(
)
;
int
axis
=
getAxis
(
)
;
if
(
axis
==
Compiler
.
AXIS_CHILD
)
{
buffer
.
append
(
nodeTest
)
;
}
else
if
(
axis
==
Compiler
.
AXIS_ATTRIBUTE
)
{
buffer
.
append
(
'@'
)
;
buffer
.
append
(
nodeTest
)
;
}
else
if
(
axis
==
Compiler
.
AXIS_SELF
&&
nodeTest
instanceof
NodeTypeTest
&&
(
(
NodeTypeTest
)
nodeTest
)
.
getNodeType
(
)
==
Compiler
.
NODE_TYPE_NODE
)
{
buffer
.
append
(
"."
)
;
}
else
if
(
axis
==
Compiler
.
AXIS_PARENT
&&
nodeTest
instanceof
NodeTypeTest
&&
(
(
NodeTypeTest
)
nodeTest
)
.
getNodeType
(
)
==
Compiler
.
NODE_TYPE_NODE
)
{
buffer
.
append
(
".."
)
;
}
else
if
(
axis
==
Compiler
.
AXIS_DESCENDANT_OR_SELF
&&
nodeTest
instanceof
NodeTypeTest
&&
(
(
NodeTypeTest
)
nodeTest
)
.
getNodeType
(
)
==
Compiler
.
NODE_TYPE_NODE
&&
(
predicates
==
null
||
predicates
.
length
==
0
)
)
{
buffer
.
append
(
""
)
;
}
else
{
buffer
.
append
(
axisToString
(
axis
)
)
;
buffer
.
append
(
"::"
)
;
buffer
.
append
(
nodeTest
)
;
}
Expression
[
]
predicates
=
getPredicates
(
)
;
if
(
predicates
!=
null
)
{
for
(
int
i
=
0
;
i
<
predicates
.
length
;
i
++
)
{
buffer
.
append
(
'['
)
;
buffer
.
append
(
predicates
[
i
]
)
;
buffer
.
append
(
']'
)
;
}
}
return
buffer
.
toString
(
)
;
}
public
static
String
axisToString
(
int
axis
)
{
switch
(
axis
)
{
case
Compiler
.
AXIS_SELF
:
return
"self"
;
case
Compiler
.
AXIS_CHILD
:
return
"child"
;
case
Compiler
.
AXIS_PARENT
:
return
"parent"
;
case
Compiler
.
AXIS_ANCESTOR
:
return
"ancestor"
;
case
Compiler
.
AXIS_ATTRIBUTE
:
return
"attribute"
;
case
Compiler
.
AXIS_NAMESPACE
:
return
"namespace"
;
case
Compiler
.
AXIS_PRECEDING
:
return
"preceding"
;
case
Compiler
.
AXIS_FOLLOWING
:
return
"following"
;
case
Compiler
.
AXIS_DESCENDANT
:
return
"descendant"
;
case
Compiler
.
AXIS_ANCESTOR_OR_SELF
:
return
"ancestor-or-self"
;
case
Compiler
.
AXIS_FOLLOWING_SIBLING
:
return
"following-sibling"
;
case
Compiler
.
AXIS_PRECEDING_SIBLING
:
return
"preceding-sibling"
;
case
Compiler
.
AXIS_DESCENDANT_OR_SELF
:
return
"descendant-or-self"
;
default
:
return
"UNKNOWN"
;
}
}
}
<EOF>
