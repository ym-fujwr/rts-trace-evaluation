package
org
.
apache
.
commons
.
jxpath
.
ri
.
compiler
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
EvalContext
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
axes
.
InitialContext
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
axes
.
NodeSetContext
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
axes
.
PredicateContext
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
axes
.
SimplePathInterpreter
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
axes
.
UnionContext
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
model
.
NodePointer
;
public
class
ExpressionPath
extends
Path
{
private
final
Expression
expression
;
private
final
Expression
[
]
predicates
;
private
boolean
basicKnown
=
false
;
private
boolean
basic
;
public
ExpressionPath
(
final
Expression
expression
,
final
Expression
[
]
predicates
,
final
Step
[
]
steps
)
{
super
(
steps
)
;
this
.
expression
=
expression
;
this
.
predicates
=
predicates
;
}
public
Expression
getExpression
(
)
{
return
expression
;
}
public
Expression
[
]
getPredicates
(
)
{
return
predicates
;
}
@
Override
public
boolean
computeContextDependent
(
)
{
if
(
expression
.
isContextDependent
(
)
)
{
return
true
;
}
if
(
predicates
!=
null
)
{
for
(
final
Expression
predicate
:
predicates
)
{
if
(
predicate
.
isContextDependent
(
)
)
{
return
true
;
}
}
}
return
super
.
computeContextDependent
(
)
;
}
public
synchronized
boolean
isSimpleExpressionPath
(
)
{
if
(
!
basicKnown
)
{
basicKnown
=
true
;
basic
=
isSimplePath
(
)
&&
areBasicPredicates
(
getPredicates
(
)
)
;
}
return
basic
;
}
@
Override
public
String
toString
(
)
{
final
StringBuffer
buffer
=
new
StringBuffer
(
)
;
if
(
expression
instanceof
CoreOperation
||
expression
instanceof
ExpressionPath
||
expression
instanceof
LocationPath
)
{
buffer
.
append
(
'('
)
;
buffer
.
append
(
expression
)
;
buffer
.
append
(
')'
)
;
}
else
{
buffer
.
append
(
expression
)
;
}
if
(
predicates
!=
null
)
{
for
(
final
Expression
predicate
:
predicates
)
{
buffer
.
append
(
'['
)
;
buffer
.
append
(
predicate
)
;
buffer
.
append
(
']'
)
;
}
}
final
Step
[
]
steps
=
getSteps
(
)
;
if
(
steps
!=
null
)
{
for
(
final
Step
step
:
steps
)
{
buffer
.
append
(
"/"
)
;
buffer
.
append
(
step
)
;
}
}
return
buffer
.
toString
(
)
;
}
@
Override
public
Object
compute
(
final
EvalContext
context
)
{
return
expressionPath
(
context
,
false
)
;
}
@
Override
public
Object
computeValue
(
final
EvalContext
context
)
{
return
expressionPath
(
context
,
true
)
;
}
protected
Object
expressionPath
(
final
EvalContext
evalContext
,
final
boolean
firstMatch
)
{
final
Object
value
=
expression
.
compute
(
evalContext
)
;
EvalContext
context
;
if
(
value
instanceof
InitialContext
)
{
context
=
(
InitialContext
)
value
;
}
else
if
(
value
instanceof
EvalContext
)
{
context
=
new
UnionContext
(
evalContext
,
new
EvalContext
[
]
{
(
EvalContext
)
value
}
)
;
}
else
{
context
=
evalContext
.
getRootContext
(
)
.
getConstantContext
(
value
)
;
}
if
(
firstMatch
&&
isSimpleExpressionPath
(
)
&&
!
(
context
instanceof
NodeSetContext
)
)
{
final
EvalContext
ctx
=
context
;
final
NodePointer
ptr
=
(
NodePointer
)
ctx
.
getSingleNodePointer
(
)
;
if
(
ptr
!=
null
&&
(
ptr
.
getIndex
(
)
==
NodePointer
.
WHOLE_COLLECTION
||
predicates
==
null
||
predicates
.
length
==
0
)
)
{
return
SimplePathInterpreter
.
interpretSimpleExpressionPath
(
evalContext
,
ptr
,
predicates
,
getSteps
(
)
)
;
}
}
if
(
predicates
!=
null
)
{
for
(
int
j
=
0
;
j
<
predicates
.
length
;
j
++
)
{
if
(
j
!=
0
)
{
context
=
new
UnionContext
(
context
,
new
EvalContext
[
]
{
context
}
)
;
}
context
=
new
PredicateContext
(
context
,
predicates
[
j
]
)
;
}
}
return
firstMatch
?
(
Object
)
getSingleNodePointerForSteps
(
context
)
:
evalSteps
(
context
)
;
}
}
<EOF>
