package
org
.
apache
.
commons
.
net
.
ftp
.
parser
;
import
java
.
io
.
File
;
import
java
.
text
.
ParseException
;
import
java
.
util
.
Locale
;
import
org
.
apache
.
commons
.
net
.
ftp
.
FTPClientConfig
;
import
org
.
apache
.
commons
.
net
.
ftp
.
FTPFile
;
public
class
OS400FTPEntryParser
extends
ConfigurableFTPFileEntryParserImpl
{
private
static
final
String
DEFAULT_DATE_FORMAT
=
"yy/MM/dd HH:mm:ss"
;
private
static
final
String
REGEX
=
"(\\S+)\\s+"
+
"(?:(\\d+)\\s+)?"
+
"(?:(\\S+)\\s+(\\S+)\\s+)?"
+
"(\\*STMF|\\*DIR|\\*FILE|\\*MEM)\\s+"
+
"(?:(\\S+)\\s*)?"
;
public
OS400FTPEntryParser
(
)
{
this
(
null
)
;
}
public
OS400FTPEntryParser
(
final
FTPClientConfig
config
)
{
super
(
REGEX
)
;
configure
(
config
)
;
}
@
Override
protected
FTPClientConfig
getDefaultConfiguration
(
)
{
return
new
FTPClientConfig
(
FTPClientConfig
.
SYST_OS400
,
DEFAULT_DATE_FORMAT
,
null
)
;
}
private
boolean
isNullOrEmpty
(
final
String
string
)
{
return
string
==
null
||
string
.
isEmpty
(
)
;
}
@
Override
public
FTPFile
parseFTPEntry
(
final
String
entry
)
{
final
FTPFile
file
=
new
FTPFile
(
)
;
file
.
setRawListing
(
entry
)
;
final
int
type
;
if
(
matches
(
entry
)
)
{
final
String
usr
=
group
(
1
)
;
final
String
filesize
=
group
(
2
)
;
String
datestr
=
""
;
if
(
!
isNullOrEmpty
(
group
(
3
)
)
||
!
isNullOrEmpty
(
group
(
4
)
)
)
{
datestr
=
group
(
3
)
+
" "
+
group
(
4
)
;
}
final
String
typeStr
=
group
(
5
)
;
String
name
=
group
(
6
)
;
boolean
mustScanForPathSeparator
=
true
;
try
{
file
.
setTimestamp
(
super
.
parseTimestamp
(
datestr
)
)
;
}
catch
(
final
ParseException
e
)
{
}
if
(
typeStr
.
equalsIgnoreCase
(
"*STMF"
)
)
{
type
=
FTPFile
.
FILE_TYPE
;
if
(
isNullOrEmpty
(
filesize
)
||
isNullOrEmpty
(
name
)
)
{
return
null
;
}
}
else
if
(
typeStr
.
equalsIgnoreCase
(
"*DIR"
)
)
{
type
=
FTPFile
.
DIRECTORY_TYPE
;
if
(
isNullOrEmpty
(
filesize
)
||
isNullOrEmpty
(
name
)
)
{
return
null
;
}
}
else
if
(
typeStr
.
equalsIgnoreCase
(
"*FILE"
)
)
{
if
(
(
name
==
null
)
||
!
name
.
toUpperCase
(
Locale
.
ROOT
)
.
endsWith
(
".SAVF"
)
)
{
return
null
;
}
mustScanForPathSeparator
=
false
;
type
=
FTPFile
.
FILE_TYPE
;
}
else
if
(
typeStr
.
equalsIgnoreCase
(
"*MEM"
)
)
{
mustScanForPathSeparator
=
false
;
type
=
FTPFile
.
FILE_TYPE
;
if
(
isNullOrEmpty
(
name
)
)
{
return
null
;
}
if
(
!
(
isNullOrEmpty
(
filesize
)
&&
isNullOrEmpty
(
datestr
)
)
)
{
return
null
;
}
name
=
name
.
replace
(
'/'
,
File
.
separatorChar
)
;
}
else
{
type
=
FTPFile
.
UNKNOWN_TYPE
;
}
file
.
setType
(
type
)
;
file
.
setUser
(
usr
)
;
try
{
file
.
setSize
(
Long
.
parseLong
(
filesize
)
)
;
}
catch
(
final
NumberFormatException
e
)
{
}
if
(
name
.
endsWith
(
"/"
)
)
{
name
=
name
.
substring
(
0
,
name
.
length
(
)
-
1
)
;
}
if
(
mustScanForPathSeparator
)
{
final
int
pos
=
name
.
lastIndexOf
(
'/'
)
;
if
(
pos
>
-
1
)
{
name
=
name
.
substring
(
pos
+
1
)
;
}
}
file
.
setName
(
name
)
;
return
file
;
}
return
null
;
}
}
<EOF>
