package
org
.
apache
.
commons
.
net
.
tftp
;
import
java
.
io
.
BufferedInputStream
;
import
java
.
io
.
BufferedOutputStream
;
import
java
.
io
.
File
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
FileNotFoundException
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
OutputStream
;
import
java
.
io
.
PrintStream
;
import
java
.
net
.
InetAddress
;
import
java
.
net
.
NetworkInterface
;
import
java
.
net
.
SocketTimeoutException
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
HashSet
;
import
org
.
apache
.
commons
.
net
.
io
.
FromNetASCIIOutputStream
;
import
org
.
apache
.
commons
.
net
.
io
.
ToNetASCIIInputStream
;
public
class
TFTPServer
implements
Runnable
{
public
enum
ServerMode
{
GET_ONLY
,
PUT_ONLY
,
GET_AND_PUT
}
private
class
TFTPTransfer
implements
Runnable
{
private
final
TFTPPacket
tftpPacket_
;
private
boolean
shutdownTransfer
;
TFTP
transferTftp_
;
public
TFTPTransfer
(
final
TFTPPacket
tftpPacket
)
{
tftpPacket_
=
tftpPacket
;
}
private
File
buildSafeFile
(
final
File
serverDirectory
,
final
String
fileName
,
final
boolean
createSubDirs
)
throws
IOException
{
File
temp
=
new
File
(
serverDirectory
,
fileName
)
;
temp
=
temp
.
getCanonicalFile
(
)
;
if
(
!
isSubdirectoryOf
(
serverDirectory
,
temp
)
)
{
throw
new
IOException
(
"Cannot access files outside of tftp server root."
)
;
}
if
(
createSubDirs
)
{
createDirectory
(
temp
.
getParentFile
(
)
)
;
}
return
temp
;
}
private
void
createDirectory
(
final
File
file
)
throws
IOException
{
final
File
parent
=
file
.
getParentFile
(
)
;
if
(
parent
==
null
)
{
throw
new
IOException
(
"Unexpected error creating requested directory"
)
;
}
if
(
!
parent
.
exists
(
)
)
{
createDirectory
(
parent
)
;
}
if
(
!
parent
.
isDirectory
(
)
)
{
throw
new
IOException
(
"Invalid directory path - file in the way of requested folder"
)
;
}
if
(
file
.
isDirectory
(
)
)
{
return
;
}
final
boolean
result
=
file
.
mkdir
(
)
;
if
(
!
result
)
{
throw
new
IOException
(
"Couldn't create requested directory"
)
;
}
}
private
void
handleRead
(
final
TFTPReadRequestPacket
trrp
)
throws
IOException
,
TFTPPacketException
{
InputStream
is
=
null
;
try
{
if
(
mode_
==
ServerMode
.
PUT_ONLY
)
{
transferTftp_
.
bufferedSend
(
new
TFTPErrorPacket
(
trrp
.
getAddress
(
)
,
trrp
.
getPort
(
)
,
TFTPErrorPacket
.
ILLEGAL_OPERATION
,
"Read not allowed by server."
)
)
;
return
;
}
try
{
is
=
new
BufferedInputStream
(
new
FileInputStream
(
buildSafeFile
(
serverReadDirectory_
,
trrp
.
getFilename
(
)
,
false
)
)
)
;
}
catch
(
final
FileNotFoundException
e
)
{
transferTftp_
.
bufferedSend
(
new
TFTPErrorPacket
(
trrp
.
getAddress
(
)
,
trrp
.
getPort
(
)
,
TFTPErrorPacket
.
FILE_NOT_FOUND
,
e
.
getMessage
(
)
)
)
;
return
;
}
catch
(
final
Exception
e
)
{
transferTftp_
.
bufferedSend
(
new
TFTPErrorPacket
(
trrp
.
getAddress
(
)
,
trrp
.
getPort
(
)
,
TFTPErrorPacket
.
UNDEFINED
,
e
.
getMessage
(
)
)
)
;
return
;
}
if
(
trrp
.
getMode
(
)
==
TFTP
.
NETASCII_MODE
)
{
is
=
new
ToNetASCIIInputStream
(
is
)
;
}
final
byte
[
]
temp
=
new
byte
[
TFTPDataPacket
.
MAX_DATA_LENGTH
]
;
TFTPPacket
answer
;
int
block
=
1
;
boolean
sendNext
=
true
;
int
readLength
=
TFTPDataPacket
.
MAX_DATA_LENGTH
;
TFTPDataPacket
lastSentData
=
null
;
while
(
readLength
==
TFTPDataPacket
.
MAX_DATA_LENGTH
&&
!
shutdownTransfer
)
{
if
(
sendNext
)
{
readLength
=
is
.
read
(
temp
)
;
if
(
readLength
==
-
1
)
{
readLength
=
0
;
}
lastSentData
=
new
TFTPDataPacket
(
trrp
.
getAddress
(
)
,
trrp
.
getPort
(
)
,
block
,
temp
,
0
,
readLength
)
;
sendData
(
transferTftp_
,
lastSentData
)
;
}
answer
=
null
;
int
timeoutCount
=
0
;
while
(
!
shutdownTransfer
&&
(
answer
==
null
||
!
answer
.
getAddress
(
)
.
equals
(
trrp
.
getAddress
(
)
)
||
answer
.
getPort
(
)
!=
trrp
.
getPort
(
)
)
)
{
if
(
answer
!=
null
)
{
log_
.
println
(
"TFTP Server ignoring message from unexpected source."
)
;
transferTftp_
.
bufferedSend
(
new
TFTPErrorPacket
(
answer
.
getAddress
(
)
,
answer
.
getPort
(
)
,
TFTPErrorPacket
.
UNKNOWN_TID
,
"Unexpected Host or Port"
)
)
;
}
try
{
answer
=
transferTftp_
.
bufferedReceive
(
)
;
}
catch
(
final
SocketTimeoutException
e
)
{
if
(
timeoutCount
>=
maxTimeoutRetries_
)
{
throw
e
;
}
timeoutCount
++
;
transferTftp_
.
bufferedSend
(
lastSentData
)
;
continue
;
}
}
if
(
answer
==
null
||
!
(
answer
instanceof
TFTPAckPacket
)
)
{
if
(
!
shutdownTransfer
)
{
logError_
.
println
(
"Unexpected response from tftp client during transfer ("
+
answer
+
").  Transfer aborted."
)
;
}
break
;
}
final
TFTPAckPacket
ack
=
(
TFTPAckPacket
)
answer
;
if
(
ack
.
getBlockNumber
(
)
!=
block
)
{
sendNext
=
false
;
}
else
{
block
++
;
if
(
block
>
65535
)
{
block
=
0
;
}
sendNext
=
true
;
}
}
}
finally
{
try
{
if
(
is
!=
null
)
{
is
.
close
(
)
;
}
}
catch
(
final
IOException
e
)
{
}
}
}
private
void
handleWrite
(
final
TFTPWriteRequestPacket
twrp
)
throws
IOException
,
TFTPPacketException
{
OutputStream
bos
=
null
;
try
{
if
(
mode_
==
ServerMode
.
GET_ONLY
)
{
transferTftp_
.
bufferedSend
(
new
TFTPErrorPacket
(
twrp
.
getAddress
(
)
,
twrp
.
getPort
(
)
,
TFTPErrorPacket
.
ILLEGAL_OPERATION
,
"Write not allowed by server."
)
)
;
return
;
}
int
lastBlock
=
0
;
final
String
fileName
=
twrp
.
getFilename
(
)
;
try
{
final
File
temp
=
buildSafeFile
(
serverWriteDirectory_
,
fileName
,
true
)
;
if
(
temp
.
exists
(
)
)
{
transferTftp_
.
bufferedSend
(
new
TFTPErrorPacket
(
twrp
.
getAddress
(
)
,
twrp
.
getPort
(
)
,
TFTPErrorPacket
.
FILE_EXISTS
,
"File already exists"
)
)
;
return
;
}
bos
=
new
BufferedOutputStream
(
new
FileOutputStream
(
temp
)
)
;
if
(
twrp
.
getMode
(
)
==
TFTP
.
NETASCII_MODE
)
{
bos
=
new
FromNetASCIIOutputStream
(
bos
)
;
}
}
catch
(
final
Exception
e
)
{
transferTftp_
.
bufferedSend
(
new
TFTPErrorPacket
(
twrp
.
getAddress
(
)
,
twrp
.
getPort
(
)
,
TFTPErrorPacket
.
UNDEFINED
,
e
.
getMessage
(
)
)
)
;
return
;
}
TFTPAckPacket
lastSentAck
=
new
TFTPAckPacket
(
twrp
.
getAddress
(
)
,
twrp
.
getPort
(
)
,
0
)
;
sendData
(
transferTftp_
,
lastSentAck
)
;
while
(
true
)
{
TFTPPacket
dataPacket
=
null
;
int
timeoutCount
=
0
;
while
(
!
shutdownTransfer
&&
(
dataPacket
==
null
||
!
dataPacket
.
getAddress
(
)
.
equals
(
twrp
.
getAddress
(
)
)
||
dataPacket
.
getPort
(
)
!=
twrp
.
getPort
(
)
)
)
{
if
(
dataPacket
!=
null
)
{
log_
.
println
(
"TFTP Server ignoring message from unexpected source."
)
;
transferTftp_
.
bufferedSend
(
new
TFTPErrorPacket
(
dataPacket
.
getAddress
(
)
,
dataPacket
.
getPort
(
)
,
TFTPErrorPacket
.
UNKNOWN_TID
,
"Unexpected Host or Port"
)
)
;
}
try
{
dataPacket
=
transferTftp_
.
bufferedReceive
(
)
;
}
catch
(
final
SocketTimeoutException
e
)
{
if
(
timeoutCount
>=
maxTimeoutRetries_
)
{
throw
e
;
}
transferTftp_
.
bufferedSend
(
lastSentAck
)
;
timeoutCount
++
;
continue
;
}
}
if
(
dataPacket
instanceof
TFTPWriteRequestPacket
)
{
lastSentAck
=
new
TFTPAckPacket
(
twrp
.
getAddress
(
)
,
twrp
.
getPort
(
)
,
0
)
;
transferTftp_
.
bufferedSend
(
lastSentAck
)
;
}
else
if
(
dataPacket
==
null
||
!
(
dataPacket
instanceof
TFTPDataPacket
)
)
{
if
(
!
shutdownTransfer
)
{
logError_
.
println
(
"Unexpected response from tftp client during transfer ("
+
dataPacket
+
").  Transfer aborted."
)
;
}
break
;
}
else
{
final
int
block
=
(
(
TFTPDataPacket
)
dataPacket
)
.
getBlockNumber
(
)
;
final
byte
[
]
data
=
(
(
TFTPDataPacket
)
dataPacket
)
.
getData
(
)
;
final
int
dataLength
=
(
(
TFTPDataPacket
)
dataPacket
)
.
getDataLength
(
)
;
final
int
dataOffset
=
(
(
TFTPDataPacket
)
dataPacket
)
.
getDataOffset
(
)
;
if
(
block
>
lastBlock
||
lastBlock
==
65535
&&
block
==
0
)
{
bos
.
write
(
data
,
dataOffset
,
dataLength
)
;
lastBlock
=
block
;
}
lastSentAck
=
new
TFTPAckPacket
(
twrp
.
getAddress
(
)
,
twrp
.
getPort
(
)
,
block
)
;
sendData
(
transferTftp_
,
lastSentAck
)
;
if
(
dataLength
<
TFTPDataPacket
.
MAX_DATA_LENGTH
)
{
bos
.
close
(
)
;
for
(
int
i
=
0
;
i
<
maxTimeoutRetries_
;
i
++
)
{
try
{
dataPacket
=
transferTftp_
.
bufferedReceive
(
)
;
}
catch
(
final
SocketTimeoutException
e
)
{
break
;
}
if
(
dataPacket
!=
null
&&
(
!
dataPacket
.
getAddress
(
)
.
equals
(
twrp
.
getAddress
(
)
)
||
dataPacket
.
getPort
(
)
!=
twrp
.
getPort
(
)
)
)
{
transferTftp_
.
bufferedSend
(
new
TFTPErrorPacket
(
dataPacket
.
getAddress
(
)
,
dataPacket
.
getPort
(
)
,
TFTPErrorPacket
.
UNKNOWN_TID
,
"Unexpected Host or Port"
)
)
;
}
else
{
transferTftp_
.
bufferedSend
(
lastSentAck
)
;
}
}
break
;
}
}
}
}
finally
{
if
(
bos
!=
null
)
{
bos
.
close
(
)
;
}
}
}
private
boolean
isSubdirectoryOf
(
final
File
parent
,
final
File
child
)
{
final
File
childsParent
=
child
.
getParentFile
(
)
;
if
(
childsParent
==
null
)
{
return
false
;
}
if
(
childsParent
.
equals
(
parent
)
)
{
return
true
;
}
return
isSubdirectoryOf
(
parent
,
childsParent
)
;
}
@
Override
public
void
run
(
)
{
try
{
transferTftp_
=
newTFTP
(
)
;
transferTftp_
.
beginBufferedOps
(
)
;
transferTftp_
.
setDefaultTimeout
(
socketTimeout_
)
;
transferTftp_
.
open
(
)
;
if
(
tftpPacket_
instanceof
TFTPReadRequestPacket
)
{
handleRead
(
(
TFTPReadRequestPacket
)
tftpPacket_
)
;
}
else
if
(
tftpPacket_
instanceof
TFTPWriteRequestPacket
)
{
handleWrite
(
(
TFTPWriteRequestPacket
)
tftpPacket_
)
;
}
else
{
log_
.
println
(
"Unsupported TFTP request ("
+
tftpPacket_
+
") - ignored."
)
;
}
}
catch
(
final
Exception
e
)
{
if
(
!
shutdownTransfer
)
{
logError_
.
println
(
"Unexpected Error in during TFTP file transfer.  Transfer aborted. "
+
e
)
;
}
}
finally
{
try
{
if
(
transferTftp_
!=
null
&&
transferTftp_
.
isOpen
(
)
)
{
transferTftp_
.
endBufferedOps
(
)
;
transferTftp_
.
close
(
)
;
}
}
catch
(
final
Exception
e
)
{
}
synchronized
(
transfers_
)
{
transfers_
.
remove
(
this
)
;
}
}
}
public
void
shutdown
(
)
{
shutdownTransfer
=
true
;
try
{
transferTftp_
.
close
(
)
;
}
catch
(
final
RuntimeException
e
)
{
}
}
}
private
static
final
int
DEFAULT_TFTP_PORT
=
69
;
private
static
final
PrintStream
nullStream
=
new
PrintStream
(
new
OutputStream
(
)
{
@
Override
public
void
write
(
final
byte
[
]
b
)
throws
IOException
{
}
@
Override
public
void
write
(
final
int
b
)
{
}
}
)
;
private
final
HashSet
<
TFTPTransfer
>
transfers_
=
new
HashSet
<
>
(
)
;
private
volatile
boolean
shutdownServer
;
private
TFTP
serverTftp_
;
private
File
serverReadDirectory_
;
private
File
serverWriteDirectory_
;
private
final
int
port_
;
private
final
InetAddress
laddr_
;
private
Exception
serverException
;
private
final
ServerMode
mode_
;
private
PrintStream
log_
;
private
PrintStream
logError_
;
private
int
maxTimeoutRetries_
=
3
;
private
int
socketTimeout_
;
private
Thread
serverThread
;
public
TFTPServer
(
final
File
serverReadDirectory
,
final
File
serverWriteDirectory
,
final
int
port
,
final
InetAddress
localaddr
,
final
ServerMode
mode
,
final
PrintStream
log
,
final
PrintStream
errorLog
)
throws
IOException
{
port_
=
port
;
mode_
=
mode
;
laddr_
=
localaddr
;
log_
=
log
==
null
?
nullStream
:
log
;
logError_
=
errorLog
==
null
?
nullStream
:
errorLog
;
launch
(
serverReadDirectory
,
serverWriteDirectory
)
;
}
public
TFTPServer
(
final
File
serverReadDirectory
,
final
File
serverWriteDirectory
,
final
int
port
,
final
NetworkInterface
localiface
,
final
ServerMode
mode
,
final
PrintStream
log
,
final
PrintStream
errorLog
)
throws
IOException
{
mode_
=
mode
;
port_
=
port
;
InetAddress
iaddr
=
null
;
if
(
localiface
!=
null
)
{
final
Enumeration
<
InetAddress
>
ifaddrs
=
localiface
.
getInetAddresses
(
)
;
if
(
(
ifaddrs
!=
null
)
&&
ifaddrs
.
hasMoreElements
(
)
)
{
iaddr
=
ifaddrs
.
nextElement
(
)
;
}
}
log_
=
log
==
null
?
nullStream
:
log
;
logError_
=
errorLog
==
null
?
nullStream
:
errorLog
;
laddr_
=
iaddr
;
launch
(
serverReadDirectory
,
serverWriteDirectory
)
;
}
public
TFTPServer
(
final
File
serverReadDirectory
,
final
File
serverWriteDirectory
,
final
int
port
,
final
ServerMode
mode
,
final
PrintStream
log
,
final
PrintStream
errorLog
)
throws
IOException
{
port_
=
port
;
mode_
=
mode
;
log_
=
log
==
null
?
nullStream
:
log
;
logError_
=
errorLog
==
null
?
nullStream
:
errorLog
;
laddr_
=
null
;
launch
(
serverReadDirectory
,
serverWriteDirectory
)
;
}
public
TFTPServer
(
final
File
serverReadDirectory
,
final
File
serverWriteDirectory
,
final
ServerMode
mode
)
throws
IOException
{
this
(
serverReadDirectory
,
serverWriteDirectory
,
DEFAULT_TFTP_PORT
,
mode
,
null
,
null
)
;
}
@
Override
protected
void
finalize
(
)
throws
Throwable
{
shutdown
(
)
;
}
public
int
getMaxTimeoutRetries
(
)
{
return
maxTimeoutRetries_
;
}
public
int
getSocketTimeout
(
)
{
return
socketTimeout_
;
}
public
boolean
isRunning
(
)
throws
Exception
{
if
(
shutdownServer
&&
serverException
!=
null
)
{
throw
serverException
;
}
return
!
shutdownServer
;
}
private
void
launch
(
final
File
serverReadDirectory
,
final
File
serverWriteDirectory
)
throws
IOException
{
log_
.
println
(
"Starting TFTP Server on port "
+
port_
+
".  Read directory: "
+
serverReadDirectory
+
" Write directory: "
+
serverWriteDirectory
+
" Server Mode is "
+
mode_
)
;
serverReadDirectory_
=
serverReadDirectory
.
getCanonicalFile
(
)
;
if
(
!
serverReadDirectory_
.
exists
(
)
||
!
serverReadDirectory
.
isDirectory
(
)
)
{
throw
new
IOException
(
"The server read directory "
+
serverReadDirectory_
+
" does not exist"
)
;
}
serverWriteDirectory_
=
serverWriteDirectory
.
getCanonicalFile
(
)
;
if
(
!
serverWriteDirectory_
.
exists
(
)
||
!
serverWriteDirectory
.
isDirectory
(
)
)
{
throw
new
IOException
(
"The server write directory "
+
serverWriteDirectory_
+
" does not exist"
)
;
}
serverTftp_
=
new
TFTP
(
)
;
socketTimeout_
=
serverTftp_
.
getDefaultTimeout
(
)
;
serverTftp_
.
setDefaultTimeout
(
0
)
;
if
(
laddr_
!=
null
)
{
serverTftp_
.
open
(
port_
,
laddr_
)
;
}
else
{
serverTftp_
.
open
(
port_
)
;
}
serverThread
=
new
Thread
(
this
)
;
serverThread
.
setDaemon
(
true
)
;
serverThread
.
start
(
)
;
}
TFTP
newTFTP
(
)
{
return
new
TFTP
(
)
;
}
@
Override
public
void
run
(
)
{
try
{
while
(
!
shutdownServer
)
{
final
TFTPPacket
tftpPacket
;
tftpPacket
=
serverTftp_
.
receive
(
)
;
final
TFTPTransfer
tt
=
new
TFTPTransfer
(
tftpPacket
)
;
synchronized
(
transfers_
)
{
transfers_
.
add
(
tt
)
;
}
final
Thread
thread
=
new
Thread
(
tt
)
;
thread
.
setDaemon
(
true
)
;
thread
.
start
(
)
;
}
}
catch
(
final
Exception
e
)
{
if
(
!
shutdownServer
)
{
serverException
=
e
;
logError_
.
println
(
"Unexpected Error in TFTP Server - Server shut down! + "
+
e
)
;
}
}
finally
{
shutdownServer
=
true
;
if
(
serverTftp_
!=
null
&&
serverTftp_
.
isOpen
(
)
)
{
serverTftp_
.
close
(
)
;
}
}
}
void
sendData
(
final
TFTP
tftp
,
final
TFTPPacket
data
)
throws
IOException
{
tftp
.
bufferedSend
(
data
)
;
}
public
void
setLog
(
final
PrintStream
log
)
{
this
.
log_
=
log
;
}
public
void
setLogError
(
final
PrintStream
logError
)
{
this
.
logError_
=
logError
;
}
public
void
setMaxTimeoutRetries
(
final
int
retries
)
{
if
(
retries
<
0
)
{
throw
new
RuntimeException
(
"Invalid Value"
)
;
}
maxTimeoutRetries_
=
retries
;
}
public
void
setSocketTimeout
(
final
int
timeout
)
{
if
(
timeout
<
10
)
{
throw
new
RuntimeException
(
"Invalid Value"
)
;
}
socketTimeout_
=
timeout
;
}
public
void
shutdown
(
)
{
shutdownServer
=
true
;
synchronized
(
transfers_
)
{
transfers_
.
forEach
(
TFTPTransfer
::
shutdown
)
;
}
try
{
serverTftp_
.
close
(
)
;
}
catch
(
final
RuntimeException
e
)
{
}
try
{
serverThread
.
join
(
)
;
}
catch
(
final
InterruptedException
e
)
{
}
}
}
<EOF>
