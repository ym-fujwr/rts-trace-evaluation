package
org
.
apache
.
commons
.
net
.
bsd
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
net
.
BindException
;
import
java
.
net
.
InetAddress
;
import
java
.
net
.
ServerSocket
;
import
java
.
net
.
Socket
;
import
java
.
net
.
SocketException
;
import
java
.
net
.
UnknownHostException
;
import
java
.
nio
.
charset
.
StandardCharsets
;
import
org
.
apache
.
commons
.
net
.
io
.
SocketInputStream
;
public
class
RCommandClient
extends
RExecClient
{
public
static
final
int
DEFAULT_PORT
=
514
;
public
static
final
int
MIN_CLIENT_PORT
=
512
;
public
static
final
int
MAX_CLIENT_PORT
=
1023
;
public
RCommandClient
(
)
{
setDefaultPort
(
DEFAULT_PORT
)
;
}
@
Override
public
void
connect
(
final
InetAddress
host
,
final
int
port
)
throws
SocketException
,
IOException
{
connect
(
host
,
port
,
InetAddress
.
getLocalHost
(
)
)
;
}
public
void
connect
(
final
InetAddress
host
,
final
int
port
,
final
InetAddress
localAddr
)
throws
SocketException
,
BindException
,
IOException
{
int
localPort
;
localPort
=
MAX_CLIENT_PORT
;
for
(
localPort
=
MAX_CLIENT_PORT
;
localPort
>=
MIN_CLIENT_PORT
;
--
localPort
)
{
try
{
_socket_
=
_socketFactory_
.
createSocket
(
host
,
port
,
localAddr
,
localPort
)
;
}
catch
(
final
SocketException
e
)
{
continue
;
}
break
;
}
if
(
localPort
<
MIN_CLIENT_PORT
)
{
throw
new
BindException
(
"All ports in use or insufficient permssion."
)
;
}
_connectAction_
(
)
;
}
@
Override
public
void
connect
(
final
InetAddress
host
,
final
int
port
,
final
InetAddress
localAddr
,
final
int
localPort
)
throws
SocketException
,
IOException
,
IllegalArgumentException
{
if
(
localPort
<
MIN_CLIENT_PORT
||
localPort
>
MAX_CLIENT_PORT
)
{
throw
new
IllegalArgumentException
(
"Invalid port number "
+
localPort
)
;
}
super
.
connect
(
host
,
port
,
localAddr
,
localPort
)
;
}
@
Override
public
void
connect
(
final
String
hostname
,
final
int
port
)
throws
SocketException
,
IOException
,
UnknownHostException
{
connect
(
InetAddress
.
getByName
(
hostname
)
,
port
,
InetAddress
.
getLocalHost
(
)
)
;
}
public
void
connect
(
final
String
hostname
,
final
int
port
,
final
InetAddress
localAddr
)
throws
SocketException
,
IOException
{
connect
(
InetAddress
.
getByName
(
hostname
)
,
port
,
localAddr
)
;
}
@
Override
public
void
connect
(
final
String
hostname
,
final
int
port
,
final
InetAddress
localAddr
,
final
int
localPort
)
throws
SocketException
,
IOException
,
IllegalArgumentException
,
UnknownHostException
{
if
(
localPort
<
MIN_CLIENT_PORT
||
localPort
>
MAX_CLIENT_PORT
)
{
throw
new
IllegalArgumentException
(
"Invalid port number "
+
localPort
)
;
}
super
.
connect
(
hostname
,
port
,
localAddr
,
localPort
)
;
}
@
Override
InputStream
createErrorStream
(
)
throws
IOException
{
int
localPort
;
ServerSocket
server
;
final
Socket
socket
;
localPort
=
MAX_CLIENT_PORT
;
server
=
null
;
for
(
localPort
=
MAX_CLIENT_PORT
;
localPort
>=
MIN_CLIENT_PORT
;
--
localPort
)
{
try
{
server
=
_serverSocketFactory_
.
createServerSocket
(
localPort
,
1
,
getLocalAddress
(
)
)
;
break
;
}
catch
(
final
SocketException
e
)
{
continue
;
}
}
if
(
server
==
null
)
{
throw
new
BindException
(
"All ports in use."
)
;
}
_output_
.
write
(
Integer
.
toString
(
server
.
getLocalPort
(
)
)
.
getBytes
(
StandardCharsets
.
UTF_8
)
)
;
_output_
.
write
(
NULL_CHAR
)
;
_output_
.
flush
(
)
;
socket
=
server
.
accept
(
)
;
server
.
close
(
)
;
if
(
isRemoteVerificationEnabled
(
)
&&
!
verifyRemote
(
socket
)
)
{
socket
.
close
(
)
;
throw
new
IOException
(
"Security violation: unexpected connection attempt by "
+
socket
.
getInetAddress
(
)
.
getHostAddress
(
)
)
;
}
return
new
SocketInputStream
(
socket
,
socket
.
getInputStream
(
)
)
;
}
public
void
rcommand
(
final
String
localUsername
,
final
String
remoteUsername
,
final
String
command
)
throws
IOException
{
rcommand
(
localUsername
,
remoteUsername
,
command
,
false
)
;
}
public
void
rcommand
(
final
String
localUsername
,
final
String
remoteUsername
,
final
String
command
,
final
boolean
separateErrorStream
)
throws
IOException
{
rexec
(
localUsername
,
remoteUsername
,
command
,
separateErrorStream
)
;
}
}
<EOF>
