package
org
.
apache
.
commons
.
net
.
telnet
;
import
java
.
io
.
BufferedInputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
InterruptedIOException
;
final
class
TelnetInputStream
extends
BufferedInputStream
implements
Runnable
{
private
static
final
int
EOF
=
-
1
;
private
static
final
int
WOULD_BLOCK
=
-
2
;
static
final
int
STATE_DATA
=
0
,
STATE_IAC
=
1
,
STATE_WILL
=
2
,
STATE_WONT
=
3
,
STATE_DO
=
4
,
STATE_DONT
=
5
,
STATE_SB
=
6
,
STATE_SE
=
7
,
STATE_CR
=
8
,
STATE_IAC_SB
=
9
;
private
boolean
hasReachedEOF
;
private
volatile
boolean
isClosed
;
private
boolean
readIsWaiting
;
private
int
receiveState
,
queueHead
,
queueTail
,
bytesAvailable
;
private
final
int
[
]
queue
;
private
final
TelnetClient
client
;
private
final
Thread
thread
;
private
IOException
ioException
;
private
final
int
suboption
[
]
;
private
int
suboptionCount
;
private
volatile
boolean
threaded
;
TelnetInputStream
(
final
InputStream
input
,
final
TelnetClient
client
)
{
this
(
input
,
client
,
true
)
;
}
TelnetInputStream
(
final
InputStream
input
,
final
TelnetClient
client
,
final
boolean
readerThread
)
{
super
(
input
)
;
this
.
client
=
client
;
this
.
receiveState
=
STATE_DATA
;
this
.
isClosed
=
true
;
this
.
hasReachedEOF
=
false
;
this
.
queue
=
new
int
[
2049
]
;
this
.
queueHead
=
0
;
this
.
queueTail
=
0
;
this
.
suboption
=
new
int
[
client
.
maxSubnegotiationLength
]
;
this
.
bytesAvailable
=
0
;
this
.
ioException
=
null
;
this
.
readIsWaiting
=
false
;
this
.
threaded
=
false
;
if
(
readerThread
)
{
this
.
thread
=
new
Thread
(
this
)
;
}
else
{
this
.
thread
=
null
;
}
}
@
Override
public
int
available
(
)
throws
IOException
{
synchronized
(
queue
)
{
if
(
threaded
)
{
return
bytesAvailable
;
}
return
bytesAvailable
+
super
.
available
(
)
;
}
}
@
Override
public
void
close
(
)
throws
IOException
{
super
.
close
(
)
;
synchronized
(
queue
)
{
hasReachedEOF
=
true
;
isClosed
=
true
;
if
(
thread
!=
null
&&
thread
.
isAlive
(
)
)
{
thread
.
interrupt
(
)
;
}
queue
.
notifyAll
(
)
;
}
}
@
Override
public
boolean
markSupported
(
)
{
return
false
;
}
private
boolean
processChar
(
final
int
ch
)
throws
InterruptedException
{
final
boolean
bufferWasEmpty
;
synchronized
(
queue
)
{
bufferWasEmpty
=
bytesAvailable
==
0
;
while
(
bytesAvailable
>=
queue
.
length
-
1
)
{
if
(
!
threaded
)
{
throw
new
IllegalStateException
(
"Queue is full! Cannot process another character."
)
;
}
queue
.
notify
(
)
;
try
{
queue
.
wait
(
)
;
}
catch
(
final
InterruptedException
e
)
{
throw
e
;
}
}
if
(
readIsWaiting
&&
threaded
)
{
queue
.
notify
(
)
;
}
queue
[
queueTail
]
=
ch
;
++
bytesAvailable
;
if
(
++
queueTail
>=
queue
.
length
)
{
queueTail
=
0
;
}
}
return
bufferWasEmpty
;
}
@
Override
public
int
read
(
)
throws
IOException
{
synchronized
(
queue
)
{
while
(
true
)
{
if
(
ioException
!=
null
)
{
final
IOException
e
;
e
=
ioException
;
ioException
=
null
;
throw
e
;
}
if
(
bytesAvailable
==
0
)
{
if
(
hasReachedEOF
)
{
return
EOF
;
}
if
(
threaded
)
{
queue
.
notify
(
)
;
try
{
readIsWaiting
=
true
;
queue
.
wait
(
)
;
readIsWaiting
=
false
;
}
catch
(
final
InterruptedException
e
)
{
throw
new
InterruptedIOException
(
"Fatal thread interruption during read."
)
;
}
}
else
{
readIsWaiting
=
true
;
int
ch
;
boolean
mayBlock
=
true
;
do
{
try
{
if
(
(
ch
=
read
(
mayBlock
)
)
<
0
)
{
if
(
ch
!=
WOULD_BLOCK
)
{
return
ch
;
}
}
}
catch
(
final
InterruptedIOException
e
)
{
synchronized
(
queue
)
{
ioException
=
e
;
queue
.
notifyAll
(
)
;
try
{
queue
.
wait
(
100
)
;
}
catch
(
final
InterruptedException
interrupted
)
{
}
}
return
EOF
;
}
try
{
if
(
ch
!=
WOULD_BLOCK
)
{
processChar
(
ch
)
;
}
}
catch
(
final
InterruptedException
e
)
{
if
(
isClosed
)
{
return
EOF
;
}
}
mayBlock
=
false
;
}
while
(
super
.
available
(
)
>
0
&&
bytesAvailable
<
queue
.
length
-
1
)
;
readIsWaiting
=
false
;
}
continue
;
}
final
int
ch
;
ch
=
queue
[
queueHead
]
;
if
(
++
queueHead
>=
queue
.
length
)
{
queueHead
=
0
;
}
--
bytesAvailable
;
if
(
bytesAvailable
==
0
&&
threaded
)
{
queue
.
notify
(
)
;
}
return
ch
;
}
}
}
private
int
read
(
final
boolean
mayBlock
)
throws
IOException
{
int
ch
;
while
(
true
)
{
if
(
!
mayBlock
&&
super
.
available
(
)
==
0
)
{
return
WOULD_BLOCK
;
}
if
(
(
ch
=
super
.
read
(
)
)
<
0
)
{
return
EOF
;
}
ch
=
ch
&
0xff
;
synchronized
(
client
)
{
client
.
processAYTResponse
(
)
;
}
client
.
spyRead
(
ch
)
;
switch
(
receiveState
)
{
case
STATE_CR
:
if
(
ch
==
'\0'
)
{
continue
;
}
case
STATE_DATA
:
if
(
ch
==
TelnetCommand
.
IAC
)
{
receiveState
=
STATE_IAC
;
continue
;
}
if
(
ch
==
'\r'
)
{
synchronized
(
client
)
{
if
(
client
.
requestedDont
(
TelnetOption
.
BINARY
)
)
{
receiveState
=
STATE_CR
;
}
else
{
receiveState
=
STATE_DATA
;
}
}
}
else
{
receiveState
=
STATE_DATA
;
}
break
;
case
STATE_IAC
:
switch
(
ch
)
{
case
TelnetCommand
.
WILL
:
receiveState
=
STATE_WILL
;
continue
;
case
TelnetCommand
.
WONT
:
receiveState
=
STATE_WONT
;
continue
;
case
TelnetCommand
.
DO
:
receiveState
=
STATE_DO
;
continue
;
case
TelnetCommand
.
DONT
:
receiveState
=
STATE_DONT
;
continue
;
case
TelnetCommand
.
SB
:
suboptionCount
=
0
;
receiveState
=
STATE_SB
;
continue
;
case
TelnetCommand
.
IAC
:
receiveState
=
STATE_DATA
;
break
;
case
TelnetCommand
.
SE
:
receiveState
=
STATE_DATA
;
continue
;
default
:
receiveState
=
STATE_DATA
;
client
.
processCommand
(
ch
)
;
continue
;
}
break
;
case
STATE_WILL
:
synchronized
(
client
)
{
client
.
processWill
(
ch
)
;
client
.
flushOutputStream
(
)
;
}
receiveState
=
STATE_DATA
;
continue
;
case
STATE_WONT
:
synchronized
(
client
)
{
client
.
processWont
(
ch
)
;
client
.
flushOutputStream
(
)
;
}
receiveState
=
STATE_DATA
;
continue
;
case
STATE_DO
:
synchronized
(
client
)
{
client
.
processDo
(
ch
)
;
client
.
flushOutputStream
(
)
;
}
receiveState
=
STATE_DATA
;
continue
;
case
STATE_DONT
:
synchronized
(
client
)
{
client
.
processDont
(
ch
)
;
client
.
flushOutputStream
(
)
;
}
receiveState
=
STATE_DATA
;
continue
;
case
STATE_SB
:
switch
(
ch
)
{
case
TelnetCommand
.
IAC
:
receiveState
=
STATE_IAC_SB
;
continue
;
default
:
if
(
suboptionCount
<
suboption
.
length
)
{
suboption
[
suboptionCount
++
]
=
ch
;
}
break
;
}
receiveState
=
STATE_SB
;
continue
;
case
STATE_IAC_SB
:
switch
(
ch
)
{
case
TelnetCommand
.
SE
:
synchronized
(
client
)
{
client
.
processSuboption
(
suboption
,
suboptionCount
)
;
client
.
flushOutputStream
(
)
;
}
receiveState
=
STATE_DATA
;
continue
;
case
TelnetCommand
.
IAC
:
if
(
suboptionCount
<
suboption
.
length
)
{
suboption
[
suboptionCount
++
]
=
ch
;
}
break
;
default
:
break
;
}
receiveState
=
STATE_SB
;
continue
;
}
break
;
}
return
ch
;
}
@
Override
public
int
read
(
final
byte
buffer
[
]
)
throws
IOException
{
return
read
(
buffer
,
0
,
buffer
.
length
)
;
}
@
Override
public
int
read
(
final
byte
buffer
[
]
,
int
offset
,
int
length
)
throws
IOException
{
int
ch
;
final
int
off
;
if
(
length
<
1
)
{
return
0
;
}
synchronized
(
queue
)
{
if
(
length
>
bytesAvailable
)
{
length
=
bytesAvailable
;
}
}
if
(
(
ch
=
read
(
)
)
==
EOF
)
{
return
EOF
;
}
off
=
offset
;
do
{
buffer
[
offset
++
]
=
(
byte
)
ch
;
}
while
(
--
length
>
0
&&
(
ch
=
read
(
)
)
!=
EOF
)
;
return
offset
-
off
;
}
@
Override
public
void
run
(
)
{
int
ch
;
try
{
_outerLoop
:
while
(
!
isClosed
)
{
try
{
if
(
(
ch
=
read
(
true
)
)
<
0
)
{
break
;
}
}
catch
(
final
InterruptedIOException
e
)
{
synchronized
(
queue
)
{
ioException
=
e
;
queue
.
notifyAll
(
)
;
try
{
queue
.
wait
(
100
)
;
}
catch
(
final
InterruptedException
interrupted
)
{
if
(
isClosed
)
{
break
_outerLoop
;
}
}
continue
;
}
}
catch
(
final
RuntimeException
re
)
{
super
.
close
(
)
;
break
_outerLoop
;
}
boolean
notify
=
false
;
try
{
notify
=
processChar
(
ch
)
;
}
catch
(
final
InterruptedException
e
)
{
if
(
isClosed
)
{
break
_outerLoop
;
}
}
if
(
notify
)
{
client
.
notifyInputListener
(
)
;
}
}
}
catch
(
final
IOException
ioe
)
{
synchronized
(
queue
)
{
ioException
=
ioe
;
}
client
.
notifyInputListener
(
)
;
}
synchronized
(
queue
)
{
isClosed
=
true
;
hasReachedEOF
=
true
;
queue
.
notify
(
)
;
}
threaded
=
false
;
}
void
start
(
)
{
if
(
thread
==
null
)
{
return
;
}
int
priority
;
isClosed
=
false
;
priority
=
Thread
.
currentThread
(
)
.
getPriority
(
)
+
1
;
if
(
priority
>
Thread
.
MAX_PRIORITY
)
{
priority
=
Thread
.
MAX_PRIORITY
;
}
thread
.
setPriority
(
priority
)
;
thread
.
setDaemon
(
true
)
;
thread
.
start
(
)
;
threaded
=
true
;
}
}
<EOF>
