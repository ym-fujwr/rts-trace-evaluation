package
org
.
apache
.
commons
.
net
.
ftp
.
parser
;
import
org
.
apache
.
commons
.
net
.
ftp
.
FTPFile
;
import
org
.
apache
.
commons
.
net
.
ftp
.
FTPFileEntryParser
;
public
abstract
class
CompositeFTPParseTestFramework
extends
FTPParseTestFramework
{
public
CompositeFTPParseTestFramework
(
final
String
name
)
{
super
(
name
)
;
}
@
Override
protected
String
[
]
getBadListing
(
)
{
return
getBadListings
(
)
[
0
]
;
}
protected
abstract
String
[
]
[
]
getBadListings
(
)
;
@
Override
protected
String
[
]
getGoodListing
(
)
{
return
getGoodListings
(
)
[
0
]
;
}
protected
abstract
String
[
]
[
]
getGoodListings
(
)
;
@
Override
public
void
testBadListing
(
)
{
final
String
badsamples
[
]
[
]
=
getBadListings
(
)
;
for
(
final
String
[
]
badsample
:
badsamples
)
{
final
FTPFileEntryParser
parser
=
getParser
(
)
;
for
(
final
String
test
:
badsample
)
{
final
FTPFile
f
=
parser
.
parseFTPEntry
(
test
)
;
assertNull
(
"Should have Failed to parse "
+
test
,
nullFileOrNullDate
(
f
)
)
;
doAdditionalBadTests
(
test
,
f
)
;
}
}
}
public
void
testConsistentListing
(
)
{
final
String
goodsamples
[
]
[
]
=
getGoodListings
(
)
;
for
(
final
String
[
]
goodsample
:
goodsamples
)
{
final
FTPFileEntryParser
parser
=
getParser
(
)
;
for
(
final
String
test
:
goodsample
)
{
final
FTPFile
f
=
parser
.
parseFTPEntry
(
test
)
;
assertNotNull
(
"Failed to parse "
+
test
,
f
)
;
doAdditionalGoodTests
(
test
,
f
)
;
}
}
}
public
void
testInconsistentListing
(
)
{
final
String
goodsamples
[
]
[
]
=
getGoodListings
(
)
;
final
FTPFileEntryParser
parser
=
getParser
(
)
;
for
(
int
i
=
0
;
i
<
goodsamples
.
length
;
i
++
)
{
final
String
test
=
goodsamples
[
i
]
[
0
]
;
final
FTPFile
f
=
parser
.
parseFTPEntry
(
test
)
;
switch
(
i
)
{
case
0
:
assertNotNull
(
"Failed to parse "
+
test
,
f
)
;
break
;
case
1
:
assertNull
(
"Should have failed to parse "
+
test
,
f
)
;
break
;
}
}
}
}
<EOF>
