diff --git a/src/main/java/org/apache/commons/net/ProtocolCommandSupport.java b/src/main/java/org/apache/commons/net/ProtocolCommandSupport.java
index 869748c50..ae8ca01d1 100644
--- a/src/main/java/org/apache/commons/net/ProtocolCommandSupport.java
+++ b/src/main/java/org/apache/commons/net/ProtocolCommandSupport.java
@@ -103,0 +104,8 @@ public class ProtocolCommandSupport implements Serializable {
+    private void readObject(final java.io.ObjectInputStream in) throws IOException, ClassNotFoundException {
+        throw new UnsupportedOperationException("Serialization is not supported");
+    }
+
+    /*
+     * Serialization is unnecessary for this class. Reject attempts to do so until such time as the Serializable attribute can be dropped.
+     */
+
@@ -113,4 +120,0 @@ public class ProtocolCommandSupport implements Serializable {
-    /*
-     * Serialization is unnecessary for this class. Reject attempts to do so until such time as the Serializable attribute can be dropped.
-     */
-
@@ -121,4 +124,0 @@ public class ProtocolCommandSupport implements Serializable {
-    private void readObject(final java.io.ObjectInputStream in) throws IOException, ClassNotFoundException {
-        throw new UnsupportedOperationException("Serialization is not supported");
-    }
-
diff --git a/src/main/java/org/apache/commons/net/ftp/FTPClient.java b/src/main/java/org/apache/commons/net/ftp/FTPClient.java
index a4205d29e..21c1d5625 100644
--- a/src/main/java/org/apache/commons/net/ftp/FTPClient.java
+++ b/src/main/java/org/apache/commons/net/ftp/FTPClient.java
@@ -2122,0 +2123,15 @@ public class FTPClient extends FTP implements Configurable {
+    /**
+     * Returns, whether the IP address from the server's response should be used. Until 3.9.0, this has always been the case. Beginning with 3.9.0, that IP
+     * address will be silently ignored, and replaced with the remote IP address of the control connection, unless this configuration option is given, which
+     * restores the old behavior. To enable this by default, use the system property {@link FTPClient#FTP_IP_ADDRESS_FROM_PASV_RESPONSE}.
+     *
+     * @return True, if the IP address from the server's response will be used (pre-3.9 compatible behavior), or false (ignore that IP address).
+     *
+     * @see FTPClient#FTP_IP_ADDRESS_FROM_PASV_RESPONSE
+     * @see #setIpAddressFromPasvResponse(boolean)
+     * @since 3.9.0
+     */
+    public boolean isIpAddressFromPasvResponse() {
+        return ipAddressFromPasvResponse;
+    }
+
@@ -3084,0 +3100,15 @@ public class FTPClient extends FTP implements Configurable {
+    /**
+     * Sets whether the IP address from the server's response should be used. Until 3.9.0, this has always been the case. Beginning with 3.9.0, that IP address
+     * will be silently ignored, and replaced with the remote IP address of the control connection, unless this configuration option is given, which restores
+     * the old behavior. To enable this by default, use the system property {@link FTPClient#FTP_IP_ADDRESS_FROM_PASV_RESPONSE}.
+     *
+     * @param usingIpAddressFromPasvResponse True, if the IP address from the server's response should be used (pre-3.9.0 compatible behavior), or false (ignore
+     *                                       that IP address).
+     * @see FTPClient#FTP_IP_ADDRESS_FROM_PASV_RESPONSE
+     * @see #isIpAddressFromPasvResponse
+     * @since 3.9.0
+     */
+    public void setIpAddressFromPasvResponse(boolean usingIpAddressFromPasvResponse) {
+        this.ipAddressFromPasvResponse = usingIpAddressFromPasvResponse;
+    }
+
@@ -3391,30 +3420,0 @@ public class FTPClient extends FTP implements Configurable {
-
-    /**
-     * Returns, whether the IP address from the server's response should be used. Until 3.9.0, this has always been the case. Beginning with 3.9.0, that IP
-     * address will be silently ignored, and replaced with the remote IP address of the control connection, unless this configuration option is given, which
-     * restores the old behavior. To enable this by default, use the system property {@link FTPClient#FTP_IP_ADDRESS_FROM_PASV_RESPONSE}.
-     *
-     * @return True, if the IP address from the server's response will be used (pre-3.9 compatible behavior), or false (ignore that IP address).
-     *
-     * @see FTPClient#FTP_IP_ADDRESS_FROM_PASV_RESPONSE
-     * @see #setIpAddressFromPasvResponse(boolean)
-     * @since 3.9.0
-     */
-    public boolean isIpAddressFromPasvResponse() {
-        return ipAddressFromPasvResponse;
-    }
-
-    /**
-     * Sets whether the IP address from the server's response should be used. Until 3.9.0, this has always been the case. Beginning with 3.9.0, that IP address
-     * will be silently ignored, and replaced with the remote IP address of the control connection, unless this configuration option is given, which restores
-     * the old behavior. To enable this by default, use the system property {@link FTPClient#FTP_IP_ADDRESS_FROM_PASV_RESPONSE}.
-     *
-     * @param usingIpAddressFromPasvResponse True, if the IP address from the server's response should be used (pre-3.9.0 compatible behavior), or false (ignore
-     *                                       that IP address).
-     * @see FTPClient#FTP_IP_ADDRESS_FROM_PASV_RESPONSE
-     * @see #isIpAddressFromPasvResponse
-     * @since 3.9.0
-     */
-    public void setIpAddressFromPasvResponse(boolean usingIpAddressFromPasvResponse) {
-        this.ipAddressFromPasvResponse = usingIpAddressFromPasvResponse;
-    }
diff --git a/src/main/java/org/apache/commons/net/ftp/FTPFile.java b/src/main/java/org/apache/commons/net/ftp/FTPFile.java
index cd83dbc87..ef3464c9d 100644
--- a/src/main/java/org/apache/commons/net/ftp/FTPFile.java
+++ b/src/main/java/org/apache/commons/net/ftp/FTPFile.java
@@ -292,0 +293,4 @@ public class FTPFile implements Serializable {
+    private void readObject(final java.io.ObjectInputStream in) throws IOException, ClassNotFoundException {
+        throw new UnsupportedOperationException("Serialization is not supported");
+    }
+
@@ -459,0 +464,4 @@ public class FTPFile implements Serializable {
+    /*
+     * Serialization is unnecessary for this class. Reject attempts to do so until such time as the Serializable attribute can be dropped.
+     */
+
@@ -470,4 +477,0 @@ public class FTPFile implements Serializable {
-    /*
-     * Serialization is unnecessary for this class. Reject attempts to do so until such time as the Serializable attribute can be dropped.
-     */
-
@@ -478,4 +481,0 @@ public class FTPFile implements Serializable {
-    private void readObject(final java.io.ObjectInputStream in) throws IOException, ClassNotFoundException {
-        throw new UnsupportedOperationException("Serialization is not supported");
-    }
-
diff --git a/src/main/java/org/apache/commons/net/ftp/FTPListParseEngine.java b/src/main/java/org/apache/commons/net/ftp/FTPListParseEngine.java
index 5946c54cc..250a86a69 100644
--- a/src/main/java/org/apache/commons/net/ftp/FTPListParseEngine.java
+++ b/src/main/java/org/apache/commons/net/ftp/FTPListParseEngine.java
@@ -95,0 +96,19 @@ public class FTPListParseEngine {
+    /**
+     * Returns a list of FTPFile objects containing the whole list of files returned by the server as read by this object's parser. The files are filtered
+     * before being added to the array.
+     *
+     * @param filter FTPFileFilter, must not be <code>null</code>.
+     *
+     * @return a list of FTPFile objects containing the whole list of files returned by the server as read by this object's parser.
+     *         <p>
+     *         <b> NOTE:</b> This array may contain null members if any of the individual file listings failed to parse. The caller should check each entry for
+     *         null before referencing it, or use the a filter such as {@link FTPFileFilters#NON_NULL} which does not allow null entries.
+     * @since 3.9.0
+     */
+    public List<FTPFile> getFileList(final FTPFileFilter filter) {
+        return entries.stream().map(e -> {
+            final FTPFile file = parser.parseFTPEntry(e);
+            return file == null && saveUnparseableEntries ? new FTPFile(e) : file;
+        }).filter(file -> filter.accept(file)).collect(Collectors.toList());
+    }
+
@@ -126,19 +144,0 @@ public class FTPListParseEngine {
-    /**
-     * Returns a list of FTPFile objects containing the whole list of files returned by the server as read by this object's parser. The files are filtered
-     * before being added to the array.
-     *
-     * @param filter FTPFileFilter, must not be <code>null</code>.
-     *
-     * @return a list of FTPFile objects containing the whole list of files returned by the server as read by this object's parser.
-     *         <p>
-     *         <b> NOTE:</b> This array may contain null members if any of the individual file listings failed to parse. The caller should check each entry for
-     *         null before referencing it, or use the a filter such as {@link FTPFileFilters#NON_NULL} which does not allow null entries.
-     * @since 3.9.0
-     */
-    public List<FTPFile> getFileList(final FTPFileFilter filter) {
-        return entries.stream().map(e -> {
-            final FTPFile file = parser.parseFTPEntry(e);
-            return file == null && saveUnparseableEntries ? new FTPFile(e) : file;
-        }).filter(file -> filter.accept(file)).collect(Collectors.toList());
-    }
-
diff --git a/src/main/java/org/apache/commons/net/ftp/FTPSClient.java b/src/main/java/org/apache/commons/net/ftp/FTPSClient.java
index 47f321375..15d7f3a24 100644
--- a/src/main/java/org/apache/commons/net/ftp/FTPSClient.java
+++ b/src/main/java/org/apache/commons/net/ftp/FTPSClient.java
@@ -284,146 +283,0 @@ public class FTPSClient extends FTPClient {
-    /**
-     * Establishes a data connection with the FTP server, returning a Socket for the connection if successful. If a restart offset has been set with
-     * {@link #setRestartOffset(long)}, a REST command is issued to the server with the offset as an argument before establishing the data connection. Active
-     * mode connections also cause a local PORT command to be issued.
-     *
-     * @param command The text representation of the FTP command to send.
-     * @param arg     The arguments to the FTP command. If this parameter is set to null, then the command is sent with no argument.
-     * @return A Socket corresponding to the established data connection. Null is returned if an FTP protocol error is reported at any point during the
-     *         establishment and initialization of the connection.
-     * @throws IOException If an I/O error occurs while either sending a command to the server or receiving a reply from the server.
-     * @since 3.1
-     */
-    private Socket openDataSecureConnection(String command, String arg) throws IOException {
-        if (getDataConnectionMode() != ACTIVE_LOCAL_DATA_CONNECTION_MODE && getDataConnectionMode() != PASSIVE_LOCAL_DATA_CONNECTION_MODE) {
-            return null;
-        }
-
-        final boolean isInet6Address = getRemoteAddress() instanceof Inet6Address;
-
-        final Socket socket;
-        Socket sslSocket = null;
-        final int soTimeoutMillis = DurationUtils.toMillisInt(getDataTimeout());
-        if (getDataConnectionMode() == ACTIVE_LOCAL_DATA_CONNECTION_MODE) {
-            // if no activePortRange was set (correctly) -> getActivePort() = 0
-            // -> new ServerSocket(0) -> bind to any free local port
-            try (final ServerSocket server = _serverSocketFactory_.createServerSocket(getActivePort(), 1, getHostAddress())) {
-                // Try EPRT only if remote server is over IPv6, if not use PORT,
-                // because EPRT has no advantage over PORT on IPv4.
-                // It could even have the disadvantage,
-                // that EPRT will make the data connection fail, because
-                // today's intelligent NAT Firewalls are able to
-                // substitute IP addresses in the PORT command,
-                // but might not be able to recognize the EPRT command.
-                if (isInet6Address) {
-                    if (!FTPReply.isPositiveCompletion(eprt(getReportHostAddress(), server.getLocalPort()))) {
-                        return null;
-                    }
-                } else if (!FTPReply.isPositiveCompletion(port(getReportHostAddress(), server.getLocalPort()))) {
-                    return null;
-                }
-
-                if ((getRestartOffset() > 0) && !restart(getRestartOffset())) {
-                    return null;
-                }
-
-                if (!FTPReply.isPositivePreliminary(sendCommand(command, arg))) {
-                    return null;
-                }
-
-                // For now, let's just use the data timeout value for waiting for
-                // the data connection. It may be desirable to let this be a
-                // separately configurable value. In any case, we really want
-                // to allow preventing the accept from blocking indefinitely.
-                if (soTimeoutMillis >= 0) {
-                    server.setSoTimeout(soTimeoutMillis);
-                }
-                socket = server.accept();
-
-                // Ensure the timeout is set before any commands are issued on the new socket
-                if (soTimeoutMillis >= 0) {
-                    socket.setSoTimeout(soTimeoutMillis);
-                }
-                if (getReceiveDataSocketBufferSize() > 0) {
-                    socket.setReceiveBufferSize(getReceiveDataSocketBufferSize());
-                }
-                if (getSendDataSocketBufferSize() > 0) {
-                    socket.setSendBufferSize(getSendDataSocketBufferSize());
-                }
-            }
-        } else { // We must be in PASSIVE_LOCAL_DATA_CONNECTION_MODE
-
-            // Try EPSV command first on IPv6 - and IPv4 if enabled.
-            // When using IPv4 with NAT it has the advantage
-            // to work with more rare configurations.
-            // E.g. if FTP server has a static PASV address (external network)
-            // and the client is coming from another internal network.
-            // In that case the data connection after PASV command would fail,
-            // while EPSV would make the client succeed by taking just the port.
-            final boolean attemptEPSV = isUseEPSVwithIPv4() || isInet6Address;
-            if (attemptEPSV && epsv() == FTPReply.ENTERING_EPSV_MODE) {
-                _parseExtendedPassiveModeReply(_replyLines.get(0));
-            } else {
-                if (isInet6Address) {
-                    return null; // Must use EPSV for IPV6
-                }
-                // If EPSV failed on IPV4, revert to PASV
-                if (pasv() != FTPReply.ENTERING_PASSIVE_MODE) {
-                    return null;
-                }
-                _parsePassiveModeReply(_replyLines.get(0));
-            }
-
-            if (getProxy() != null) {
-                socket = new Socket(getProxy());
-            } else {
-                socket = _socketFactory_.createSocket();
-            }
-
-            if (getReceiveDataSocketBufferSize() > 0) {
-                socket.setReceiveBufferSize(getReceiveDataSocketBufferSize());
-            }
-            if (getSendDataSocketBufferSize() > 0) {
-                socket.setSendBufferSize(getSendDataSocketBufferSize());
-            }
-            if (getPassiveLocalIPAddress() != null) {
-                socket.bind(new InetSocketAddress(getPassiveLocalIPAddress(), 0));
-            }
-
-            // For now, let's just use the data timeout value for waiting for
-            // the data connection. It may be desirable to let this be a
-            // separately configurable value. In any case, we really want
-            // to allow preventing the accept from blocking indefinitely.
-            if (soTimeoutMillis >= 0) {
-                socket.setSoTimeout(soTimeoutMillis);
-            }
-
-            socket.connect(new InetSocketAddress(getPassiveHost(), getPassivePort()), connectTimeout);
-
-            if (getProxy() != null) {
-                sslSocket = context.getSocketFactory().createSocket(socket, getPassiveHost(), getPassivePort(), true);
-            }
-
-            if ((getRestartOffset() > 0) && !restart(getRestartOffset())) {
-                closeSockets(socket, sslSocket);
-                return null;
-            }
-
-            if (!FTPReply.isPositivePreliminary(sendCommand(command, arg))) {
-                closeSockets(socket, sslSocket);
-                return null;
-            }
-        }
-
-        if (isRemoteVerificationEnabled() && !verifyRemote(socket)) {
-            // Grab the host before we close the socket to avoid NET-663
-            final InetAddress socketHost = socket.getInetAddress();
-
-            closeSockets(socket, sslSocket);
-
-            throw new IOException(
-                    "Host attempting data connection " + socketHost.getHostAddress() + " is not same as server " + getRemoteAddress().getHostAddress());
-        }
-
-        return getProxy() != null ? sslSocket : socket;
-    }
-
@@ -455,0 +310,16 @@ public class FTPSClient extends FTPClient {
+    /**
+     * Close open sockets.
+     *
+     * @param socket    main socket for proxy if enabled
+     * @param sslSocket ssl socket
+     * @throws IOException closing sockets is not successful
+     */
+    private void closeSockets(Socket socket, Socket sslSocket) throws IOException {
+        if (socket != null) {
+            socket.close();
+        }
+        if (sslSocket != null) {
+            sslSocket.close();
+        }
+    }
+
@@ -805,0 +676,146 @@ public class FTPSClient extends FTPClient {
+    /**
+     * Establishes a data connection with the FTP server, returning a Socket for the connection if successful. If a restart offset has been set with
+     * {@link #setRestartOffset(long)}, a REST command is issued to the server with the offset as an argument before establishing the data connection. Active
+     * mode connections also cause a local PORT command to be issued.
+     *
+     * @param command The text representation of the FTP command to send.
+     * @param arg     The arguments to the FTP command. If this parameter is set to null, then the command is sent with no argument.
+     * @return A Socket corresponding to the established data connection. Null is returned if an FTP protocol error is reported at any point during the
+     *         establishment and initialization of the connection.
+     * @throws IOException If an I/O error occurs while either sending a command to the server or receiving a reply from the server.
+     * @since 3.1
+     */
+    private Socket openDataSecureConnection(String command, String arg) throws IOException {
+        if (getDataConnectionMode() != ACTIVE_LOCAL_DATA_CONNECTION_MODE && getDataConnectionMode() != PASSIVE_LOCAL_DATA_CONNECTION_MODE) {
+            return null;
+        }
+
+        final boolean isInet6Address = getRemoteAddress() instanceof Inet6Address;
+
+        final Socket socket;
+        Socket sslSocket = null;
+        final int soTimeoutMillis = DurationUtils.toMillisInt(getDataTimeout());
+        if (getDataConnectionMode() == ACTIVE_LOCAL_DATA_CONNECTION_MODE) {
+            // if no activePortRange was set (correctly) -> getActivePort() = 0
+            // -> new ServerSocket(0) -> bind to any free local port
+            try (final ServerSocket server = _serverSocketFactory_.createServerSocket(getActivePort(), 1, getHostAddress())) {
+                // Try EPRT only if remote server is over IPv6, if not use PORT,
+                // because EPRT has no advantage over PORT on IPv4.
+                // It could even have the disadvantage,
+                // that EPRT will make the data connection fail, because
+                // today's intelligent NAT Firewalls are able to
+                // substitute IP addresses in the PORT command,
+                // but might not be able to recognize the EPRT command.
+                if (isInet6Address) {
+                    if (!FTPReply.isPositiveCompletion(eprt(getReportHostAddress(), server.getLocalPort()))) {
+                        return null;
+                    }
+                } else if (!FTPReply.isPositiveCompletion(port(getReportHostAddress(), server.getLocalPort()))) {
+                    return null;
+                }
+
+                if ((getRestartOffset() > 0) && !restart(getRestartOffset())) {
+                    return null;
+                }
+
+                if (!FTPReply.isPositivePreliminary(sendCommand(command, arg))) {
+                    return null;
+                }
+
+                // For now, let's just use the data timeout value for waiting for
+                // the data connection. It may be desirable to let this be a
+                // separately configurable value. In any case, we really want
+                // to allow preventing the accept from blocking indefinitely.
+                if (soTimeoutMillis >= 0) {
+                    server.setSoTimeout(soTimeoutMillis);
+                }
+                socket = server.accept();
+
+                // Ensure the timeout is set before any commands are issued on the new socket
+                if (soTimeoutMillis >= 0) {
+                    socket.setSoTimeout(soTimeoutMillis);
+                }
+                if (getReceiveDataSocketBufferSize() > 0) {
+                    socket.setReceiveBufferSize(getReceiveDataSocketBufferSize());
+                }
+                if (getSendDataSocketBufferSize() > 0) {
+                    socket.setSendBufferSize(getSendDataSocketBufferSize());
+                }
+            }
+        } else { // We must be in PASSIVE_LOCAL_DATA_CONNECTION_MODE
+
+            // Try EPSV command first on IPv6 - and IPv4 if enabled.
+            // When using IPv4 with NAT it has the advantage
+            // to work with more rare configurations.
+            // E.g. if FTP server has a static PASV address (external network)
+            // and the client is coming from another internal network.
+            // In that case the data connection after PASV command would fail,
+            // while EPSV would make the client succeed by taking just the port.
+            final boolean attemptEPSV = isUseEPSVwithIPv4() || isInet6Address;
+            if (attemptEPSV && epsv() == FTPReply.ENTERING_EPSV_MODE) {
+                _parseExtendedPassiveModeReply(_replyLines.get(0));
+            } else {
+                if (isInet6Address) {
+                    return null; // Must use EPSV for IPV6
+                }
+                // If EPSV failed on IPV4, revert to PASV
+                if (pasv() != FTPReply.ENTERING_PASSIVE_MODE) {
+                    return null;
+                }
+                _parsePassiveModeReply(_replyLines.get(0));
+            }
+
+            if (getProxy() != null) {
+                socket = new Socket(getProxy());
+            } else {
+                socket = _socketFactory_.createSocket();
+            }
+
+            if (getReceiveDataSocketBufferSize() > 0) {
+                socket.setReceiveBufferSize(getReceiveDataSocketBufferSize());
+            }
+            if (getSendDataSocketBufferSize() > 0) {
+                socket.setSendBufferSize(getSendDataSocketBufferSize());
+            }
+            if (getPassiveLocalIPAddress() != null) {
+                socket.bind(new InetSocketAddress(getPassiveLocalIPAddress(), 0));
+            }
+
+            // For now, let's just use the data timeout value for waiting for
+            // the data connection. It may be desirable to let this be a
+            // separately configurable value. In any case, we really want
+            // to allow preventing the accept from blocking indefinitely.
+            if (soTimeoutMillis >= 0) {
+                socket.setSoTimeout(soTimeoutMillis);
+            }
+
+            socket.connect(new InetSocketAddress(getPassiveHost(), getPassivePort()), connectTimeout);
+
+            if (getProxy() != null) {
+                sslSocket = context.getSocketFactory().createSocket(socket, getPassiveHost(), getPassivePort(), true);
+            }
+
+            if ((getRestartOffset() > 0) && !restart(getRestartOffset())) {
+                closeSockets(socket, sslSocket);
+                return null;
+            }
+
+            if (!FTPReply.isPositivePreliminary(sendCommand(command, arg))) {
+                closeSockets(socket, sslSocket);
+                return null;
+            }
+        }
+
+        if (isRemoteVerificationEnabled() && !verifyRemote(socket)) {
+            // Grab the host before we close the socket to avoid NET-663
+            final InetAddress socketHost = socket.getInetAddress();
+
+            closeSockets(socket, sslSocket);
+
+            throw new IOException(
+                    "Host attempting data connection " + socketHost.getHostAddress() + " is not same as server " + getRemoteAddress().getHostAddress());
+        }
+
+        return getProxy() != null ? sslSocket : socket;
+    }
+
@@ -937,0 +954,2 @@ public class FTPSClient extends FTPClient {
+    // DEPRECATED - for API compatibility only - DO NOT USE
+
@@ -947,2 +964,0 @@ public class FTPSClient extends FTPClient {
-    // DEPRECATED - for API compatibility only - DO NOT USE
-
@@ -1017,16 +1032,0 @@ public class FTPSClient extends FTPClient {
-    /**
-     * Close open sockets.
-     *
-     * @param socket    main socket for proxy if enabled
-     * @param sslSocket ssl socket
-     * @throws IOException closing sockets is not successful
-     */
-    private void closeSockets(Socket socket, Socket sslSocket) throws IOException {
-        if (socket != null) {
-            socket.close();
-        }
-        if (sslSocket != null) {
-            sslSocket.close();
-        }
-    }
-
diff --git a/src/main/java/org/apache/commons/net/ntp/TimeStamp.java b/src/main/java/org/apache/commons/net/ntp/TimeStamp.java
index 506b1b440..e98c4355d 100644
--- a/src/main/java/org/apache/commons/net/ntp/TimeStamp.java
+++ b/src/main/java/org/apache/commons/net/ntp/TimeStamp.java
@@ -345,0 +346,4 @@ public class TimeStamp implements Serializable, Comparable<TimeStamp> {
+    private void readObject(final java.io.ObjectInputStream in) throws IOException, ClassNotFoundException {
+        throw new UnsupportedOperationException("Serialization is not supported");
+    }
+
@@ -376,0 +381,4 @@ public class TimeStamp implements Serializable, Comparable<TimeStamp> {
+    /*
+     * Serialization is unnecessary for this class. Reject attempts to do so until such time as the Serializable attribute can be dropped.
+     */
+
@@ -397,4 +404,0 @@ public class TimeStamp implements Serializable, Comparable<TimeStamp> {
-    /*
-     * Serialization is unnecessary for this class. Reject attempts to do so until such time as the Serializable attribute can be dropped.
-     */
-
@@ -405,4 +408,0 @@ public class TimeStamp implements Serializable, Comparable<TimeStamp> {
-    private void readObject(final java.io.ObjectInputStream in) throws IOException, ClassNotFoundException {
-        throw new UnsupportedOperationException("Serialization is not supported");
-    }
-
diff --git a/src/main/java/org/apache/commons/net/util/ListenerList.java b/src/main/java/org/apache/commons/net/util/ListenerList.java
index a54f5dcbd..ea1e0d529 100644
--- a/src/main/java/org/apache/commons/net/util/ListenerList.java
+++ b/src/main/java/org/apache/commons/net/util/ListenerList.java
@@ -59,2 +59,2 @@ public class ListenerList implements Serializable, Iterable<EventListener> {
-    public void removeListener(final EventListener listener) {
-        listeners.remove(listener);
+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {
+        throw new UnsupportedOperationException("Serialization is not supported");
@@ -67,2 +67,2 @@ public class ListenerList implements Serializable, Iterable<EventListener> {
-    private void writeObject(final ObjectOutputStream out) throws IOException {
-        throw new UnsupportedOperationException("Serialization is not supported");
+    public void removeListener(final EventListener listener) {
+        listeners.remove(listener);
@@ -71 +71 @@ public class ListenerList implements Serializable, Iterable<EventListener> {
-    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {
+    private void writeObject(final ObjectOutputStream out) throws IOException {
diff --git a/src/test/java/org/apache/commons/net/ftp/FTPSClientTest.java b/src/test/java/org/apache/commons/net/ftp/FTPSClientTest.java
index ba83b7426..780c6d060 100644
--- a/src/test/java/org/apache/commons/net/ftp/FTPSClientTest.java
+++ b/src/test/java/org/apache/commons/net/ftp/FTPSClientTest.java
@@ -76,0 +77,6 @@ public class FTPSClientTest {
+    private static final long TEST_TIMEOUT = 10000; // individual test timeout
+
+    private static final boolean TRACE_CALLS = Boolean.parseBoolean(System.getenv("TRACE_CALLS"));
+    private static final boolean ADD_LISTENER = Boolean.parseBoolean(System.getenv("ADD_LISTENER"));
+    private static final long startTime = System.nanoTime();
+
@@ -86,12 +91,0 @@ public class FTPSClientTest {
-    private static final long TEST_TIMEOUT = 10000; // individual test timeout
-    private static final boolean TRACE_CALLS = Boolean.parseBoolean(System.getenv("TRACE_CALLS"));
-    private static final boolean ADD_LISTENER = Boolean.parseBoolean(System.getenv("ADD_LISTENER"));
-
-    private static final long startTime = System.nanoTime();
-
-    private static void trace(String msg) {
-        if (TRACE_CALLS) {
-            System.err.println(msg + " " + (System.nanoTime() - startTime));
-        }
-    }
-
@@ -162,0 +157,6 @@ public class FTPSClientTest {
+    private static void trace(String msg) {
+        if (TRACE_CALLS) {
+            System.err.println(msg + " " + (System.nanoTime() - startTime));
+        }
+    }
+
diff --git a/src/test/java/org/apache/commons/net/ftp/NoProtocolSslConfigurationProxy.java b/src/test/java/org/apache/commons/net/ftp/NoProtocolSslConfigurationProxy.java
index 060c9eb78..65bd9517b 100644
--- a/src/test/java/org/apache/commons/net/ftp/NoProtocolSslConfigurationProxy.java
+++ b/src/test/java/org/apache/commons/net/ftp/NoProtocolSslConfigurationProxy.java
@@ -33,5 +32,0 @@ public class NoProtocolSslConfigurationProxy implements SslConfiguration {
-    @Override
-    public String[] getEnabledProtocols() {
-        return null;
-    }
-
@@ -45,2 +40,2 @@ public class NoProtocolSslConfigurationProxy implements SslConfiguration {
-    public SSLSocketFactory getSocketFactory() throws GeneralSecurityException {
-        return this.sslConfiguration.getSocketFactory();
+    public ClientAuth getClientAuth() {
+        return this.sslConfiguration.getClientAuth();
@@ -50,2 +45,2 @@ public class NoProtocolSslConfigurationProxy implements SslConfiguration {
-    public SSLContext getSSLContext() throws GeneralSecurityException {
-        return this.sslConfiguration.getSSLContext();
+    public String[] getEnabledCipherSuites() {
+        return this.sslConfiguration.getEnabledCipherSuites();
@@ -55,2 +50,2 @@ public class NoProtocolSslConfigurationProxy implements SslConfiguration {
-    public SSLContext getSSLContext(String protocol) throws GeneralSecurityException {
-        return this.sslConfiguration.getSSLContext(protocol);
+    public String[] getEnabledProtocols() {
+        return null;
@@ -60,2 +55,2 @@ public class NoProtocolSslConfigurationProxy implements SslConfiguration {
-    public String[] getEnabledCipherSuites() {
-        return this.sslConfiguration.getEnabledCipherSuites();
+    public SSLSocketFactory getSocketFactory() throws GeneralSecurityException {
+        return this.sslConfiguration.getSocketFactory();
@@ -65,2 +60,7 @@ public class NoProtocolSslConfigurationProxy implements SslConfiguration {
-    public ClientAuth getClientAuth() {
-        return this.sslConfiguration.getClientAuth();
+    public SSLContext getSSLContext() throws GeneralSecurityException {
+        return this.sslConfiguration.getSSLContext();
+    }
+
+    @Override
+    public SSLContext getSSLContext(String protocol) throws GeneralSecurityException {
+        return this.sslConfiguration.getSSLContext(protocol);
