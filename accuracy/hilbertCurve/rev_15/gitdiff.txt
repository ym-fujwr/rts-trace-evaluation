diff --git a/src/main/java/org/davidmoten/hilbert/Range.java b/src/main/java/org/davidmoten/hilbert/Range.java
index 04bd2bf..0303342 100644
--- a/src/main/java/org/davidmoten/hilbert/Range.java
+++ b/src/main/java/org/davidmoten/hilbert/Range.java
@@ -21 +21 @@ public final class Range {
-    
+
@@ -23 +23 @@ public final class Range {
-        return new Range(value,value);
+        return new Range(value, value);
@@ -114,0 +115,4 @@ public final class Range {
+    public Range join(Range range) {
+        return Range.create(Math.min(low, range.low), Math.max(high, range.high));
+    }
+
diff --git a/src/main/java/org/davidmoten/hilbert/Ranges2.java b/src/main/java/org/davidmoten/hilbert/Ranges2.java
new file mode 100644
index 0000000..49e58c3
--- /dev/null
+++ b/src/main/java/org/davidmoten/hilbert/Ranges2.java
@@ -0,0 +1,93 @@
+package org.davidmoten.hilbert;
+
+import java.util.Comparator;
+import java.util.TreeSet;
+
+import com.github.davidmoten.guavamini.Preconditions;
+
+public class Ranges2 {
+
+    private final int maxRanges;
+    private final TreeSet<Node> set;
+    private Node ranges;
+    private int count;
+
+    public Ranges2(int maxRanges) {
+        this.maxRanges = maxRanges;
+        this.ranges = null;
+        this.set = new TreeSet<>();
+    }
+
+    public void add(Range r) {
+        Preconditions.checkArgument(ranges == null || ranges.value.high() < r.low());
+        ranges = insert(ranges, r);
+        count++;
+        if (ranges.next != null) {
+            // if there are at least two ranges
+            set.add(ranges);
+            if (count > maxRanges) {
+                // join the range with the smallest distance to next
+                Node x = set.first();
+                Node next = x.next;
+                Node y = new Node(x.value.join(next.value));
+                y.next = next.next;
+                if (x.previous == null) {
+                    ranges = y;
+                } else {
+                    x.previous.next = y;
+                    y.previous = x.previous;
+                }
+                // x has been replaced now so null its references for the joy of gc (I remember
+                // some old/new generation gc problem with linked lists that was fixed by doing
+                // this)
+                x.next = null;
+                x.previous = null;
+
+                // remove x (its old distance was used for sorting)
+                set.remove(x);
+                // add y as replacement for x
+                set.add(y);
+                count--;
+            }
+        }
+    }
+
+    private static Node insert(Node ranges, Range r) {
+        if (ranges == null) {
+            return new Node(r);
+        } else {
+            return ranges.insert(r);
+        }
+    }
+
+    private static final class Node implements Comparator<Node> {
+        final Range value;
+        Node next;
+        Node previous;
+
+        Node(Range value) {
+            this.value = value;
+        }
+
+        Node insert(Range value) {
+            Node n = new Node(value);
+            n.next = this;
+            previous = n;
+            return n;
+        }
+
+        @Override
+        public int compare(Node a, Node b) {
+            long x = a.next.value.low() - a.value.high();
+            long y = b.next.value.low() - b.value.high();
+            if (x < y) {
+                return -1;
+            } else if (x == y) {
+                return 0;
+            } else {
+                return 1;
+            }
+        }
+    }
+
+}
diff --git a/src/main/java/org/davidmoten/hilbert/SmallHilbertCurve.java b/src/main/java/org/davidmoten/hilbert/SmallHilbertCurve.java
index 95bf694..ca80780 100644
--- a/src/main/java/org/davidmoten/hilbert/SmallHilbertCurve.java
+++ b/src/main/java/org/davidmoten/hilbert/SmallHilbertCurve.java
@@ -162,0 +163,40 @@ public final class SmallHilbertCurve {
+    public Ranges2 query2(long[] a, long[] b, int maxRanges) {
+        Box box = new Box(a, b);
+        SortedSet<Long> set = new TreeSet<>();
+        box.visitPerimeter(cell -> {
+            long n = index(cell);
+            set.add(n);
+        });
+        List<Long> list = new ArrayList<>(set);
+        int i = 0;
+        Ranges2 ranges = new Ranges2(maxRanges);
+        long rangeStart = -1;
+        while (true) {
+            if (i == list.size()) {
+                break;
+            }
+            if (rangeStart == -1) {
+                rangeStart = list.get(i);
+            }
+            while (i < list.size() - 1 && list.get(i + 1) == list.get(i) + 1) {
+                i++;
+            }
+            if (i == list.size() - 1) {
+                ranges.add(Range.create(rangeStart, list.get(i)));
+                break;
+            }
+            long[] point = point(list.get(i) + 1);
+            if (box.contains(point)) {
+                // is not on the perimeter (would have been caught in previous while loop)
+                // so is internal to the box which means the next value in the sorted hilbert
+                // curve indexes for the perimiter must be where it exits
+                i += 1;
+            } else {
+                ranges.add(Range.create(rangeStart, list.get(i)));
+                rangeStart = -1;
+                i++;
+            }
+        }
+        return ranges;
+    }
+    
diff --git a/src/main/java/org/davidmoten/hilbert/internal/util/BoundedPriorityQueue.java b/src/main/java/org/davidmoten/hilbert/internal/util/BoundedPriorityQueue.java
index ab9a318..59e476c 100644
--- a/src/main/java/org/davidmoten/hilbert/internal/util/BoundedPriorityQueue.java
+++ b/src/main/java/org/davidmoten/hilbert/internal/util/BoundedPriorityQueue.java
@@ -18,2 +18,2 @@ public final class BoundedPriorityQueue<T> {
-     * Constructs a {@link BoundedPriorityQueue} with the specified
-     * {@code maxSize} and {@code comparator}.
+     * Constructs a {@link BoundedPriorityQueue} with the specified {@code maxSize}
+     * and {@code comparator}.
@@ -21,6 +21,4 @@ public final class BoundedPriorityQueue<T> {
-     * @param maxSize
-     *            - The maximum size the queue can reach, must be a positive
-     *            integer.
-     * @param comparator
-     *            - The comparator to be used to compare the elements in the
-     *            queue, must be non-null.
+     * @param maxSize    - The maximum size the queue can reach, must be a positive
+     *                   integer.
+     * @param comparator - The comparator to be used to compare the elements in the
+     *                   queue, must be non-null.
@@ -52,6 +50,5 @@ public final class BoundedPriorityQueue<T> {
-     * Adds an element to the queue. If the queue contains {@code maxSize}
-     * elements, {@code e} will be compared to the lowest element in the queue
-     * using {@code comparator}. If {@code e} is greater than or equal to the
-     * lowest element, that element will be removed and {@code e} will be added
-     * instead. Otherwise, the queue will not be modified and {@code e} will not
-     * be added.
+     * Adds an element to the queue. If the queue contains {@code maxSize} elements,
+     * {@code e} will be compared to the lowest element in the queue using
+     * {@code comparator}. If {@code e} is greater than or equal to the lowest
+     * element, that element will be removed and {@code e} will be added instead.
+     * Otherwise, the queue will not be modified and {@code e} will not be added.
@@ -59,2 +56,3 @@ public final class BoundedPriorityQueue<T> {
-     * @param t
-     *            - Element to be added, must be non-null.
+     * @param t - Element to be added, must be non-null.
+     * @return null if no element was removed from queue otherwise returns the
+     *         element removed from the queue due to this addition
@@ -62 +60 @@ public final class BoundedPriorityQueue<T> {
-    public void add(final T t) {
+    public T add(final T t) {
@@ -65,0 +64 @@ public final class BoundedPriorityQueue<T> {
+        final T v;
@@ -69 +68 @@ public final class BoundedPriorityQueue<T> {
-                return;
+                return null;
@@ -71 +70 @@ public final class BoundedPriorityQueue<T> {
-                queue.poll();
+                v = queue.poll();
@@ -72,0 +72,2 @@ public final class BoundedPriorityQueue<T> {
+        } else {
+            v = null;
@@ -74,0 +76 @@ public final class BoundedPriorityQueue<T> {
+        return v;
@@ -76 +78 @@ public final class BoundedPriorityQueue<T> {
-    
+
@@ -79,2 +81,2 @@ public final class BoundedPriorityQueue<T> {
-     *         {@link Collections#unmodifiableList(java.util.List)}
-     *         unmodifiableList sorted in reverse order.
+     *         {@link Collections#unmodifiableList(java.util.List)} unmodifiableList
+     *         sorted in reverse order.
