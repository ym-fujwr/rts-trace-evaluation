package
org
.
apache
.
commons
.
jxpath
.
ri
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Collections
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
List
;
import
java
.
util
.
NoSuchElementException
;
import
org
.
apache
.
commons
.
jxpath
.
BasicNodeSet
;
import
org
.
apache
.
commons
.
jxpath
.
ExpressionContext
;
import
org
.
apache
.
commons
.
jxpath
.
JXPathContext
;
import
org
.
apache
.
commons
.
jxpath
.
JXPathException
;
import
org
.
apache
.
commons
.
jxpath
.
NodeSet
;
import
org
.
apache
.
commons
.
jxpath
.
Pointer
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
axes
.
RootContext
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
model
.
NodePointer
;
import
org
.
apache
.
commons
.
jxpath
.
util
.
ReverseComparator
;
public
abstract
class
EvalContext
implements
ExpressionContext
,
Iterator
{
protected
EvalContext
parentContext
;
protected
RootContext
rootContext
;
protected
int
position
=
0
;
private
boolean
startedSetIteration
=
false
;
private
boolean
done
=
false
;
private
boolean
hasPerformedIteratorStep
=
false
;
private
Iterator
pointerIterator
;
public
EvalContext
(
EvalContext
parentContext
)
{
this
.
parentContext
=
parentContext
;
}
public
Pointer
getContextNodePointer
(
)
{
return
getCurrentNodePointer
(
)
;
}
public
JXPathContext
getJXPathContext
(
)
{
return
getRootContext
(
)
.
getJXPathContext
(
)
;
}
public
int
getPosition
(
)
{
return
position
;
}
public
int
getDocumentOrder
(
)
{
return
parentContext
!=
null
&&
parentContext
.
isChildOrderingRequired
(
)
?
1
:
0
;
}
public
boolean
isChildOrderingRequired
(
)
{
return
getDocumentOrder
(
)
!=
0
;
}
public
boolean
hasNext
(
)
{
if
(
pointerIterator
!=
null
)
{
return
pointerIterator
.
hasNext
(
)
;
}
if
(
getDocumentOrder
(
)
!=
0
)
{
return
constructIterator
(
)
;
}
if
(
!
done
&&
!
hasPerformedIteratorStep
)
{
performIteratorStep
(
)
;
}
return
!
done
;
}
public
Object
next
(
)
{
if
(
pointerIterator
!=
null
)
{
return
pointerIterator
.
next
(
)
;
}
if
(
getDocumentOrder
(
)
!=
0
)
{
if
(
!
constructIterator
(
)
)
{
throw
new
NoSuchElementException
(
)
;
}
return
pointerIterator
.
next
(
)
;
}
if
(
!
done
&&
!
hasPerformedIteratorStep
)
{
performIteratorStep
(
)
;
}
if
(
done
)
{
throw
new
NoSuchElementException
(
)
;
}
hasPerformedIteratorStep
=
false
;
return
getCurrentNodePointer
(
)
;
}
private
void
performIteratorStep
(
)
{
done
=
true
;
if
(
position
!=
0
&&
nextNode
(
)
)
{
done
=
false
;
}
else
{
while
(
nextSet
(
)
)
{
if
(
nextNode
(
)
)
{
done
=
false
;
break
;
}
}
}
hasPerformedIteratorStep
=
true
;
}
public
void
remove
(
)
{
throw
new
UnsupportedOperationException
(
"JXPath iterators cannot remove nodes"
)
;
}
private
boolean
constructIterator
(
)
{
HashSet
set
=
new
HashSet
(
)
;
ArrayList
list
=
new
ArrayList
(
)
;
while
(
nextSet
(
)
)
{
while
(
nextNode
(
)
)
{
NodePointer
pointer
=
getCurrentNodePointer
(
)
;
if
(
!
set
.
contains
(
pointer
)
)
{
set
.
add
(
pointer
)
;
list
.
add
(
pointer
)
;
}
}
}
if
(
list
.
isEmpty
(
)
)
{
return
false
;
}
sortPointers
(
list
)
;
pointerIterator
=
list
.
iterator
(
)
;
return
true
;
}
protected
void
sortPointers
(
List
l
)
{
switch
(
getDocumentOrder
(
)
)
{
case
1
:
Collections
.
sort
(
l
)
;
break
;
case
-
1
:
Collections
.
sort
(
l
,
ReverseComparator
.
INSTANCE
)
;
break
;
default
:
break
;
}
}
public
List
getContextNodeList
(
)
{
int
pos
=
position
;
if
(
pos
!=
0
)
{
reset
(
)
;
}
List
list
=
new
ArrayList
(
)
;
while
(
nextNode
(
)
)
{
list
.
add
(
getCurrentNodePointer
(
)
)
;
}
if
(
pos
!=
0
)
{
setPosition
(
pos
)
;
}
else
{
reset
(
)
;
}
return
list
;
}
public
NodeSet
getNodeSet
(
)
{
if
(
position
!=
0
)
{
throw
new
JXPathException
(
"Simultaneous operations: "
+
"should not request pointer list while "
+
"iterating over an EvalContext"
)
;
}
BasicNodeSet
set
=
new
BasicNodeSet
(
)
;
while
(
nextSet
(
)
)
{
while
(
nextNode
(
)
)
{
set
.
add
(
(
Pointer
)
getCurrentNodePointer
(
)
.
clone
(
)
)
;
}
}
return
set
;
}
public
Object
getValue
(
)
{
return
getNodeSet
(
)
;
}
public
String
toString
(
)
{
Pointer
ptr
=
getContextNodePointer
(
)
;
return
ptr
==
null
?
"Empty expression context"
:
"Expression context ["
+
getPosition
(
)
+
"] "
+
ptr
.
asPath
(
)
;
}
public
RootContext
getRootContext
(
)
{
if
(
rootContext
==
null
)
{
rootContext
=
parentContext
.
getRootContext
(
)
;
}
return
rootContext
;
}
public
void
reset
(
)
{
position
=
0
;
}
public
int
getCurrentPosition
(
)
{
return
position
;
}
public
Pointer
getSingleNodePointer
(
)
{
reset
(
)
;
while
(
nextSet
(
)
)
{
if
(
nextNode
(
)
)
{
return
getCurrentNodePointer
(
)
;
}
}
return
null
;
}
public
abstract
NodePointer
getCurrentNodePointer
(
)
;
public
boolean
nextSet
(
)
{
reset
(
)
;
if
(
!
startedSetIteration
)
{
startedSetIteration
=
true
;
while
(
parentContext
.
nextSet
(
)
)
{
if
(
parentContext
.
nextNode
(
)
)
{
return
true
;
}
}
return
false
;
}
if
(
parentContext
.
nextNode
(
)
)
{
return
true
;
}
while
(
parentContext
.
nextSet
(
)
)
{
if
(
parentContext
.
nextNode
(
)
)
{
return
true
;
}
}
return
false
;
}
public
abstract
boolean
nextNode
(
)
;
public
boolean
setPosition
(
int
position
)
{
this
.
position
=
position
;
return
true
;
}
}
<EOF>
