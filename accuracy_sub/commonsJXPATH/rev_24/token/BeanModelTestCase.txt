package
org
.
apache
.
commons
.
jxpath
.
ri
.
model
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Collections
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
List
;
import
java
.
util
.
Locale
;
import
org
.
apache
.
commons
.
jxpath
.
AbstractFactory
;
import
org
.
apache
.
commons
.
jxpath
.
ClassFunctions
;
import
org
.
apache
.
commons
.
jxpath
.
JXPathContext
;
import
org
.
apache
.
commons
.
jxpath
.
JXPathTestCase
;
import
org
.
apache
.
commons
.
jxpath
.
NestedTestBean
;
import
org
.
apache
.
commons
.
jxpath
.
Pointer
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
QName
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
compiler
.
NodeNameTest
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
compiler
.
TestFunctions
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
model
.
beans
.
PropertyOwnerPointer
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
model
.
beans
.
PropertyPointer
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
model
.
dynabeans
.
DynaBeanModelTest
;
public
abstract
class
BeanModelTestCase
extends
JXPathTestCase
{
private
JXPathContext
context
;
@
Override
public
void
setUp
(
)
{
context
=
JXPathContext
.
newContext
(
createContextBean
(
)
)
;
context
.
setLocale
(
Locale
.
US
)
;
context
.
setFactory
(
getAbstractFactory
(
)
)
;
}
protected
abstract
Object
createContextBean
(
)
;
protected
abstract
AbstractFactory
getAbstractFactory
(
)
;
public
void
testIndividualIterators
(
)
{
testIndividual
(
+
1
,
0
,
true
,
false
,
0
)
;
testIndividual
(
-
1
,
0
,
true
,
false
,
4
)
;
testIndividual
(
0
,
-
1
,
true
,
true
,
4
)
;
testIndividual
(
+
1
,
-
1
,
true
,
true
,
4
)
;
testIndividual
(
-
1
,
-
1
,
true
,
true
,
0
)
;
testIndividual
(
0
,
1
,
true
,
false
,
2
)
;
testIndividual
(
0
,
1
,
true
,
true
,
1
)
;
testIndividual
(
0
,
0
,
false
,
false
,
4
)
;
testIndividual
(
0
,
0
,
false
,
true
,
4
)
;
}
private
void
testIndividual
(
final
int
relativePropertyIndex
,
final
int
offset
,
final
boolean
useStartLocation
,
final
boolean
reverse
,
final
int
expected
)
{
final
PropertyOwnerPointer
root
=
(
PropertyOwnerPointer
)
NodePointer
.
newNodePointer
(
new
QName
(
null
,
"root"
)
,
createContextBean
(
)
,
Locale
.
getDefault
(
)
)
;
NodeIterator
it
;
PropertyPointer
start
=
null
;
if
(
useStartLocation
)
{
start
=
root
.
getPropertyPointer
(
)
;
start
.
setPropertyIndex
(
relativeProperty
(
start
,
relativePropertyIndex
)
)
;
start
.
setIndex
(
offset
)
;
}
it
=
root
.
childIterator
(
new
NodeNameTest
(
new
QName
(
null
,
"integers"
)
)
,
reverse
,
start
)
;
int
size
=
0
;
while
(
it
.
setPosition
(
it
.
getPosition
(
)
+
1
)
)
{
size
++
;
}
assertEquals
(
"ITERATIONS: Individual, relativePropertyIndex="
+
relativePropertyIndex
+
", offset="
+
offset
+
", useStartLocation="
+
useStartLocation
+
", reverse="
+
reverse
,
expected
,
size
)
;
}
public
void
testMultipleIterators
(
)
{
testMultiple
(
0
,
0
,
true
,
false
,
20
)
;
testMultiple
(
3
,
0
,
true
,
false
,
16
)
;
testMultiple
(
3
,
-
1
,
true
,
true
,
8
)
;
testMultiple
(
3
,
0
,
true
,
true
,
4
)
;
testMultiple
(
0
,
0
,
false
,
false
,
21
)
;
testMultiple
(
0
,
0
,
false
,
true
,
21
)
;
testMultiple
(
3
,
1
,
true
,
false
,
15
)
;
testMultiple
(
3
,
3
,
true
,
false
,
13
)
;
}
private
void
testMultiple
(
final
int
propertyIndex
,
final
int
offset
,
final
boolean
useStartLocation
,
final
boolean
reverse
,
final
int
expected
)
{
final
PropertyOwnerPointer
root
=
(
PropertyOwnerPointer
)
NodePointer
.
newNodePointer
(
new
QName
(
null
,
"root"
)
,
createContextBean
(
)
,
Locale
.
getDefault
(
)
)
;
NodeIterator
it
;
PropertyPointer
start
=
null
;
if
(
useStartLocation
)
{
start
=
root
.
getPropertyPointer
(
)
;
start
.
setPropertyIndex
(
propertyIndex
)
;
start
.
setIndex
(
offset
)
;
}
it
=
root
.
childIterator
(
null
,
reverse
,
start
)
;
int
size
=
0
;
while
(
it
.
setPosition
(
it
.
getPosition
(
)
+
1
)
)
{
size
++
;
}
assertEquals
(
"ITERATIONS: Multiple, propertyIndex="
+
propertyIndex
+
", offset="
+
offset
+
", useStartLocation="
+
useStartLocation
+
", reverse="
+
reverse
,
expected
,
size
)
;
}
private
int
relativeProperty
(
final
PropertyPointer
holder
,
final
int
offset
)
{
final
String
[
]
names
=
holder
.
getPropertyNames
(
)
;
for
(
int
i
=
0
;
i
<
names
.
length
;
i
++
)
{
if
(
names
[
i
]
.
equals
(
"integers"
)
)
{
return
i
+
offset
;
}
}
return
-
1
;
}
public
void
testIteratePropertyArrayWithHasNext
(
)
{
final
JXPathContext
context
=
JXPathContext
.
newContext
(
createContextBean
(
)
)
;
final
Iterator
it
=
context
.
iteratePointers
(
"/integers"
)
;
final
List
actual
=
new
ArrayList
(
)
;
while
(
it
.
hasNext
(
)
)
{
actual
.
add
(
(
(
Pointer
)
it
.
next
(
)
)
.
asPath
(
)
)
;
}
assertEquals
(
"Iterating 'hasNext'/'next'<"
+
"/integers"
+
">"
,
list
(
"/integers[1]"
,
"/integers[2]"
,
"/integers[3]"
,
"/integers[4]"
)
,
actual
)
;
}
public
void
testIteratePropertyArrayWithoutHasNext
(
)
{
final
JXPathContext
context
=
JXPathContext
.
newContext
(
createContextBean
(
)
)
;
final
Iterator
it
=
context
.
iteratePointers
(
"/integers"
)
;
final
List
actual
=
new
ArrayList
(
)
;
for
(
int
i
=
0
;
i
<
4
;
i
++
)
{
actual
.
add
(
it
.
next
(
)
.
toString
(
)
)
;
}
assertEquals
(
"Iterating 'next'<"
+
"/integers"
+
">"
,
list
(
"/integers[1]"
,
"/integers[2]"
,
"/integers[3]"
,
"/integers[4]"
)
,
actual
)
;
}
public
void
testIterateAndSet
(
)
{
final
JXPathContext
context
=
JXPathContext
.
newContext
(
createContextBean
(
)
)
;
Iterator
it
=
context
.
iteratePointers
(
"beans/int"
)
;
int
i
=
5
;
while
(
it
.
hasNext
(
)
)
{
final
NodePointer
pointer
=
(
NodePointer
)
it
.
next
(
)
;
pointer
.
setValue
(
Integer
.
valueOf
(
i
++
)
)
;
}
it
=
context
.
iteratePointers
(
"beans/int"
)
;
final
List
actual
=
new
ArrayList
(
)
;
while
(
it
.
hasNext
(
)
)
{
actual
.
add
(
(
(
Pointer
)
it
.
next
(
)
)
.
getValue
(
)
)
;
}
assertEquals
(
"Iterating <"
+
"beans/int"
+
">"
,
list
(
Integer
.
valueOf
(
5
)
,
Integer
.
valueOf
(
6
)
)
,
actual
)
;
}
public
void
testIteratePointerSetValue
(
)
{
final
JXPathContext
context
=
JXPathContext
.
newContext
(
createContextBean
(
)
)
;
assertXPathValue
(
context
,
"/beans[1]/name"
,
"Name 1"
)
;
assertXPathValue
(
context
,
"/beans[2]/name"
,
"Name 2"
)
;
context
.
setValue
(
"/beans[2]/name"
,
"Name 2 set"
)
;
assertXPathValue
(
context
,
"/beans[2]/name"
,
"Name 2 set"
)
;
context
.
setValue
(
"/beans[2]/name"
,
"Name 2"
)
;
assertXPathValue
(
context
,
"/beans[2]/name"
,
"Name 2"
)
;
int
iterCount
=
0
;
final
Iterator
iter
=
context
.
iteratePointers
(
"/beans/name"
)
;
while
(
iter
.
hasNext
(
)
)
{
iterCount
++
;
final
Pointer
pointer
=
(
Pointer
)
iter
.
next
(
)
;
String
s
=
(
String
)
pointer
.
getValue
(
)
;
s
=
s
+
"suffix"
;
pointer
.
setValue
(
s
)
;
assertEquals
(
"pointer.getValue"
,
s
,
pointer
.
getValue
(
)
)
;
assertEquals
(
"context.getValue"
,
s
,
context
.
getValue
(
pointer
.
asPath
(
)
)
)
;
}
assertEquals
(
"Iteration count"
,
2
,
iterCount
)
;
assertXPathValue
(
context
,
"/beans[1]/name"
,
"Name 1suffix"
)
;
assertXPathValue
(
context
,
"/beans[2]/name"
,
"Name 2suffix"
)
;
}
public
void
testRoot
(
)
{
assertXPathValueAndPointer
(
context
,
"/"
,
context
.
getContextBean
(
)
,
"/"
)
;
}
public
void
testAxisAncestor
(
)
{
assertXPathValue
(
context
,
"int/ancestor::root = /"
,
Boolean
.
TRUE
)
;
assertXPathValue
(
context
,
"count(beans/name/ancestor-or-self::node())"
,
Double
.
valueOf
(
5
)
)
;
assertXPathValue
(
context
,
"beans/name/ancestor-or-self::node()[3] = /"
,
Boolean
.
TRUE
)
;
}
public
void
testAxisChild
(
)
{
assertXPathValue
(
context
,
"boolean"
,
Boolean
.
FALSE
)
;
assertXPathPointer
(
context
,
"boolean"
,
"/boolean"
)
;
assertXPathPointerIterator
(
context
,
"boolean"
,
list
(
"/boolean"
)
)
;
assertXPathValue
(
context
,
"count(set)"
,
Double
.
valueOf
(
3
)
)
;
assertXPathValueIterator
(
context
,
"foo:boolean"
,
list
(
)
)
;
assertXPathValue
(
context
,
"count(*)"
,
Double
.
valueOf
(
21
)
)
;
assertXPathValue
(
context
,
"count(child::node())"
,
Double
.
valueOf
(
21
)
)
;
}
public
void
testAxisChildNestedBean
(
)
{
assertXPathValue
(
context
,
"nestedBean/name"
,
"Name 0"
)
;
assertXPathPointer
(
context
,
"nestedBean/name"
,
"/nestedBean/name"
)
;
assertXPathPointerIterator
(
context
,
"nestedBean/name"
,
list
(
"/nestedBean/name"
)
)
;
}
public
void
testAxisChildNestedCollection
(
)
{
assertXPathValueIterator
(
context
,
"integers"
,
list
(
Integer
.
valueOf
(
1
)
,
Integer
.
valueOf
(
2
)
,
Integer
.
valueOf
(
3
)
,
Integer
.
valueOf
(
4
)
)
)
;
assertXPathPointer
(
context
,
"integers"
,
"/integers"
)
;
assertXPathPointerIterator
(
context
,
"integers"
,
list
(
"/integers[1]"
,
"/integers[2]"
,
"/integers[3]"
,
"/integers[4]"
)
)
;
}
public
void
testIndexPredicate
(
)
{
assertXPathValue
(
context
,
"integers[2]"
,
Integer
.
valueOf
(
2
)
)
;
assertXPathPointer
(
context
,
"integers[2]"
,
"/integers[2]"
)
;
assertXPathPointerIterator
(
context
,
"integers[2]"
,
list
(
"/integers[2]"
)
)
;
assertXPathValue
(
context
,
"beans[1]/name"
,
"Name 1"
)
;
assertXPathPointer
(
context
,
"beans[1]/name"
,
"/beans[1]/name"
)
;
assertXPathValueIterator
(
context
,
"beans[1]/strings"
,
list
(
"String 1"
,
"String 2"
,
"String 3"
)
)
;
assertXPathValueIterator
(
context
,
"beans/strings[2]"
,
list
(
"String 2"
,
"String 2"
)
)
;
assertXPathValue
(
context
,
"beans/strings[2]"
,
"String 2"
)
;
assertXPathValue
(
context
,
"(beans/strings[2])[1]"
,
"String 2"
)
;
}
public
void
testAxisDescendant
(
)
{
assertXPathValue
(
context
,
"count(descendant::node())"
,
Double
.
valueOf
(
65
)
)
;
assertXPathValue
(
context
,
"count(descendant::root)"
,
Double
.
valueOf
(
0
)
)
;
assertXPathValue
(
context
,
"count(descendant::name)"
,
Double
.
valueOf
(
7
)
)
;
}
public
void
testAxisDescendantOrSelf
(
)
{
assertXPathValueIterator
(
context
,
"descendant-or-self::name"
,
set
(
"Name 1"
,
"Name 2"
,
"Name 3"
,
"Name 6"
,
"Name 0"
,
"Name 5"
,
"Name 4"
)
)
;
assertXPathValueIterator
(
context
,
"//name"
,
set
(
"Name 1"
,
"Name 2"
,
"Name 3"
,
"Name 6"
,
"Name 0"
,
"Name 5"
,
"Name 4"
)
)
;
assertXPathValue
(
context
,
"count(descendant-or-self::root)"
,
Double
.
valueOf
(
1
)
)
;
assertXPathValue
(
context
,
"count(nestedBean//.)"
,
Double
.
valueOf
(
7
)
)
;
assertXPathValue
(
context
,
"count(//self::beans)"
,
Double
.
valueOf
(
2
)
)
;
assertXPathValue
(
context
,
"count(descendant-or-self::node())"
,
Double
.
valueOf
(
66
)
)
;
}
public
void
testAxisFollowing
(
)
{
assertXPathValue
(
context
,
"count(nestedBean/strings[2]/following::node())"
,
Double
.
valueOf
(
21
)
)
;
assertXPathValue
(
context
,
"count(nestedBean/strings[2]/following::strings)"
,
Double
.
valueOf
(
7
)
)
;
}
public
void
testAxisFollowingSibling
(
)
{
assertXPathValue
(
context
,
"count(/nestedBean/following-sibling::node())"
,
Double
.
valueOf
(
8
)
)
;
assertXPathValue
(
context
,
"count(/nestedBean/following-sibling::object)"
,
Double
.
valueOf
(
1
)
)
;
assertXPathValue
(
context
,
"count(/nestedBean/boolean/../following-sibling::node())"
,
Double
.
valueOf
(
8
)
)
;
assertXPathValue
(
context
,
"count(/nestedBean/boolean/../following-sibling::object)"
,
Double
.
valueOf
(
1
)
)
;
assertXPathValue
(
context
,
"count(/descendant::boolean/following-sibling::node())"
,
Double
.
valueOf
(
53
)
)
;
assertXPathValue
(
context
,
"count(/descendant::boolean/following-sibling::name)"
,
Double
.
valueOf
(
7
)
)
;
}
public
void
testAxisParent
(
)
{
assertXPathValue
(
context
,
"count(/beans/..)"
,
Double
.
valueOf
(
1
)
)
;
assertXPathValue
(
context
,
"count(//..)"
,
Double
.
valueOf
(
9
)
)
;
assertXPathValue
(
context
,
"count(//../..)"
,
Double
.
valueOf
(
2
)
)
;
assertXPathValueIterator
(
context
,
"//parent::beans/name"
,
list
(
"Name 1"
,
"Name 2"
)
)
;
}
public
void
testAxisPreceding
(
)
{
assertXPathValue
(
context
,
"count(beans[2]/int/preceding::node())"
,
Double
.
valueOf
(
8
)
)
;
assertXPathValue
(
context
,
"count(beans[2]/int/preceding::boolean)"
,
Double
.
valueOf
(
2
)
)
;
}
public
void
testAxisPrecedingSibling
(
)
{
assertXPathValue
(
context
,
"count(/boolean/preceding-sibling::node())"
,
Double
.
valueOf
(
2
)
)
;
assertXPathValue
(
context
,
"count(/nestedBean/int/../preceding-sibling::node())"
,
Double
.
valueOf
(
12
)
)
;
assertXPathValue
(
context
,
"count(/descendant::int/preceding-sibling::node())"
,
Double
.
valueOf
(
10
)
)
;
}
public
void
testAxisSelf
(
)
{
assertXPathValue
(
context
,
"self::node() = /"
,
Boolean
.
TRUE
)
;
assertXPathValue
(
context
,
"self::root = /"
,
Boolean
.
TRUE
)
;
}
public
void
testUnion
(
)
{
assertXPathValueIterator
(
context
,
"integers | beans[1]/strings"
,
list
(
"String 1"
,
"String 2"
,
"String 3"
,
Integer
.
valueOf
(
1
)
,
Integer
.
valueOf
(
2
)
,
Integer
.
valueOf
(
3
)
,
Integer
.
valueOf
(
4
)
)
)
;
assertXPathValue
(
context
,
"count((integers | beans[1]/strings)[contains(., '1')])"
,
Double
.
valueOf
(
2
)
)
;
assertXPathValue
(
context
,
"count((integers | beans[1]/strings)[name(.) = 'strings'])"
,
Double
.
valueOf
(
3
)
)
;
assertXPathValue
(
context
,
"(integers)[2]"
,
Integer
.
valueOf
(
2
)
)
;
}
public
void
testAxisAttribute
(
)
{
assertXPathValue
(
context
,
"count(@*)"
,
Double
.
valueOf
(
21.0
)
)
;
assertXPathValueLenient
(
context
,
"@foo"
,
null
)
;
}
public
void
testAttributeName
(
)
{
assertXPathValue
(
context
,
"nestedBean[@name = 'int']"
,
Integer
.
valueOf
(
1
)
)
;
assertXPathPointer
(
context
,
"nestedBean[@name = 'int']"
,
"/nestedBean/int"
)
;
}
public
void
testAttributeLang
(
)
{
assertXPathValue
(
context
,
"@xml:lang"
,
"en-US"
)
;
assertXPathValue
(
context
,
"count(@xml:*)"
,
Double
.
valueOf
(
1
)
)
;
assertXPathValue
(
context
,
"lang('en')"
,
Boolean
.
TRUE
)
;
assertXPathValue
(
context
,
"lang('fr')"
,
Boolean
.
FALSE
)
;
}
public
void
testCoreFunctions
(
)
{
assertXPathValue
(
context
,
"boolean(boolean)"
,
Boolean
.
TRUE
)
;
assertXPathValue
(
context
,
"boolean(boolean = false())"
,
Boolean
.
TRUE
)
;
assertXPathValue
(
context
,
"boolean(integers[position() < 3])"
,
Boolean
.
TRUE
)
;
assertXPathValue
(
context
,
"boolean(integers[position() > 4])"
,
Boolean
.
FALSE
)
;
assertXPathValue
(
context
,
"sum(integers)"
,
Double
.
valueOf
(
10
)
)
;
assertXPathValueAndPointer
(
context
,
"integers[last()]"
,
Integer
.
valueOf
(
4
)
,
"/integers[4]"
)
;
assertXPathValueAndPointer
(
context
,
"//strings[last()]"
,
"String 3"
,
"/beans[1]/strings[3]"
)
;
}
public
void
testBooleanPredicate
(
)
{
assertXPathValue
(
context
,
"beans[int > 2]/name"
,
"Name 2"
)
;
assertXPathValueIterator
(
context
,
"beans[int > 2]/name"
,
list
(
"Name 2"
)
)
;
assertXPathValueIterator
(
context
,
"beans[int >= 1]/name"
,
list
(
"Name 1"
,
"Name 2"
)
)
;
assertXPathValueIterator
(
context
,
"beans[int < 2]/name"
,
list
(
"Name 1"
)
)
;
assertXPathValueIterator
(
context
,
"beans[int <= 3]/name"
,
list
(
"Name 1"
,
"Name 2"
)
)
;
assertXPathValueIterator
(
context
,
"beans[1]/strings[string-length() = 8]"
,
list
(
"String 1"
,
"String 2"
,
"String 3"
)
)
;
assertXPathValueIterator
(
context
,
"//self::node()[name = 'Name 0']/name"
,
list
(
"Name 0"
)
)
;
assertXPathValue
(
context
,
"beans/strings[name(.)='strings'][2]"
,
"String 2"
)
;
assertXPathValueIterator
(
context
,
"//self::node()[name(.) = concat('n', 'a', 'm', 'e')]"
,
list
(
"Name 1"
,
"Name 2"
,
"Name 3"
,
"Name 6"
,
"Name 0"
,
"Name 5"
,
"Name 4"
)
)
;
assertXPathValueIterator
(
context
,
"integers[position()<3]"
,
list
(
Integer
.
valueOf
(
1
)
,
Integer
.
valueOf
(
2
)
)
)
;
context
.
getVariables
(
)
.
declareVariable
(
"temp"
,
context
.
getValue
(
"beans"
)
)
;
assertXPathValueIterator
(
context
,
"$temp[int < 2]/int"
,
list
(
Integer
.
valueOf
(
1
)
)
)
;
}
public
void
testDocumentOrder
(
)
{
assertDocumentOrder
(
context
,
"boolean"
,
"int"
,
-
1
)
;
assertDocumentOrder
(
context
,
"integers[1]"
,
"integers[2]"
,
-
1
)
;
assertDocumentOrder
(
context
,
"integers[1]"
,
"integers[1]"
,
0
)
;
assertDocumentOrder
(
context
,
"nestedBean/int"
,
"nestedBean"
,
1
)
;
assertDocumentOrder
(
context
,
"nestedBean/int"
,
"nestedBean/strings"
,
-
1
)
;
assertDocumentOrder
(
context
,
"nestedBean/int"
,
"object/int"
,
-
1
)
;
}
public
void
testSetPropertyValue
(
)
{
assertXPathSetValue
(
context
,
"int"
,
Integer
.
valueOf
(
2
)
)
;
assertXPathSetValue
(
context
,
"int"
,
"3"
,
Integer
.
valueOf
(
3
)
)
;
assertXPathSetValue
(
context
,
"int"
,
new
int
[
]
{
4
}
,
Integer
.
valueOf
(
4
)
)
;
assertXPathSetValue
(
context
,
"@int"
,
Integer
.
valueOf
(
10
)
)
;
}
public
void
testSetCollectionElement
(
)
{
assertXPathSetValue
(
context
,
"integers[2]"
,
Integer
.
valueOf
(
5
)
)
;
assertXPathSetValue
(
context
,
"integers[2]"
,
new
int
[
]
{
6
}
,
Integer
.
valueOf
(
6
)
)
;
}
public
void
testSetContextDependentNode
(
)
{
assertXPathSetValue
(
context
,
"integers[position() = 1]"
,
Integer
.
valueOf
(
8
)
)
;
assertXPathSetValue
(
context
,
"beans[name = 'Name 1']/int"
,
Integer
.
valueOf
(
9
)
)
;
}
public
void
testSetNonPrimitiveValue
(
)
{
assertXPathSetValue
(
context
,
"beans[2]"
,
null
)
;
context
.
setValue
(
"beans[2]"
,
new
NestedTestBean
(
"Name 9"
)
)
;
assertEquals
(
"Modified <"
+
"beans[2]/name"
+
">"
,
"Name 9"
,
context
.
getValue
(
"beans[2]/name"
)
)
;
}
public
void
testCreatePath
(
)
{
context
.
setValue
(
"nestedBean"
,
null
)
;
assertXPathCreatePath
(
context
,
"/nestedBean/int"
,
Integer
.
valueOf
(
1
)
,
"/nestedBean/int"
)
;
boolean
ex
=
false
;
try
{
assertXPathCreatePath
(
context
,
"/nestedBean/beans[last() + 1]"
,
Integer
.
valueOf
(
1
)
,
"/nestedBean/beans[last() + 1]"
)
;
}
catch
(
final
Exception
e
)
{
ex
=
true
;
}
assertTrue
(
"Exception thrown on invalid path for creation"
,
ex
)
;
}
public
void
testCreatePathAndSetValue
(
)
{
context
.
setValue
(
"nestedBean"
,
null
)
;
assertXPathCreatePathAndSetValue
(
context
,
"/nestedBean/int"
,
Integer
.
valueOf
(
2
)
,
"/nestedBean/int"
)
;
}
public
void
testCreatePathExpandNewCollection
(
)
{
context
.
setValue
(
"beans"
,
null
)
;
assertXPathCreatePath
(
context
,
"/beans[2]/int"
,
Integer
.
valueOf
(
1
)
,
"/beans[2]/int"
)
;
}
public
void
testCreatePathAndSetValueExpandNewCollection
(
)
{
context
.
setValue
(
"beans"
,
null
)
;
assertXPathCreatePathAndSetValue
(
context
,
"/beans[2]/int"
,
Integer
.
valueOf
(
2
)
,
"/beans[2]/int"
)
;
}
public
void
testCreatePathExpandExistingCollection
(
)
{
assertXPathCreatePathAndSetValue
(
context
,
"/integers[5]"
,
Integer
.
valueOf
(
3
)
,
"/integers[5]"
)
;
}
public
void
testCreatePathExpandExistingCollectionAndSetProperty
(
)
{
assertXPathCreatePath
(
context
,
"/beans[3]/int"
,
Integer
.
valueOf
(
1
)
,
"/beans[3]/int"
)
;
}
public
void
testCreatePathAndSetValueExpandExistingCollection
(
)
{
assertXPathCreatePathAndSetValue
(
context
,
"/beans[3]/int"
,
Integer
.
valueOf
(
2
)
,
"/beans[3]/int"
)
;
}
public
void
testCreatePathCreateBeanExpandCollection
(
)
{
context
.
setValue
(
"nestedBean"
,
null
)
;
assertXPathCreatePath
(
context
,
"/nestedBean/strings[2]"
,
"String 2"
,
"/nestedBean/strings[2]"
)
;
}
public
void
testCreatePathAndSetValueCreateBeanExpandCollection
(
)
{
context
.
setValue
(
"nestedBean"
,
null
)
;
assertXPathCreatePathAndSetValue
(
context
,
"/nestedBean/strings[2]"
,
"Test"
,
"/nestedBean/strings[2]"
)
;
}
public
void
testRemovePathPropertyValue
(
)
{
context
.
removePath
(
"nestedBean/int"
)
;
assertEquals
(
"Remove property value"
,
Integer
.
valueOf
(
0
)
,
context
.
getValue
(
"nestedBean/int"
)
)
;
}
public
void
testRemovePathArrayElement
(
)
{
context
.
removePath
(
"nestedBean/strings[1]"
)
;
assertEquals
(
"Remove array element"
,
"String 2"
,
context
.
getValue
(
"nestedBean/strings[1]"
)
)
;
}
public
void
testRemoveAllArrayElements
(
)
{
context
.
removeAll
(
"nestedBean/strings"
)
;
assertXPathValueIterator
(
context
,
"nestedBean/strings"
,
list
(
)
)
;
}
public
void
testRemoveAllListElements
(
)
{
context
.
removeAll
(
"list"
)
;
assertXPathValueIterator
(
context
,
"list"
,
this
instanceof
DynaBeanModelTest
?
list
(
null
,
null
,
null
)
:
list
(
)
)
;
}
public
void
testRemoveAllMapEntries
(
)
{
context
.
removeAll
(
"map/*"
)
;
assertXPathValue
(
context
,
"map"
,
Collections
.
EMPTY_MAP
)
;
}
public
void
testRemovePathBeanValue
(
)
{
context
.
removePath
(
"nestedBean"
)
;
assertEquals
(
"Remove collection element"
,
null
,
context
.
getValue
(
"nestedBean"
)
)
;
}
public
void
testRelativeContextRelativePath
(
)
{
final
JXPathContext
relative
=
context
.
getRelativeContext
(
context
.
getPointer
(
"nestedBean"
)
)
;
assertXPathValueAndPointer
(
relative
,
"int"
,
Integer
.
valueOf
(
1
)
,
"/nestedBean/int"
)
;
}
public
void
testRelativeContextAbsolutePath
(
)
{
final
JXPathContext
relative
=
context
.
getRelativeContext
(
context
.
getPointer
(
"nestedBean"
)
)
;
assertXPathValueAndPointer
(
relative
,
"/integers[2]"
,
Integer
.
valueOf
(
2
)
,
"/integers[2]"
)
;
}
public
void
testRelativeContextParent
(
)
{
final
JXPathContext
relative
=
context
.
getRelativeContext
(
context
.
getPointer
(
"nestedBean"
)
)
;
assertXPathValueAndPointer
(
relative
,
"../integers[2]"
,
Integer
.
valueOf
(
2
)
,
"/integers[2]"
)
;
}
public
void
testRelativeContextInheritance
(
)
{
context
.
setFunctions
(
new
ClassFunctions
(
TestFunctions
.
class
,
"test"
)
)
;
final
JXPathContext
relative
=
context
.
getRelativeContext
(
context
.
getPointer
(
"nestedBean"
)
)
;
assertXPathValue
(
relative
,
"test:countPointers(strings)"
,
Integer
.
valueOf
(
3
)
)
;
}
}
<EOF>
