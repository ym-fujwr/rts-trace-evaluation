package
org
.
apache
.
commons
.
jxpath
.
ri
;
import
java
.
lang
.
ref
.
SoftReference
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Collections
;
import
java
.
util
.
Comparator
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
Map
;
import
java
.
util
.
Map
.
Entry
;
import
java
.
util
.
Vector
;
import
org
.
apache
.
commons
.
jxpath
.
CompiledExpression
;
import
org
.
apache
.
commons
.
jxpath
.
ExceptionHandler
;
import
org
.
apache
.
commons
.
jxpath
.
Function
;
import
org
.
apache
.
commons
.
jxpath
.
Functions
;
import
org
.
apache
.
commons
.
jxpath
.
JXPathContext
;
import
org
.
apache
.
commons
.
jxpath
.
JXPathException
;
import
org
.
apache
.
commons
.
jxpath
.
JXPathFunctionNotFoundException
;
import
org
.
apache
.
commons
.
jxpath
.
JXPathInvalidSyntaxException
;
import
org
.
apache
.
commons
.
jxpath
.
JXPathNotFoundException
;
import
org
.
apache
.
commons
.
jxpath
.
JXPathTypeConversionException
;
import
org
.
apache
.
commons
.
jxpath
.
Pointer
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
axes
.
InitialContext
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
axes
.
RootContext
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
compiler
.
Expression
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
compiler
.
LocationPath
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
compiler
.
Path
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
compiler
.
TreeCompiler
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
model
.
NodePointer
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
model
.
NodePointerFactory
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
model
.
VariablePointerFactory
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
model
.
beans
.
BeanPointerFactory
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
model
.
beans
.
CollectionPointerFactory
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
model
.
container
.
ContainerPointerFactory
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
model
.
dynamic
.
DynamicPointerFactory
;
import
org
.
apache
.
commons
.
jxpath
.
util
.
ClassLoaderUtil
;
import
org
.
apache
.
commons
.
jxpath
.
util
.
ReverseComparator
;
import
org
.
apache
.
commons
.
jxpath
.
util
.
TypeUtils
;
public
class
JXPathContextReferenceImpl
extends
JXPathContext
{
public
static
final
boolean
USE_SOFT_CACHE
=
true
;
private
static
final
Compiler
COMPILER
=
new
TreeCompiler
(
)
;
private
static
Map
compiled
=
new
HashMap
(
)
;
private
static
int
cleanupCount
=
0
;
private
static
NodePointerFactory
[
]
nodeFactoryArray
=
null
;
private
static
final
int
CLEANUP_THRESHOLD
=
500
;
private
static
final
Vector
nodeFactories
=
new
Vector
(
)
;
static
{
nodeFactories
.
add
(
new
CollectionPointerFactory
(
)
)
;
nodeFactories
.
add
(
new
BeanPointerFactory
(
)
)
;
nodeFactories
.
add
(
new
DynamicPointerFactory
(
)
)
;
nodeFactories
.
add
(
new
VariablePointerFactory
(
)
)
;
final
Object
domFactory
=
allocateConditionally
(
"org.apache.commons.jxpath.ri.model.dom.DOMPointerFactory"
,
"org.w3c.dom.Node"
)
;
if
(
domFactory
!=
null
)
{
nodeFactories
.
add
(
domFactory
)
;
}
final
Object
jdomFactory
=
allocateConditionally
(
"org.apache.commons.jxpath.ri.model.jdom.JDOMPointerFactory"
,
"org.jdom.Document"
)
;
if
(
jdomFactory
!=
null
)
{
nodeFactories
.
add
(
jdomFactory
)
;
}
final
Object
dynaBeanFactory
=
allocateConditionally
(
"org.apache.commons.jxpath.ri.model.dynabeans."
+
"DynaBeanPointerFactory"
,
"org.apache.commons.beanutils.DynaBean"
)
;
if
(
dynaBeanFactory
!=
null
)
{
nodeFactories
.
add
(
dynaBeanFactory
)
;
}
nodeFactories
.
add
(
new
ContainerPointerFactory
(
)
)
;
createNodeFactoryArray
(
)
;
}
private
static
synchronized
void
createNodeFactoryArray
(
)
{
if
(
nodeFactoryArray
==
null
)
{
nodeFactoryArray
=
(
NodePointerFactory
[
]
)
nodeFactories
.
toArray
(
new
NodePointerFactory
[
nodeFactories
.
size
(
)
]
)
;
Arrays
.
sort
(
nodeFactoryArray
,
new
Comparator
(
)
{
@
Override
public
int
compare
(
final
Object
a
,
final
Object
b
)
{
final
int
orderA
=
(
(
NodePointerFactory
)
a
)
.
getOrder
(
)
;
final
int
orderB
=
(
(
NodePointerFactory
)
b
)
.
getOrder
(
)
;
return
orderA
-
orderB
;
}
}
)
;
}
}
public
static
void
addNodePointerFactory
(
final
NodePointerFactory
factory
)
{
synchronized
(
nodeFactories
)
{
nodeFactories
.
add
(
factory
)
;
nodeFactoryArray
=
null
;
}
}
public
static
boolean
removeNodePointerFactory
(
final
NodePointerFactory
factory
)
{
synchronized
(
nodeFactories
)
{
final
boolean
remove
=
nodeFactories
.
remove
(
factory
)
;
nodeFactoryArray
=
null
;
return
remove
;
}
}
public
static
NodePointerFactory
[
]
getNodePointerFactories
(
)
{
return
nodeFactoryArray
;
}
protected
NamespaceResolver
namespaceResolver
;
private
Pointer
rootPointer
;
private
Pointer
contextPointer
;
protected
JXPathContextReferenceImpl
(
final
JXPathContext
parentContext
,
final
Object
contextBean
)
{
this
(
parentContext
,
contextBean
,
null
)
;
}
public
JXPathContextReferenceImpl
(
final
JXPathContext
parentContext
,
final
Object
contextBean
,
final
Pointer
contextPointer
)
{
super
(
parentContext
,
contextBean
)
;
synchronized
(
nodeFactories
)
{
createNodeFactoryArray
(
)
;
}
if
(
contextPointer
!=
null
)
{
this
.
contextPointer
=
contextPointer
;
this
.
rootPointer
=
NodePointer
.
newNodePointer
(
new
QName
(
null
,
"root"
)
,
contextPointer
.
getRootNode
(
)
,
getLocale
(
)
)
;
}
else
{
this
.
contextPointer
=
NodePointer
.
newNodePointer
(
new
QName
(
null
,
"root"
)
,
contextBean
,
getLocale
(
)
)
;
this
.
rootPointer
=
this
.
contextPointer
;
}
NamespaceResolver
parentNR
=
null
;
if
(
parentContext
instanceof
JXPathContextReferenceImpl
)
{
parentNR
=
(
(
JXPathContextReferenceImpl
)
parentContext
)
.
getNamespaceResolver
(
)
;
}
namespaceResolver
=
new
NamespaceResolver
(
parentNR
)
;
namespaceResolver
.
setNamespaceContextPointer
(
(
NodePointer
)
this
.
contextPointer
)
;
}
protected
Compiler
getCompiler
(
)
{
return
COMPILER
;
}
@
Override
protected
CompiledExpression
compilePath
(
final
String
xpath
)
{
return
new
JXPathCompiledExpression
(
xpath
,
compileExpression
(
xpath
)
)
;
}
private
Expression
compileExpression
(
final
String
xpath
)
{
Expression
expr
;
synchronized
(
compiled
)
{
if
(
USE_SOFT_CACHE
)
{
expr
=
null
;
final
SoftReference
ref
=
(
SoftReference
)
compiled
.
get
(
xpath
)
;
if
(
ref
!=
null
)
{
expr
=
(
Expression
)
ref
.
get
(
)
;
}
}
else
{
expr
=
(
Expression
)
compiled
.
get
(
xpath
)
;
}
}
if
(
expr
!=
null
)
{
return
expr
;
}
expr
=
(
Expression
)
Parser
.
parseExpression
(
xpath
,
getCompiler
(
)
)
;
synchronized
(
compiled
)
{
if
(
USE_SOFT_CACHE
)
{
if
(
cleanupCount
++
>=
CLEANUP_THRESHOLD
)
{
final
Iterator
it
=
compiled
.
entrySet
(
)
.
iterator
(
)
;
while
(
it
.
hasNext
(
)
)
{
final
Entry
me
=
(
Entry
)
it
.
next
(
)
;
if
(
(
(
SoftReference
)
me
.
getValue
(
)
)
.
get
(
)
==
null
)
{
it
.
remove
(
)
;
}
}
cleanupCount
=
0
;
}
compiled
.
put
(
xpath
,
new
SoftReference
(
expr
)
)
;
}
else
{
compiled
.
put
(
xpath
,
expr
)
;
}
}
return
expr
;
}
@
Override
public
Object
getValue
(
final
String
xpath
)
{
final
Expression
expression
=
compileExpression
(
xpath
)
;
return
getValue
(
xpath
,
expression
)
;
}
public
Object
getValue
(
final
String
xpath
,
final
Expression
expr
)
{
Object
result
=
expr
.
computeValue
(
getEvalContext
(
)
)
;
if
(
result
==
null
)
{
if
(
expr
instanceof
Path
&&
!
isLenient
(
)
)
{
throw
new
JXPathNotFoundException
(
"No value for xpath: "
+
xpath
)
;
}
return
null
;
}
if
(
result
instanceof
EvalContext
)
{
final
EvalContext
ctx
=
(
EvalContext
)
result
;
result
=
ctx
.
getSingleNodePointer
(
)
;
if
(
!
isLenient
(
)
&&
result
==
null
)
{
throw
new
JXPathNotFoundException
(
"No value for xpath: "
+
xpath
)
;
}
}
if
(
result
instanceof
NodePointer
)
{
result
=
(
(
NodePointer
)
result
)
.
getValuePointer
(
)
;
if
(
!
isLenient
(
)
)
{
NodePointer
.
verify
(
(
NodePointer
)
result
)
;
}
result
=
(
(
NodePointer
)
result
)
.
getValue
(
)
;
}
return
result
;
}
@
Override
public
Object
getValue
(
final
String
xpath
,
final
Class
requiredType
)
{
final
Expression
expr
=
compileExpression
(
xpath
)
;
return
getValue
(
xpath
,
expr
,
requiredType
)
;
}
public
Object
getValue
(
final
String
xpath
,
final
Expression
expr
,
final
Class
requiredType
)
{
Object
value
=
getValue
(
xpath
,
expr
)
;
if
(
value
!=
null
&&
requiredType
!=
null
)
{
if
(
!
TypeUtils
.
canConvert
(
value
,
requiredType
)
)
{
throw
new
JXPathTypeConversionException
(
"Invalid expression type. '"
+
xpath
+
"' returns "
+
value
.
getClass
(
)
.
getName
(
)
+
". It cannot be converted to "
+
requiredType
.
getName
(
)
)
;
}
value
=
TypeUtils
.
convert
(
value
,
requiredType
)
;
}
return
value
;
}
@
Override
public
Iterator
iterate
(
final
String
xpath
)
{
return
iterate
(
xpath
,
compileExpression
(
xpath
)
)
;
}
public
Iterator
iterate
(
final
String
xpath
,
final
Expression
expr
)
{
return
expr
.
iterate
(
getEvalContext
(
)
)
;
}
@
Override
public
Pointer
getPointer
(
final
String
xpath
)
{
return
getPointer
(
xpath
,
compileExpression
(
xpath
)
)
;
}
public
Pointer
getPointer
(
final
String
xpath
,
final
Expression
expr
)
{
Object
result
=
expr
.
computeValue
(
getEvalContext
(
)
)
;
if
(
result
instanceof
EvalContext
)
{
result
=
(
(
EvalContext
)
result
)
.
getSingleNodePointer
(
)
;
}
if
(
result
instanceof
Pointer
)
{
if
(
!
isLenient
(
)
&&
!
(
(
NodePointer
)
result
)
.
isActual
(
)
)
{
throw
new
JXPathNotFoundException
(
"No pointer for xpath: "
+
xpath
)
;
}
return
(
Pointer
)
result
;
}
return
NodePointer
.
newNodePointer
(
null
,
result
,
getLocale
(
)
)
;
}
@
Override
public
void
setValue
(
final
String
xpath
,
final
Object
value
)
{
setValue
(
xpath
,
compileExpression
(
xpath
)
,
value
)
;
}
public
void
setValue
(
final
String
xpath
,
final
Expression
expr
,
final
Object
value
)
{
try
{
setValue
(
xpath
,
expr
,
value
,
false
)
;
}
catch
(
final
Throwable
ex
)
{
throw
new
JXPathException
(
"Exception trying to set value with xpath "
+
xpath
,
ex
)
;
}
}
@
Override
public
Pointer
createPath
(
final
String
xpath
)
{
return
createPath
(
xpath
,
compileExpression
(
xpath
)
)
;
}
public
Pointer
createPath
(
final
String
xpath
,
final
Expression
expr
)
{
try
{
final
Object
result
=
expr
.
computeValue
(
getEvalContext
(
)
)
;
Pointer
pointer
;
if
(
result
instanceof
Pointer
)
{
pointer
=
(
Pointer
)
result
;
}
else
if
(
result
instanceof
EvalContext
)
{
final
EvalContext
ctx
=
(
EvalContext
)
result
;
pointer
=
ctx
.
getSingleNodePointer
(
)
;
}
else
{
checkSimplePath
(
expr
)
;
throw
new
JXPathException
(
"Cannot create path:"
+
xpath
)
;
}
return
(
(
NodePointer
)
pointer
)
.
createPath
(
this
)
;
}
catch
(
final
Throwable
ex
)
{
throw
new
JXPathException
(
"Exception trying to create xpath "
+
xpath
,
ex
)
;
}
}
@
Override
public
Pointer
createPathAndSetValue
(
final
String
xpath
,
final
Object
value
)
{
return
createPathAndSetValue
(
xpath
,
compileExpression
(
xpath
)
,
value
)
;
}
public
Pointer
createPathAndSetValue
(
final
String
xpath
,
final
Expression
expr
,
final
Object
value
)
{
try
{
return
setValue
(
xpath
,
expr
,
value
,
true
)
;
}
catch
(
final
Throwable
ex
)
{
throw
new
JXPathException
(
"Exception trying to create xpath "
+
xpath
,
ex
)
;
}
}
private
Pointer
setValue
(
final
String
xpath
,
final
Expression
expr
,
final
Object
value
,
final
boolean
create
)
{
final
Object
result
=
expr
.
computeValue
(
getEvalContext
(
)
)
;
Pointer
pointer
;
if
(
result
instanceof
Pointer
)
{
pointer
=
(
Pointer
)
result
;
}
else
if
(
result
instanceof
EvalContext
)
{
final
EvalContext
ctx
=
(
EvalContext
)
result
;
pointer
=
ctx
.
getSingleNodePointer
(
)
;
}
else
{
if
(
create
)
{
checkSimplePath
(
expr
)
;
}
throw
new
JXPathException
(
"Cannot set value for xpath: "
+
xpath
)
;
}
if
(
create
)
{
pointer
=
(
(
NodePointer
)
pointer
)
.
createPath
(
this
,
value
)
;
}
else
{
pointer
.
setValue
(
value
)
;
}
return
pointer
;
}
private
void
checkSimplePath
(
final
Expression
expr
)
{
if
(
!
(
expr
instanceof
LocationPath
)
||
!
(
(
LocationPath
)
expr
)
.
isSimplePath
(
)
)
{
throw
new
JXPathInvalidSyntaxException
(
"JXPath can only create a path if it uses exclusively "
+
"the child:: and attribute:: axes and has "
+
"no context-dependent predicates"
)
;
}
}
@
Override
public
Iterator
iteratePointers
(
final
String
xpath
)
{
return
iteratePointers
(
xpath
,
compileExpression
(
xpath
)
)
;
}
public
Iterator
iteratePointers
(
final
String
xpath
,
final
Expression
expr
)
{
return
expr
.
iteratePointers
(
getEvalContext
(
)
)
;
}
@
Override
public
void
removePath
(
final
String
xpath
)
{
removePath
(
xpath
,
compileExpression
(
xpath
)
)
;
}
public
void
removePath
(
final
String
xpath
,
final
Expression
expr
)
{
try
{
final
NodePointer
pointer
=
(
NodePointer
)
getPointer
(
xpath
,
expr
)
;
if
(
pointer
!=
null
)
{
pointer
.
remove
(
)
;
}
}
catch
(
final
Throwable
ex
)
{
throw
new
JXPathException
(
"Exception trying to remove xpath "
+
xpath
,
ex
)
;
}
}
@
Override
public
void
removeAll
(
final
String
xpath
)
{
removeAll
(
xpath
,
compileExpression
(
xpath
)
)
;
}
public
void
removeAll
(
final
String
xpath
,
final
Expression
expr
)
{
try
{
final
ArrayList
list
=
new
ArrayList
(
)
;
Iterator
it
=
expr
.
iteratePointers
(
getEvalContext
(
)
)
;
while
(
it
.
hasNext
(
)
)
{
list
.
add
(
it
.
next
(
)
)
;
}
Collections
.
sort
(
list
,
ReverseComparator
.
INSTANCE
)
;
it
=
list
.
iterator
(
)
;
if
(
it
.
hasNext
(
)
)
{
final
NodePointer
pointer
=
(
NodePointer
)
it
.
next
(
)
;
pointer
.
remove
(
)
;
while
(
it
.
hasNext
(
)
)
{
removePath
(
(
(
NodePointer
)
it
.
next
(
)
)
.
asPath
(
)
)
;
}
}
}
catch
(
final
Throwable
ex
)
{
throw
new
JXPathException
(
"Exception trying to remove all for xpath "
+
xpath
,
ex
)
;
}
}
@
Override
public
JXPathContext
getRelativeContext
(
final
Pointer
pointer
)
{
final
Object
contextBean
=
pointer
.
getNode
(
)
;
if
(
contextBean
==
null
)
{
throw
new
JXPathException
(
"Cannot create a relative context for a non-existent node: "
+
pointer
)
;
}
return
new
JXPathContextReferenceImpl
(
this
,
contextBean
,
pointer
)
;
}
@
Override
public
Pointer
getContextPointer
(
)
{
return
contextPointer
;
}
private
NodePointer
getAbsoluteRootPointer
(
)
{
return
(
NodePointer
)
rootPointer
;
}
private
EvalContext
getEvalContext
(
)
{
return
new
InitialContext
(
new
RootContext
(
this
,
(
NodePointer
)
getContextPointer
(
)
)
)
;
}
public
EvalContext
getAbsoluteRootContext
(
)
{
return
new
InitialContext
(
new
RootContext
(
this
,
getAbsoluteRootPointer
(
)
)
)
;
}
public
NodePointer
getVariablePointer
(
final
QName
name
)
{
return
NodePointer
.
newNodePointer
(
name
,
VariablePointerFactory
.
contextWrapper
(
this
)
,
getLocale
(
)
)
;
}
public
Function
getFunction
(
final
QName
functionName
,
final
Object
[
]
parameters
)
{
final
String
namespace
=
functionName
.
getPrefix
(
)
;
final
String
name
=
functionName
.
getName
(
)
;
JXPathContext
funcCtx
=
this
;
Function
func
;
Functions
funcs
;
while
(
funcCtx
!=
null
)
{
funcs
=
funcCtx
.
getFunctions
(
)
;
if
(
funcs
!=
null
)
{
func
=
funcs
.
getFunction
(
namespace
,
name
,
parameters
)
;
if
(
func
!=
null
)
{
return
func
;
}
}
funcCtx
=
funcCtx
.
getParentContext
(
)
;
}
throw
new
JXPathFunctionNotFoundException
(
"Undefined function: "
+
functionName
.
toString
(
)
)
;
}
@
Override
public
void
registerNamespace
(
final
String
prefix
,
final
String
namespaceURI
)
{
if
(
namespaceResolver
.
isSealed
(
)
)
{
namespaceResolver
=
(
NamespaceResolver
)
namespaceResolver
.
clone
(
)
;
}
namespaceResolver
.
registerNamespace
(
prefix
,
namespaceURI
)
;
}
@
Override
public
String
getNamespaceURI
(
final
String
prefix
)
{
return
namespaceResolver
.
getNamespaceURI
(
prefix
)
;
}
@
Override
public
String
getPrefix
(
final
String
namespaceURI
)
{
return
namespaceResolver
.
getPrefix
(
namespaceURI
)
;
}
@
Override
public
void
setNamespaceContextPointer
(
final
Pointer
pointer
)
{
if
(
namespaceResolver
.
isSealed
(
)
)
{
namespaceResolver
=
(
NamespaceResolver
)
namespaceResolver
.
clone
(
)
;
}
namespaceResolver
.
setNamespaceContextPointer
(
(
NodePointer
)
pointer
)
;
}
@
Override
public
Pointer
getNamespaceContextPointer
(
)
{
return
namespaceResolver
.
getNamespaceContextPointer
(
)
;
}
public
NamespaceResolver
getNamespaceResolver
(
)
{
namespaceResolver
.
seal
(
)
;
return
namespaceResolver
;
}
@
Override
public
void
setExceptionHandler
(
final
ExceptionHandler
exceptionHandler
)
{
if
(
rootPointer
instanceof
NodePointer
)
{
(
(
NodePointer
)
rootPointer
)
.
setExceptionHandler
(
exceptionHandler
)
;
}
}
public
static
Object
allocateConditionally
(
final
String
className
,
final
String
existenceCheckClassName
)
{
try
{
try
{
ClassLoaderUtil
.
getClass
(
existenceCheckClassName
,
true
)
;
}
catch
(
final
ClassNotFoundException
ex
)
{
return
null
;
}
final
Class
cls
=
ClassLoaderUtil
.
getClass
(
className
,
true
)
;
return
cls
.
getConstructor
(
)
.
newInstance
(
)
;
}
catch
(
final
Exception
ex
)
{
throw
new
JXPathException
(
"Cannot allocate "
+
className
,
ex
)
;
}
}
}
<EOF>
