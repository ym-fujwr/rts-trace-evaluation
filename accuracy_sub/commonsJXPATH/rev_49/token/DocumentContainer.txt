package
org
.
apache
.
commons
.
jxpath
.
xml
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
net
.
URL
;
import
java
.
util
.
HashMap
;
import
org
.
apache
.
commons
.
jxpath
.
Container
;
import
org
.
apache
.
commons
.
jxpath
.
JXPathException
;
import
org
.
apache
.
commons
.
jxpath
.
util
.
ClassLoaderUtil
;
public
class
DocumentContainer
extends
XMLParser2
implements
Container
{
public
static
final
String
MODEL_DOM
=
"DOM"
;
public
static
final
String
MODEL_JDOM
=
"JDOM"
;
private
static
final
long
serialVersionUID
=
-
8713290334113427066L
;
private
static
HashMap
parserClasses
=
new
HashMap
(
)
;
static
{
parserClasses
.
put
(
MODEL_DOM
,
"org.apache.commons.jxpath.xml.DOMParser"
)
;
parserClasses
.
put
(
MODEL_JDOM
,
"org.apache.commons.jxpath.xml.JDOMParser"
)
;
}
private
static
HashMap
parsers
=
new
HashMap
(
)
;
private
Object
document
;
private
final
URL
xmlURL
;
private
final
String
model
;
public
static
void
registerXMLParser
(
final
String
model
,
final
XMLParser
parser
)
{
parsers
.
put
(
model
,
parser
)
;
}
public
static
void
registerXMLParser
(
final
String
model
,
final
String
parserClassName
)
{
parserClasses
.
put
(
model
,
parserClassName
)
;
}
public
DocumentContainer
(
final
URL
xmlURL
)
{
this
(
xmlURL
,
MODEL_DOM
)
;
}
public
DocumentContainer
(
final
URL
xmlURL
,
final
String
model
)
{
this
.
xmlURL
=
xmlURL
;
if
(
xmlURL
==
null
)
{
throw
new
JXPathException
(
"XML URL is null"
)
;
}
this
.
model
=
model
;
}
@
Override
public
Object
getValue
(
)
{
if
(
document
==
null
)
{
try
{
InputStream
stream
=
null
;
try
{
if
(
xmlURL
!=
null
)
{
stream
=
xmlURL
.
openStream
(
)
;
}
document
=
parseXML
(
stream
)
;
}
finally
{
if
(
stream
!=
null
)
{
stream
.
close
(
)
;
}
}
}
catch
(
final
IOException
ex
)
{
throw
new
JXPathException
(
"Cannot read XML from: "
+
xmlURL
.
toString
(
)
,
ex
)
;
}
}
return
document
;
}
@
Override
public
Object
parseXML
(
final
InputStream
stream
)
{
final
XMLParser
parser
=
getParser
(
model
)
;
if
(
parser
instanceof
XMLParser2
)
{
final
XMLParser2
parser2
=
(
XMLParser2
)
parser
;
parser2
.
setValidating
(
isValidating
(
)
)
;
parser2
.
setNamespaceAware
(
isNamespaceAware
(
)
)
;
parser2
.
setIgnoringElementContentWhitespace
(
isIgnoringElementContentWhitespace
(
)
)
;
parser2
.
setExpandEntityReferences
(
isExpandEntityReferences
(
)
)
;
parser2
.
setIgnoringComments
(
isIgnoringComments
(
)
)
;
parser2
.
setCoalescing
(
isCoalescing
(
)
)
;
}
return
parser
.
parseXML
(
stream
)
;
}
@
Override
public
void
setValue
(
final
Object
value
)
{
throw
new
UnsupportedOperationException
(
)
;
}
private
static
XMLParser
getParser
(
final
String
model
)
{
return
(
XMLParser
)
parsers
.
computeIfAbsent
(
model
,
k
->
{
final
String
className
=
(
String
)
parserClasses
.
get
(
model
)
;
if
(
className
==
null
)
{
throw
new
JXPathException
(
"Unsupported XML model: "
+
model
)
;
}
try
{
final
Class
clazz
=
ClassLoaderUtil
.
getClass
(
className
,
true
)
;
return
(
XMLParser
)
clazz
.
getConstructor
(
)
.
newInstance
(
)
;
}
catch
(
final
Exception
ex
)
{
throw
new
JXPathException
(
"Cannot allocate XMLParser: "
+
className
,
ex
)
;
}
}
)
;
}
}
<EOF>
