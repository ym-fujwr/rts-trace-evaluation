package
org
.
apache
.
commons
.
net
.
ftp
;
import
java
.
io
.
BufferedReader
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
InputStreamReader
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
LinkedList
;
import
java
.
util
.
List
;
import
java
.
util
.
ListIterator
;
import
org
.
apache
.
commons
.
net
.
util
.
Charsets
;
public
class
FTPListParseEngine
{
private
static
final
FTPFile
[
]
EMPTY_FTP_FILE_ARRAY
=
new
FTPFile
[
0
]
;
private
List
<
String
>
entries
=
new
LinkedList
<
>
(
)
;
private
ListIterator
<
String
>
internalIterator
=
entries
.
listIterator
(
)
;
private
final
FTPFileEntryParser
parser
;
private
final
boolean
saveUnparseableEntries
;
public
FTPListParseEngine
(
final
FTPFileEntryParser
parser
)
{
this
(
parser
,
null
)
;
}
FTPListParseEngine
(
final
FTPFileEntryParser
parser
,
final
FTPClientConfig
configuration
)
{
this
.
parser
=
parser
;
if
(
configuration
!=
null
)
{
this
.
saveUnparseableEntries
=
configuration
.
getUnparseableEntries
(
)
;
}
else
{
this
.
saveUnparseableEntries
=
false
;
}
}
public
FTPFile
[
]
getFiles
(
)
throws
IOException
{
return
getFiles
(
FTPFileFilters
.
NON_NULL
)
;
}
public
FTPFile
[
]
getFiles
(
final
FTPFileFilter
filter
)
throws
IOException
{
final
List
<
FTPFile
>
tmpResults
=
new
ArrayList
<
>
(
)
;
for
(
final
String
entry
:
entries
)
{
FTPFile
temp
=
this
.
parser
.
parseFTPEntry
(
entry
)
;
if
(
temp
==
null
&&
saveUnparseableEntries
)
{
temp
=
new
FTPFile
(
entry
)
;
}
if
(
filter
.
accept
(
temp
)
)
{
tmpResults
.
add
(
temp
)
;
}
}
return
tmpResults
.
toArray
(
EMPTY_FTP_FILE_ARRAY
)
;
}
public
FTPFile
[
]
getNext
(
final
int
quantityRequested
)
{
final
List
<
FTPFile
>
tmpResults
=
new
LinkedList
<
>
(
)
;
int
count
=
quantityRequested
;
while
(
count
>
0
&&
this
.
internalIterator
.
hasNext
(
)
)
{
final
String
entry
=
this
.
internalIterator
.
next
(
)
;
FTPFile
temp
=
this
.
parser
.
parseFTPEntry
(
entry
)
;
if
(
temp
==
null
&&
saveUnparseableEntries
)
{
temp
=
new
FTPFile
(
entry
)
;
}
tmpResults
.
add
(
temp
)
;
count
--
;
}
return
tmpResults
.
toArray
(
EMPTY_FTP_FILE_ARRAY
)
;
}
public
FTPFile
[
]
getPrevious
(
final
int
quantityRequested
)
{
final
List
<
FTPFile
>
tmpResults
=
new
LinkedList
<
>
(
)
;
int
count
=
quantityRequested
;
while
(
count
>
0
&&
this
.
internalIterator
.
hasPrevious
(
)
)
{
final
String
entry
=
this
.
internalIterator
.
previous
(
)
;
FTPFile
temp
=
this
.
parser
.
parseFTPEntry
(
entry
)
;
if
(
temp
==
null
&&
saveUnparseableEntries
)
{
temp
=
new
FTPFile
(
entry
)
;
}
tmpResults
.
add
(
0
,
temp
)
;
count
--
;
}
return
tmpResults
.
toArray
(
EMPTY_FTP_FILE_ARRAY
)
;
}
public
boolean
hasNext
(
)
{
return
internalIterator
.
hasNext
(
)
;
}
public
boolean
hasPrevious
(
)
{
return
internalIterator
.
hasPrevious
(
)
;
}
private
void
read
(
final
InputStream
inputStream
,
final
String
charsetName
)
throws
IOException
{
try
(
final
BufferedReader
reader
=
new
BufferedReader
(
new
InputStreamReader
(
inputStream
,
Charsets
.
toCharset
(
charsetName
)
)
)
)
{
String
line
=
this
.
parser
.
readNextEntry
(
reader
)
;
while
(
line
!=
null
)
{
this
.
entries
.
add
(
line
)
;
line
=
this
.
parser
.
readNextEntry
(
reader
)
;
}
}
}
@
Deprecated
public
void
readServerList
(
final
InputStream
inputStream
)
throws
IOException
{
readServerList
(
inputStream
,
null
)
;
}
public
void
readServerList
(
final
InputStream
inputStream
,
final
String
charsetName
)
throws
IOException
{
this
.
entries
=
new
LinkedList
<
>
(
)
;
read
(
inputStream
,
charsetName
)
;
this
.
parser
.
preParse
(
this
.
entries
)
;
resetIterator
(
)
;
}
public
void
resetIterator
(
)
{
this
.
internalIterator
=
this
.
entries
.
listIterator
(
)
;
}
}
<EOF>
