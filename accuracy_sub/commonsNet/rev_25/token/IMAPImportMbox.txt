package
org
.
apache
.
commons
.
net
.
examples
.
mail
;
import
java
.
io
.
BufferedReader
;
import
java
.
io
.
File
;
import
java
.
io
.
FileReader
;
import
java
.
io
.
IOException
;
import
java
.
net
.
URI
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
BitSet
;
import
java
.
util
.
List
;
import
java
.
util
.
regex
.
Matcher
;
import
java
.
util
.
regex
.
Pattern
;
import
org
.
apache
.
commons
.
net
.
imap
.
IMAPClient
;
public
final
class
IMAPImportMbox
{
private
static
final
String
CRLF
=
"\r\n"
;
private
static
final
Pattern
PATFROM
=
Pattern
.
compile
(
">+From "
)
;
private
static
String
getDate
(
final
String
msg
)
{
final
Pattern
FROM_RE
=
Pattern
.
compile
(
"From \\S+ +\\S+ (\\S+)  ?(\\S+) (\\S+) (\\S+)"
)
;
String
date
=
null
;
final
Matcher
m
=
FROM_RE
.
matcher
(
msg
)
;
if
(
m
.
lookingAt
(
)
)
{
date
=
m
.
group
(
2
)
+
"-"
+
m
.
group
(
1
)
+
"-"
+
m
.
group
(
4
)
+
" "
+
m
.
group
(
3
)
+
" +0000"
;
}
return
date
;
}
private
static
boolean
listContains
(
final
List
<
String
>
contains
,
final
String
string
)
{
for
(
final
String
entry
:
contains
)
{
if
(
string
.
contains
(
entry
)
)
{
return
true
;
}
}
return
false
;
}
public
static
void
main
(
final
String
[
]
args
)
throws
IOException
{
if
(
args
.
length
<
2
)
{
System
.
err
.
println
(
"Usage: IMAPImportMbox imap[s]://user:password@host[:port]/folder/path <mboxfile> [selectors]"
)
;
System
.
err
.
println
(
"\tWhere: a selector is a list of numbers/number ranges - 1,2,3-10"
+
" - or a list of strings to match in the initial From line"
)
;
System
.
exit
(
1
)
;
}
final
URI
uri
=
URI
.
create
(
args
[
0
]
)
;
final
String
file
=
args
[
1
]
;
final
File
mbox
=
new
File
(
file
)
;
if
(
!
mbox
.
isFile
(
)
||
!
mbox
.
canRead
(
)
)
{
throw
new
IOException
(
"Cannot read mailbox file: "
+
mbox
)
;
}
final
String
path
=
uri
.
getPath
(
)
;
if
(
path
==
null
||
path
.
length
(
)
<
1
)
{
throw
new
IllegalArgumentException
(
"Invalid folderPath: '"
+
path
+
"'"
)
;
}
final
String
folder
=
path
.
substring
(
1
)
;
final
List
<
String
>
contains
=
new
ArrayList
<
>
(
)
;
final
BitSet
msgNums
=
new
BitSet
(
)
;
for
(
int
i
=
2
;
i
<
args
.
length
;
i
++
)
{
final
String
arg
=
args
[
i
]
;
if
(
arg
.
matches
(
"\\d+(-\\d+)?(,\\d+(-\\d+)?)*"
)
)
{
for
(
final
String
entry
:
arg
.
split
(
","
)
)
{
final
String
[
]
parts
=
entry
.
split
(
"-"
)
;
if
(
parts
.
length
==
2
)
{
final
int
low
=
Integer
.
parseInt
(
parts
[
0
]
)
;
final
int
high
=
Integer
.
parseInt
(
parts
[
1
]
)
;
for
(
int
j
=
low
;
j
<=
high
;
j
++
)
{
msgNums
.
set
(
j
)
;
}
}
else
{
msgNums
.
set
(
Integer
.
parseInt
(
entry
)
)
;
}
}
}
else
{
contains
.
add
(
arg
)
;
}
}
final
IMAPClient
imap
=
IMAPUtils
.
imapLogin
(
uri
,
10000
,
null
)
;
int
total
=
0
;
int
loaded
=
0
;
try
{
imap
.
setSoTimeout
(
6000
)
;
final
BufferedReader
br
=
new
BufferedReader
(
new
FileReader
(
file
)
)
;
String
line
;
final
StringBuilder
sb
=
new
StringBuilder
(
)
;
boolean
wanted
=
false
;
while
(
(
line
=
br
.
readLine
(
)
)
!=
null
)
{
if
(
line
.
startsWith
(
"From "
)
)
{
if
(
process
(
sb
,
imap
,
folder
,
total
)
)
{
loaded
++
;
}
sb
.
setLength
(
0
)
;
total
++
;
wanted
=
wanted
(
total
,
line
,
msgNums
,
contains
)
;
}
else
if
(
startsWith
(
line
,
PATFROM
)
)
{
line
=
line
.
substring
(
1
)
;
}
if
(
wanted
)
{
sb
.
append
(
line
)
;
sb
.
append
(
CRLF
)
;
}
}
br
.
close
(
)
;
if
(
wanted
&&
process
(
sb
,
imap
,
folder
,
total
)
)
{
loaded
++
;
}
}
catch
(
final
IOException
e
)
{
System
.
out
.
println
(
"Error processing msg: "
+
total
+
" "
+
imap
.
getReplyString
(
)
)
;
e
.
printStackTrace
(
)
;
System
.
exit
(
10
)
;
return
;
}
finally
{
imap
.
logout
(
)
;
imap
.
disconnect
(
)
;
}
System
.
out
.
println
(
"Processed "
+
total
+
" messages, loaded "
+
loaded
)
;
}
private
static
boolean
process
(
final
StringBuilder
sb
,
final
IMAPClient
imap
,
final
String
folder
,
final
int
msgNum
)
throws
IOException
{
final
int
length
=
sb
.
length
(
)
;
final
boolean
haveMessage
=
length
>
2
;
if
(
haveMessage
)
{
System
.
out
.
println
(
"MsgNum: "
+
msgNum
+
" Length "
+
length
)
;
sb
.
setLength
(
length
-
2
)
;
final
String
msg
=
sb
.
toString
(
)
;
if
(
!
imap
.
append
(
folder
,
null
,
getDate
(
msg
)
,
msg
)
)
{
throw
new
IOException
(
"Failed to import message: "
+
msgNum
+
" "
+
imap
.
getReplyString
(
)
)
;
}
}
return
haveMessage
;
}
private
static
boolean
startsWith
(
final
String
input
,
final
Pattern
pat
)
{
final
Matcher
m
=
pat
.
matcher
(
input
)
;
return
m
.
lookingAt
(
)
;
}
private
static
boolean
wanted
(
final
int
msgNum
,
final
String
line
,
final
BitSet
msgNums
,
final
List
<
String
>
contains
)
{
return
(
msgNums
.
isEmpty
(
)
&&
contains
.
isEmpty
(
)
)
||
msgNums
.
get
(
msgNum
)
||
listContains
(
contains
,
line
)
;
}
}
<EOF>
