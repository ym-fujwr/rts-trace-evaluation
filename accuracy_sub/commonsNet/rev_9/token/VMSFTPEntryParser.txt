package
org
.
apache
.
commons
.
net
.
ftp
.
parser
;
import
java
.
io
.
BufferedReader
;
import
java
.
io
.
IOException
;
import
java
.
text
.
ParseException
;
import
java
.
util
.
StringTokenizer
;
import
org
.
apache
.
commons
.
net
.
ftp
.
FTPClientConfig
;
import
org
.
apache
.
commons
.
net
.
ftp
.
FTPFile
;
public
class
VMSFTPEntryParser
extends
ConfigurableFTPFileEntryParserImpl
{
private
static
final
String
DEFAULT_DATE_FORMAT
=
"d-MMM-yyyy HH:mm:ss"
;
private
static
final
String
REGEX
=
"(.*?;[0-9]+)\\s*"
+
"(\\d+)(?:/\\d+)?\\s*"
+
"(\\S+)\\s+(\\S+)\\s+"
+
"\\[(([0-9$A-Za-z_]+)|([0-9$A-Za-z_]+),([0-9$a-zA-Z_]+))\\]?\\s*"
+
"\\([a-zA-Z]*,([a-zA-Z]*),([a-zA-Z]*),([a-zA-Z]*)\\)"
;
public
VMSFTPEntryParser
(
)
{
this
(
null
)
;
}
public
VMSFTPEntryParser
(
final
FTPClientConfig
config
)
{
super
(
REGEX
)
;
configure
(
config
)
;
}
@
Override
protected
FTPClientConfig
getDefaultConfiguration
(
)
{
return
new
FTPClientConfig
(
FTPClientConfig
.
SYST_VMS
,
DEFAULT_DATE_FORMAT
,
null
)
;
}
protected
boolean
isVersioning
(
)
{
return
false
;
}
@
Deprecated
public
FTPFile
[
]
parseFileList
(
final
java
.
io
.
InputStream
listStream
)
throws
IOException
{
final
org
.
apache
.
commons
.
net
.
ftp
.
FTPListParseEngine
engine
=
new
org
.
apache
.
commons
.
net
.
ftp
.
FTPListParseEngine
(
this
)
;
engine
.
readServerList
(
listStream
,
null
)
;
return
engine
.
getFiles
(
)
;
}
@
Override
public
FTPFile
parseFTPEntry
(
final
String
entry
)
{
final
long
longBlock
=
512
;
if
(
matches
(
entry
)
)
{
final
FTPFile
f
=
new
FTPFile
(
)
;
f
.
setRawListing
(
entry
)
;
String
name
=
group
(
1
)
;
final
String
size
=
group
(
2
)
;
final
String
datestr
=
group
(
3
)
+
" "
+
group
(
4
)
;
final
String
owner
=
group
(
5
)
;
final
String
permissions
[
]
=
new
String
[
3
]
;
permissions
[
0
]
=
group
(
9
)
;
permissions
[
1
]
=
group
(
10
)
;
permissions
[
2
]
=
group
(
11
)
;
try
{
f
.
setTimestamp
(
super
.
parseTimestamp
(
datestr
)
)
;
}
catch
(
final
ParseException
e
)
{
}
final
String
grp
;
final
String
user
;
final
StringTokenizer
t
=
new
StringTokenizer
(
owner
,
","
)
;
switch
(
t
.
countTokens
(
)
)
{
case
1
:
grp
=
null
;
user
=
t
.
nextToken
(
)
;
break
;
case
2
:
grp
=
t
.
nextToken
(
)
;
user
=
t
.
nextToken
(
)
;
break
;
default
:
grp
=
null
;
user
=
null
;
}
if
(
name
.
lastIndexOf
(
".DIR"
)
!=
-
1
)
{
f
.
setType
(
FTPFile
.
DIRECTORY_TYPE
)
;
}
else
{
f
.
setType
(
FTPFile
.
FILE_TYPE
)
;
}
if
(
!
isVersioning
(
)
)
{
name
=
name
.
substring
(
0
,
name
.
lastIndexOf
(
';'
)
)
;
}
f
.
setName
(
name
)
;
final
long
sizeInBytes
=
Long
.
parseLong
(
size
)
*
longBlock
;
f
.
setSize
(
sizeInBytes
)
;
f
.
setGroup
(
grp
)
;
f
.
setUser
(
user
)
;
for
(
int
access
=
0
;
access
<
3
;
access
++
)
{
final
String
permission
=
permissions
[
access
]
;
f
.
setPermission
(
access
,
FTPFile
.
READ_PERMISSION
,
permission
.
indexOf
(
'R'
)
>=
0
)
;
f
.
setPermission
(
access
,
FTPFile
.
WRITE_PERMISSION
,
permission
.
indexOf
(
'W'
)
>=
0
)
;
f
.
setPermission
(
access
,
FTPFile
.
EXECUTE_PERMISSION
,
permission
.
indexOf
(
'E'
)
>=
0
)
;
}
return
f
;
}
return
null
;
}
@
Override
public
String
readNextEntry
(
final
BufferedReader
reader
)
throws
IOException
{
String
line
=
reader
.
readLine
(
)
;
final
StringBuilder
entry
=
new
StringBuilder
(
)
;
while
(
line
!=
null
)
{
if
(
line
.
startsWith
(
"Directory"
)
||
line
.
startsWith
(
"Total"
)
)
{
line
=
reader
.
readLine
(
)
;
continue
;
}
entry
.
append
(
line
)
;
if
(
line
.
trim
(
)
.
endsWith
(
")"
)
)
{
break
;
}
line
=
reader
.
readLine
(
)
;
}
return
entry
.
length
(
)
==
0
?
null
:
entry
.
toString
(
)
;
}
}
<EOF>
