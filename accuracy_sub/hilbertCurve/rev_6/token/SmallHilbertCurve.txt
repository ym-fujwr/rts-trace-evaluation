package
org
.
davidmoten
.
hilbert
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
List
;
import
java
.
util
.
SortedSet
;
import
java
.
util
.
TreeSet
;
import
com
.
github
.
davidmoten
.
guavamini
.
Preconditions
;
public
final
class
SmallHilbertCurve
{
private
final
int
bits
;
private
final
int
dimensions
;
private
final
int
length
;
private
SmallHilbertCurve
(
int
bits
,
int
dimensions
)
{
this
.
bits
=
bits
;
this
.
dimensions
=
dimensions
;
this
.
length
=
bits
*
dimensions
;
}
public
long
index
(
long
...
point
)
{
Preconditions
.
checkArgument
(
point
.
length
==
dimensions
)
;
return
toIndex
(
HilbertCurve
.
transposedIndex
(
bits
,
point
)
)
;
}
public
long
[
]
point
(
long
index
)
{
return
HilbertCurve
.
transposedIndexToPoint
(
bits
,
transposeLong
(
index
)
)
;
}
public
void
point
(
long
index
,
long
[
]
x
)
{
Util
.
zero
(
x
)
;
transposeLong
(
index
,
x
)
;
HilbertCurve
.
transposedIndexToPoint
(
bits
,
x
)
;
}
private
long
toIndex
(
long
...
transposedIndex
)
{
long
b
=
0
;
int
bIndex
=
length
-
1
;
long
mask
=
1L
<
<
(
bits
-
1
)
;
for
(
int
i
=
0
;
i
<
bits
;
i
++
)
{
for
(
int
j
=
0
;
j
<
transposedIndex
.
length
;
j
++
)
{
if
(
(
transposedIndex
[
j
]
&
mask
)
!=
0
)
{
b
|=
1L
<
<
bIndex
;
}
bIndex
--
;
}
mask
>>=
1
;
}
return
b
;
}
private
void
transposeLong
(
long
index
,
long
[
]
x
)
{
for
(
int
idx
=
0
;
idx
<
64
;
idx
++
)
{
if
(
(
index
&
(
1L
<
<
idx
)
)
!=
0
)
{
int
dim
=
(
length
-
idx
-
1
)
%
dimensions
;
int
shift
=
(
idx
/
dimensions
)
%
bits
;
x
[
dim
]
|=
1L
<
<
shift
;
}
}
}
private
long
[
]
transposeLong
(
long
index
)
{
long
[
]
x
=
new
long
[
dimensions
]
;
transposeLong
(
index
,
x
)
;
return
x
;
}
public
Ranges
query
(
long
[
]
a
,
long
[
]
b
)
{
Box
box
=
new
Box
(
a
,
b
)
;
SortedSet
<
Long
>
set
=
new
TreeSet
<
>
(
)
;
box
.
visitPerimeter
(
cell
->
{
long
n
=
index
(
cell
)
;
set
.
add
(
n
)
;
}
)
;
List
<
Long
>
list
=
new
ArrayList
<
>
(
set
)
;
int
i
=
0
;
List
<
Range
>
ranges
=
new
ArrayList
<
>
(
)
;
long
rangeStart
=
-
1
;
while
(
true
)
{
if
(
i
==
list
.
size
(
)
)
{
break
;
}
if
(
rangeStart
==
-
1
)
{
rangeStart
=
list
.
get
(
i
)
;
}
while
(
i
<
list
.
size
(
)
-
1
&&
list
.
get
(
i
+
1
)
==
list
.
get
(
i
)
+
1
)
{
i
++
;
}
if
(
i
==
list
.
size
(
)
-
1
)
{
ranges
.
add
(
Range
.
create
(
rangeStart
,
list
.
get
(
i
)
)
)
;
break
;
}
long
[
]
point
=
point
(
list
.
get
(
i
)
+
1
)
;
if
(
box
.
contains
(
point
)
)
{
i
+=
1
;
}
else
{
ranges
.
add
(
Range
.
create
(
rangeStart
,
list
.
get
(
i
)
)
)
;
rangeStart
=
-
1
;
i
++
;
}
}
return
new
Ranges
(
ranges
)
;
}
public
static
final
class
Builder
{
private
int
bits
;
Builder
(
)
{
}
public
Builder
bits
(
int
bits
)
{
this
.
bits
=
bits
;
return
this
;
}
public
SmallHilbertCurve
dimensions
(
int
dimensions
)
{
Preconditions
.
checkArgument
(
bits
*
dimensions
<=
63
,
"bits * dimensions must be less than or equal to 63"
)
;
return
new
SmallHilbertCurve
(
bits
,
dimensions
)
;
}
}
}
<EOF>
