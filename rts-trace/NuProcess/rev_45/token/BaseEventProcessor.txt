package
com
.
zaxxer
.
nuprocess
.
internal
;
import
java
.
util
.
Collection
;
import
java
.
util
.
Map
;
import
java
.
util
.
concurrent
.
ConcurrentHashMap
;
import
java
.
util
.
concurrent
.
CyclicBarrier
;
import
java
.
util
.
concurrent
.
atomic
.
AtomicBoolean
;
import
java
.
util
.
logging
.
Level
;
import
java
.
util
.
logging
.
Logger
;
import
com
.
sun
.
jna
.
ptr
.
IntByReference
;
public
abstract
class
BaseEventProcessor
<
T
extends
BasePosixProcess
>
implements
IEventProcessor
<
T
>
{
public
static
final
int
LINGER_TIME_MS
;
protected
static
final
int
DEADPOOL_POLL_INTERVAL
;
protected
static
final
int
LINGER_ITERATIONS
;
private
static
final
Logger
LOGGER
=
Logger
.
getLogger
(
BaseEventProcessor
.
class
.
getCanonicalName
(
)
)
;
private
final
int
lingerIterations
;
protected
Map
<
Integer
,
T
>
pidToProcessMap
;
protected
Map
<
Integer
,
T
>
fildesToProcessMap
;
protected
volatile
boolean
shutdown
;
private
CyclicBarrier
startBarrier
;
private
AtomicBoolean
isRunning
;
static
{
LINGER_TIME_MS
=
Math
.
max
(
1000
,
Integer
.
getInteger
(
"com.zaxxer.nuprocess.lingerTimeMs"
,
2500
)
)
;
DEADPOOL_POLL_INTERVAL
=
Math
.
min
(
LINGER_TIME_MS
,
Math
.
max
(
100
,
Integer
.
getInteger
(
"com.zaxxer.nuprocess.deadPoolPollMs"
,
250
)
)
)
;
LINGER_ITERATIONS
=
LINGER_TIME_MS
/
DEADPOOL_POLL_INTERVAL
;
}
public
BaseEventProcessor
(
)
{
this
(
LINGER_ITERATIONS
)
;
}
public
BaseEventProcessor
(
int
lingerIterations
)
{
this
.
lingerIterations
=
lingerIterations
;
pidToProcessMap
=
new
ConcurrentHashMap
<
Integer
,
T
>
(
)
;
fildesToProcessMap
=
new
ConcurrentHashMap
<
Integer
,
T
>
(
)
;
isRunning
=
new
AtomicBoolean
(
)
;
}
@
Override
public
void
run
(
)
{
try
{
if
(
startBarrier
!=
null
)
{
startBarrier
.
await
(
)
;
}
int
idleCount
=
0
;
while
(
!
isRunning
.
compareAndSet
(
idleCount
>
lingerIterations
&&
pidToProcessMap
.
isEmpty
(
)
,
false
)
)
{
idleCount
=
(
!
shutdown
&&
process
(
)
)
?
0
:
(
idleCount
+
1
)
;
}
}
catch
(
Exception
e
)
{
LOGGER
.
log
(
Level
.
WARNING
,
"Aborting processing loop after unexpected exception ("
+
pidToProcessMap
.
size
(
)
+
" processes running)"
,
e
)
;
isRunning
.
set
(
false
)
;
}
finally
{
if
(
startBarrier
==
null
)
{
close
(
)
;
}
}
}
@
Override
public
CyclicBarrier
getSpawnBarrier
(
)
{
startBarrier
=
new
CyclicBarrier
(
2
)
;
return
startBarrier
;
}
@
Override
public
boolean
checkAndSetRunning
(
)
{
return
isRunning
.
compareAndSet
(
false
,
true
)
;
}
@
Override
public
void
shutdown
(
)
{
shutdown
=
true
;
Collection
<
T
>
processes
=
pidToProcessMap
.
values
(
)
;
IntByReference
exitCode
=
new
IntByReference
(
)
;
for
(
T
process
:
processes
)
{
LibC
.
kill
(
process
.
getPid
(
)
,
LibC
.
SIGTERM
)
;
process
.
onExit
(
Integer
.
MAX_VALUE
-
1
)
;
LibC
.
waitpid
(
process
.
getPid
(
)
,
exitCode
,
LibC
.
WNOHANG
)
;
}
}
protected
abstract
void
close
(
)
;
}
<EOF>
