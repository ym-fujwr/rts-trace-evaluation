package
org
.
apache
.
commons
.
jxpath
.
ri
.
axes
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Iterator
;
import
org
.
apache
.
commons
.
jxpath
.
BasicNodeSet
;
import
org
.
apache
.
commons
.
jxpath
.
Pointer
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
EvalContext
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
model
.
NodePointer
;
public
class
UnionContext
extends
NodeSetContext
{
private
final
EvalContext
[
]
contexts
;
private
boolean
prepared
;
public
UnionContext
(
final
EvalContext
parentContext
,
final
EvalContext
[
]
contexts
)
{
super
(
parentContext
,
new
BasicNodeSet
(
)
)
;
this
.
contexts
=
contexts
;
}
@
Override
public
int
getDocumentOrder
(
)
{
return
contexts
.
length
>
1
?
1
:
super
.
getDocumentOrder
(
)
;
}
@
Override
public
boolean
setPosition
(
final
int
position
)
{
if
(
!
prepared
)
{
prepared
=
true
;
final
BasicNodeSet
nodeSet
=
(
BasicNodeSet
)
getNodeSet
(
)
;
final
ArrayList
pointers
=
new
ArrayList
(
)
;
for
(
final
EvalContext
ctx
:
contexts
)
{
while
(
ctx
.
nextSet
(
)
)
{
while
(
ctx
.
nextNode
(
)
)
{
final
NodePointer
ptr
=
ctx
.
getCurrentNodePointer
(
)
;
if
(
!
pointers
.
contains
(
ptr
)
)
{
pointers
.
add
(
ptr
)
;
}
}
}
}
sortPointers
(
pointers
)
;
for
(
final
Iterator
it
=
pointers
.
iterator
(
)
;
it
.
hasNext
(
)
;
)
{
nodeSet
.
add
(
(
Pointer
)
it
.
next
(
)
)
;
}
}
return
super
.
setPosition
(
position
)
;
}
}
<EOF>
