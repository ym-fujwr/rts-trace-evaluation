package
org
.
apache
.
commons
.
jxpath
.
ri
.
compiler
;
import
java
.
util
.
Collection
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
Iterator
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
EvalContext
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
InfoSetUtil
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
axes
.
InitialContext
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
axes
.
SelfContext
;
public
abstract
class
CoreOperationRelationalExpression
extends
CoreOperation
{
protected
CoreOperationRelationalExpression
(
Expression
[
]
args
)
{
super
(
args
)
;
}
public
final
Object
computeValue
(
EvalContext
context
)
{
return
compute
(
args
[
0
]
.
compute
(
context
)
,
args
[
1
]
.
compute
(
context
)
)
?
Boolean
.
TRUE
:
Boolean
.
FALSE
;
}
protected
final
int
getPrecedence
(
)
{
return
RELATIONAL_EXPR_PRECEDENCE
;
}
protected
final
boolean
isSymmetric
(
)
{
return
false
;
}
protected
abstract
boolean
evaluateCompare
(
int
compare
)
;
private
boolean
compute
(
Object
left
,
Object
right
)
{
left
=
reduce
(
left
)
;
right
=
reduce
(
right
)
;
if
(
left
instanceof
InitialContext
)
{
(
(
InitialContext
)
left
)
.
reset
(
)
;
}
if
(
right
instanceof
InitialContext
)
{
(
(
InitialContext
)
right
)
.
reset
(
)
;
}
if
(
left
instanceof
Iterator
&&
right
instanceof
Iterator
)
{
return
findMatch
(
(
Iterator
)
left
,
(
Iterator
)
right
)
;
}
if
(
left
instanceof
Iterator
)
{
return
containsMatch
(
(
Iterator
)
left
,
right
)
;
}
if
(
right
instanceof
Iterator
)
{
return
containsMatch
(
left
,
(
Iterator
)
right
)
;
}
double
ld
=
InfoSetUtil
.
doubleValue
(
left
)
;
if
(
Double
.
isNaN
(
ld
)
)
{
return
false
;
}
double
rd
=
InfoSetUtil
.
doubleValue
(
right
)
;
if
(
Double
.
isNaN
(
rd
)
)
{
return
false
;
}
return
evaluateCompare
(
ld
==
rd
?
0
:
ld
<
rd
?
-
1
:
1
)
;
}
private
Object
reduce
(
Object
o
)
{
if
(
o
instanceof
SelfContext
)
{
o
=
(
(
EvalContext
)
o
)
.
getSingleNodePointer
(
)
;
}
if
(
o
instanceof
Collection
)
{
o
=
(
(
Collection
)
o
)
.
iterator
(
)
;
}
return
o
;
}
private
boolean
containsMatch
(
Iterator
it
,
Object
value
)
{
while
(
it
.
hasNext
(
)
)
{
Object
element
=
it
.
next
(
)
;
if
(
compute
(
element
,
value
)
)
{
return
true
;
}
}
return
false
;
}
private
boolean
containsMatch
(
Object
value
,
Iterator
it
)
{
while
(
it
.
hasNext
(
)
)
{
Object
element
=
it
.
next
(
)
;
if
(
compute
(
value
,
element
)
)
{
return
true
;
}
}
return
false
;
}
private
boolean
findMatch
(
Iterator
lit
,
Iterator
rit
)
{
HashSet
left
=
new
HashSet
(
)
;
while
(
lit
.
hasNext
(
)
)
{
left
.
add
(
lit
.
next
(
)
)
;
}
while
(
rit
.
hasNext
(
)
)
{
if
(
containsMatch
(
left
.
iterator
(
)
,
rit
.
next
(
)
)
)
{
return
true
;
}
}
return
false
;
}
}
<EOF>
