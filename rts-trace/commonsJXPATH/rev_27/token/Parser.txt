package
org
.
apache
.
commons
.
jxpath
.
ri
;
import
java
.
io
.
StringReader
;
import
org
.
apache
.
commons
.
jxpath
.
JXPathInvalidSyntaxException
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
parser
.
ParseException
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
parser
.
TokenMgrError
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
parser
.
XPathParser
;
public
class
Parser
{
private
static
final
XPathParser
PARSER
=
new
XPathParser
(
new
StringReader
(
""
)
)
;
public
static
Object
parseExpression
(
String
expression
,
Compiler
compiler
)
{
synchronized
(
PARSER
)
{
PARSER
.
setCompiler
(
compiler
)
;
Object
expr
;
try
{
PARSER
.
ReInit
(
new
StringReader
(
expression
)
)
;
expr
=
PARSER
.
parseExpression
(
)
;
}
catch
(
TokenMgrError
e
)
{
throw
new
JXPathInvalidSyntaxException
(
"Invalid XPath: '"
+
addEscapes
(
expression
)
+
"'. Invalid symbol '"
+
addEscapes
(
String
.
valueOf
(
e
.
getCharacter
(
)
)
)
+
"' "
+
describePosition
(
expression
,
e
.
getPosition
(
)
)
)
;
}
catch
(
ParseException
e
)
{
throw
new
JXPathInvalidSyntaxException
(
"Invalid XPath: '"
+
addEscapes
(
expression
)
+
"'. Syntax error "
+
describePosition
(
expression
,
e
.
currentToken
.
beginColumn
)
)
;
}
return
expr
;
}
}
private
static
String
describePosition
(
String
expression
,
int
position
)
{
if
(
position
<=
0
)
{
return
"at the beginning of the expression"
;
}
if
(
position
>=
expression
.
length
(
)
)
{
return
"- expression incomplete"
;
}
return
"after: '"
+
addEscapes
(
expression
.
substring
(
0
,
position
)
)
+
"'"
;
}
private
static
String
addEscapes
(
String
string
)
{
return
TokenMgrError
.
addEscapes
(
string
)
;
}
}
<EOF>
