package
org
.
apache
.
commons
.
jxpath
.
ri
.
model
.
beans
;
import
org
.
apache
.
commons
.
jxpath
.
AbstractFactory
;
import
org
.
apache
.
commons
.
jxpath
.
JXPathAbstractFactoryException
;
import
org
.
apache
.
commons
.
jxpath
.
JXPathContext
;
import
org
.
apache
.
commons
.
jxpath
.
JXPathIntrospector
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
QName
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
model
.
NodePointer
;
import
org
.
apache
.
commons
.
jxpath
.
util
.
ValueUtils
;
public
abstract
class
PropertyPointer
extends
NodePointer
{
private
static
final
long
serialVersionUID
=
1L
;
public
static
final
int
UNSPECIFIED_PROPERTY
=
Integer
.
MIN_VALUE
;
protected
int
propertyIndex
=
UNSPECIFIED_PROPERTY
;
protected
Object
bean
;
public
PropertyPointer
(
final
NodePointer
parent
)
{
super
(
parent
)
;
}
public
int
getPropertyIndex
(
)
{
return
propertyIndex
;
}
public
void
setPropertyIndex
(
final
int
index
)
{
if
(
propertyIndex
!=
index
)
{
propertyIndex
=
index
;
setIndex
(
WHOLE_COLLECTION
)
;
}
}
public
Object
getBean
(
)
{
if
(
bean
==
null
)
{
bean
=
getImmediateParentPointer
(
)
.
getNode
(
)
;
}
return
bean
;
}
@
Override
public
QName
getName
(
)
{
return
new
QName
(
null
,
getPropertyName
(
)
)
;
}
public
abstract
String
getPropertyName
(
)
;
public
abstract
void
setPropertyName
(
String
propertyName
)
;
public
abstract
int
getPropertyCount
(
)
;
public
abstract
String
[
]
getPropertyNames
(
)
;
protected
abstract
boolean
isActualProperty
(
)
;
@
Override
public
boolean
isActual
(
)
{
if
(
!
isActualProperty
(
)
)
{
return
false
;
}
return
super
.
isActual
(
)
;
}
private
static
final
Object
UNINITIALIZED
=
new
Object
(
)
;
private
Object
value
=
UNINITIALIZED
;
@
Override
public
Object
getImmediateNode
(
)
{
if
(
value
==
UNINITIALIZED
)
{
value
=
index
==
WHOLE_COLLECTION
?
ValueUtils
.
getValue
(
getBaseValue
(
)
)
:
ValueUtils
.
getValue
(
getBaseValue
(
)
,
index
)
;
}
return
value
;
}
@
Override
public
boolean
isCollection
(
)
{
final
Object
value
=
getBaseValue
(
)
;
return
value
!=
null
&&
ValueUtils
.
isCollection
(
value
)
;
}
@
Override
public
boolean
isLeaf
(
)
{
final
Object
value
=
getNode
(
)
;
return
value
==
null
||
JXPathIntrospector
.
getBeanInfo
(
value
.
getClass
(
)
)
.
isAtomic
(
)
;
}
@
Override
public
int
getLength
(
)
{
final
Object
baseValue
=
getBaseValue
(
)
;
return
baseValue
==
null
?
1
:
ValueUtils
.
getLength
(
baseValue
)
;
}
@
Override
public
NodePointer
getImmediateValuePointer
(
)
{
return
NodePointer
.
newChildNodePointer
(
(
NodePointer
)
this
.
clone
(
)
,
getName
(
)
,
getImmediateNode
(
)
)
;
}
@
Override
public
NodePointer
createPath
(
final
JXPathContext
context
)
{
if
(
getImmediateNode
(
)
==
null
)
{
final
AbstractFactory
factory
=
getAbstractFactory
(
context
)
;
final
int
inx
=
index
==
WHOLE_COLLECTION
?
0
:
index
;
final
boolean
success
=
factory
.
createObject
(
context
,
this
,
getBean
(
)
,
getPropertyName
(
)
,
inx
)
;
if
(
!
success
)
{
throw
new
JXPathAbstractFactoryException
(
"Factory "
+
factory
+
" could not create an object for path: "
+
asPath
(
)
)
;
}
}
return
this
;
}
@
Override
public
NodePointer
createPath
(
final
JXPathContext
context
,
final
Object
value
)
{
if
(
index
!=
WHOLE_COLLECTION
&&
index
>=
getLength
(
)
)
{
createPath
(
context
)
;
}
setValue
(
value
)
;
return
this
;
}
@
Override
public
NodePointer
createChild
(
final
JXPathContext
context
,
final
QName
name
,
final
int
index
,
final
Object
value
)
{
final
PropertyPointer
prop
=
(
PropertyPointer
)
clone
(
)
;
if
(
name
!=
null
)
{
prop
.
setPropertyName
(
name
.
toString
(
)
)
;
}
prop
.
setIndex
(
index
)
;
return
prop
.
createPath
(
context
,
value
)
;
}
@
Override
public
NodePointer
createChild
(
final
JXPathContext
context
,
final
QName
name
,
final
int
index
)
{
final
PropertyPointer
prop
=
(
PropertyPointer
)
clone
(
)
;
if
(
name
!=
null
)
{
prop
.
setPropertyName
(
name
.
toString
(
)
)
;
}
prop
.
setIndex
(
index
)
;
return
prop
.
createPath
(
context
)
;
}
@
Override
public
int
hashCode
(
)
{
return
getImmediateParentPointer
(
)
.
hashCode
(
)
+
propertyIndex
+
index
;
}
@
Override
public
boolean
equals
(
final
Object
object
)
{
if
(
object
==
this
)
{
return
true
;
}
if
(
!
(
object
instanceof
PropertyPointer
)
)
{
return
false
;
}
final
PropertyPointer
other
=
(
PropertyPointer
)
object
;
if
(
parent
!=
other
.
parent
&&
(
parent
==
null
||
!
parent
.
equals
(
other
.
parent
)
)
)
{
return
false
;
}
if
(
getPropertyIndex
(
)
!=
other
.
getPropertyIndex
(
)
||
!
getPropertyName
(
)
.
equals
(
other
.
getPropertyName
(
)
)
)
{
return
false
;
}
final
int
iThis
=
index
==
WHOLE_COLLECTION
?
0
:
index
;
final
int
iOther
=
other
.
index
==
WHOLE_COLLECTION
?
0
:
other
.
index
;
return
iThis
==
iOther
;
}
@
Override
public
int
compareChildNodePointers
(
final
NodePointer
pointer1
,
final
NodePointer
pointer2
)
{
return
getValuePointer
(
)
.
compareChildNodePointers
(
pointer1
,
pointer2
)
;
}
}
<EOF>
