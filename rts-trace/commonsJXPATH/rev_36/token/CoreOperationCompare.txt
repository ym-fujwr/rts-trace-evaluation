package
org
.
apache
.
commons
.
jxpath
.
ri
.
compiler
;
import
java
.
util
.
Collection
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
Iterator
;
import
org
.
apache
.
commons
.
jxpath
.
Pointer
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
EvalContext
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
InfoSetUtil
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
axes
.
InitialContext
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
axes
.
SelfContext
;
public
abstract
class
CoreOperationCompare
extends
CoreOperation
{
private
final
boolean
invert
;
public
CoreOperationCompare
(
final
Expression
arg1
,
final
Expression
arg2
)
{
this
(
arg1
,
arg2
,
false
)
;
}
protected
CoreOperationCompare
(
final
Expression
arg1
,
final
Expression
arg2
,
final
boolean
invert
)
{
super
(
new
Expression
[
]
{
arg1
,
arg2
}
)
;
this
.
invert
=
invert
;
}
@
Override
public
Object
computeValue
(
final
EvalContext
context
)
{
return
equal
(
context
,
args
[
0
]
,
args
[
1
]
)
?
Boolean
.
TRUE
:
Boolean
.
FALSE
;
}
@
Override
protected
int
getPrecedence
(
)
{
return
COMPARE_PRECEDENCE
;
}
@
Override
protected
boolean
isSymmetric
(
)
{
return
true
;
}
protected
boolean
equal
(
final
EvalContext
context
,
final
Expression
left
,
final
Expression
right
)
{
Object
l
=
left
.
compute
(
context
)
;
Object
r
=
right
.
compute
(
context
)
;
if
(
l
instanceof
InitialContext
)
{
(
(
EvalContext
)
l
)
.
reset
(
)
;
}
if
(
l
instanceof
SelfContext
)
{
l
=
(
(
EvalContext
)
l
)
.
getSingleNodePointer
(
)
;
}
if
(
r
instanceof
InitialContext
)
{
(
(
EvalContext
)
r
)
.
reset
(
)
;
}
if
(
r
instanceof
SelfContext
)
{
r
=
(
(
EvalContext
)
r
)
.
getSingleNodePointer
(
)
;
}
if
(
l
instanceof
Collection
)
{
l
=
(
(
Collection
)
l
)
.
iterator
(
)
;
}
if
(
r
instanceof
Collection
)
{
r
=
(
(
Collection
)
r
)
.
iterator
(
)
;
}
if
(
l
instanceof
Iterator
&&
r
instanceof
Iterator
)
{
return
findMatch
(
(
Iterator
)
l
,
(
Iterator
)
r
)
;
}
if
(
l
instanceof
Iterator
)
{
return
contains
(
(
Iterator
)
l
,
r
)
;
}
if
(
r
instanceof
Iterator
)
{
return
contains
(
(
Iterator
)
r
,
l
)
;
}
return
equal
(
l
,
r
)
;
}
protected
boolean
contains
(
final
Iterator
it
,
final
Object
value
)
{
while
(
it
.
hasNext
(
)
)
{
final
Object
element
=
it
.
next
(
)
;
if
(
equal
(
element
,
value
)
)
{
return
true
;
}
}
return
false
;
}
protected
boolean
findMatch
(
final
Iterator
lit
,
final
Iterator
rit
)
{
final
HashSet
left
=
new
HashSet
(
)
;
while
(
lit
.
hasNext
(
)
)
{
left
.
add
(
lit
.
next
(
)
)
;
}
while
(
rit
.
hasNext
(
)
)
{
if
(
contains
(
left
.
iterator
(
)
,
rit
.
next
(
)
)
)
{
return
true
;
}
}
return
false
;
}
protected
boolean
equal
(
Object
l
,
Object
r
)
{
if
(
l
instanceof
Pointer
)
{
l
=
(
(
Pointer
)
l
)
.
getValue
(
)
;
}
if
(
r
instanceof
Pointer
)
{
r
=
(
(
Pointer
)
r
)
.
getValue
(
)
;
}
boolean
result
;
if
(
l
instanceof
Boolean
||
r
instanceof
Boolean
)
{
result
=
l
==
r
||
InfoSetUtil
.
booleanValue
(
l
)
==
InfoSetUtil
.
booleanValue
(
r
)
;
}
else
if
(
l
instanceof
Number
||
r
instanceof
Number
)
{
final
double
ld
=
InfoSetUtil
.
doubleValue
(
l
)
;
if
(
Double
.
isNaN
(
ld
)
)
{
return
false
;
}
final
double
rd
=
InfoSetUtil
.
doubleValue
(
r
)
;
if
(
Double
.
isNaN
(
rd
)
)
{
return
false
;
}
result
=
ld
==
rd
;
}
else
{
if
(
l
instanceof
String
||
r
instanceof
String
)
{
l
=
InfoSetUtil
.
stringValue
(
l
)
;
r
=
InfoSetUtil
.
stringValue
(
r
)
;
}
result
=
l
==
r
||
l
!=
null
&&
l
.
equals
(
r
)
;
}
return
result
^
invert
;
}
}
<EOF>
