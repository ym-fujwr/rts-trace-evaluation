package
org
.
apache
.
commons
.
jxpath
.
ri
.
axes
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Collections
;
import
java
.
util
.
List
;
import
org
.
apache
.
commons
.
jxpath
.
JXPathException
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
Compiler
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
EvalContext
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
InfoSetUtil
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
QName
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
compiler
.
Expression
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
compiler
.
NameAttributeTest
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
compiler
.
NodeNameTest
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
compiler
.
NodeTest
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
compiler
.
Step
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
model
.
NodeIterator
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
model
.
NodePointer
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
model
.
beans
.
LangAttributePointer
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
model
.
beans
.
NullElementPointer
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
model
.
beans
.
NullPropertyPointer
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
model
.
beans
.
PropertyOwnerPointer
;
import
org
.
apache
.
commons
.
jxpath
.
ri
.
model
.
beans
.
PropertyPointer
;
public
class
SimplePathInterpreter
{
private
static
final
QName
QNAME_NAME
=
new
QName
(
null
,
"name"
)
;
private
static
final
int
PERFECT_MATCH
=
1000
;
public
static
NodePointer
interpretSimpleLocationPath
(
EvalContext
context
,
NodePointer
root
,
Step
[
]
steps
)
{
NodePointer
pointer
=
doStep
(
context
,
root
,
steps
,
0
)
;
return
pointer
;
}
public
static
NodePointer
interpretSimpleExpressionPath
(
EvalContext
context
,
NodePointer
root
,
Expression
[
]
predicates
,
Step
[
]
steps
)
{
NodePointer
pointer
=
doPredicate
(
context
,
root
,
steps
,
-
1
,
predicates
,
0
)
;
return
pointer
;
}
private
static
NodePointer
doStep
(
EvalContext
context
,
NodePointer
parent
,
Step
[
]
steps
,
int
currentStep
)
{
if
(
parent
==
null
)
{
return
null
;
}
if
(
currentStep
==
steps
.
length
)
{
return
parent
;
}
parent
=
valuePointer
(
parent
)
;
Step
step
=
steps
[
currentStep
]
;
Expression
[
]
predicates
=
step
.
getPredicates
(
)
;
if
(
parent
instanceof
PropertyOwnerPointer
)
{
if
(
predicates
==
null
||
predicates
.
length
==
0
)
{
return
doStepNoPredicatesPropertyOwner
(
context
,
(
PropertyOwnerPointer
)
parent
,
steps
,
currentStep
)
;
}
return
doStepPredicatesPropertyOwner
(
context
,
(
PropertyOwnerPointer
)
parent
,
steps
,
currentStep
)
;
}
if
(
predicates
==
null
||
predicates
.
length
==
0
)
{
return
doStepNoPredicatesStandard
(
context
,
parent
,
steps
,
currentStep
)
;
}
return
doStepPredicatesStandard
(
context
,
parent
,
steps
,
currentStep
)
;
}
private
static
NodePointer
doStepNoPredicatesPropertyOwner
(
EvalContext
context
,
PropertyOwnerPointer
parentPointer
,
Step
[
]
steps
,
int
currentStep
)
{
Step
step
=
steps
[
currentStep
]
;
NodePointer
childPointer
=
createChildPointerForStep
(
parentPointer
,
step
)
;
if
(
childPointer
==
null
)
{
return
null
;
}
if
(
!
childPointer
.
isActual
(
)
)
{
return
createNullPointer
(
context
,
parentPointer
,
steps
,
currentStep
)
;
}
if
(
currentStep
==
steps
.
length
-
1
)
{
return
childPointer
;
}
if
(
childPointer
.
isCollection
(
)
)
{
int
bestQuality
=
0
;
childPointer
=
(
NodePointer
)
childPointer
.
clone
(
)
;
NodePointer
bestMatch
=
null
;
int
count
=
childPointer
.
getLength
(
)
;
for
(
int
i
=
0
;
i
<
count
;
i
++
)
{
childPointer
.
setIndex
(
i
)
;
NodePointer
pointer
=
doStep
(
context
,
childPointer
,
steps
,
currentStep
+
1
)
;
int
quality
=
computeQuality
(
pointer
)
;
if
(
quality
==
PERFECT_MATCH
)
{
return
pointer
;
}
else
if
(
quality
>
bestQuality
)
{
bestQuality
=
quality
;
bestMatch
=
(
NodePointer
)
pointer
.
clone
(
)
;
}
}
if
(
bestMatch
!=
null
)
{
return
bestMatch
;
}
return
createNullPointer
(
context
,
childPointer
,
steps
,
currentStep
)
;
}
return
doStep
(
context
,
childPointer
,
steps
,
currentStep
+
1
)
;
}
private
static
NodePointer
doStepNoPredicatesStandard
(
EvalContext
context
,
NodePointer
parentPointer
,
Step
[
]
steps
,
int
currentStep
)
{
Step
step
=
steps
[
currentStep
]
;
if
(
step
.
getAxis
(
)
==
Compiler
.
AXIS_SELF
)
{
return
doStep
(
context
,
parentPointer
,
steps
,
currentStep
+
1
)
;
}
int
bestQuality
=
0
;
NodePointer
bestMatch
=
null
;
NodeIterator
it
=
getNodeIterator
(
context
,
parentPointer
,
step
)
;
if
(
it
!=
null
)
{
for
(
int
i
=
1
;
it
.
setPosition
(
i
)
;
i
++
)
{
NodePointer
childPointer
=
it
.
getNodePointer
(
)
;
if
(
steps
.
length
==
currentStep
+
1
)
{
return
childPointer
;
}
NodePointer
pointer
=
doStep
(
context
,
childPointer
,
steps
,
currentStep
+
1
)
;
int
quality
=
computeQuality
(
pointer
)
;
if
(
quality
==
PERFECT_MATCH
)
{
return
pointer
;
}
if
(
quality
>
bestQuality
)
{
bestQuality
=
quality
;
bestMatch
=
(
NodePointer
)
pointer
.
clone
(
)
;
}
}
}
return
bestMatch
!=
null
?
bestMatch
:
createNullPointer
(
context
,
parentPointer
,
steps
,
currentStep
)
;
}
private
static
NodePointer
doStepPredicatesPropertyOwner
(
EvalContext
context
,
PropertyOwnerPointer
parentPointer
,
Step
[
]
steps
,
int
currentStep
)
{
Step
step
=
steps
[
currentStep
]
;
Expression
[
]
predicates
=
step
.
getPredicates
(
)
;
NodePointer
childPointer
=
createChildPointerForStep
(
parentPointer
,
step
)
;
if
(
!
childPointer
.
isActual
(
)
)
{
return
createNullPointer
(
context
,
parentPointer
,
steps
,
currentStep
)
;
}
return
doPredicate
(
context
,
childPointer
,
steps
,
currentStep
,
predicates
,
0
)
;
}
private
static
NodePointer
createChildPointerForStep
(
PropertyOwnerPointer
parentPointer
,
Step
step
)
{
int
axis
=
step
.
getAxis
(
)
;
if
(
axis
==
Compiler
.
AXIS_CHILD
||
axis
==
Compiler
.
AXIS_ATTRIBUTE
)
{
QName
name
=
(
(
NodeNameTest
)
step
.
getNodeTest
(
)
)
.
getNodeName
(
)
;
if
(
axis
==
Compiler
.
AXIS_ATTRIBUTE
&&
isLangAttribute
(
name
)
)
{
return
new
LangAttributePointer
(
parentPointer
)
;
}
if
(
parentPointer
.
isValidProperty
(
name
)
)
{
NodePointer
childPointer
=
parentPointer
.
getPropertyPointer
(
)
;
(
(
PropertyPointer
)
childPointer
)
.
setPropertyName
(
name
.
toString
(
)
)
;
childPointer
.
setAttribute
(
axis
==
Compiler
.
AXIS_ATTRIBUTE
)
;
return
childPointer
;
}
return
null
;
}
return
parentPointer
;
}
private
static
NodePointer
doStepPredicatesStandard
(
EvalContext
context
,
NodePointer
parent
,
Step
[
]
steps
,
int
currentStep
)
{
Step
step
=
steps
[
currentStep
]
;
Expression
[
]
predicates
=
step
.
getPredicates
(
)
;
int
axis
=
step
.
getAxis
(
)
;
if
(
axis
==
Compiler
.
AXIS_SELF
)
{
return
doPredicate
(
context
,
parent
,
steps
,
currentStep
,
predicates
,
0
)
;
}
Expression
predicate
=
predicates
[
0
]
;
if
(
predicates
.
length
==
1
)
{
NodeIterator
it
=
getNodeIterator
(
context
,
parent
,
step
)
;
NodePointer
pointer
=
null
;
if
(
it
!=
null
)
{
if
(
predicate
instanceof
NameAttributeTest
)
{
String
key
=
keyFromPredicate
(
context
,
predicate
)
;
for
(
int
i
=
1
;
it
.
setPosition
(
i
)
;
i
++
)
{
NodePointer
ptr
=
it
.
getNodePointer
(
)
;
if
(
isNameAttributeEqual
(
ptr
,
key
)
)
{
pointer
=
ptr
;
break
;
}
}
}
else
{
int
index
=
indexFromPredicate
(
context
,
predicate
)
;
if
(
it
.
setPosition
(
index
+
1
)
)
{
pointer
=
it
.
getNodePointer
(
)
;
}
}
}
if
(
pointer
!=
null
)
{
return
doStep
(
context
,
pointer
,
steps
,
currentStep
+
1
)
;
}
}
else
{
NodeIterator
it
=
getNodeIterator
(
context
,
parent
,
step
)
;
if
(
it
!=
null
)
{
List
list
=
new
ArrayList
(
)
;
for
(
int
i
=
1
;
it
.
setPosition
(
i
)
;
i
++
)
{
list
.
add
(
it
.
getNodePointer
(
)
)
;
}
NodePointer
pointer
=
doPredicatesStandard
(
context
,
list
,
steps
,
currentStep
,
predicates
,
0
)
;
if
(
pointer
!=
null
)
{
return
pointer
;
}
}
}
return
createNullPointer
(
context
,
parent
,
steps
,
currentStep
)
;
}
private
static
NodePointer
doPredicate
(
EvalContext
context
,
NodePointer
parent
,
Step
[
]
steps
,
int
currentStep
,
Expression
[
]
predicates
,
int
currentPredicate
)
{
if
(
currentPredicate
==
predicates
.
length
)
{
return
doStep
(
context
,
parent
,
steps
,
currentStep
+
1
)
;
}
Expression
predicate
=
predicates
[
currentPredicate
]
;
if
(
predicate
instanceof
NameAttributeTest
)
{
return
doPredicateName
(
context
,
parent
,
steps
,
currentStep
,
predicates
,
currentPredicate
)
;
}
return
doPredicateIndex
(
context
,
parent
,
steps
,
currentStep
,
predicates
,
currentPredicate
)
;
}
private
static
NodePointer
doPredicateName
(
EvalContext
context
,
NodePointer
parent
,
Step
[
]
steps
,
int
currentStep
,
Expression
[
]
predicates
,
int
currentPredicate
)
{
Expression
predicate
=
predicates
[
currentPredicate
]
;
String
key
=
keyFromPredicate
(
context
,
predicate
)
;
NodePointer
child
=
valuePointer
(
parent
)
;
if
(
child
instanceof
PropertyOwnerPointer
)
{
PropertyPointer
pointer
=
(
(
PropertyOwnerPointer
)
child
)
.
getPropertyPointer
(
)
;
pointer
.
setPropertyName
(
key
)
;
if
(
pointer
.
isActual
(
)
)
{
return
doPredicate
(
context
,
pointer
,
steps
,
currentStep
,
predicates
,
currentPredicate
+
1
)
;
}
}
else
if
(
child
.
isCollection
(
)
)
{
NodePointer
bestMatch
=
null
;
int
bestQuality
=
0
;
child
=
(
NodePointer
)
child
.
clone
(
)
;
int
count
=
child
.
getLength
(
)
;
for
(
int
i
=
0
;
i
<
count
;
i
++
)
{
child
.
setIndex
(
i
)
;
NodePointer
valuePointer
=
valuePointer
(
child
)
;
NodePointer
pointer
;
if
(
(
valuePointer
instanceof
PropertyOwnerPointer
)
||
valuePointer
.
isCollection
(
)
)
{
pointer
=
doPredicateName
(
context
,
valuePointer
,
steps
,
currentStep
,
predicates
,
currentPredicate
)
;
}
else
if
(
isNameAttributeEqual
(
valuePointer
,
key
)
)
{
pointer
=
doPredicate
(
context
,
valuePointer
,
steps
,
currentStep
,
predicates
,
currentPredicate
+
1
)
;
}
else
{
pointer
=
null
;
}
if
(
pointer
!=
null
)
{
int
quality
=
computeQuality
(
pointer
)
;
if
(
quality
==
PERFECT_MATCH
)
{
return
pointer
;
}
if
(
quality
>
bestQuality
)
{
bestMatch
=
(
NodePointer
)
pointer
.
clone
(
)
;
bestQuality
=
quality
;
}
}
}
if
(
bestMatch
!=
null
)
{
return
bestMatch
;
}
}
else
{
NodePointer
found
=
doPredicatesStandard
(
context
,
Collections
.
singletonList
(
child
)
,
steps
,
currentStep
,
predicates
,
currentPredicate
)
;
if
(
found
!=
null
)
{
return
found
;
}
}
return
createNullPointerForPredicates
(
context
,
child
,
steps
,
currentStep
,
predicates
,
currentPredicate
)
;
}
private
static
NodePointer
doPredicatesStandard
(
EvalContext
context
,
List
parents
,
Step
[
]
steps
,
int
currentStep
,
Expression
[
]
predicates
,
int
currentPredicate
)
{
if
(
parents
.
size
(
)
==
0
)
{
return
null
;
}
if
(
currentPredicate
==
predicates
.
length
)
{
NodePointer
pointer
=
(
NodePointer
)
parents
.
get
(
0
)
;
return
doStep
(
context
,
pointer
,
steps
,
currentStep
+
1
)
;
}
Expression
predicate
=
predicates
[
currentPredicate
]
;
if
(
predicate
instanceof
NameAttributeTest
)
{
String
key
=
keyFromPredicate
(
context
,
predicate
)
;
List
newList
=
new
ArrayList
(
)
;
for
(
int
i
=
0
;
i
<
parents
.
size
(
)
;
i
++
)
{
NodePointer
pointer
=
(
NodePointer
)
parents
.
get
(
i
)
;
if
(
isNameAttributeEqual
(
pointer
,
key
)
)
{
newList
.
add
(
pointer
)
;
}
}
if
(
newList
.
size
(
)
==
0
)
{
return
null
;
}
return
doPredicatesStandard
(
context
,
newList
,
steps
,
currentStep
,
predicates
,
currentPredicate
+
1
)
;
}
else
{
int
index
=
indexFromPredicate
(
context
,
predicate
)
;
if
(
index
<
0
||
index
>=
parents
.
size
(
)
)
{
return
null
;
}
NodePointer
ptr
=
(
NodePointer
)
parents
.
get
(
index
)
;
return
doPredicate
(
context
,
ptr
,
steps
,
currentStep
,
predicates
,
currentPredicate
+
1
)
;
}
}
private
static
NodePointer
doPredicateIndex
(
EvalContext
context
,
NodePointer
parent
,
Step
[
]
steps
,
int
currentStep
,
Expression
[
]
predicates
,
int
currentPredicate
)
{
Expression
predicate
=
predicates
[
currentPredicate
]
;
int
index
=
indexFromPredicate
(
context
,
predicate
)
;
NodePointer
pointer
=
parent
;
if
(
isCollectionElement
(
pointer
,
index
)
)
{
pointer
=
(
NodePointer
)
pointer
.
clone
(
)
;
pointer
.
setIndex
(
index
)
;
return
doPredicate
(
context
,
pointer
,
steps
,
currentStep
,
predicates
,
currentPredicate
+
1
)
;
}
return
createNullPointerForPredicates
(
context
,
parent
,
steps
,
currentStep
,
predicates
,
currentPredicate
)
;
}
private
static
int
indexFromPredicate
(
EvalContext
context
,
Expression
predicate
)
{
Object
value
=
predicate
.
computeValue
(
context
)
;
if
(
value
instanceof
EvalContext
)
{
value
=
(
(
EvalContext
)
value
)
.
getSingleNodePointer
(
)
;
}
if
(
value
instanceof
NodePointer
)
{
value
=
(
(
NodePointer
)
value
)
.
getValue
(
)
;
}
if
(
value
==
null
)
{
throw
new
JXPathException
(
"Predicate value is null: "
+
predicate
)
;
}
if
(
value
instanceof
Number
)
{
final
double
round
=
0.5
;
return
(
int
)
(
InfoSetUtil
.
doubleValue
(
value
)
+
round
)
-
1
;
}
return
InfoSetUtil
.
booleanValue
(
value
)
?
0
:
-
1
;
}
private
static
String
keyFromPredicate
(
EvalContext
context
,
Expression
predicate
)
{
Expression
expr
=
(
(
NameAttributeTest
)
predicate
)
.
getNameTestExpression
(
)
;
return
InfoSetUtil
.
stringValue
(
expr
.
computeValue
(
context
)
)
;
}
private
static
int
computeQuality
(
NodePointer
pointer
)
{
int
quality
=
PERFECT_MATCH
;
while
(
pointer
!=
null
&&
!
pointer
.
isActual
(
)
)
{
quality
--
;
pointer
=
pointer
.
getImmediateParentPointer
(
)
;
}
return
quality
;
}
private
static
boolean
isNameAttributeEqual
(
NodePointer
pointer
,
String
name
)
{
NodeIterator
it
=
pointer
.
attributeIterator
(
QNAME_NAME
)
;
return
it
!=
null
&&
it
.
setPosition
(
1
)
&&
name
.
equals
(
it
.
getNodePointer
(
)
.
getValue
(
)
)
;
}
private
static
boolean
isCollectionElement
(
NodePointer
pointer
,
int
index
)
{
return
pointer
.
isActual
(
)
&&
(
index
==
0
||
(
pointer
.
isCollection
(
)
&&
index
>=
0
&&
index
<
pointer
.
getLength
(
)
)
)
;
}
private
static
NodePointer
valuePointer
(
NodePointer
pointer
)
{
return
pointer
==
null
?
null
:
pointer
.
getValuePointer
(
)
;
}
public
static
NodePointer
createNullPointer
(
EvalContext
context
,
NodePointer
parent
,
Step
[
]
steps
,
int
currentStep
)
{
if
(
currentStep
==
steps
.
length
)
{
return
parent
;
}
parent
=
valuePointer
(
parent
)
;
Step
step
=
steps
[
currentStep
]
;
int
axis
=
step
.
getAxis
(
)
;
if
(
axis
==
Compiler
.
AXIS_CHILD
||
axis
==
Compiler
.
AXIS_ATTRIBUTE
)
{
NullPropertyPointer
pointer
=
new
NullPropertyPointer
(
parent
)
;
QName
name
=
(
(
NodeNameTest
)
step
.
getNodeTest
(
)
)
.
getNodeName
(
)
;
pointer
.
setPropertyName
(
name
.
toString
(
)
)
;
pointer
.
setAttribute
(
axis
==
Compiler
.
AXIS_ATTRIBUTE
)
;
parent
=
pointer
;
}
Expression
[
]
predicates
=
step
.
getPredicates
(
)
;
return
createNullPointerForPredicates
(
context
,
parent
,
steps
,
currentStep
,
predicates
,
0
)
;
}
private
static
NodePointer
createNullPointerForPredicates
(
EvalContext
context
,
NodePointer
parent
,
Step
[
]
steps
,
int
currentStep
,
Expression
[
]
predicates
,
int
currentPredicate
)
{
for
(
int
i
=
currentPredicate
;
i
<
predicates
.
length
;
i
++
)
{
Expression
predicate
=
predicates
[
i
]
;
if
(
predicate
instanceof
NameAttributeTest
)
{
String
key
=
keyFromPredicate
(
context
,
predicate
)
;
parent
=
valuePointer
(
parent
)
;
NullPropertyPointer
pointer
=
new
NullPropertyPointer
(
parent
)
;
pointer
.
setNameAttributeValue
(
key
)
;
parent
=
pointer
;
}
else
{
int
index
=
indexFromPredicate
(
context
,
predicate
)
;
if
(
parent
instanceof
NullPropertyPointer
)
{
parent
.
setIndex
(
index
)
;
}
else
{
parent
=
new
NullElementPointer
(
parent
,
index
)
;
}
}
}
return
createNullPointer
(
context
,
parent
,
steps
,
currentStep
+
1
)
;
}
private
static
NodeIterator
getNodeIterator
(
EvalContext
context
,
NodePointer
pointer
,
Step
step
)
{
if
(
step
.
getAxis
(
)
==
Compiler
.
AXIS_CHILD
)
{
NodeTest
nodeTest
=
step
.
getNodeTest
(
)
;
QName
qname
=
(
(
NodeNameTest
)
nodeTest
)
.
getNodeName
(
)
;
String
prefix
=
qname
.
getPrefix
(
)
;
if
(
prefix
!=
null
)
{
String
namespaceURI
=
context
.
getJXPathContext
(
)
.
getNamespaceURI
(
prefix
)
;
nodeTest
=
new
NodeNameTest
(
qname
,
namespaceURI
)
;
}
return
pointer
.
childIterator
(
nodeTest
,
false
,
null
)
;
}
if
(
!
(
step
.
getNodeTest
(
)
instanceof
NodeNameTest
)
)
{
throw
new
UnsupportedOperationException
(
"Not supported node test for attributes: "
+
step
.
getNodeTest
(
)
)
;
}
return
pointer
.
attributeIterator
(
(
(
NodeNameTest
)
step
.
getNodeTest
(
)
)
.
getNodeName
(
)
)
;
}
private
static
boolean
isLangAttribute
(
QName
name
)
{
return
name
.
getPrefix
(
)
!=
null
&&
name
.
getPrefix
(
)
.
equals
(
"xml"
)
&&
name
.
getName
(
)
.
equals
(
"lang"
)
;
}
}
<EOF>
