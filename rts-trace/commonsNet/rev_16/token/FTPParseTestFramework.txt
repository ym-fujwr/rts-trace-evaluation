package
org
.
apache
.
commons
.
net
.
ftp
.
parser
;
import
java
.
text
.
SimpleDateFormat
;
import
java
.
time
.
Instant
;
import
java
.
util
.
Calendar
;
import
java
.
util
.
Locale
;
import
org
.
apache
.
commons
.
net
.
ftp
.
FTPFile
;
import
org
.
apache
.
commons
.
net
.
ftp
.
FTPFileEntryParser
;
import
junit
.
framework
.
TestCase
;
public
abstract
class
FTPParseTestFramework
extends
TestCase
{
protected
enum
CalendarUnit
{
MILLISECOND
(
Calendar
.
MILLISECOND
)
,
SECOND
(
Calendar
.
SECOND
)
,
MINUTE
(
Calendar
.
MINUTE
)
,
HOUR_OF_DAY
(
Calendar
.
HOUR_OF_DAY
)
,
DAY_OF_MONTH
(
Calendar
.
DAY_OF_MONTH
)
,
MONTH
(
Calendar
.
MONTH
)
,
YEAR
(
Calendar
.
YEAR
)
;
final
int
unit
;
CalendarUnit
(
final
int
calUnit
)
{
unit
=
calUnit
;
}
}
private
FTPFileEntryParser
parser
;
protected
SimpleDateFormat
df
;
public
FTPParseTestFramework
(
final
String
name
)
{
super
(
name
)
;
}
protected
void
doAdditionalBadTests
(
final
String
test
,
final
FTPFile
f
)
{
}
protected
void
doAdditionalGoodTests
(
final
String
test
,
final
FTPFile
f
)
{
}
protected
abstract
String
[
]
getBadListing
(
)
;
protected
abstract
String
[
]
getGoodListing
(
)
;
protected
abstract
FTPFileEntryParser
getParser
(
)
;
protected
FTPFile
nullFileOrNullDate
(
final
FTPFile
f
)
{
if
(
f
==
null
)
{
return
null
;
}
if
(
f
.
getTimestamp
(
)
==
null
)
{
return
null
;
}
return
f
;
}
@
Override
protected
void
setUp
(
)
throws
Exception
{
super
.
setUp
(
)
;
parser
=
getParser
(
)
;
df
=
new
SimpleDateFormat
(
"EEE MMM dd HH:mm:ss yyyy"
,
Locale
.
US
)
;
}
public
void
testBadListing
(
)
{
final
String
[
]
badsamples
=
getBadListing
(
)
;
for
(
final
String
test
:
badsamples
)
{
final
FTPFile
f
=
parser
.
parseFTPEntry
(
test
)
;
assertNull
(
"Should have Failed to parse <"
+
test
+
">"
,
nullFileOrNullDate
(
f
)
)
;
doAdditionalBadTests
(
test
,
f
)
;
}
}
public
abstract
void
testDefaultPrecision
(
)
;
public
void
testGoodListing
(
)
{
final
String
[
]
goodsamples
=
getGoodListing
(
)
;
for
(
final
String
test
:
goodsamples
)
{
final
FTPFile
f
=
parser
.
parseFTPEntry
(
test
)
;
assertNotNull
(
"Failed to parse "
+
test
,
f
)
;
doAdditionalGoodTests
(
test
,
f
)
;
}
}
public
abstract
void
testParseFieldsOnDirectory
(
)
throws
Exception
;
public
abstract
void
testParseFieldsOnFile
(
)
throws
Exception
;
protected
void
testPrecision
(
final
String
listEntry
,
final
CalendarUnit
expectedPrecision
)
{
final
FTPFile
file
=
getParser
(
)
.
parseFTPEntry
(
listEntry
)
;
assertNotNull
(
"Could not parse "
+
listEntry
,
file
)
;
final
Calendar
stamp
=
file
.
getTimestamp
(
)
;
assertNotNull
(
"Failed to parse time in "
+
listEntry
,
stamp
)
;
final
Instant
instant
=
file
.
getTimestampInstant
(
)
;
assertNotNull
(
"Failed to parse time in "
+
listEntry
,
instant
)
;
final
int
ordinal
=
expectedPrecision
.
ordinal
(
)
;
final
CalendarUnit
[
]
values
=
CalendarUnit
.
values
(
)
;
for
(
int
i
=
ordinal
;
i
<
values
.
length
;
i
++
)
{
final
CalendarUnit
unit
=
values
[
i
]
;
assertTrue
(
"Expected set "
+
unit
+
" in "
+
listEntry
,
stamp
.
isSet
(
unit
.
unit
)
)
;
}
if
(
ordinal
>
0
)
{
final
CalendarUnit
prevUnit
=
values
[
ordinal
-
1
]
;
assertFalse
(
"Expected not set "
+
prevUnit
+
" in "
+
listEntry
,
stamp
.
isSet
(
prevUnit
.
unit
)
)
;
}
}
public
abstract
void
testRecentPrecision
(
)
;
}
<EOF>
