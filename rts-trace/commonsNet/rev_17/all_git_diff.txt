diff --git a/.github/workflows/codeql-analysis.yml b/.github/workflows/codeql-analysis.yml
index 290246808..87325a9f5 100644
--- a/.github/workflows/codeql-analysis.yml
+++ b/.github/workflows/codeql-analysis.yml
@@ -1,80 +1,80 @@
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the "License"); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-name: "CodeQL"
-
-on:
-  push:
-    branches: [ master ]
-  pull_request:
-    # The branches below must be a subset of the branches above
-    branches: [ master ]
-  schedule:
-    - cron: '33 9 * * 4'
-
-jobs:
-  analyze:
-    name: Analyze
-    runs-on: ubuntu-latest
-    permissions:
-      actions: read
-      contents: read
-      security-events: write
-
-    strategy:
-      fail-fast: false
-      matrix:
-        language: [ 'java' ]
-        # CodeQL supports [ 'cpp', 'csharp', 'go', 'java', 'javascript', 'python', 'ruby' ]
-        # Learn more about CodeQL language support at https://git.io/codeql-language-support
-
-    steps:
-    - name: Checkout repository
-      uses: actions/checkout@v3.0.2
-    - uses: actions/cache@v3.0.8
-      with:
-        path: ~/.m2/repository
-        key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
-        restore-keys: |
-          ${{ runner.os }}-maven-
-
-    # Initializes the CodeQL tools for scanning.
-    - name: Initialize CodeQL
-      uses: github/codeql-action/init@v2
-      with:
-        languages: ${{ matrix.language }}
-        # If you wish to specify custom queries, you can do so here or in a config file.
-        # By default, queries listed here will override any specified in a config file.
-        # Prefix the list here with "+" to use these queries and those in the config file.
-        # queries: ./path/to/local/query, your-org/your-repo/queries@main
-
-    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).
-    # If this step fails, then you should remove it and run the build manually (see below)
-    - name: Autobuild
-      uses: github/codeql-action/autobuild@v2
-
-    # ‚ÑπÔ∏è Command-line programs to run using the OS shell.
-    # üìö https://git.io/JvXDl
-
-    # ‚úèÔ∏è If the Autobuild fails above, remove it and uncomment the following three lines
-    #    and modify them (or add more) to build your code if your project
-    #    uses a compiled language
-
-    #- run: |
-    #   make bootstrap
-    #   make release
-
-    - name: Perform CodeQL Analysis
-      uses: github/codeql-action/analyze@v2
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+name: "CodeQL"
+
+on:
+  push:
+    branches: [ master ]
+  pull_request:
+    # The branches below must be a subset of the branches above
+    branches: [ master ]
+  schedule:
+    - cron: '33 9 * * 4'
+
+jobs:
+  analyze:
+    name: Analyze
+    runs-on: ubuntu-latest
+    permissions:
+      actions: read
+      contents: read
+      security-events: write
+
+    strategy:
+      fail-fast: false
+      matrix:
+        language: [ 'java' ]
+        # CodeQL supports [ 'cpp', 'csharp', 'go', 'java', 'javascript', 'python', 'ruby' ]
+        # Learn more about CodeQL language support at https://git.io/codeql-language-support
+
+    steps:
+    - name: Checkout repository
+      uses: actions/checkout@v3.0.2
+    - uses: actions/cache@v3.0.8
+      with:
+        path: ~/.m2/repository
+        key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
+        restore-keys: |
+          ${{ runner.os }}-maven-
+
+    # Initializes the CodeQL tools for scanning.
+    - name: Initialize CodeQL
+      uses: github/codeql-action/init@v2
+      with:
+        languages: ${{ matrix.language }}
+        # If you wish to specify custom queries, you can do so here or in a config file.
+        # By default, queries listed here will override any specified in a config file.
+        # Prefix the list here with "+" to use these queries and those in the config file.
+        # queries: ./path/to/local/query, your-org/your-repo/queries@main
+
+    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).
+    # If this step fails, then you should remove it and run the build manually (see below)
+    - name: Autobuild
+      uses: github/codeql-action/autobuild@v2
+
+    # ‚ÑπÔ∏è Command-line programs to run using the OS shell.
+    # üìö https://git.io/JvXDl
+
+    # ‚úèÔ∏è If the Autobuild fails above, remove it and uncomment the following three lines
+    #    and modify them (or add more) to build your code if your project
+    #    uses a compiled language
+
+    #- run: |
+    #   make bootstrap
+    #   make release
+
+    - name: Perform CodeQL Analysis
+      uses: github/codeql-action/analyze@v2
diff --git a/.github/workflows/maven.yml b/.github/workflows/maven.yml
index 9f923fac2..2af8eb225 100644
--- a/.github/workflows/maven.yml
+++ b/.github/workflows/maven.yml
@@ -1,57 +1,57 @@
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the "License"); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-name: Java CI
-
-on: [push, pull_request, workflow_dispatch]
-
-jobs:
-  build:
-    timeout-minutes: 7
-    continue-on-error: ${{ matrix.experimental }}
-    strategy:
-      matrix:
-        java: [ 8, 11, 17 ]
-        os: [ubuntu-latest]
-        experimental: [false]
-        # Don't need 
-        include:
-          - java: 8
-            os: macos-latest
-            experimental: false
-          - java: 8
-            os: windows-latest
-            experimental: false
-#        include:
-#          - java: 18-ea
-#            experimental: true        
-
-    runs-on: ${{ matrix.os }}
-    steps:
-    - uses: actions/checkout@v3.0.2
-    - uses: actions/cache@v3.0.8
-      with:
-        path: ~/.m2/repository
-        key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
-        restore-keys: |
-          ${{ runner.os }}-maven-
-    - name: Set up JDK ${{ matrix.java }}
-      uses: actions/setup-java@v3.5.1
-      with:
-        distribution: 'temurin'
-        java-version: ${{ matrix.java }}
-    - name: Build with Maven
-      run: mvn -V --batch-mode -Ddoclint=all --file pom.xml --no-transfer-progress
-# N.B. Add  -Pslf4j-simple to enable logging above
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+name: Java CI
+
+on: [push, pull_request, workflow_dispatch]
+
+jobs:
+  build:
+    timeout-minutes: 7
+    continue-on-error: ${{ matrix.experimental }}
+    strategy:
+      matrix:
+        java: [ 8, 11, 17 ]
+        os: [ubuntu-latest]
+        experimental: [false]
+        # Don't need 
+        include:
+          - java: 8
+            os: macos-latest
+            experimental: false
+          - java: 8
+            os: windows-latest
+            experimental: false
+#        include:
+#          - java: 18-ea
+#            experimental: true        
+
+    runs-on: ${{ matrix.os }}
+    steps:
+    - uses: actions/checkout@v3.0.2
+    - uses: actions/cache@v3.0.8
+      with:
+        path: ~/.m2/repository
+        key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
+        restore-keys: |
+          ${{ runner.os }}-maven-
+    - name: Set up JDK ${{ matrix.java }}
+      uses: actions/setup-java@v3.5.1
+      with:
+        distribution: 'temurin'
+        java-version: ${{ matrix.java }}
+    - name: Build with Maven
+      run: mvn -V --batch-mode -Ddoclint=all --file pom.xml --no-transfer-progress
+# N.B. Add  -Pslf4j-simple to enable logging above
diff --git a/README.md b/README.md
index d034f3742..c405871c8 100644
--- a/README.md
+++ b/README.md
@@ -1,107 +1,107 @@
-<!---
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<!---
- +======================================================================+
- |****                                                              ****|
- |****      THIS FILE IS GENERATED BY THE COMMONS BUILD PLUGIN      ****|
- |****                    DO NOT EDIT DIRECTLY                      ****|
- |****                                                              ****|
- +======================================================================+
- | TEMPLATE FILE: readme-md-template.md                                 |
- | commons-build-plugin/trunk/src/main/resources/commons-xdoc-templates |
- +======================================================================+
- |                                                                      |
- | 1) Re-generate using: mvn commons-build:readme-md                    |
- |                                                                      |
- | 2) Set the following properties in the component's pom:              |
- |    - commons.componentid (required, alphabetic, lower case)          |
- |    - commons.release.version (required)                              |
- |                                                                      |
- | 3) Example Properties                                                |
- |                                                                      |
- |  <properties>                                                        |
- |    <commons.componentid>math</commons.componentid>                   |
- |    <commons.release.version>1.2</commons.release.version>            |
- |  </properties>                                                       |
- |                                                                      |
- +======================================================================+
---->
-Apache Commons Net
-===================
-
-[![GitHub Actions Status](https://github.com/apache/commons-net/workflows/Java%20CI/badge.svg)](https://github.com/apache/commons-net/actions)
-[![Coverage Status](https://codecov.io/gh/apache/commons-net/branch/master/graph/badge.svg)](https://app.codecov.io/gh/apache/commons-net/branch/master)
-[![Maven Central](https://maven-badges.herokuapp.com/maven-central/commons-net/commons-net/badge.svg?gav=true)](https://maven-badges.herokuapp.com/maven-central/commons-net/commons-net/?gav=true)
-[![Javadocs](https://javadoc.io/badge/commons-net/commons-net/3.8.0.svg)](https://javadoc.io/doc/commons-net/commons-net/3.8.0)
-[![CodeQL](https://github.com/apache/commons-net/workflows/CodeQL/badge.svg)](https://github.com/apache/commons-net/actions/workflows/codeql-analysis.yml?query=workflow%3ACodeQL)
-
-Apache Commons Net library contains a collection of network utilities and protocol implementations.
-Supported protocols include: Echo, Finger, FTP, NNTP, NTP, POP3(S), SMTP(S), Telnet, Whois
-
-Documentation
--------------
-
-More information can be found on the [Apache Commons Net homepage](https://commons.apache.org/proper/commons-net).
-The [Javadoc](https://commons.apache.org/proper/commons-net/apidocs) can be browsed.
-Questions related to the usage of Apache Commons Net should be posted to the [user mailing list][ml].
-
-Where can I get the latest release?
------------------------------------
-You can download source and binaries from our [download page](https://commons.apache.org/proper/commons-net/download_net.cgi).
-
-Alternatively you can pull it from the central Maven repositories:
-
-```xml
-<dependency>
-  <groupId>commons-net</groupId>
-  <artifactId>commons-net</artifactId>
-  <version>3.8.0</version>
-</dependency>
-```
-
-Contributing
-------------
-
-We accept Pull Requests via GitHub. The [developer mailing list][ml] is the main channel of communication for contributors.
-There are some guidelines which will make applying PRs easier for us:
-+ No tabs! Please use spaces for indentation.
-+ Respect the code style.
-+ Create minimal diffs - disable on save actions like reformat source code or organize imports. If you feel the source code should be reformatted create a separate PR for this change.
-+ Provide JUnit tests for your changes and make sure your changes don't break any existing tests by running ```mvn```.
-
-If you plan to contribute on a regular basis, please consider filing a [contributor license agreement](https://www.apache.org/licenses/#clas).
-You can learn more about contributing via GitHub in our [contribution guidelines](CONTRIBUTING.md).
-
-License
--------
-This code is under the [Apache Licence v2](https://www.apache.org/licenses/LICENSE-2.0).
-
-See the `NOTICE.txt` file for required notices and attributions.
-
-Donations
----------
-You like Apache Commons Net? Then [donate back to the ASF](https://www.apache.org/foundation/contributing.html) to support the development.
-
-Additional Resources
---------------------
-
-+ [Apache Commons Homepage](https://commons.apache.org/)
-+ [Apache Issue Tracker (JIRA)](https://issues.apache.org/jira/browse/NET)
-+ [Apache Commons Twitter Account](https://twitter.com/ApacheCommons)
-+ `#apache-commons` IRC channel on `irc.freenode.org`
-
-[ml]:https://commons.apache.org/mail-lists.html
+<!---
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<!---
+ +======================================================================+
+ |****                                                              ****|
+ |****      THIS FILE IS GENERATED BY THE COMMONS BUILD PLUGIN      ****|
+ |****                    DO NOT EDIT DIRECTLY                      ****|
+ |****                                                              ****|
+ +======================================================================+
+ | TEMPLATE FILE: readme-md-template.md                                 |
+ | commons-build-plugin/trunk/src/main/resources/commons-xdoc-templates |
+ +======================================================================+
+ |                                                                      |
+ | 1) Re-generate using: mvn commons-build:readme-md                    |
+ |                                                                      |
+ | 2) Set the following properties in the component's pom:              |
+ |    - commons.componentid (required, alphabetic, lower case)          |
+ |    - commons.release.version (required)                              |
+ |                                                                      |
+ | 3) Example Properties                                                |
+ |                                                                      |
+ |  <properties>                                                        |
+ |    <commons.componentid>math</commons.componentid>                   |
+ |    <commons.release.version>1.2</commons.release.version>            |
+ |  </properties>                                                       |
+ |                                                                      |
+ +======================================================================+
+--->
+Apache Commons Net
+===================
+
+[![GitHub Actions Status](https://github.com/apache/commons-net/workflows/Java%20CI/badge.svg)](https://github.com/apache/commons-net/actions)
+[![Coverage Status](https://codecov.io/gh/apache/commons-net/branch/master/graph/badge.svg)](https://app.codecov.io/gh/apache/commons-net/branch/master)
+[![Maven Central](https://maven-badges.herokuapp.com/maven-central/commons-net/commons-net/badge.svg?gav=true)](https://maven-badges.herokuapp.com/maven-central/commons-net/commons-net/?gav=true)
+[![Javadocs](https://javadoc.io/badge/commons-net/commons-net/3.8.0.svg)](https://javadoc.io/doc/commons-net/commons-net/3.8.0)
+[![CodeQL](https://github.com/apache/commons-net/workflows/CodeQL/badge.svg)](https://github.com/apache/commons-net/actions/workflows/codeql-analysis.yml?query=workflow%3ACodeQL)
+
+Apache Commons Net library contains a collection of network utilities and protocol implementations.
+Supported protocols include: Echo, Finger, FTP, NNTP, NTP, POP3(S), SMTP(S), Telnet, Whois
+
+Documentation
+-------------
+
+More information can be found on the [Apache Commons Net homepage](https://commons.apache.org/proper/commons-net).
+The [Javadoc](https://commons.apache.org/proper/commons-net/apidocs) can be browsed.
+Questions related to the usage of Apache Commons Net should be posted to the [user mailing list][ml].
+
+Where can I get the latest release?
+-----------------------------------
+You can download source and binaries from our [download page](https://commons.apache.org/proper/commons-net/download_net.cgi).
+
+Alternatively you can pull it from the central Maven repositories:
+
+```xml
+<dependency>
+  <groupId>commons-net</groupId>
+  <artifactId>commons-net</artifactId>
+  <version>3.8.0</version>
+</dependency>
+```
+
+Contributing
+------------
+
+We accept Pull Requests via GitHub. The [developer mailing list][ml] is the main channel of communication for contributors.
+There are some guidelines which will make applying PRs easier for us:
++ No tabs! Please use spaces for indentation.
++ Respect the code style.
++ Create minimal diffs - disable on save actions like reformat source code or organize imports. If you feel the source code should be reformatted create a separate PR for this change.
++ Provide JUnit tests for your changes and make sure your changes don't break any existing tests by running ```mvn```.
+
+If you plan to contribute on a regular basis, please consider filing a [contributor license agreement](https://www.apache.org/licenses/#clas).
+You can learn more about contributing via GitHub in our [contribution guidelines](CONTRIBUTING.md).
+
+License
+-------
+This code is under the [Apache Licence v2](https://www.apache.org/licenses/LICENSE-2.0).
+
+See the `NOTICE.txt` file for required notices and attributions.
+
+Donations
+---------
+You like Apache Commons Net? Then [donate back to the ASF](https://www.apache.org/foundation/contributing.html) to support the development.
+
+Additional Resources
+--------------------
+
++ [Apache Commons Homepage](https://commons.apache.org/)
++ [Apache Issue Tracker (JIRA)](https://issues.apache.org/jira/browse/NET)
++ [Apache Commons Twitter Account](https://twitter.com/ApacheCommons)
++ `#apache-commons` IRC channel on `irc.freenode.org`
+
+[ml]:https://commons.apache.org/mail-lists.html
diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index 0f417a9b3..045e904c2 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -1,1667 +1,1667 @@
-<!--
-
-   Licensed to the Apache Software Foundation (ASF) under one or more
-   contributor license agreements.  See the NOTICE file distributed with
-   this work for additional information regarding copyright ownership.
-   The ASF licenses this file to You under the Apache License, Version 2.0
-   (the "License"); you may not use this file except in compliance with
-   the License.  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-
--->
-<!--
-This file is also used by the maven-changes-plugin to generate the release notes.
-Useful ways of finding items to add to this file are:
-
-1.  Add items when you fix a bug or add a feature (this makes the
-release process easy :-).
-
-2.  Do a JIRA search for tickets closed since the previous release.
-
-3.  Use the report generated by the maven-changelog-plugin to see all
-SVN commits. Set the project.properties' maven.changelog.range
-property to the number of days since the last release.
-
-To generate the release notes from this file:
-
-mvn changes:announcement-generate -Prelease-notes [-Dchanges.version=nnn]
-
-then tweak the formatting if necessary
-and commit
-
-The <action> type attribute can be add,update,fix,remove.
--->
-
-<document>
-  <properties>
-    <title>Apache Commons Net Release Notes</title>
-    <author email="dev@commons.apache.org">Apache Commons developers</author>
-  </properties>
-
-    <!-- NOTE:
-    The description below is specially formatted so as to improve the layout of the generated release notes:
-    The parsing process removes all line feeds, replacing them with a single space.
-    The Velocity template in resources/templates has been enhanced to replace pairs of adjacent spaces
-    with a new-line in the release notes. (These spaces are ignored when displaying HTML).
-    If the output is not quite correct, check for invisible trailing spaces!
-
-    N.B. The release notes template groups actions by type, and only extracts data for the current release.
-    The changes report outputs actions in the order they appear in this file.
-
-    To regenerate the release notes:
-    mvn changes:announcement-generate -Prelease-notes [-Dchanges.version=nnn]
-
-    Defining changes.version allows one to create the RN without first removing the SNAPSHOT suffix.
-     -->
-
-  <body>
-    <release version="3.9.0" date="2021-MM-DD" description="Maintenance and bug fix release (Java 8).">
-      <!-- FIX -->
-      <action type="fix" issue="NET-708" dev="ggregory" due-to="XenoAmess">
-        Use yyyy instead of YYYY in SimpleDateFormat #97.
-      </action>
-      <action type="update" dev="sebb">
-        Prevent serialization of the 4 classes that implement Serializable.
-        It is not useful and is unlikely to work properly.
-      </action>
-      <action type="fix" dev="ggregory" due-to="Arturo Bernal">
-        Use Math.min and Math.max method instead of manual calculations. #104.
-      </action>
-      <!-- ADD -->
-      <action type="add" dev="ggregory" due-to="Gary Gregory">
-        [FTP] Add FTPClient.mdtmInstant(String).
-      </action>
-      <action type="add" dev="ggregory" due-to="Gary Gregory">
-        [FTP] Add MLSxEntryParser.parseGmtInstant(String).
-      </action>
-      <action type="add" dev="ggregory" due-to="Gary Gregory">
-        [FTP] Add FTPClient.getControlKeepAliveReplyTimeoutDuration().
-      </action>
-      <action type="add" dev="ggregory" due-to="Gary Gregory">
-        [FTP] Add FTPClient.setControlKeepAliveReplyTimeout(Duration).
-      </action>
-      <action type="add" dev="ggregory" due-to="Gary Gregory">
-        [FTP] Add FTPClient.getControlKeepAliveTimeoutDuration().
-      </action>
-      <action type="add" dev="ggregory" due-to="Gary Gregory">
-        [FTP] Add FTPClient.setControlKeepAliveTimeout(Duration).
-      </action>
-      <action type="add" dev="ggregory" due-to="Gary Gregory">
-        [FTP] Add FTPClient.getDataTimeout().
-      </action>
-      <action type="add" dev="ggregory" due-to="Gary Gregory">
-        [FTP] Add FTPClient.setDataTimeout(Duration).
-      </action>
-      <action type="add" dev="ggregory" due-to="Gary Gregory">
-        [FTP] Add FTPFile.getTimestampInstant().
-      </action>
-      <action type="add" dev="ggregory" due-to="Gary Gregory">
-        Add github/codeql-action.
-      </action>
-      <!-- UPDATE -->
-      <action type="update" dev="ggregory" due-to="Dependabot, Gary Gregory">
-        Bump actions/cache from 2.1.6 to 3.0.8 #93, #102.
-      </action>
-      <action type="update" dev="ggregory" due-to="Dependabot, Gary Gregory">
-        Bump actions/checkout from 2.3.4 to 3.0.2 #89, #91, #100.
-      </action>
-      <action dev="ggregory" type="update" due-to="Gary Gregory">
-        A actions/setup-java from 1.4.3 to 3.5.1.
-      </action>
-      <action type="update" dev="ggregory" due-to="Dependabot">
-        Bump junit from 4.13.1 to 5.9.1 Vintage #74.
-      </action>
-      <action type="update" dev="ggregory" due-to="Dependabot, Gary Gregory">
-        Bump commons-io from 2.6 to 2.11.0 #60.
-      </action>
-      <action dev="ggregory" type="update" due-to="Gary Gregory">
-        Bump commons.jacoco.version from 0.8.6 to 0.8.8.
-      </action>
-      <action dev="ggregory" type="update" due-to="Gary Gregory">
-        Bump commons.japicmp.version from 0.14.3 to 0.16.0.
-      </action>
-      <action dev="ggregory" type="update" due-to="Gary Gregory">
-        Bump commons.surefire.version from 2.22.2 to 3.0.0-M7.
-      </action>
-      <action type="update" dev="ggregory" due-to="XenoAmess, Gary Gregory">
-        Bump ftpserver-core from 1.1.1 to 1.2.0 #96.
-      </action>
-      <action type="update" dev="ggregory" due-to="Dependabot">
-        Bump exec-maven-plugin from 3.0.0 to 3.1.0 #109.
-      </action>
-      <action type="update" dev="ggregory" due-to="Dependabot">
-        Bump commons-parent from 53 to 54 #112
-      </action>
-    </release>
-    <release version="3.8.0" date="2021-02-13" description="Maintenance and bug fix release (Java 7).">
-      <!-- ADD -->
-      <action type="add" dev="ggregory" due-to="Arturo Bernal, Gary Gregory">
-        Add and use NetConstants.
-      </action>
-      <action type="add" dev="ggregory" due-to="Gary Gregory">
-        Add and use SocketClient.applySocketAttributes().
-      </action>
-      <action type="add" dev="ggregory" due-to="Gary Gregory">
-        [FTP] Add FTPClient.hasFeature(FTPCmd).
-      </action>
-      <action type="add" dev="ggregory" due-to="Gary Gregory">
-        [FTP] Add FTPClient.mdtmCalendar(String).
-      </action>
-      <!-- FIX -->
-      <action type="fix" dev="ggregory" due-to="Gary Gregory">
-        [IMAP] Fix concurrent counting of chunks in IMAPExportMbox.
-      </action>
-      <action type="fix" dev="ggregory" due-to="Gary Gregory">
-        Fix possible if rare NPEs in tests.
-      </action>
-      <!-- UPDATE -->
-      <action type="update" dev="ggregory" due-to="Dependabot">
-        Bump actions/checkout from v2.3.3 to v2.3.4 #69.
-      </action>
-      <action issue="NET-685" type="update" dev="ggregory" due-to="Simo385">
-        Update SocketClient default connect timeout from ‚àû to 60 seconds #51.
-      </action>
-      <action issue="NET-695" type="update" dev="ggregory" due-to="Gary Gregory, Possibly Cott">
-        Apply SocketClient timeout after connection but before SSL negotiation.
-      </action>
-      <action type="update" dev="ggregory" due-to="Arturo Bernal, Gary Gregory">
-        Minor Improvements #71, #72.
-      </action>
-      <action type="update" dev="ggregory" due-to="Dependabot">
-        Bump actions/cache from v2 to v2.1.4 #73.
-      </action>
-    </release>
-    <release version="3.7.2" date="2020-10-14" description="Maintenance and bug fix release (Java 7).">
-      <action issue="NET-689" type="fix" dev="ggregory" due-to="Charlie, Gary Gregory">
-        Host name is not set on the SSLSocket causing isEndpointCheckingEnabled to fail.
-      </action>
-      <action type="fix" dev="ggregory" due-to="Dependabot">
-        Fix possible socket and input stream leak on socket exception in
-        org.apache.commons.net.ftp.FTPClient._retrieveFile(String, String, OutputStream).
-      </action>
-      <action issue="NET-690" type="fix" dev="ggregory" due-to="payal-meh, Gary Gregory">
-        Performance issue when using the FTPClient to retrieve files #65.
-      </action>
-      <action issue="NET-691" type="update" dev="ggregory" due-to="Lewis John McGibbney">
-        Improve Javadoc for IMAPSClient #68.
-      </action>
-      <!-- UPDATES -->
-      <action type="update" dev="ggregory" due-to="Dependabot">
-        Bump actions/setup-java from v1.4.2 to v1.4.3 #62.
-      </action>
-      <action type="update" dev="ggregory" due-to="Dependabot">
-        Bump junit from 4.13 to 4.13.1 #67.
-      </action>
-    </release>
-    <release version="3.7.1" date="2020-09-30" description="Maintenance and bug fix release (Java 7).">
-      <action issue="NET-687" type="fix" dev="ggregory" due-to="Gary Gregory, Mikael, j-verse">
-        [FTPS] javax.net.ssl.SSLException: Unsupported or unrecognized SSL message, #59.
-      </action>
-      <!-- UPDATES -->
-      <action type="update" dev="ggregory" due-to="Dependabot">
-        Update actions/checkout from v2.3.1 to v2.3.3 #56, #61.
-      </action>
-    </release>
-    <release version="3.7" date="2020-08-05"
-      description="
-This is mainly a bug-fix release (Java 7). See further details below.
-
- This release requires a minimum of Java 7.
-
- This release is binary compatible with previous releases.
- However it is not source compatible with releases before 3.4, as some methods were added to the interface NtpV3Packet in 3.4
-
- Note that the examples packages were moved under org/apache/commons/net/examples.
- The examples are not part of the public API, so this does not affect compatibility.
-
-">
-      <action issue="NET-673" type="fix" dev="sebb">
-        IMAPClient.APPEND does not always calculate the correct length
-      </action>
-      <action issue="NET-646" type="add" dev="sebb">
-        ALLO FTP Command for files >2GB
-      </action>
-      <action issue="NET-615" type="add" dev="sebb">
-        IMAPClient could simplify using empty arguments
-      </action>
-      <action issue="NET-614" type="add" dev="sebb">
-        IMAP fails to quote/encode mailbox names
-      </action>
-      <action issue="NET-643" type="fix" dev="sebb" due-to="Vasily">
-        NPE when closing telnet stream
-      </action>
-      <action issue="NET-648" type="add" dev="pschumacher">
-        Add Automatic-Module-Name MANIFEST entry for Java 9 compatibility
-      </action>
-      <action issue="NET-641" type="fix" dev="sebb" due-to="pin_ptr">
-        SubnetUtils.SubnetInfo.isInRange("0.0.0.0") returns true for CIDR/31, 32
-      </action>
-      <action issue="NET-638" type="add" dev="sebb" due-to="Daniel Leong">
-        Telnet subnegotiations hard-limited to 512 bytes - allow override
-      </action>
-      <action issue="NET-639" type="fix" dev="sebb" due-to=" Alexander Eller">
-        MVSFTPEntryParser.preParse - MVS, z/OS - allow for merged Ext/Used fields
-      </action>
-      <action issue="NET-636" type="fix" dev="sebb">
-        examples should be in org.apache.commons.net subpackage
-      </action>
-      <action issue="NET-634" type="add" dev="sebb" due-to="Mauro Molinari">
-        Add SIZE command support
-      </action>
-      <action type="add" dev="sebb">
-        Add POP3ExportMbox example code
-      </action>
-      <action issue="NET-633" type="update" dev="sebb" due-to="n0rm1e">
-        Add XOAUTH2 to IMAP and SMTP
-      </action>
-      <action issue="NET-632" type="update" dev="sebb" due-to="prakapenka">
-        FTPHTTPClient - support for encoding other than UTF-8
-      </action>
-      <action issue="NET-631" type="fix" dev="sebb">
-        Bug in MVSFTPEntryParser.parseUnixList (FindBugs)
-      </action>
-      <action issue="NET-584" type="fix" dev="sebb" due-to="Kazantsev Andrey Sergeevich/Nick Manley">
-        Error when using org.apache.commons.net.ftp.FTPClient setControlKeepAliveTimeout
-      </action>
-      <action issue="NET-626" type="update" dev="sebb" due-to="Makoto Sakaguchi">
-        SubnetUtils#SubnetUtils - improved comment
-      </action>
-      <action issue="NET-625" type="update" dev="sebb">
-        SubnetUtils - improve construction
-      </action>
-      <action issue="NET-624" type="update" dev="sebb" due-to="Makoto Sakaguchi">
-        SubnetInfo#getCidrSignature - improve functions
-      </action>
-      <action issue="NET-624" type="fix" dev="sebb" due-to="Makoto Sakaguchi">
-        SubnetInfo#toCidrNotation: A wrong format subnet mask is allowed
-      </action>
-      <action issue="NET-623" type="fix" dev="sebb" due-to="Makoto Sakaguchi">
-        SubnetUtils - fixed spelling errors
-      </action>
-      <action issue="NET-621" type="update" dev="sebb" due-to="Makoto Sakaguchi">
-        SubnetUtils#SubnetInfo - remove unnecessary accessors
-      </action>
-      <action issue="NET-619" type="update" dev="sebb" due-to="Makoto Sakaguchi">
-        SubnetUtils - improve binary netmask algorithm
-      </action>
-      <action issue="NET-613" type="fix" dev="sebb" due-to="Donald Kwakkel">
-        System Information Leak in ftp parser
-      </action>
-      <action issue="NET-678" type="update" dev="sebb" due-to="Roman Grigoriadi">
-        VMS ftp LIST parsing results in empty file list
-      </action>
-      <action issue="NET-674" type="add" dev="sebb" due-to="Chris Steingen">
-        FTPListParseEngine should support listing via MLSD
-      </action>
-      <action issue="NET-663" type="fix" dev="sebb" due-to="Max Shenfield">
-        NullPointerException when FTPClient remote verification fails
-      </action>
-      <action issue="NET-649" type="fix" dev="sebb" due-to="Filipe Bojikian Rissi">
-        227 Entering Passive Mode
-      </action>
-      <action issue="NET-660" type="add" dev="sebb" due-to="Nagabhushan S N">
-        Next and Previous IP Address in SubnetUtils.SubnetInfo
-      </action>
-      <action issue="NET-682" type="fix" dev="sebb" due-to="richard">
-        MVSFTPEntryParser doesn't support Record Formats of U
-      </action>
-    </release>
-    <release version="3.6" date="2017-02-15"
-      description="
-This is mainly a bug-fix release (Java 6). See further details below.
-
-
- This release is binary compatible with previous releases.
- However it is not source compatible with releases before 3.4, as some methods were added to the interface NtpV3Packet in 3.4
-
-  The code now requires a minimum of Java 6.
-
-  Changes to functionality:
- * The FTP client now performs stricter checks on non-multiline command replies.
-  The 3 digit code must now be followed by a space and some text, as per RFC 959.
-  To suppress this stricter checking, call FTP#setStrictReplyParsing(false). This should not be needed with a well-behaved server.
-  Note also that if strict checking is disabled, some functions may unconditionally strip the next character after the code,
-without checking it if is a space.
-
-* The FTP client mlistFile() method now checks for a leading space before removing it.
-  If the space is missing, a MalformedServerReplyException is thrown.
-  This will only happen if the FTP server is not compliant with RFC 3659.
-
-  Notable additions:
- * The POP3Mail examples can now get password from console, stdin or an environment variable.
-
-* TFTPClient code has been rewritten to improve error handling and retries.
-  
-">
-      <action issue="NET-613" type="fix" dev="sebb">
-        TFTPClient assumes that lastBlock == 0 only once
-      </action>
-      <action issue="NET-320" type="fix" dev="sebb" due-to="Kevin Bulebush">
-        Allow TFTPServer.java to bind to a specific network adapter
-      </action>
-      <action issue="NET-414" type="fix" dev="sebb" due-to="Chuck Wolber">
-        Apache Commons TFTP does not reject request replies that originate from a control port.
-      </action>
-      <action issue="NET-477" type="fix" dev="sebb" due-to="John Walton">
-        TFTP sendFile retry broken
-      </action>
-      <action issue="NET-612" type="update" dev="sebb">
-        Allow TFTP socket IO tracing
-      </action>
-      <action issue="NET-596" type="fix" dev="sebb" due-to="Vincent Bories-Azeau">
-        NullPointerException when disconnecting TelnetClient twice with JDK 7
-      </action>
-      <action issue="NET-602" type="fix" dev="sebb" due-to="Ross Braithwaite">
-        Failure to parse times from SYST_L8 systems that report as "WINDOWS Type: L8"
-      </action>
-      <action issue="NET-604" type="fix" dev="sebb" due-to="Frank Delporte">
-        TFTP send and receive don't have progress indication
-      </action>
-      <action issue="NET-588" type="fix" dev="sebb" due-to="Dave Nice / Thai H">
-        FTPClient.setPassiveNatWorkaround assumes host is outside site local range
-      </action>
-      <action issue="NET-610" type="fix" dev="sebb" due-to="Sergey Yanzin">
-        FTPClient.mlistFile incorrectly handles MLST reply
-      </action>
-      <action issue="NET-611" type="fix" dev="sebb">
-        FTP does not validate command reply syntax fully
-      </action>
-      <action issue="NET-609" type="fix" dev="sebb" due-to="Tqup3">
-        DefaultUnixFTPFileEntryParserFactory Issue (leading spaces removal configuration)
-      </action>
-      <action type="update" dev="sebb">
-        POP3Mail example: support host port; allow reading password from Console/stdin/environment
-      </action>
-      <action issue="NET-597" type="fix" dev="sebb" due-to="Hiroki Taniura">
-        FTP fails to parse listings for Solaris 10 FTPd in Japanese
-      </action>
-      <action issue="NET-599" type="update" dev="sebb">
-        Add shorthand FTPClientConfig constructor
-      </action>
-      <action issue="NET-593" type="fix" dev="sebb" due-to="Joerg Weule">
-        HostnameVerifier is called with ip addess instead of the provided hostname
-      </action>
-      <action issue="NET-594" type="fix" dev="sebb" due-to="Brad Worrral">
-        TelnetClient._closeOutputStream unhandled exception from FilterOutputStream.close
-      </action>
-      <action issue="NET-592" type="fix" dev="sebb" due-to="Mark Ford">
-        plainSocket in FTPSClient is never closed
-      </action>
-    </release>
-    <release version="3.5" date="2016-05-05"
-      description="
-This is mainly a bug-fix release (Java 6). See further details below.
-
-
- This release is binary compatible with previous releases.
- However it is not source compatible with releases before 3.4, as some methods were added to the interface NtpV3Packet in 3.4
-
-  The code now requires a minimum of Java 6.
-
-  Notable additions:
-  The IMAP examples can now get password from console, stdin or an environment variable.
-        ">
-      <action issue="NET-583" type="fix" dev="sebb" due-to="Holger Rehn">
-        FTPClient.getReplyString() returns wrong value after connect()
-      </action>
-      <action type="add" dev="sebb">
-        Alternative password input methods for IMAP examples
-      </action>
-      <action type="add" dev="sebb">
-        More tests for Feb 29 handling.
-      </action>
-      <action issue="NET-586" type="fix" dev="sebb">
-        Don't use Feb 29 for short future date tests
-      </action>
-      <action type="fix" dev="sebb">
-        Documentation tweaks
-      </action>
-    </release>
-    <release version="3.4" date="2015-11-26"
-      description="
-This is mainly a bug-fix release. See further details below.
-
-  This release is binary compatible with previous releases.
-  However it is not source compatible, as some methods have been added to the interface NtpV3Packet
-
-  Notable additions:
-  IMAPExportMbox (example app) allows IMAP folders to be exported into an mbox file.
-  This is the inverse of the IMAPImportMbox example added previously
-        ">
-      <action issue="NET-581" type="fix" dev="sebb">
-        SimpleSMTPHeader fails to supply the required Date: header
-      </action>
-      <action issue="NET-582" type="fix" dev="sebb">
-        SimpleSMTPHeader does not allow for missing To: field
-      </action>
-      <action issue="NET-580" type="fix" dev="sebb" due-to="Simon Arlott">
-        SMTPClient.sendSimpleMessage() silently ignores failed recipients
-        Update Javadoc
-      </action>
-      <action issue="NET-579" type="fix" dev="sebb" due-to="Simon Arlott">
-        SSL/TLS SocketClients do not verify the hostname against the certificate
-      </action>
-      <action issue="NET-576" type="update" dev="sebb">
-        Allow FTPClient to use SYST response if system type is not specified in configuration
-      </action>
-      <action issue="NET-575" type="update" dev="sebb">
-        FTPClientExample should support setting the date format
-      </action>
-      <action issue="NET-538" type="fix" dev="sebb" due-to="Dzmitry">
-        FTPHTTPClient should use socket factory to create sockets
-      </action>
-      <action issue="NET-566" type="fix" dev="sebb" due-to="Gary Russell">
-        UnixFTPEntryParser Drops Leading Spaces from File Names
-      </action>
-      <action type="update" dev="sebb">
-        examples/Main now uses a property file to define aliases instead of scanning class files
-      </action>
-      <action issue="NET-552" type="fix" dev="sebb" due-to="Quentin Devriendt">
-        SocketTimeoutException connecting a FTP server via an HTTP Proxy
-      </action>
-      <action issue="NET-528" type="add" dev="sebb">
-        FTPListParseEngine does not provide access to raw responses
-      </action>
-      <action issue="NET-565" type="add" dev="sebb">
-        Add FTPClient method to return an FTPFile from an MDTM command
-      </action>
-      <action issue="NET-564" type="update" dev="sebb">
-        FTPFile.toFormattedString - allow specification of TimeZone for display
-      </action>
-      <action issue="NET-562" type="update" dev="sebb">
-        FTPFile.toFormattedString should print only signficant parts of the parsed date
-      </action>
-      <action issue="NET-563" type="fix" dev="sebb">
-        MLSxEntryParser needs test cases; parsing is too lax
-      </action>
-      <action issue="NET-561" type="fix" dev="sebb">
-        FTPFile.toFormattedString prints user and group in wrong order
-      </action>
-      <action issue="NET-544" type="fix" dev="sebb" due-to="Olivier Queyrut ">
-        FTPClient.initiateListParsing does not correctly check if parserKey was cached
-      </action>
-      <action issue="NET-554" type="update" dev="sebb">
-        Simplify TelnetOptionHandler class hierarchy
-      </action>
-      <action issue="NET-558" type="fix" dev="sebb" due-to="Ralph Becker">
-        FTPClient.getModificationTime(filename) returns complete received line including response code and EOL
-        Strip the response code and EOL
-      </action>
-      <action issue="NET-556" type="update" dev="sebb" due-to="Andy Rosa">
-        Make SubnetInfo.isInRange(int) public
-      </action>
-      <action issue="NET-550" type="fix" dev="sebb" due-to="Geoffrey Hardy">
-        Default FTPClient bufferSize results in very slow retrieve transfers
-        Fix code in Util#copyStream (also copyReader) that failed to use the proper default for buffer size 0
-      </action>
-      <action issue="NET-551" type="fix" dev="sebb">
-        Util copyReader calls CopyStreamListener.bytesTransferred with the incorrect value for bytesTransferred
-      </action>
-      <action type="update" dev="sebb">
-        Added control character processing to TelnetClientExample
-      </action>
-      <action issue="NET-547" type="update" dev="sebb" due-to="Fabio Scippacercola">
-        There is a lack of documentation regarding setControlKeepAliveTimeout
-      </action>
-      <action issue="NET-549" type="fix" dev="sebb" due-to="Pradeep Natarajan">
-        Telnet does not convert LF to CRLF in ASCII mode
-      </action>
-      <action issue="NET-543" type="fix" dev="sebb" due-to="Ferry Huberts">
-        telnet: spy read EOL is reversed
-      </action>
-      <action issue="NET-540" type="add" dev="sebb">
-        Article#printThread should have option to use any PrintStream
-      </action>
-      <action issue="NET-539" type="fix" dev="sebb">
-        NPE if Threader.thread invoked with empty list or with null array
-      </action>
-      <action issue="NET-536" type="add" dev="sebb">
-        IMAP FETCH example
-        IMAPExportMbox can export selected nessages from an IMAP folder
-      </action>
-      <action issue="NET-535" type="add" dev="sebb">
-        IMAP FETCH can overflow reply buffer; provide for partial responses
-      </action>
-      <action issue="NET-534" type="update" dev="sebb">
-        Unnecesssary call to getReplyString() if no listeners configured
-      </action>
-      <action issue="NET-530" type="fix" dev="sebb" due-to="fish ship">
-        input parameter of org.apache.commons.net.ftp.FTP.__getReply(boolean) is not used
-      </action>
-      <action issue="NET-529" type="fix" dev="sebb" due-to="Putinas Piliponis">
-        SubnetUtils throws exception on valid input
-      </action>
-      <action issue="NET-527" type="add" dev="sebb" due-to="jason mathews">
-        Add SimpleNTPServer as example and for testing
-      </action>
-      <action issue="NET-516" type="fix" dev="sebb" due-to="Asha K S &amp; pavan">
-        parser problem occurs if the filename contains one or more characters of which the second byte of Shift-JIS code is 0x85
-        Fix NT parser
-      </action>
-      <action type="update" dev="sebb">
-        Added control encoding option to FTPClientExample
-      </action>
-      <action issue="NET-526" type="update" dev="sebb" due-to="Jason Mathews, MITRE Corp">
-        Added missing set methods on NTP class and interface
-      </action>
-      <action issue="NET-526" type="update" dev="sebb">
-        Avoid greedy matches within a regex
-      </action>
-      <action issue="NET-520" type="fix" dev="sebb">
-        SubnetUtils("0.0.0.0/0") does not behave as expected
-        Fixed range checking so network and broadcast addresses are treated as unsigned ints
-      </action>
-      <action issue="NET-521" type="fix" dev="sebb">
-        SubnetUtils.SubnetInfo.getAddressCount() can overflow as it returns an int
-      </action>
-      <action issue="NET-515" type="fix" due-to="Sebastian Ritter">
-        FTPClient sample in class javadoc "bug"
-      </action>
-      <action issue="NET-519" type="fix">
-        Apache Commons Net 3.3 has a performance issue
-      </action>
-      <action issue="NET-517" dev="sebb" type="fix" due-to="David Kocher">
-        FTPClient#reinitialize is package protected
-      </action>
-      <action issue="NET-512" dev="sebb" type="add" due-to="Thomas Raddatz">
-        Downloading files or members from the AS400 QSYS file system is not supported
-      </action>
-      <action issue="NET-518" dev="sebb" type="fix" due-to="David Kocher">
-        FTPClient#initFeatureMap should not initialize empty map if reply code is 530
-      </action>
-      <action issue="NET-514" dev="sebb" type="fix">
-        IMAP APPEND multiple issues in IMapClient.
-        Deprecated unusable append methods.
-        Added new append method, as well as example IMapImportMbox class to make use of it.
-      </action>
-      <action issue="NET-511" dev="ggregory" type="fix" due-to="Kyriacos Elia, Daniel Scott">
-        Exception for new SubnetUtils("0.0.0.0/0").
-      </action>
-    </release>
-    <release version="3.3" date="2013-06-11"
-      description="
-This is mainly a bug-fix release. See further details below.
-        ">
-      <action issue="NET-509" dev="sebb" due-to="Anthony Dahanne" type="update">
-        AuthenticatingSMTPClient needs a constructor with the isImplicit argument for SSL
-      </action>
-      <action issue="NET-501" dev="sebb" due-to="Juli√°n Lastiri" type="fix">
-        Race Condition on TelnetClient.disconnect() and TelnetInputStream.run()
-        java.lang.IllegalStateException: Queue is full! Cannot process another character.
-      </action>
-      <action issue="NET-505" dev="sebb" due-to="Sean Kelley" type="update">
-        User specified bufferSize reset to default when FTPClient is disconnected or reinitialized resulting in performance
-        degradation.
-      </action>
-      <action issue="NET-507" dev="sebb" due-to="Jiri Netolicky" type="update">
-        Option to disable private IP replacement in FTP passive mode.
-      </action>
-      <action issue="NET-503" dev="sebb" due-to="Ofer Regev" type="add">
-        AuthenticatingSMTPClient does not support non-default encoding
-      </action>
-      <action issue="NET-500" dev="sebb" due-to="Michael Frick" type="fix">
-        Always call FTPClient#setFileType after connection.
-        Not all servers default to ASCII.
-      </action>
-      <action issue="NET-465" dev="sebb" due-to="Jim Kerwood" type="fix">
-        FTPClient setSendBufferSize and setReceiveBufferSize on data socket.
-        The previous fix caused performance problems.
-        Added new getters and setters for the SO_SNDBUF and SO_RCVBUF values to be used on the data socket.
-      </action>
-      <action issue="NET-496" dev="sebb" type="add">
-        Util copyReader/copyStream classes should use default buffer size for non-positive buffer size parameters.
-      </action>
-      <action issue="NET-310" dev="sebb" type="add">
-        FTPCommand conversion to use enum; added FTPCmd emum and deprecated FTPCommand.
-      </action>
-      <action issue="NET-480" dev="sebb" due-to="Peter Naber" type="fix">
-        Wrong passivHost when using FTPHTTPClient with EPSV
-      </action>
-      <action issue="NET-494" dev="sebb" type="fix">
-        FTPClient.CSL.cleanUp() fails to restore timeout value on exception
-      </action>
-      <action issue="NET-492" dev="sebb" due-to="Tomasz Jedrzejewski" type="fix">
-        FTPClient.printWorkingDirectory() incorrectly parses certain valid PWD command results
-      </action>
-    </release>
-    <release version="3.2" date="2012-12-03"
-      description="
-This release fixes bugs and adds some new functionality (see below).
- It is binary compatible with previous releases.
- Note that Clirr shows that two public methods have been removed (NET-485). These are not used within NET.
-        ">
-      <action issue="NET-46" dev="sebb" type="fix">
-        retrieveFileStream fails randomly or hangs
-      </action>
-      <action issue="NET-485" dev="sebb" type="fix">
-        Remove unnecessary Base64 methods.
-      </action>
-      <action issue="NET-482" dev="sebb" type="update" due-to="Houman Atashbar">
-        Support XOAUTH.
-      </action>
-      <action issue="NET-484" dev="sebb" type="fix">
-        Base64.CHUNK_SEPARATOR should be private
-      </action>
-      <action issue="NET-483" dev="sebb" type="fix">
-        Base64.encodeBase64(byte[], boolean, boolean, int) does not calculate output size correctly for unchunked output.
-      </action>
-      <action issue="NET-466" dev="sebb" type="fix" due-to="Martin Oberhuber">
-        Regression: TelnetInputStream#available() blocks.
-      </action>
-      <action issue="NET-426" dev="sebb" type="fix" due-to="Ketan">
-        FTPS: Hook to customize _openDataConnection_ SSLSocket before startHandshake() is called.
-        Implement _openDataConnection(String, String) method to properly
-        interface with FTPClient.openDataConnection(String, String)
-      </action>
-      <action issue="NET-456" dev="sebb" type="fix">
-        TelnetClient hangs when reader-thread startup is delayed.
-      </action>
-      <action issue="NET-449" dev="sebb" type="fix">
-        listFiles bug with folder that begins with "-". Clarify Javadoc.
-      </action>
-      <action issue="NET-473" dev="sebb" type="fix">
-        FTPClient setSoTimeout (int time) will result in NullPointerException. Clarify Javadoc.
-      </action>
-      <action issue="NET-468" dev="sebb" type="add" due-to="Bogdan Drozdowski">
-        Request for native support for socks proxy routing with Commons net FTP.
-      </action>
-      <action issue="NET-475" dev="sebb" type="fix">
-        FtpClient sends REST when calling listFiles. Clarified Javadoc.
-      </action>
-      <action issue="NET-465" dev="sebb" type="add" due-to="Bogdan Drozdowski">
-        FTPClient setSendBufferSize and setReceiveBufferSize on data socket.
-      </action>
-      <action issue="NET-462" dev="sebb" type="add" due-to="Bogdan Drozdowski">
-        FTPClient in PASSIVE_LOCAL_DATA_CONNECTION_MODE cannot work when host have several different IP.
-      </action>
-      <action issue="NET-467" dev="sebb" type="fix">
-        IMAPClient#fetch() does not handle literal strings.
-      </action>
-      <action issue="NET-458" dev="sebb" type="fix" due-to="Denis Molony">
-        MVSFTPEntryParser.parseSimpleEntry - ArrayIndexOutOfBoundsException.
-      </action>
-      <action issue="NET-450" dev="sebb" type="fix" due-to="Roger Hardiman">
-        Bug in documentation for FTPClient.
-      </action>
-      <action dev="sebb" type="add">
-        The examples can now be run using "java -jar commons-net-examples-m.n.jar".
-        This will automatically include the main net jar in the classpath.
-        See documentation.
-        FTPClientExample now supports "-A" for anonymous login
-      </action>
-      <action issue="NET-442" dev="sebb" type="fix">
-        StringIndexOutOfBoundsException: String index out of range: -1 if server respond with root is current directory.
-      </action>
-      <action issue="NET-444" dev="sebb" type="fix">
-        FTPTimestampParserImpl fails to parse future dates correctly on Feb 28th in a leap year.
-      </action>
-    </release>
-    <release version="3.1" date="Feb 20, 2012"
-      description="
-This release fixes a few bugs and adds some new functionality (see below).
-  It is binary compatible with previous releases
-        ">
-      <action issue="NET-441" dev="sebb" type="fix" due-to="consiliens">
-        [FTP] mlistDir doc should be "MLSD" not "MSLD".
-      </action>
-      <action issue="NET-440" dev="sebb" type="add">
-        [FTP] Allow user to provide default value in case SYST command fails.
-      </action>
-      <action issue="NET-438" dev="sebb" type="fix" due-to="Norman Maurer">
-        POP3Client.capa() should call POP3Client.getAdditionalReply()
-      </action>
-      <action issue="NET-412" dev="sebb" type="fix" due-to="Chuck Wolber">
-        TFTP implementation subject to Sorcerer's Apprentice Syndrome
-      </action>
-      <action issue="NET-410" dev="sebb" type="fix" due-to="Chuck Wolber">
-        TFTP does not handle RFC 783 retransmits
-      </action>
-      <action issue="NET-437" dev="sebb" type="fix" due-to="Gavin Camp">
-        TelnetInputStream doesn't support non-blocking IO when reader thread is not enabled
-      </action>
-      <action issue="NET-346" dev="sebb" type="add" due-to="Kevin Samuel">
-        FTP should support reporting NATed external IP address
-      </action>
-      <action issue="NET-433" dev="sebb" type="add">
-        Commons NET site should link to the examples
-      </action>
-      <action issue="NET-422" dev="sebb" type="fix" due-to="Tomas Mysik / Magnus Johansson">
-        FTP using HTTP proxy not working
-      </action>
-      <action issue="NET-423" dev="sebb" type="fix" due-to="Jens Koch">
-        FTPClient.storeFIle might fail when ControlKeepAliveTimeout is set (ditto for FTPCLient.retrieveFile)
-      </action>
-      <action issue="NET-426" dev="sebb" type="add" due-to="Ketan">
-        FTPS: Hook to customize _openDataConnection_ SSLSocket before startHandshake() is called
-      </action>
-      <action issue="NET-430" dev="sebb" type="fix" due-to="Thomas Mathis">
-        Can't login to POP3S Server using explicit mode
-      </action>
-      <action issue="NET-434" dev="sebb" type="fix" due-to="zhangyong">
-        FTPClient fails to close local listener socket when command socket channel encounter "ReadTimeoutException"
-      </action>
-      <action issue="NET-436" dev="sebb" type="add" due-to="J√ºrgen Jung">
-        [FTP] Support for SYST "Mac OS" listing - "MACOS Peter's Server"
-      </action>
-      <action issue="NET-425" dev="sebb" type="update" due-to="Steven Jardine">
-        [FTP] _openDataConnection_, __storeFile, and __storeFileStream should be protected and take String for FTP command.
-        Likewise for receiveFile and receiveFileStream.
-      </action>
-      <action issue="NET-416" dev="sebb" type="update" due-to="Abhijeet Gaikwad">
-        [Telnet] Increasing sub-negotiation message holder array size
-      </action>
-      <action issue="NET-428" dev="sebb" type="fix" due-to="sebb">
-        SubnetUtils throws ArrayIndexOutOfBoundsException for new SubnetUtils( "1.2.3.4/32" ).getInfo().getAllAddresses()
-      </action>
-      <action issue="NET-421" dev="sebb" type="fix" due-to="Oliver Saggau">
-        Problem connecting to TLS/SSL SMTP server using explicit mode.
-      </action>
-      <action issue="NET-415" dev="sebb" type="fix" due-to="george thomas">
-        [Site] typo in migration how-to.
-      </action>
-    </release>
-
-    <release version="3.0.1" date="June 6, 2011" description="
-This is a bug-fix release.
-        ">
-      <action issue="NET-409" dev="sebb" type="fix">
-        FTPClient truncates file (storeFile method).
-        Fix bug introduced in release 3.0.
-      </action>
-    </release>
-    <release version="3.0" date="May 16, 2011"
-      description="
-This release fixes many bugs (see below), and adds new functionality:
-  - basic support for IMAP and IMAPS
-  - support for SMTPS and POP3S
-
-    FTP changes:
-  - default for lenient future dates is now true, which fixes short date parsing where host clock is ahead of client clock
-  - no longer parses every response line twice
-  - OS auto-detection can be overriden by defining the property 'org.apache.commons.net.ftp.systemType';
-  - or by creating a properties file '/systemType.properties' which provides a mapping from getSystemType() to parser name
-  See the Javadoc for FTPClient.initiateListParsing(String parserKey, String pathname).
-  - SASL, PLAIN and CRAM-MD5 authentication added
-  - added control channel keep-alive for use with misbehaving routers, see FTPClient.setControlKeepAliveTimeout(long controlIdle)
-
-    NNTP changes:
-  - reworked to use long for article numbers
-  - added streaming equivalents for the array methods
-
-  Added TrustManagerUtils and KeyManagerUtils classes to simplify setting up trust and key namagers.
-KeyManagerUtils can be used to provide client certificates.
-
-  This release is binary-compatible with 2.2, but there are some minor changes to source compatibility:
-  - telnet.TelnetClient#addOptionHandler(TelnetOptionHandler) now additionally throws IOException
-  - telnet.TelnetClient#deleteOptionHandler() now additionally throws IOException
-  - ftp.FTPSClient ctors no longer throw NoSuchAlgorithmException
-  - Redundant CODE_nnn definitions have been removed from FTPReply, SMTPReply and NNTPReply classes
-  - Unused String constants KEYSTORE_ALGORITHM, PROVIDER, STORE_TYPE, TRUSTSTORE_ALGORITHM removed from FTPSClient
-
-  All users are recommended to upgrade.
-">
-      <action issue="NET-407" dev="sebb" type="update">
-        Change lenientFutureDates to default to true.
-        This means short dates will be parsed as the current year when the host clock is up to 1 day ahead of the client clock.
-      </action>
-      <action issue="NET-404" dev="sebb" type="fix">
-        FTPSSocketFactory does not override createSocket(); causes java.net.SocketException: Unconnected sockets not implemented.
-      </action>
-      <action issue="NET-399" dev="sebb" type="fix" due-to="Noah Levitt">
-        ftp data connection does not use connectTimeout.
-      </action>
-      <action issue="NET-400" dev="sebb" type="update" due-to="David Kocher">
-        Option to override SSL negotiation. Make FTPSClient#execAuth() and FTPSClient#sslNegotiation() protected
-      </action>
-      <action issue="NET-402" dev="sebb" type="fix">
-        IMAP, NNTP, POP3 and SMTP classes uses BufferedReader for control channel, which does not follow the standard.
-        Changed reader to CRLFLineReader.
-      </action>
-      <action issue="NET-401" dev="sebb" type="fix">
-        FTP class uses BufferedReader for control channel, which does not follow the standard.
-        Changed reader to CRLFLineReader.
-      </action>
-      <action issue="NET-331" dev="sebb" type="update">
-        AS400 file timestamp format is wrong. Workround exists.
-      </action>
-      <action issue="NET-269" dev="sebb" type="update">
-        Remove semi-redundant check in SubnetUtils.calculate().
-      </action>
-      <action issue="NET-219" dev="sebb" type="update">
-        Should Telnet class Exception blocks write to System.err?
-        Catch blocks removed, and throws clauses added to allow caller to more easily detect and recover.
-      </action>
-      <action issue="NET-397" dev="sebb" type="update" due-to="Bogdan Drozdowski"
-        due-to-email="bogdandr # op . pl">
-        FTPSClient does not handle AUTH or ADAT and only partially handles PBSZ. FTPSCommand should be deprecated.
-      </action>
-      <action issue="NET-268" dev="sebb" type="fix">
-        Better handling of CIDR/31 and CIDR/32 where isInclusive = false.
-        Return 0 for address count, and 0.0.0.0 for each of the addresses
-      </action>
-      <action issue="NET-395" dev="sebb" type="update">
-        Move ProtocolCommandSupport to SocketClient.
-      </action>
-      <action issue="NET-393" dev="sebb" type="update">
-        Should the sendCommandWithID() methods be public?
-        Made methods private, and deleted currently unused ones.
-      </action>
-      <action issue="NET-394" dev="sebb" type="update">
-        Are the sendUntaggedCommand() methods needed?
-        Renamed the method as sendData(), as it's not a command.
-      </action>
-      <action issue="NET-392" dev="sebb" type="update">
-        Use enum for IMAPCommand.
-      </action>
-      <action issue="NET-333" dev="sebb" type="add" due-to="Bogdan Drozdowski" due-to-email="bogdandr # op . pl">
-        Added basic IMAP/IMAPS implementation.
-      </action>
-      <action issue="NET-389" dev="sebb" type="fix">
-        Unix parser should ignore "total nnn" lines.
-      </action>
-      <action issue="NET-369" dev="sebb" type="remove">
-        Article.addHeaderField() is currently write-only - there is no way to retrieve the headers - is it needed?
-        Method was removed, along with the field.
-      </action>
-      <action issue="NET-367" dev="sebb" type="fix">
-        ntp.TimeStamp uses incorrect lazy initialisation of static fields simpleFormatter and utcFormatter.
-      </action>
-      <action issue="NET-381" dev="sebb" type="update">
-        Parsing is inefficient, as it parses everything twice.
-      </action>
-      <action issue="NET-388" dev="sebb" type="fix">
-        VMSVersioningFTPEntryParser#preParse should not call super.preParse().
-      </action>
-      <action issue="NET-362" dev="sebb" type="fix">
-        TelnetInputStream has various threading bugs.
-      </action>
-      <action issue="NET-89" dev="sebb" type="fix">
-        TelnetClient use of FromNetASCIIInputStream and ToNetASCIIOutputStream breaks binary mode.
-        See also NET-387.
-      </action>
-      <action issue="NET-385" dev="sebb" type="update">
-        FTP does not apply timeout to initial responses.
-      </action>
-      <action issue="NET-384" dev="sebb" type="update">
-        KeyManagerUtils - the KeyManager is not efficient.
-      </action>
-      <action issue="NET-383" dev="sebb" type="update">
-        KeyManagerUtils - allow alias to be omitted when there is only one private key in the store
-      </action>
-      <action issue="NET-326" dev="sebb" type="add">
-        A KeyManager is required when the protection level is set to 'P' with FTPSClient on active mode.
-        Added KeyManagerUtils class to simplify provision of client certificates.
-      </action>
-      <action issue="NET-273" dev="sebb" type="add">
-        FEAT response parsing. Added FTPClient methods: boolean hasFeature(feature [,option]),
-        String fetaureValue(feature), String[] featureValues(feature)
-      </action>
-      <action issue="NET-379" dev="sebb" type="add">
-        FTPClient - support for processing arbitrary commands that only use the control channel
-      </action>
-      <action issue="NET-378" dev="sebb" type="add">
-        FTP listing should support MLST and MLSD.
-      </action>
-      <action issue="NET-377" dev="sebb" type="update">
-        NLST does not take notice of HiddenFiles setting.
-      </action>
-      <action issue="NET-373" dev="sebb" type="update">
-        NNTP Listgroups not working - broken server implementation.
-      </action>
-      <action issue="NET-375" dev="sebb" type="update">
-        DotTerminatedMessageReader should extend BufferedReader, rather than Reader.
-      </action>
-      <action issue="NET-374" dev="sebb" type="update">
-        ParserInitializationException doesn't use standard JDK exception chaining
-      </action>
-      <action issue="NET-372" dev="sebb" type="add">
-        FTPSClient: java.security.cert.CertificateException: No X509TrustManager implementation available if trustManager == null
-      </action>
-      <action issue="NET-371" dev="sebb" type="add">
-        Create TrustManagerFactory to provide custom TrustManagers.
-      </action>
-      <action issue="NET-354" dev="sebb" type="fix" due-to="Leif John Korshavn">
-        FTPSClient not properly supporting CCC and PROT P.
-      </action>
-      <action issue="NET-368" dev="sebb" type="update">
-        Threader.thread should accept an Iterable rather than a List.
-      </action>
-      <action issue="NET-327" dev="sebb" type="add" due-to="Bogdan Drozdowski" due-to-email="bogdandr # op . pl">
-        "Unconnected sockets not implemented" when using FTPSClient
-        Added disconnect() override which resets the socket factories to their defaults
-      </action>
-      <action issue="NET-350" dev="sebb" type="add" due-to="Bogdan Drozdowski" due-to-email="bogdandr # op . pl">
-        "java.net.SocketException: Broken pipe" when calling "TelnetClient.sendAYT()"
-        Added SocketClient#isAvailable() method to perform additional checks on a socket.
-      </action>
-      <action issue="NET-237" dev="sebb" type="add">
-        Add streaming methods (corresponding to array methods) to NNTPClient.
-      </action>
-      <action issue="NET-365" dev="sebb" type="fix">
-        FTPClient.listFiles() does not work properly, if remote server speaks German.
-        Match non-space{3} instead of A-Za-z{3}
-      </action>
-      <action issue="NET-366" dev="sebb" type="fix">
-        FTPClientConfig: setServerLanguageCode and setShortMonthNames do not work.
-        Ensure that config is passed to all parsers that can use it.
-      </action>
-      <action issue="NET-276" dev="sebb" type="fix">
-        NNTPClient has problems with group listings for large groups.
-      </action>
-      <action issue="NET-185" dev="sebb" type="fix">
-        Possible NPE in Threader.java
-      </action>
-      <action issue="NET-364" dev="sebb" type="fix">
-        nntp.Article is very inefficient and incorrect.
-      </action>
-      <action issue="NET-314" dev="sebb" type="add" due-to="Bogdan Drozdowski" due-to-email="bogdandr # op . pl">
-        The FTP client should autodetect the control encoding.
-      </action>
-      <action issue="NET-363" dev="sebb" type="fix" due-to="daniel damon">
-        Can't connect to a server behind firewall in passive mode.
-      </action>
-      <action issue="NET-348" dev="sebb" type="fix">
-        Queue is full TelnetInputStream.
-      </action>
-      <action issue="NET-361" dev="sebb" type="add">
-        Implement Telnet Command sender.
-      </action>
-      <action issue="NET-345" dev="sebb" type="fix" due-to="Archie Cobbs">
-        Telnet client: not properly handling IAC bytes within subnegotiation messages:
-        - failing to double IACs on output
-        - failing to de-double IACs in input
-      </action>
-      <action issue="NET-343" dev="sebb" type="add" due-to="Archie Cobbs">
-        Telnet client: Support Client-initiated Subnegotiation Messages.
-      </action>
-      <action issue="NET-344" dev="sebb" type="add" due-to="Archie Cobbs">
-        Telnet client: Support Listener Notification of Incoming Data.
-      </action>
-      <action issue="NET-270" dev="sebb" type="fix">
-        Incorrect error handling in method initiateListParsing of FTPClient.
-      </action>
-      <action issue="NET-352" dev="sebb" type="add" due-to="Bogdan Drozdowski" due-to-email="bogdandr # op . pl">
-        SASL PLAIN and CRAM-MD5 authentication.
-      </action>
-      <action issue="NET-357" dev="sebb" type="add" due-to="Bogdan Drozdowski" due-to-email="bogdandr # op . pl">
-        The POP3 client does not support SSL/TLS connections.
-      </action>
-      <action dev="sebb" type="remove">
-        Removed deprecated unused fields from FTPSClient:
-        - KEYSTORE_ALGORITHM, PROVIDER, STORE_TYPE, TRUSTSTORE_ALGORITHM
-      </action>
-      <action issue="NET-258" dev="sebb" type="fix">
-        Implement A Keepalive Mechanism. Control channel keepalive implemented for the following methods:
-        appendFile, storeFile, storeUniqueFile, retrieveFile.
-      </action>
-      <action issue="NET-289" dev="sebb" type="fix" due-to="Luc Claes">
-        StackOverflowError in Threader.
-      </action>
-      <action issue="NET-317" dev="sebb" type="fix">
-        POP3MessageInfo fields should be final.
-      </action>
-      <action issue="NET-252" dev="sebb" type="fix">
-        Get rid of using deprecated API in VMSFTPEntryParser.
-      </action>
-      <action issue="NET-330" dev="sebb" type="remove">
-        The method VMSFTPEntryParser.parseFileList(InputStream listStream) should not be present.
-      </action>
-      <action issue="NET-303" dev="sebb" type="fix">
-        FTPFileEntryParser API samples are wrong.
-      </action>
-      <action issue="NET-229" dev="sebb" type="add">
-        Use properties file (/systemType.properties) to handle new OS-type auto-detection.
-      </action>
-      <action issue="NET-332" dev="sebb" type="add">
-        Commons net ftp cannot handle unknown type parser and should allow override of parser through vm argument.
-        The system property "org.apache.commons.net.ftp.systemType" can be used to provide the system type.
-      </action>
-      <action issue="NET-286" dev="sebb" type="fix">
-        Unhandled SecurityException in DefaultFTPFileEntryParserFactory.createFileEntryParser when using applets.
-      </action>
-      <action issue="NET-360" dev="sebb" type="fix">
-        DefaultFTPFileEntryParserFactory.createFileEntryParser(String key) always tries to load a class.
-      </action>
-      <action issue="NET-156" dev="sebb" type="add">
-        New FTPClient method to retrieve all directory names in the current working directory.
-        Added methods listDirectories(), listDirectories(String path).
-      </action>
-      <action issue="NET-353" dev="sebb" type="add" due-to="Bogdan Drozdowski" due-to-email="bogdandr # op . pl">
-        The SMTPClient does not support authentication.
-      </action>
-      <action issue="NET-356" dev="sebb" type="add" due-to="Bogdan Drozdowski" due-to-email="bogdandr # op . pl">
-        The SMTP client does not support SSL/TLS connections.
-      </action>
-      <action issue="NET-358" dev="sebb" type="add">
-        Implement copy Listener in FTPClient file operations.
-      </action>
-      <action issue="NET-359" dev="sebb" type="fix">
-        CopyStreamAdapter unconditionally resets the CopyStreamEvent source and is inefficient.
-      </action>
-      <action issue="NET-355" dev="sebb" type="fix">
-        examples.nntp.NNTPUtils does not compile
-      </action>
-      <action issue="NET-351" dev="sebb" type="add" due-to="Bogdan Drozdowski" due-to-email="bogdandr # op . pl">
-        APOP authentication fails most of the time.
-        Fix by adding leading 0 if necessary.
-      </action>
-    </release>
-    <release version="2.2" date="Nov 22, 2010"
-      description="
-This is primarily a maintenance release, but it also includes new features and enhancements.
-
-  Users of version 2.0 are encouraged to upgrade to 2.2, as this release includes some important bug fixes.
-
-  See the detailed list of changes below for full description of all bug fixes and enhancements.
-
-">
-      <action issue="NET-334" dev="sebb" type="fix">
-        FromNetASCIIInputStream can throw a NullPointerException
-      </action>
-      <action issue="NET-341" dev="sebb" type="fix">
-        FTPClient.remoteAppend(String filename) uses STOR instead of APPE
-      </action>
-      <action issue="NET-339" dev="sebb" type="fix">
-        Incorrect parsing of timestamp on Windows CE
-        Fix parsing to allow for new-style DOS listing using 24hr clock rather than AM/PM
-      </action>
-      <action issue="NET-338" dev="sebb" type="add">
-        ftp.FTPClient.initiateListParsing(String parserKey, String pathname)
-        can call createFileEntryParser with null systemName.
-        Fix this by adding getSystemType() which does not return null, and deprecating getSystemName().
-      </action>
-      <action issue="NET-244" dev="sebb" type="add">
-        Add support for FTPFileFilter filters. New classes FTPFileFilter, FTPFileFilters, new methods:
-        FTPListParseEngine#getFiles(FTPFileFilter filter)
-        FTPClient.listFiles(String pathname, FTPFileFilter filter)
-      </action>
-      <action issue="NET-313" dev="sebb" type="fix">
-        Optionally enable EPSV with IPv4; Only send EPRT with IPv6.
-        Fix incorrect port used with EPRT. Allow activeMaxPort == activeMinPort in getActivePort() method.
-      </action>
-      <action issue="NET-328" dev="sebb" type="fix">
-        FromNetASCIIInputStream.read(byte[], int, int) may change length passed to superclass if not doing conversion
-      </action>
-      <action issue="NET-74" dev="sebb" type="add">
-        Testcase to show WindowSizeOptionHandler is working OK
-      </action>
-      <action issue="NET-330" dev="sebb" type="fix">
-        The method VMSFTPEntryParser.parseFileList(InputStream listStream) should not be present.
-        Partial fix - marked method as deprecated and to be removed
-      </action>
-      <action issue="NET-180" dev="sebb" type="fix">
-        Telnet EOR is "consumed" by TelnetInputStream when in BINARY transmission.
-        Send notification to TelnetNotificationHandler.
-      </action>
-      <action issue="NET-329" dev="sebb" type="fix">
-        TelnetInoutStream#__read() bug in the __receiveState handling for the _STATE_IAC state.
-      </action>
-      <action issue="NET-283" dev="sebb" type="fix">
-        SocketClient should ensure input and output streams are closed
-      </action>
-      <action issue="NET-302" dev="sebb" type="fix">
-        FTP: initiateListParsing should not cache entryParser
-      </action>
-      <action issue="NET-282" dev="rwinston" type="fix">
-        Improvement to isInRange method in SubnetUtil.SubnetInfo class
-      </action>
-      <action issue="NET-266" dev="rwinston" type="fix">
-        FTPClient.listFiles() corrupts file name in certain circumstances
-      </action>
-      <action issue="NET-264" dev="sebb" type="fix">
-        Telnet spyStream NullPointerException
-      </action>
-      <action dev="sebb" type="update">
-        Deprecated the following unused fields from org.apache.commons.net.ftp.FTPSClient:
-        KEYSTORE_ALGORITHM, PROVIDER, STORE_TYPE, TRUSTSTORE_ALGORITHM
-      </action>
-      <action dev="niallp" type="fix">
-        Fix site reports
-      </action>
-      <action issue="NET-285" dev="rwinston" type="fix">
-        Add support for setting external host ip/port range
-      </action>
-      <action issue="NET-290" dev="rwinston" type="fix">
-        Add fix and testcase for DotTerminatedMessageReader
-      </action>
-      <action issue="NET-288" dev="rwinston" type="fix">
-        Add support for IPv6 EPRT/EPSV
-      </action>
-      <action issue="NET-305" dev="rwinston" type="fix">
-        Fix SubnetUtils for /32 subnets and add inclusive host count flag
-      </action>
-      <action issue="NET-300" dev="rwinston" type="fix">
-        Fix NPE when listHiddenFiles was on
-      </action>
-      <action issue="NET-215" dev="rwinston" type="fix">
-        UNIXFTPEntryParser didn't preserve trailing whitespace in files
-      </action>
-      <action issue="NET-236" dev="rwinston" type="fix">
-        method SubnetUtils.SubnetInfo.isInRange(addr) returns incorrect result
-      </action>
-      <action issue="NET-242" dev="rwinston" type="fix">
-        Method createServerSocket of FTPSSocketFactory never called and thus UseClientMode is incorrect in a secured ftp transfer
-        using active mode.
-      </action>
-      <action issue="NET-248" dev="rwinston" type="fix">
-        Fix inconsistent command list in FTPCommand
-      </action>
-      <action issue="NET-250" dev="rwinston" type="fix">
-        DefaultFTPFileEntryParserFactory did not work with Netware FTP server returning "NETWARE TYPE: L8"
-      </action>
-      <action issue="NET-257" dev="rwinston" type="fix">
-        FTP.getReplyStrings() returned array of null Strings
-      </action>
-      <action issue="NET-259" dev="rwinston" type="fix">
-        UnixFTPEntryParser regex did not match some directory entries
-      </action>
-      <action issue="NET-260" dev="rwinston" type="fix">
-        SubnetUtils.SubnetInfo.isInRange(...) returned incorrect values
-      </action>
-      <action issue="NET-261" dev="rwinston" type="update">
-        SubnetUtils.SubnetInfo.isInRange(...) behavior not documented
-      </action>
-      <action issue="NET-262" dev="rwinston" type="fix">
-        SubnetUtils did not handle /31 and /32 CIDRs well
-      </action>
-      <action issue="NET-265" dev="rwinston" type="fix">
-        UnixFTPEntryParser failed to parse entry in certain conditions
-      </action>
-      <action issue="NET-266" dev="rwinston" type="fix">
-        FTPClient.listFiles() corrupted file name in certain circumstances
-      </action>
-      <action issue="NET-251" dev="rwinston" type="update">
-        Moved class "ThreadContainer" from Threader.java into its own source file
-      </action>
-      <action issue="NET-256" dev="rwinston" type="fix">
-        FTPSClient should accept a pre-configured SSLContext
-      </action>
-      <action issue="NET-263" dev="rwinston" type="add">
-        SubnetUtils / SubNetInfo toString() implementations
-      </action>
-      <action dev="rwinston" type="fix">
-        Improve NNTPClient handling of invalid articles
-      </action>
-      <action dev="rwinston" type="update">
-        Refactor examples package.
-      </action>
-      <action dev="sebb" type="add">
-        Javadoc fixes, improvements, and refactoring.
-      </action>
-      <action issue="NET-245" dev="rwinston" type="fix">
-        Apply MFMT patch
-      </action>
-      <action issue="NET-279" dev="rwinston" type="fix">
-        Fix copying of reply lines collection
-      </action>
-      <action issue="NET-277" dev="rwinston" type="fix">
-        Fix incorrect NNTP constant
-      </action>
-      <action issue="NET-274" dev="rwinston" type="fix">
-        Restore socket state after CCC command
-      </action>
-      <action issue="NET-275" dev="rwinston" type="fix">
-        Example code in FTPClient doesn't compile
-      </action>
-      <action dev="rwinston" type="fix">
-        Fix inconsistent handling of socket read/write buffer size
-      </action>
-      <action issue="NET-294" dev="sebb" type="fix">
-        UnixFTPEntryParser fails to parse some entries
-      </action>
-    </release>
-
-    <release version="2.1" description="Not released" />
-
-    <release version="2.0" date="October 20, 2008" description="Java 5.0 release">
-      <action dev="rwinston" type="fix" issue="NET-307">
-        One of the "connect" method in class org.apache.commons.net.SocketClient doesn't handle connection timeout properly
-      </action>
-      <action dev="rwinston" type="update">
-        Add null check in TelnetClient::disconnect().
-      </action>
-      <action dev="rwinston" type="remove">
-        Remove deprecated FTPFileIterator and FTPFileList classes.
-      </action>
-      <action dev="rwinston" type="add">
-        Add connection timeout functionality to SocketClient.
-      </action>
-      <action dev="rwinston" type="update">
-        Make the KeyManager and TrustManager settable (niklas@protocol7.com).
-      </action>
-      <action dev="rwinston" type="update">
-        Patch FTPSClient to set default SSLServerSocketFactory. Thanks niklas@protocol7.com
-      </action>
-      <action dev="rwinston" type="fix" issue="NET-68">
-        Patch to prevent TFTPClient dropping last packet. Thanks palm@poplarware.com
-      </action>
-      <action dev="rwinston" type="update">
-        Change isConnected() method to delegate to underlying socket connection.
-      </action>
-      <action dev="rwinston" type="add">
-        FTPS (TLS and SSL) is now supported. Thanks to Jose Juan Montiel, Paul Ferraro, and Satoshi Ishigami.
-      </action>
-      <action dev="rwinston" type="update">
-        Commons::Net now uses Maven 2. The project.xml has been replaced with a pom.xml, and the source tree layout
-        has been changed accordingly.
-      </action>
-      <action dev="rwinston" type="remove">
-        Removed old ftp2 proposal directories.
-      </action>
-      <action dev="rwinston" type="update">
-        Commons::Net now uses JDK regex functionality, saving on an extra [oro] dependency. There are now
-        no external dependencies required.
-      </action>
-      <action dev="rwinston" type="fix">
-        Various syntactic issues (FindBugs issues, JDK 5.0 generics support)
-      </action>
-      <action dev="dfs" type="fix">
-        Applied Rob Hasselbaum's
-        rhasselbaum -> alumni.ithaca.edu
-        patch for PR 38688 fixing a
-        TelnetInputStream hang.
-      </action>
-      <action dev="dfs" type="update">
-        Exposed control connection of FTP
-        class via _controlInput_ and _controlOutput_
-        protected member variables in response
-        to PR 38309 reported by
-        josejuan.montiel@gmail.com.
-      </action>
-      <action dev="dfs" type="fix">
-        Reverted PR 32859 patch to TFTPClient
-        because it caused final packets to not
-        be sent.
-      </action>
-      <action dev="rwinston" type="update" issue="NET-36">
-        Make FTPClient extend SocketClient instead of TelnetClient. From jhindsley@providerlink.com
-      </action>
-      <action dev="rwinston" type="fix" issue="NET-39">
-        Adds an "e" symbolic link flag to the Unix FTP parser. From denisgaebler@netscape.net
-      </action>
-      <action dev="rwinston" type="fix" issue="NET-119">
-        Allow hidden files to be listed. Thanks to mario@ops.co.at
-      </action>
-      <action dev="rwinston" type="update">
-        Remove reflective check for Socket::isConnected() (no longer needed)
-      </action>
-      <action dev="rwinston" type="add" issue="NET-136">
-        Added WindowSizeOptionHandler for TelnetClient. Thanks to yuvalkashtan@gmail.com
-      </action>
-      <action dev="rwinston" type="update">
-        Refactored *Client classes under net/ package into separate subpackages, and move PrintCommandListener
-        out of the examples/ package.
-      </action>
-      <action dev="rwinston" type="add">
-        Added an ant target to the Maven build to generate an FTP-only jar file, for clients who
-        wish to use only FTP-based functionality.
-      </action>
-      <action dev="rwinston" type="update">
-        Custom SocketFactory interface has been replaced with the JDK SocketFactory implementation. Added
-        ServerSocketFactory instance to SocketClient.
-      </action>
-      <action dev="rwinston" type="update">
-        Removed redundant FTP.IMAGE_FILE_TYPE flag.
-      </action>
-      <action dev="rwinston" type="update">
-        Added heavily updated MVSFTPEntryParser from henrik.sorensen@balcab.ch
-      </action>
-      <action dev="rwinston" type="remove">
-        Removed deprecated classes FTPFileListParser, FTPFileListParserImpl, and DefaultFTPFileListParser. Also
-        removed associated deprecated methods from FTPClient.
-      </action>
-      <action dev="rwinston" type="fix" issue="NET-164">
-        Added encoding to FingerClient. From Ulrich Mayring.
-      </action>
-      <action dev="rwinston" type="fix" issue="NET-24">
-        Catch BindException in RCommandClient::connect().
-      </action>
-      <action dev="rwinston" type="fix" issue="NET-178">
-        Add encoding specifier to SMTPClient.
-      </action>
-      <action dev="rwinston" type="add">
-        Add setters for socket send/receive buffer size to SocketClient.
-      </action>
-      <action dev="rwinston" type="fix" issue="NET-177">
-        Fix PASV specifiers that broke previously. From Chris Eagle.
-      </action>
-      <action dev="rwinston" type="fix" issue="NET-182">
-        Catch NPE in FTP parser factory method.
-      </action>
-      <action dev="rwinston" type="fix" issue="NET-172">
-        Don't bind a UDP socket to NTP protocol port.
-      </action>
-      <action dev="rwinston" type="fix">
-        Better handling of user and group names with embedded spaces in FTP listings.
-      </action>
-      <action dev="rwinston" type="fix" issue="NET-173">
-        Add configurable multiline parsing.
-      </action>
-      <action dev="rwinston" type="fix" issue="NET-188">
-        Add fix for broken leap year date parsing.
-      </action>
-      <action dev="rwinston" type="add">
-        Add SubnetUtils class (suggested by Kenny McLeod)
-      </action>
-      <action dev="rwinston" type="fix" issue="NET-169">
-        Add Unix-type handling for UNKNOWN Type: L8 syst() message systems.
-      </action>
-      <action dev="rwinston" type="fix" issue="NET-198">
-        Allow FTPTimestampParserImpl to take a predefined Calendar instance representing current time.
-      </action>
-      <action dev="sebb" type="fix" issue="NET-194">
-        Replace Exception with IOException
-      </action>
-      <action dev="sebb" type="update" issue="NET-214">
-        VMS file permission parsing
-      </action>
-      <action dev="sebb" type="fix" issue="NET-208">
-        TelnetInputStream swallows interruptedexception as IOException
-      </action>
-      <action dev="sebb" type="fix" issue="NET-223">
-        the data connection socket is not closed when an IOException occurred
-      </action>
-      <action dev="sebb" type="fix" issue="NET-230">
-        ParserInitializationException when connecting to a Unix FTP server: comparison string must be upper case
-      </action>
-      <action dev="sebb" type="fix" issue="NET-225">
-        FTPFileEntryParserImpl.preParse() doesn't remove unparsable entries at the end of the file list
-      </action>
-    </release>
-
-
-    <!-- 1.5.0 has not yet been released, so comment out the section until it is ready for release -->
-    <!-- <release version="1.5.0" date="" description=""> <action dev="dfs" type="fix" issue="NET-3"> TelnetInputStream.java: 
-      Applied Rob Hasselbaum's rhasselbaum@alumni.ithaca.edu patch for PR 38688 fixing a TelnetInputStream hang. </action> <action 
-      dev="rwinston" type="fix" issue="NET-73"> TelnetInputStream.java: Fixing another potential deadlock for telnet and FTP (patch 
-      courtesy Rob Hasselbaum). </action> <action dev="dfs" type="update" issue="NET-57"> FTP.java: Exposed control connection 
-      of FTP class via _controlInput_ and _controlOutput_ protected member variables in response to PR 38309 reported by josejuan.montiel@gmail.com. 
-      </action> <action dev="rwinston" type="fix" issue="NET-68"> TFTPClient.java: Fix bug causing final packets to not be sent. 
-      </action> <action dev="rwinston" type="fix" issue="NET-161"> TFTPClient.java: Fix sendFile() (related to NET-68). </action> 
-      <action dev="rwinston" type="fix" issue="NET-181"> TFTPClient.java: block number wraparound. </action> <action dev="scohen" 
-      type="fix" issue="NET-16"> UNIXFTPEntryParser.java: support for group names with spaces (patch courtesy D. Kilzer). </action> 
-      <action dev="scohen" type="fix" issue="NET-62"> DefaultFTPFileEntryParserFactory.java: Wrap NoClassDefFoundError in FTP parser 
-      exception when ORO is not available. </action> <action dev="rwinston" type="add" issue="NET-33"> FTPClient.java: Fix closing 
-      FTP ServerSocket after timeout </action> <action dev="rwinston" type="add"> FTPClientConfig.java: Added an FTP parser for 
-      Netware FTP servers. Tested on Novell Netware 6.5. </action> <action dev="rwinston" type="fix" issue="NET-188"> FTPTimestampParserImpl.java: 
-      Fix leap year date parsing bug. </action> <action dev="rwinston" type="fix"> Article.java: Fix minor issues with NNTP parsing. 
-      </action> </release> -->
-
-
-    <release version="1.4.1" date="December 3, 2005" description="fix release to restore jdk 1.3 compatability">
-      <action dev="scohen" type="fix">
-        Applied patches for defect 37113. Code incompatible with jdk 1.3. Original patch submitted by Andrea Rombald
-      </action>
-      <action dev="scohen" type="fix">
-        Applied patches for defect 37522. updated project.xml to correct compatibility level.
-      </action>
-    </release>
-
-    <release version="1.4.0" date="May 7, 2005" description="Some additions and enhancements">
-      <action dev="dfs" type="fix">
-        Fixed typo in method name.
-        FTP.removeCommandListener() was missing
-        the L. Problem reported by
-        Per.Lindberger@linkon.se.
-      </action>
-      <action dev="rwinston" type="fix">
-        Applied fix for PR 33942 and PR 31793. Original patch submitted by mario@ops.co.at
-      </action>
-      <action dev="rwinston" type="fix">
-        TFTPClient was ignoring final ACK (PR 32859). Thanks to perttu.auramo@ekahau.com
-      </action>
-      <action dev="rwinston" type="fix">
-        Applied fix for ACL parsing in the FTP client (PR 33972). Submitted by robertalasch@yahoo.com
-      </action>
-      <action dev="rwinston" type="fix">
-        Added missing NTP/SNTP unit tests to the codebase.
-      </action>
-      <action dev="dfs" type="fix">
-        Applied fix for POP3Client returning empty reply strings (PR 34133). Thanks to sammy_c@lineone.net
-      </action>
-      <action dev="rwinston" type="fix">
-        NTP port parameter was being ignored (PR 34219). Fixed by felix.eichhorn@3soft.de
-      </action>
-      <action dev="scohen" type="add">
-        An FTP parser for MVS was added. Submitted by wnoto@openfinance.com
-      </action>
-      <action dev="scohen" type="add">
-        Added functionality for extensible parsing of FTP responses, using a configurable format string. This should enable the
-        FTP client to operate across many different locales and date formats.
-      </action>
-    </release>
-
-    <release version="1.3.0" date="December 15, 2004" description="many fixes and enhancements">
-      <action dev="rwinston" type="fix">
-        Applied patch for PR 31793. Thanks to mario@ops.co.at
-      </action>
-      <action dev="rwinston" type="add">
-        Added message threading functionality to the NNTP client.
-      </action>
-      <action dev="rwinston" type="update">
-        Added return code 521 to FTPReply.java - this should obviate the need for the Ant FTP task to manually declare it.
-      </action>
-      <action dev="rwinston" type="fix">
-        Add explicit notify() in TelnetInputStream::read(), so available() returns an accurate value. Thanks to
-        tpalkot@gmail.com.
-      </action>
-      <action dev="rwinston" type="add">
-        Added SNTP/NTP components into the Commons-Net codebase, courtesy of
-        Jason Matthews.
-      </action>
-      <action dev="rwinston" type="add">
-        Added POP3 test suite, courtesy of Mike George mike.george@comcast.net.
-      </action>
-      <action dev="scohen" type="fix">
-        Applied fix for FTPClient returning null for certain timestamp formats (BUG #30737)
-      </action>
-      <action dev="rwinston" type="fix">
-        Build.xml fixes - dont include example classes in redistributable
-        .jar, remove test dependency from javadoc target, and exclude private members from generated javadoc.
-      </action>
-      <action dev="rwinston" type="fix">
-        Fixed bug in TFTPClient::setMaxTimeout(), spotted by steve@widge.net
-      </action>
-      <action dev="dfs" type="fix">
-        Some changes to facilitate compilation under JDK 5.0
-      </action>
-      <action dev="rwinston" type="fix">
-        Return correct NNTP article count when high and low watermarks are 0.
-        Spotted by jmordax@terra.es
-      </action>
-      <action dev="rwinston" type="fix">
-        Remove trailing null byte in TFTP packets. Thanks to gerard.dens@alcatel.be
-      </action>
-      <action dev="dfs" type="fix">
-        Many javadoc fixes.
-      </action>
-      <action dev="rwinston" type="update">
-        Allow FTPClient to set transfer buffer size.
-      </action>
-      <action dev="rwinston" type="update">
-        Ensure consistent handling of encoding throughout FTPClient
-        operations. Patch submitted by leif@tanukisoftware.com.
-      </action>
-      <action dev="dfs" type="fix">
-        Fix TelnetClient zombie thread issue
-      </action>
-
-
-    </release>
-    <release version="1.3.0-dev" date="July 28, 2004" description="regression fix">
-      <action dev="dfs" type="fix">
-        Fixed regression from migration to new parsers. Most of the
-        new parsers parsed the file size as an integer instead of a
-        long. Changed all of them to set the size to long. This
-        problem was detected by the reporter of:
-        https://issues.apache.org/bugzilla/show_bug.cgi?id=30345
-      </action>
-    </release>
-    <release version="1.2.2" date="June 25, 2004" description="fix release">
-      <action dev="scohen" type="fix">
-        fixed bug in the way FTPClient.listFiles worked when a directory was not
-        specified. Current directory was not being 'remembered'. This was most
-        problematic in the dependent ftp task of Ant.
-      </action>
-      <action dev="scohen" type="fix">
-        fixed handling of certain unusual "special" file types in the Unix parser.
-      </action>
-    </release>
-
-    <release version="1.2.1" date="May 6, 2004" description="fix release">
-      <action dev="scohen" type="fix">
-        changed code that rendered package uncompilable under JDK 1.2
-      </action>
-    </release>
-
-    <release version="1.2.0" date="April 30, 2004" description="autodetection of system for listings">
-      <action dev="scohen" type="fix">
-        Mario Ivankovits mario@ops.co.at added
-        functionality supporting correct handling of the &quot;dirstyle&quot;
-        attribute of NT and OS400 servers that allows them to mimic Unix ftp servers.
-        and a bug fix affecting handling of sticky and suid bits on Unix FTP servers.
-      </action>
-      <action dev="scohen" type="add">
-        Mario Ivankovits mario@ops.co.at added parser for OS400.
-      </action>
-      <action dev="jbrekke,scohen" type="fix">
-        Added a functional junit test testing list parsing against real servers
-        and fix several bugs found through this test.
-      </action>
-      <action dev="dfs" type="add">
-        Ted Wise ctwise@bellsouth.net provided a
-        patch to add the XHDR extended NNTP command.
-      </action>
-      <action dev="scohen,dfs" type="update">
-        Deprecated FTPFileListParser interface, DefaultFTPFileListParser
-        class, and the FTPClient.listFiles methods that accepted an
-        FTPFileListParser parameter. These deprecated classes and methods
-        will be removed in version 2.0.
-      </action>
-      <action dev="scohen" type="add">
-        Added org.apache.commons.net.parser.FTPFileEntryParserFactory
-        interface and a default implementation:
-        DefaultFTPFileEntryParserFactory. This addition facilitates the
-        autodetection of which FTPFileEntryParser to use to generate
-        listings. FTPClient.listFiles methods were added that implement
-        autodetection.
-      </action>
-    </release>
-
-    <!-- Not yet released; probably never will be <release version="1.1.1" date="TBD" description="last jdk1.1 compatible 
-      release"> <action dev="scohen" type="fix"> Removed all JDK 1.1 incompatibilities that had been introduced unintentionally 
-      in previous versions. Release 1.1.1 is the last JDK 1.1 compatible release. Any future 1.1.x maintenance releases will remain 
-      JDK !.1 compatible, but version 1.2 may break compatibility and will be guaranteed to work with only J2SE 1.2 and later. 
-      </action> </release> -->
-    <release version="1.1.0" date="October 23, 2003" description="many enhancements and bug fixes">
-      <action dev="dfs" type="add">
-        Rory Winston Rory.Winston@telewest.co.uk provided
-        patches to add the following extended NNTP commands to
-        NNTPClient: XOVER, AUTHINFO USER, AUTHINFO PASS, and
-        LIST ACTIVE.
-      </action>
-      <action dev="dfs" type="fix">
-        Changed connection hooks for FTP, SMTP, POP3, and NNTP classes
-        to force use of an 8-bit US-ASCII superset (ISO-8859-1) for
-        protocol communication. This was necessary because
-        InputStreamReader and OutputStreamWriter use the default
-        client-side character set encoding. fasselin@ca.ibm.com
-        reported failure of SMTP on OS/390 which has EBCDIC as the
-        native character set.
-      </action>
-
-      <action dev="dfs" type="fix">
-        Applied variation of fix suggested by Matthieu Recouly
-        matthieu.recouly@laposte.net so that
-        UnixFTPEntryParser may handle listings of the form:
-        "drwxr-xr-x 1 usernameftp 512 Jan 29 23:32 prog"
-        where the space between user name and group is omitted.
-      </action>
-      <action dev="dfs" type="fix">
-        Applied patch from Stephane Este-Gracias
-        sestegra@free.fr that fixes the parsing of
-        VMS listings by VMSFTPEntryParser..
-      </action>
-      <action dev="brekke" type="fix">
-        If the buffer queue run full, the run() method sometimes hangs forever.
-        Changed wait() to wait(100) as with other changes in TelnetInputStream.
-        Fix submitted From: J. Matysiak ( j.matysiak@cenit.de ).
-      </action>
-      <action dev="brekke" type="fix">
-        FTP.smnt(String dir) was not passing on the dir to the SMNT command as an argument.
-      </action>
-      <action dev="brekke" type="add">
-        Added a link to the FAQ currently hosted on the Apache Wiki.
-      </action>
-      <action dev="dfs" type="update">
-        Changed package private NNTP._reader and NNTP._writer member
-        variables to protected NNTP._reader_ and NNTP._writer_
-        variables as suggested by issue report 16995 to facilitate
-        extending NNTPClient functionality in subclasses.
-      </action>
-      <action dev="dfs" type="update">
-        Changed name of FTPClient.__openDataConnection() to
-        FTPClient._openDataConnection_() to remain consistent
-        with the convention in the code that protected members
-        are of the form _foo_. At some point __openDataConnection()
-        had been changed from private to protected.
-      </action>
-      <action dev="brekke" type="add">
-        Added terminal option support to the telnet client with tests.
-        From Bruno D'Avanzo ( b.davanzo@inwind.it ).
-      </action>
-      <action dev="scohen" type="add">
-        New parsers merged with mainline with support for old list parsers.
-      </action>
-    </release>
-
-    <release version="1.0.0" date="February 23, 2003" description="first jakarta-commons release">
-      <action dev="brekke" type="add">
-        Added a migration document for moving from NetComponents to Commons/Net.
-      </action>
-      <action dev="brekke" type="fix">
-        Moved the ftp2 tree with tests to a proposal directory and setup
-        a build for that code. This can grow in this area so users don't
-        think it is production ready.
-      </action>
-      <action dev="dfs" type="fix">
-        Cleaned up license header on some source.
-      </action>
-      <action dev="dfs" type="fix">
-        Moved .io and .util to .net.io and .net.util in preparation for
-        1.0 release.
-      </action>
-      <action dev="dfs" type="fix">
-        Fixed typo in NNTP.removeProtocolCommandListener() method name. It
-        was missing an L. From: joev@atg.com.
-      </action>
-      <action dev="brekke" type="add">
-        Various site updates including this changes doc and publish
-        date information.
-      </action>
-      <action dev="dfs" type="fix">
-        Patch for restarting FTP file transfers. The offset was not
-        being sent immediately before the data transfer command on
-        account. The bug was apparently introduced in NetComponents
-        when it was decided to always send a PORT command before each data
-        transfer to avoid socket reuse problems on Windows.
-        From: Tapan Karecha ( tapan@india.hp.com ).
-      </action>
-      <action dev="dfs" type="fix">
-        Applied a fix for potential deadlock in TelnetInputStream by
-        changing a wait() to a wait(100).
-        From: Tapan Karecha ( tapan@india.hp.com ).
-      </action>
-      <action dev="dfs" type="update">
-        FTP examples now use passive ftp connections.
-      </action>
-    </release>
-  </body>
-</document>
+<!--
+
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to You under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+-->
+<!--
+This file is also used by the maven-changes-plugin to generate the release notes.
+Useful ways of finding items to add to this file are:
+
+1.  Add items when you fix a bug or add a feature (this makes the
+release process easy :-).
+
+2.  Do a JIRA search for tickets closed since the previous release.
+
+3.  Use the report generated by the maven-changelog-plugin to see all
+SVN commits. Set the project.properties' maven.changelog.range
+property to the number of days since the last release.
+
+To generate the release notes from this file:
+
+mvn changes:announcement-generate -Prelease-notes [-Dchanges.version=nnn]
+
+then tweak the formatting if necessary
+and commit
+
+The <action> type attribute can be add,update,fix,remove.
+-->
+
+<document>
+  <properties>
+    <title>Apache Commons Net Release Notes</title>
+    <author email="dev@commons.apache.org">Apache Commons developers</author>
+  </properties>
+
+    <!-- NOTE:
+    The description below is specially formatted so as to improve the layout of the generated release notes:
+    The parsing process removes all line feeds, replacing them with a single space.
+    The Velocity template in resources/templates has been enhanced to replace pairs of adjacent spaces
+    with a new-line in the release notes. (These spaces are ignored when displaying HTML).
+    If the output is not quite correct, check for invisible trailing spaces!
+
+    N.B. The release notes template groups actions by type, and only extracts data for the current release.
+    The changes report outputs actions in the order they appear in this file.
+
+    To regenerate the release notes:
+    mvn changes:announcement-generate -Prelease-notes [-Dchanges.version=nnn]
+
+    Defining changes.version allows one to create the RN without first removing the SNAPSHOT suffix.
+     -->
+
+  <body>
+    <release version="3.9.0" date="2021-MM-DD" description="Maintenance and bug fix release (Java 8).">
+      <!-- FIX -->
+      <action type="fix" issue="NET-708" dev="ggregory" due-to="XenoAmess">
+        Use yyyy instead of YYYY in SimpleDateFormat #97.
+      </action>
+      <action type="update" dev="sebb">
+        Prevent serialization of the 4 classes that implement Serializable.
+        It is not useful and is unlikely to work properly.
+      </action>
+      <action type="fix" dev="ggregory" due-to="Arturo Bernal">
+        Use Math.min and Math.max method instead of manual calculations. #104.
+      </action>
+      <!-- ADD -->
+      <action type="add" dev="ggregory" due-to="Gary Gregory">
+        [FTP] Add FTPClient.mdtmInstant(String).
+      </action>
+      <action type="add" dev="ggregory" due-to="Gary Gregory">
+        [FTP] Add MLSxEntryParser.parseGmtInstant(String).
+      </action>
+      <action type="add" dev="ggregory" due-to="Gary Gregory">
+        [FTP] Add FTPClient.getControlKeepAliveReplyTimeoutDuration().
+      </action>
+      <action type="add" dev="ggregory" due-to="Gary Gregory">
+        [FTP] Add FTPClient.setControlKeepAliveReplyTimeout(Duration).
+      </action>
+      <action type="add" dev="ggregory" due-to="Gary Gregory">
+        [FTP] Add FTPClient.getControlKeepAliveTimeoutDuration().
+      </action>
+      <action type="add" dev="ggregory" due-to="Gary Gregory">
+        [FTP] Add FTPClient.setControlKeepAliveTimeout(Duration).
+      </action>
+      <action type="add" dev="ggregory" due-to="Gary Gregory">
+        [FTP] Add FTPClient.getDataTimeout().
+      </action>
+      <action type="add" dev="ggregory" due-to="Gary Gregory">
+        [FTP] Add FTPClient.setDataTimeout(Duration).
+      </action>
+      <action type="add" dev="ggregory" due-to="Gary Gregory">
+        [FTP] Add FTPFile.getTimestampInstant().
+      </action>
+      <action type="add" dev="ggregory" due-to="Gary Gregory">
+        Add github/codeql-action.
+      </action>
+      <!-- UPDATE -->
+      <action type="update" dev="ggregory" due-to="Dependabot, Gary Gregory">
+        Bump actions/cache from 2.1.6 to 3.0.8 #93, #102.
+      </action>
+      <action type="update" dev="ggregory" due-to="Dependabot, Gary Gregory">
+        Bump actions/checkout from 2.3.4 to 3.0.2 #89, #91, #100.
+      </action>
+      <action dev="ggregory" type="update" due-to="Gary Gregory">
+        A actions/setup-java from 1.4.3 to 3.5.1.
+      </action>
+      <action type="update" dev="ggregory" due-to="Dependabot">
+        Bump junit from 4.13.1 to 5.9.1 Vintage #74.
+      </action>
+      <action type="update" dev="ggregory" due-to="Dependabot, Gary Gregory">
+        Bump commons-io from 2.6 to 2.11.0 #60.
+      </action>
+      <action dev="ggregory" type="update" due-to="Gary Gregory">
+        Bump commons.jacoco.version from 0.8.6 to 0.8.8.
+      </action>
+      <action dev="ggregory" type="update" due-to="Gary Gregory">
+        Bump commons.japicmp.version from 0.14.3 to 0.16.0.
+      </action>
+      <action dev="ggregory" type="update" due-to="Gary Gregory">
+        Bump commons.surefire.version from 2.22.2 to 3.0.0-M7.
+      </action>
+      <action type="update" dev="ggregory" due-to="XenoAmess, Gary Gregory">
+        Bump ftpserver-core from 1.1.1 to 1.2.0 #96.
+      </action>
+      <action type="update" dev="ggregory" due-to="Dependabot">
+        Bump exec-maven-plugin from 3.0.0 to 3.1.0 #109.
+      </action>
+      <action type="update" dev="ggregory" due-to="Dependabot">
+        Bump commons-parent from 53 to 54 #112
+      </action>
+    </release>
+    <release version="3.8.0" date="2021-02-13" description="Maintenance and bug fix release (Java 7).">
+      <!-- ADD -->
+      <action type="add" dev="ggregory" due-to="Arturo Bernal, Gary Gregory">
+        Add and use NetConstants.
+      </action>
+      <action type="add" dev="ggregory" due-to="Gary Gregory">
+        Add and use SocketClient.applySocketAttributes().
+      </action>
+      <action type="add" dev="ggregory" due-to="Gary Gregory">
+        [FTP] Add FTPClient.hasFeature(FTPCmd).
+      </action>
+      <action type="add" dev="ggregory" due-to="Gary Gregory">
+        [FTP] Add FTPClient.mdtmCalendar(String).
+      </action>
+      <!-- FIX -->
+      <action type="fix" dev="ggregory" due-to="Gary Gregory">
+        [IMAP] Fix concurrent counting of chunks in IMAPExportMbox.
+      </action>
+      <action type="fix" dev="ggregory" due-to="Gary Gregory">
+        Fix possible if rare NPEs in tests.
+      </action>
+      <!-- UPDATE -->
+      <action type="update" dev="ggregory" due-to="Dependabot">
+        Bump actions/checkout from v2.3.3 to v2.3.4 #69.
+      </action>
+      <action issue="NET-685" type="update" dev="ggregory" due-to="Simo385">
+        Update SocketClient default connect timeout from ‚àû to 60 seconds #51.
+      </action>
+      <action issue="NET-695" type="update" dev="ggregory" due-to="Gary Gregory, Possibly Cott">
+        Apply SocketClient timeout after connection but before SSL negotiation.
+      </action>
+      <action type="update" dev="ggregory" due-to="Arturo Bernal, Gary Gregory">
+        Minor Improvements #71, #72.
+      </action>
+      <action type="update" dev="ggregory" due-to="Dependabot">
+        Bump actions/cache from v2 to v2.1.4 #73.
+      </action>
+    </release>
+    <release version="3.7.2" date="2020-10-14" description="Maintenance and bug fix release (Java 7).">
+      <action issue="NET-689" type="fix" dev="ggregory" due-to="Charlie, Gary Gregory">
+        Host name is not set on the SSLSocket causing isEndpointCheckingEnabled to fail.
+      </action>
+      <action type="fix" dev="ggregory" due-to="Dependabot">
+        Fix possible socket and input stream leak on socket exception in
+        org.apache.commons.net.ftp.FTPClient._retrieveFile(String, String, OutputStream).
+      </action>
+      <action issue="NET-690" type="fix" dev="ggregory" due-to="payal-meh, Gary Gregory">
+        Performance issue when using the FTPClient to retrieve files #65.
+      </action>
+      <action issue="NET-691" type="update" dev="ggregory" due-to="Lewis John McGibbney">
+        Improve Javadoc for IMAPSClient #68.
+      </action>
+      <!-- UPDATES -->
+      <action type="update" dev="ggregory" due-to="Dependabot">
+        Bump actions/setup-java from v1.4.2 to v1.4.3 #62.
+      </action>
+      <action type="update" dev="ggregory" due-to="Dependabot">
+        Bump junit from 4.13 to 4.13.1 #67.
+      </action>
+    </release>
+    <release version="3.7.1" date="2020-09-30" description="Maintenance and bug fix release (Java 7).">
+      <action issue="NET-687" type="fix" dev="ggregory" due-to="Gary Gregory, Mikael, j-verse">
+        [FTPS] javax.net.ssl.SSLException: Unsupported or unrecognized SSL message, #59.
+      </action>
+      <!-- UPDATES -->
+      <action type="update" dev="ggregory" due-to="Dependabot">
+        Update actions/checkout from v2.3.1 to v2.3.3 #56, #61.
+      </action>
+    </release>
+    <release version="3.7" date="2020-08-05"
+      description="
+This is mainly a bug-fix release (Java 7). See further details below.
+
+ This release requires a minimum of Java 7.
+
+ This release is binary compatible with previous releases.
+ However it is not source compatible with releases before 3.4, as some methods were added to the interface NtpV3Packet in 3.4
+
+ Note that the examples packages were moved under org/apache/commons/net/examples.
+ The examples are not part of the public API, so this does not affect compatibility.
+
+">
+      <action issue="NET-673" type="fix" dev="sebb">
+        IMAPClient.APPEND does not always calculate the correct length
+      </action>
+      <action issue="NET-646" type="add" dev="sebb">
+        ALLO FTP Command for files >2GB
+      </action>
+      <action issue="NET-615" type="add" dev="sebb">
+        IMAPClient could simplify using empty arguments
+      </action>
+      <action issue="NET-614" type="add" dev="sebb">
+        IMAP fails to quote/encode mailbox names
+      </action>
+      <action issue="NET-643" type="fix" dev="sebb" due-to="Vasily">
+        NPE when closing telnet stream
+      </action>
+      <action issue="NET-648" type="add" dev="pschumacher">
+        Add Automatic-Module-Name MANIFEST entry for Java 9 compatibility
+      </action>
+      <action issue="NET-641" type="fix" dev="sebb" due-to="pin_ptr">
+        SubnetUtils.SubnetInfo.isInRange("0.0.0.0") returns true for CIDR/31, 32
+      </action>
+      <action issue="NET-638" type="add" dev="sebb" due-to="Daniel Leong">
+        Telnet subnegotiations hard-limited to 512 bytes - allow override
+      </action>
+      <action issue="NET-639" type="fix" dev="sebb" due-to=" Alexander Eller">
+        MVSFTPEntryParser.preParse - MVS, z/OS - allow for merged Ext/Used fields
+      </action>
+      <action issue="NET-636" type="fix" dev="sebb">
+        examples should be in org.apache.commons.net subpackage
+      </action>
+      <action issue="NET-634" type="add" dev="sebb" due-to="Mauro Molinari">
+        Add SIZE command support
+      </action>
+      <action type="add" dev="sebb">
+        Add POP3ExportMbox example code
+      </action>
+      <action issue="NET-633" type="update" dev="sebb" due-to="n0rm1e">
+        Add XOAUTH2 to IMAP and SMTP
+      </action>
+      <action issue="NET-632" type="update" dev="sebb" due-to="prakapenka">
+        FTPHTTPClient - support for encoding other than UTF-8
+      </action>
+      <action issue="NET-631" type="fix" dev="sebb">
+        Bug in MVSFTPEntryParser.parseUnixList (FindBugs)
+      </action>
+      <action issue="NET-584" type="fix" dev="sebb" due-to="Kazantsev Andrey Sergeevich/Nick Manley">
+        Error when using org.apache.commons.net.ftp.FTPClient setControlKeepAliveTimeout
+      </action>
+      <action issue="NET-626" type="update" dev="sebb" due-to="Makoto Sakaguchi">
+        SubnetUtils#SubnetUtils - improved comment
+      </action>
+      <action issue="NET-625" type="update" dev="sebb">
+        SubnetUtils - improve construction
+      </action>
+      <action issue="NET-624" type="update" dev="sebb" due-to="Makoto Sakaguchi">
+        SubnetInfo#getCidrSignature - improve functions
+      </action>
+      <action issue="NET-624" type="fix" dev="sebb" due-to="Makoto Sakaguchi">
+        SubnetInfo#toCidrNotation: A wrong format subnet mask is allowed
+      </action>
+      <action issue="NET-623" type="fix" dev="sebb" due-to="Makoto Sakaguchi">
+        SubnetUtils - fixed spelling errors
+      </action>
+      <action issue="NET-621" type="update" dev="sebb" due-to="Makoto Sakaguchi">
+        SubnetUtils#SubnetInfo - remove unnecessary accessors
+      </action>
+      <action issue="NET-619" type="update" dev="sebb" due-to="Makoto Sakaguchi">
+        SubnetUtils - improve binary netmask algorithm
+      </action>
+      <action issue="NET-613" type="fix" dev="sebb" due-to="Donald Kwakkel">
+        System Information Leak in ftp parser
+      </action>
+      <action issue="NET-678" type="update" dev="sebb" due-to="Roman Grigoriadi">
+        VMS ftp LIST parsing results in empty file list
+      </action>
+      <action issue="NET-674" type="add" dev="sebb" due-to="Chris Steingen">
+        FTPListParseEngine should support listing via MLSD
+      </action>
+      <action issue="NET-663" type="fix" dev="sebb" due-to="Max Shenfield">
+        NullPointerException when FTPClient remote verification fails
+      </action>
+      <action issue="NET-649" type="fix" dev="sebb" due-to="Filipe Bojikian Rissi">
+        227 Entering Passive Mode
+      </action>
+      <action issue="NET-660" type="add" dev="sebb" due-to="Nagabhushan S N">
+        Next and Previous IP Address in SubnetUtils.SubnetInfo
+      </action>
+      <action issue="NET-682" type="fix" dev="sebb" due-to="richard">
+        MVSFTPEntryParser doesn't support Record Formats of U
+      </action>
+    </release>
+    <release version="3.6" date="2017-02-15"
+      description="
+This is mainly a bug-fix release (Java 6). See further details below.
+
+
+ This release is binary compatible with previous releases.
+ However it is not source compatible with releases before 3.4, as some methods were added to the interface NtpV3Packet in 3.4
+
+  The code now requires a minimum of Java 6.
+
+  Changes to functionality:
+ * The FTP client now performs stricter checks on non-multiline command replies.
+  The 3 digit code must now be followed by a space and some text, as per RFC 959.
+  To suppress this stricter checking, call FTP#setStrictReplyParsing(false). This should not be needed with a well-behaved server.
+  Note also that if strict checking is disabled, some functions may unconditionally strip the next character after the code,
+without checking it if is a space.
+
+* The FTP client mlistFile() method now checks for a leading space before removing it.
+  If the space is missing, a MalformedServerReplyException is thrown.
+  This will only happen if the FTP server is not compliant with RFC 3659.
+
+  Notable additions:
+ * The POP3Mail examples can now get password from console, stdin or an environment variable.
+
+* TFTPClient code has been rewritten to improve error handling and retries.
+  
+">
+      <action issue="NET-613" type="fix" dev="sebb">
+        TFTPClient assumes that lastBlock == 0 only once
+      </action>
+      <action issue="NET-320" type="fix" dev="sebb" due-to="Kevin Bulebush">
+        Allow TFTPServer.java to bind to a specific network adapter
+      </action>
+      <action issue="NET-414" type="fix" dev="sebb" due-to="Chuck Wolber">
+        Apache Commons TFTP does not reject request replies that originate from a control port.
+      </action>
+      <action issue="NET-477" type="fix" dev="sebb" due-to="John Walton">
+        TFTP sendFile retry broken
+      </action>
+      <action issue="NET-612" type="update" dev="sebb">
+        Allow TFTP socket IO tracing
+      </action>
+      <action issue="NET-596" type="fix" dev="sebb" due-to="Vincent Bories-Azeau">
+        NullPointerException when disconnecting TelnetClient twice with JDK 7
+      </action>
+      <action issue="NET-602" type="fix" dev="sebb" due-to="Ross Braithwaite">
+        Failure to parse times from SYST_L8 systems that report as "WINDOWS Type: L8"
+      </action>
+      <action issue="NET-604" type="fix" dev="sebb" due-to="Frank Delporte">
+        TFTP send and receive don't have progress indication
+      </action>
+      <action issue="NET-588" type="fix" dev="sebb" due-to="Dave Nice / Thai H">
+        FTPClient.setPassiveNatWorkaround assumes host is outside site local range
+      </action>
+      <action issue="NET-610" type="fix" dev="sebb" due-to="Sergey Yanzin">
+        FTPClient.mlistFile incorrectly handles MLST reply
+      </action>
+      <action issue="NET-611" type="fix" dev="sebb">
+        FTP does not validate command reply syntax fully
+      </action>
+      <action issue="NET-609" type="fix" dev="sebb" due-to="Tqup3">
+        DefaultUnixFTPFileEntryParserFactory Issue (leading spaces removal configuration)
+      </action>
+      <action type="update" dev="sebb">
+        POP3Mail example: support host port; allow reading password from Console/stdin/environment
+      </action>
+      <action issue="NET-597" type="fix" dev="sebb" due-to="Hiroki Taniura">
+        FTP fails to parse listings for Solaris 10 FTPd in Japanese
+      </action>
+      <action issue="NET-599" type="update" dev="sebb">
+        Add shorthand FTPClientConfig constructor
+      </action>
+      <action issue="NET-593" type="fix" dev="sebb" due-to="Joerg Weule">
+        HostnameVerifier is called with ip addess instead of the provided hostname
+      </action>
+      <action issue="NET-594" type="fix" dev="sebb" due-to="Brad Worrral">
+        TelnetClient._closeOutputStream unhandled exception from FilterOutputStream.close
+      </action>
+      <action issue="NET-592" type="fix" dev="sebb" due-to="Mark Ford">
+        plainSocket in FTPSClient is never closed
+      </action>
+    </release>
+    <release version="3.5" date="2016-05-05"
+      description="
+This is mainly a bug-fix release (Java 6). See further details below.
+
+
+ This release is binary compatible with previous releases.
+ However it is not source compatible with releases before 3.4, as some methods were added to the interface NtpV3Packet in 3.4
+
+  The code now requires a minimum of Java 6.
+
+  Notable additions:
+  The IMAP examples can now get password from console, stdin or an environment variable.
+        ">
+      <action issue="NET-583" type="fix" dev="sebb" due-to="Holger Rehn">
+        FTPClient.getReplyString() returns wrong value after connect()
+      </action>
+      <action type="add" dev="sebb">
+        Alternative password input methods for IMAP examples
+      </action>
+      <action type="add" dev="sebb">
+        More tests for Feb 29 handling.
+      </action>
+      <action issue="NET-586" type="fix" dev="sebb">
+        Don't use Feb 29 for short future date tests
+      </action>
+      <action type="fix" dev="sebb">
+        Documentation tweaks
+      </action>
+    </release>
+    <release version="3.4" date="2015-11-26"
+      description="
+This is mainly a bug-fix release. See further details below.
+
+  This release is binary compatible with previous releases.
+  However it is not source compatible, as some methods have been added to the interface NtpV3Packet
+
+  Notable additions:
+  IMAPExportMbox (example app) allows IMAP folders to be exported into an mbox file.
+  This is the inverse of the IMAPImportMbox example added previously
+        ">
+      <action issue="NET-581" type="fix" dev="sebb">
+        SimpleSMTPHeader fails to supply the required Date: header
+      </action>
+      <action issue="NET-582" type="fix" dev="sebb">
+        SimpleSMTPHeader does not allow for missing To: field
+      </action>
+      <action issue="NET-580" type="fix" dev="sebb" due-to="Simon Arlott">
+        SMTPClient.sendSimpleMessage() silently ignores failed recipients
+        Update Javadoc
+      </action>
+      <action issue="NET-579" type="fix" dev="sebb" due-to="Simon Arlott">
+        SSL/TLS SocketClients do not verify the hostname against the certificate
+      </action>
+      <action issue="NET-576" type="update" dev="sebb">
+        Allow FTPClient to use SYST response if system type is not specified in configuration
+      </action>
+      <action issue="NET-575" type="update" dev="sebb">
+        FTPClientExample should support setting the date format
+      </action>
+      <action issue="NET-538" type="fix" dev="sebb" due-to="Dzmitry">
+        FTPHTTPClient should use socket factory to create sockets
+      </action>
+      <action issue="NET-566" type="fix" dev="sebb" due-to="Gary Russell">
+        UnixFTPEntryParser Drops Leading Spaces from File Names
+      </action>
+      <action type="update" dev="sebb">
+        examples/Main now uses a property file to define aliases instead of scanning class files
+      </action>
+      <action issue="NET-552" type="fix" dev="sebb" due-to="Quentin Devriendt">
+        SocketTimeoutException connecting a FTP server via an HTTP Proxy
+      </action>
+      <action issue="NET-528" type="add" dev="sebb">
+        FTPListParseEngine does not provide access to raw responses
+      </action>
+      <action issue="NET-565" type="add" dev="sebb">
+        Add FTPClient method to return an FTPFile from an MDTM command
+      </action>
+      <action issue="NET-564" type="update" dev="sebb">
+        FTPFile.toFormattedString - allow specification of TimeZone for display
+      </action>
+      <action issue="NET-562" type="update" dev="sebb">
+        FTPFile.toFormattedString should print only signficant parts of the parsed date
+      </action>
+      <action issue="NET-563" type="fix" dev="sebb">
+        MLSxEntryParser needs test cases; parsing is too lax
+      </action>
+      <action issue="NET-561" type="fix" dev="sebb">
+        FTPFile.toFormattedString prints user and group in wrong order
+      </action>
+      <action issue="NET-544" type="fix" dev="sebb" due-to="Olivier Queyrut ">
+        FTPClient.initiateListParsing does not correctly check if parserKey was cached
+      </action>
+      <action issue="NET-554" type="update" dev="sebb">
+        Simplify TelnetOptionHandler class hierarchy
+      </action>
+      <action issue="NET-558" type="fix" dev="sebb" due-to="Ralph Becker">
+        FTPClient.getModificationTime(filename) returns complete received line including response code and EOL
+        Strip the response code and EOL
+      </action>
+      <action issue="NET-556" type="update" dev="sebb" due-to="Andy Rosa">
+        Make SubnetInfo.isInRange(int) public
+      </action>
+      <action issue="NET-550" type="fix" dev="sebb" due-to="Geoffrey Hardy">
+        Default FTPClient bufferSize results in very slow retrieve transfers
+        Fix code in Util#copyStream (also copyReader) that failed to use the proper default for buffer size 0
+      </action>
+      <action issue="NET-551" type="fix" dev="sebb">
+        Util copyReader calls CopyStreamListener.bytesTransferred with the incorrect value for bytesTransferred
+      </action>
+      <action type="update" dev="sebb">
+        Added control character processing to TelnetClientExample
+      </action>
+      <action issue="NET-547" type="update" dev="sebb" due-to="Fabio Scippacercola">
+        There is a lack of documentation regarding setControlKeepAliveTimeout
+      </action>
+      <action issue="NET-549" type="fix" dev="sebb" due-to="Pradeep Natarajan">
+        Telnet does not convert LF to CRLF in ASCII mode
+      </action>
+      <action issue="NET-543" type="fix" dev="sebb" due-to="Ferry Huberts">
+        telnet: spy read EOL is reversed
+      </action>
+      <action issue="NET-540" type="add" dev="sebb">
+        Article#printThread should have option to use any PrintStream
+      </action>
+      <action issue="NET-539" type="fix" dev="sebb">
+        NPE if Threader.thread invoked with empty list or with null array
+      </action>
+      <action issue="NET-536" type="add" dev="sebb">
+        IMAP FETCH example
+        IMAPExportMbox can export selected nessages from an IMAP folder
+      </action>
+      <action issue="NET-535" type="add" dev="sebb">
+        IMAP FETCH can overflow reply buffer; provide for partial responses
+      </action>
+      <action issue="NET-534" type="update" dev="sebb">
+        Unnecesssary call to getReplyString() if no listeners configured
+      </action>
+      <action issue="NET-530" type="fix" dev="sebb" due-to="fish ship">
+        input parameter of org.apache.commons.net.ftp.FTP.__getReply(boolean) is not used
+      </action>
+      <action issue="NET-529" type="fix" dev="sebb" due-to="Putinas Piliponis">
+        SubnetUtils throws exception on valid input
+      </action>
+      <action issue="NET-527" type="add" dev="sebb" due-to="jason mathews">
+        Add SimpleNTPServer as example and for testing
+      </action>
+      <action issue="NET-516" type="fix" dev="sebb" due-to="Asha K S &amp; pavan">
+        parser problem occurs if the filename contains one or more characters of which the second byte of Shift-JIS code is 0x85
+        Fix NT parser
+      </action>
+      <action type="update" dev="sebb">
+        Added control encoding option to FTPClientExample
+      </action>
+      <action issue="NET-526" type="update" dev="sebb" due-to="Jason Mathews, MITRE Corp">
+        Added missing set methods on NTP class and interface
+      </action>
+      <action issue="NET-526" type="update" dev="sebb">
+        Avoid greedy matches within a regex
+      </action>
+      <action issue="NET-520" type="fix" dev="sebb">
+        SubnetUtils("0.0.0.0/0") does not behave as expected
+        Fixed range checking so network and broadcast addresses are treated as unsigned ints
+      </action>
+      <action issue="NET-521" type="fix" dev="sebb">
+        SubnetUtils.SubnetInfo.getAddressCount() can overflow as it returns an int
+      </action>
+      <action issue="NET-515" type="fix" due-to="Sebastian Ritter">
+        FTPClient sample in class javadoc "bug"
+      </action>
+      <action issue="NET-519" type="fix">
+        Apache Commons Net 3.3 has a performance issue
+      </action>
+      <action issue="NET-517" dev="sebb" type="fix" due-to="David Kocher">
+        FTPClient#reinitialize is package protected
+      </action>
+      <action issue="NET-512" dev="sebb" type="add" due-to="Thomas Raddatz">
+        Downloading files or members from the AS400 QSYS file system is not supported
+      </action>
+      <action issue="NET-518" dev="sebb" type="fix" due-to="David Kocher">
+        FTPClient#initFeatureMap should not initialize empty map if reply code is 530
+      </action>
+      <action issue="NET-514" dev="sebb" type="fix">
+        IMAP APPEND multiple issues in IMapClient.
+        Deprecated unusable append methods.
+        Added new append method, as well as example IMapImportMbox class to make use of it.
+      </action>
+      <action issue="NET-511" dev="ggregory" type="fix" due-to="Kyriacos Elia, Daniel Scott">
+        Exception for new SubnetUtils("0.0.0.0/0").
+      </action>
+    </release>
+    <release version="3.3" date="2013-06-11"
+      description="
+This is mainly a bug-fix release. See further details below.
+        ">
+      <action issue="NET-509" dev="sebb" due-to="Anthony Dahanne" type="update">
+        AuthenticatingSMTPClient needs a constructor with the isImplicit argument for SSL
+      </action>
+      <action issue="NET-501" dev="sebb" due-to="Juli√°n Lastiri" type="fix">
+        Race Condition on TelnetClient.disconnect() and TelnetInputStream.run()
+        java.lang.IllegalStateException: Queue is full! Cannot process another character.
+      </action>
+      <action issue="NET-505" dev="sebb" due-to="Sean Kelley" type="update">
+        User specified bufferSize reset to default when FTPClient is disconnected or reinitialized resulting in performance
+        degradation.
+      </action>
+      <action issue="NET-507" dev="sebb" due-to="Jiri Netolicky" type="update">
+        Option to disable private IP replacement in FTP passive mode.
+      </action>
+      <action issue="NET-503" dev="sebb" due-to="Ofer Regev" type="add">
+        AuthenticatingSMTPClient does not support non-default encoding
+      </action>
+      <action issue="NET-500" dev="sebb" due-to="Michael Frick" type="fix">
+        Always call FTPClient#setFileType after connection.
+        Not all servers default to ASCII.
+      </action>
+      <action issue="NET-465" dev="sebb" due-to="Jim Kerwood" type="fix">
+        FTPClient setSendBufferSize and setReceiveBufferSize on data socket.
+        The previous fix caused performance problems.
+        Added new getters and setters for the SO_SNDBUF and SO_RCVBUF values to be used on the data socket.
+      </action>
+      <action issue="NET-496" dev="sebb" type="add">
+        Util copyReader/copyStream classes should use default buffer size for non-positive buffer size parameters.
+      </action>
+      <action issue="NET-310" dev="sebb" type="add">
+        FTPCommand conversion to use enum; added FTPCmd emum and deprecated FTPCommand.
+      </action>
+      <action issue="NET-480" dev="sebb" due-to="Peter Naber" type="fix">
+        Wrong passivHost when using FTPHTTPClient with EPSV
+      </action>
+      <action issue="NET-494" dev="sebb" type="fix">
+        FTPClient.CSL.cleanUp() fails to restore timeout value on exception
+      </action>
+      <action issue="NET-492" dev="sebb" due-to="Tomasz Jedrzejewski" type="fix">
+        FTPClient.printWorkingDirectory() incorrectly parses certain valid PWD command results
+      </action>
+    </release>
+    <release version="3.2" date="2012-12-03"
+      description="
+This release fixes bugs and adds some new functionality (see below).
+ It is binary compatible with previous releases.
+ Note that Clirr shows that two public methods have been removed (NET-485). These are not used within NET.
+        ">
+      <action issue="NET-46" dev="sebb" type="fix">
+        retrieveFileStream fails randomly or hangs
+      </action>
+      <action issue="NET-485" dev="sebb" type="fix">
+        Remove unnecessary Base64 methods.
+      </action>
+      <action issue="NET-482" dev="sebb" type="update" due-to="Houman Atashbar">
+        Support XOAUTH.
+      </action>
+      <action issue="NET-484" dev="sebb" type="fix">
+        Base64.CHUNK_SEPARATOR should be private
+      </action>
+      <action issue="NET-483" dev="sebb" type="fix">
+        Base64.encodeBase64(byte[], boolean, boolean, int) does not calculate output size correctly for unchunked output.
+      </action>
+      <action issue="NET-466" dev="sebb" type="fix" due-to="Martin Oberhuber">
+        Regression: TelnetInputStream#available() blocks.
+      </action>
+      <action issue="NET-426" dev="sebb" type="fix" due-to="Ketan">
+        FTPS: Hook to customize _openDataConnection_ SSLSocket before startHandshake() is called.
+        Implement _openDataConnection(String, String) method to properly
+        interface with FTPClient.openDataConnection(String, String)
+      </action>
+      <action issue="NET-456" dev="sebb" type="fix">
+        TelnetClient hangs when reader-thread startup is delayed.
+      </action>
+      <action issue="NET-449" dev="sebb" type="fix">
+        listFiles bug with folder that begins with "-". Clarify Javadoc.
+      </action>
+      <action issue="NET-473" dev="sebb" type="fix">
+        FTPClient setSoTimeout (int time) will result in NullPointerException. Clarify Javadoc.
+      </action>
+      <action issue="NET-468" dev="sebb" type="add" due-to="Bogdan Drozdowski">
+        Request for native support for socks proxy routing with Commons net FTP.
+      </action>
+      <action issue="NET-475" dev="sebb" type="fix">
+        FtpClient sends REST when calling listFiles. Clarified Javadoc.
+      </action>
+      <action issue="NET-465" dev="sebb" type="add" due-to="Bogdan Drozdowski">
+        FTPClient setSendBufferSize and setReceiveBufferSize on data socket.
+      </action>
+      <action issue="NET-462" dev="sebb" type="add" due-to="Bogdan Drozdowski">
+        FTPClient in PASSIVE_LOCAL_DATA_CONNECTION_MODE cannot work when host have several different IP.
+      </action>
+      <action issue="NET-467" dev="sebb" type="fix">
+        IMAPClient#fetch() does not handle literal strings.
+      </action>
+      <action issue="NET-458" dev="sebb" type="fix" due-to="Denis Molony">
+        MVSFTPEntryParser.parseSimpleEntry - ArrayIndexOutOfBoundsException.
+      </action>
+      <action issue="NET-450" dev="sebb" type="fix" due-to="Roger Hardiman">
+        Bug in documentation for FTPClient.
+      </action>
+      <action dev="sebb" type="add">
+        The examples can now be run using "java -jar commons-net-examples-m.n.jar".
+        This will automatically include the main net jar in the classpath.
+        See documentation.
+        FTPClientExample now supports "-A" for anonymous login
+      </action>
+      <action issue="NET-442" dev="sebb" type="fix">
+        StringIndexOutOfBoundsException: String index out of range: -1 if server respond with root is current directory.
+      </action>
+      <action issue="NET-444" dev="sebb" type="fix">
+        FTPTimestampParserImpl fails to parse future dates correctly on Feb 28th in a leap year.
+      </action>
+    </release>
+    <release version="3.1" date="Feb 20, 2012"
+      description="
+This release fixes a few bugs and adds some new functionality (see below).
+  It is binary compatible with previous releases
+        ">
+      <action issue="NET-441" dev="sebb" type="fix" due-to="consiliens">
+        [FTP] mlistDir doc should be "MLSD" not "MSLD".
+      </action>
+      <action issue="NET-440" dev="sebb" type="add">
+        [FTP] Allow user to provide default value in case SYST command fails.
+      </action>
+      <action issue="NET-438" dev="sebb" type="fix" due-to="Norman Maurer">
+        POP3Client.capa() should call POP3Client.getAdditionalReply()
+      </action>
+      <action issue="NET-412" dev="sebb" type="fix" due-to="Chuck Wolber">
+        TFTP implementation subject to Sorcerer's Apprentice Syndrome
+      </action>
+      <action issue="NET-410" dev="sebb" type="fix" due-to="Chuck Wolber">
+        TFTP does not handle RFC 783 retransmits
+      </action>
+      <action issue="NET-437" dev="sebb" type="fix" due-to="Gavin Camp">
+        TelnetInputStream doesn't support non-blocking IO when reader thread is not enabled
+      </action>
+      <action issue="NET-346" dev="sebb" type="add" due-to="Kevin Samuel">
+        FTP should support reporting NATed external IP address
+      </action>
+      <action issue="NET-433" dev="sebb" type="add">
+        Commons NET site should link to the examples
+      </action>
+      <action issue="NET-422" dev="sebb" type="fix" due-to="Tomas Mysik / Magnus Johansson">
+        FTP using HTTP proxy not working
+      </action>
+      <action issue="NET-423" dev="sebb" type="fix" due-to="Jens Koch">
+        FTPClient.storeFIle might fail when ControlKeepAliveTimeout is set (ditto for FTPCLient.retrieveFile)
+      </action>
+      <action issue="NET-426" dev="sebb" type="add" due-to="Ketan">
+        FTPS: Hook to customize _openDataConnection_ SSLSocket before startHandshake() is called
+      </action>
+      <action issue="NET-430" dev="sebb" type="fix" due-to="Thomas Mathis">
+        Can't login to POP3S Server using explicit mode
+      </action>
+      <action issue="NET-434" dev="sebb" type="fix" due-to="zhangyong">
+        FTPClient fails to close local listener socket when command socket channel encounter "ReadTimeoutException"
+      </action>
+      <action issue="NET-436" dev="sebb" type="add" due-to="J√ºrgen Jung">
+        [FTP] Support for SYST "Mac OS" listing - "MACOS Peter's Server"
+      </action>
+      <action issue="NET-425" dev="sebb" type="update" due-to="Steven Jardine">
+        [FTP] _openDataConnection_, __storeFile, and __storeFileStream should be protected and take String for FTP command.
+        Likewise for receiveFile and receiveFileStream.
+      </action>
+      <action issue="NET-416" dev="sebb" type="update" due-to="Abhijeet Gaikwad">
+        [Telnet] Increasing sub-negotiation message holder array size
+      </action>
+      <action issue="NET-428" dev="sebb" type="fix" due-to="sebb">
+        SubnetUtils throws ArrayIndexOutOfBoundsException for new SubnetUtils( "1.2.3.4/32" ).getInfo().getAllAddresses()
+      </action>
+      <action issue="NET-421" dev="sebb" type="fix" due-to="Oliver Saggau">
+        Problem connecting to TLS/SSL SMTP server using explicit mode.
+      </action>
+      <action issue="NET-415" dev="sebb" type="fix" due-to="george thomas">
+        [Site] typo in migration how-to.
+      </action>
+    </release>
+
+    <release version="3.0.1" date="June 6, 2011" description="
+This is a bug-fix release.
+        ">
+      <action issue="NET-409" dev="sebb" type="fix">
+        FTPClient truncates file (storeFile method).
+        Fix bug introduced in release 3.0.
+      </action>
+    </release>
+    <release version="3.0" date="May 16, 2011"
+      description="
+This release fixes many bugs (see below), and adds new functionality:
+  - basic support for IMAP and IMAPS
+  - support for SMTPS and POP3S
+
+    FTP changes:
+  - default for lenient future dates is now true, which fixes short date parsing where host clock is ahead of client clock
+  - no longer parses every response line twice
+  - OS auto-detection can be overriden by defining the property 'org.apache.commons.net.ftp.systemType';
+  - or by creating a properties file '/systemType.properties' which provides a mapping from getSystemType() to parser name
+  See the Javadoc for FTPClient.initiateListParsing(String parserKey, String pathname).
+  - SASL, PLAIN and CRAM-MD5 authentication added
+  - added control channel keep-alive for use with misbehaving routers, see FTPClient.setControlKeepAliveTimeout(long controlIdle)
+
+    NNTP changes:
+  - reworked to use long for article numbers
+  - added streaming equivalents for the array methods
+
+  Added TrustManagerUtils and KeyManagerUtils classes to simplify setting up trust and key namagers.
+KeyManagerUtils can be used to provide client certificates.
+
+  This release is binary-compatible with 2.2, but there are some minor changes to source compatibility:
+  - telnet.TelnetClient#addOptionHandler(TelnetOptionHandler) now additionally throws IOException
+  - telnet.TelnetClient#deleteOptionHandler() now additionally throws IOException
+  - ftp.FTPSClient ctors no longer throw NoSuchAlgorithmException
+  - Redundant CODE_nnn definitions have been removed from FTPReply, SMTPReply and NNTPReply classes
+  - Unused String constants KEYSTORE_ALGORITHM, PROVIDER, STORE_TYPE, TRUSTSTORE_ALGORITHM removed from FTPSClient
+
+  All users are recommended to upgrade.
+">
+      <action issue="NET-407" dev="sebb" type="update">
+        Change lenientFutureDates to default to true.
+        This means short dates will be parsed as the current year when the host clock is up to 1 day ahead of the client clock.
+      </action>
+      <action issue="NET-404" dev="sebb" type="fix">
+        FTPSSocketFactory does not override createSocket(); causes java.net.SocketException: Unconnected sockets not implemented.
+      </action>
+      <action issue="NET-399" dev="sebb" type="fix" due-to="Noah Levitt">
+        ftp data connection does not use connectTimeout.
+      </action>
+      <action issue="NET-400" dev="sebb" type="update" due-to="David Kocher">
+        Option to override SSL negotiation. Make FTPSClient#execAuth() and FTPSClient#sslNegotiation() protected
+      </action>
+      <action issue="NET-402" dev="sebb" type="fix">
+        IMAP, NNTP, POP3 and SMTP classes uses BufferedReader for control channel, which does not follow the standard.
+        Changed reader to CRLFLineReader.
+      </action>
+      <action issue="NET-401" dev="sebb" type="fix">
+        FTP class uses BufferedReader for control channel, which does not follow the standard.
+        Changed reader to CRLFLineReader.
+      </action>
+      <action issue="NET-331" dev="sebb" type="update">
+        AS400 file timestamp format is wrong. Workround exists.
+      </action>
+      <action issue="NET-269" dev="sebb" type="update">
+        Remove semi-redundant check in SubnetUtils.calculate().
+      </action>
+      <action issue="NET-219" dev="sebb" type="update">
+        Should Telnet class Exception blocks write to System.err?
+        Catch blocks removed, and throws clauses added to allow caller to more easily detect and recover.
+      </action>
+      <action issue="NET-397" dev="sebb" type="update" due-to="Bogdan Drozdowski"
+        due-to-email="bogdandr # op . pl">
+        FTPSClient does not handle AUTH or ADAT and only partially handles PBSZ. FTPSCommand should be deprecated.
+      </action>
+      <action issue="NET-268" dev="sebb" type="fix">
+        Better handling of CIDR/31 and CIDR/32 where isInclusive = false.
+        Return 0 for address count, and 0.0.0.0 for each of the addresses
+      </action>
+      <action issue="NET-395" dev="sebb" type="update">
+        Move ProtocolCommandSupport to SocketClient.
+      </action>
+      <action issue="NET-393" dev="sebb" type="update">
+        Should the sendCommandWithID() methods be public?
+        Made methods private, and deleted currently unused ones.
+      </action>
+      <action issue="NET-394" dev="sebb" type="update">
+        Are the sendUntaggedCommand() methods needed?
+        Renamed the method as sendData(), as it's not a command.
+      </action>
+      <action issue="NET-392" dev="sebb" type="update">
+        Use enum for IMAPCommand.
+      </action>
+      <action issue="NET-333" dev="sebb" type="add" due-to="Bogdan Drozdowski" due-to-email="bogdandr # op . pl">
+        Added basic IMAP/IMAPS implementation.
+      </action>
+      <action issue="NET-389" dev="sebb" type="fix">
+        Unix parser should ignore "total nnn" lines.
+      </action>
+      <action issue="NET-369" dev="sebb" type="remove">
+        Article.addHeaderField() is currently write-only - there is no way to retrieve the headers - is it needed?
+        Method was removed, along with the field.
+      </action>
+      <action issue="NET-367" dev="sebb" type="fix">
+        ntp.TimeStamp uses incorrect lazy initialisation of static fields simpleFormatter and utcFormatter.
+      </action>
+      <action issue="NET-381" dev="sebb" type="update">
+        Parsing is inefficient, as it parses everything twice.
+      </action>
+      <action issue="NET-388" dev="sebb" type="fix">
+        VMSVersioningFTPEntryParser#preParse should not call super.preParse().
+      </action>
+      <action issue="NET-362" dev="sebb" type="fix">
+        TelnetInputStream has various threading bugs.
+      </action>
+      <action issue="NET-89" dev="sebb" type="fix">
+        TelnetClient use of FromNetASCIIInputStream and ToNetASCIIOutputStream breaks binary mode.
+        See also NET-387.
+      </action>
+      <action issue="NET-385" dev="sebb" type="update">
+        FTP does not apply timeout to initial responses.
+      </action>
+      <action issue="NET-384" dev="sebb" type="update">
+        KeyManagerUtils - the KeyManager is not efficient.
+      </action>
+      <action issue="NET-383" dev="sebb" type="update">
+        KeyManagerUtils - allow alias to be omitted when there is only one private key in the store
+      </action>
+      <action issue="NET-326" dev="sebb" type="add">
+        A KeyManager is required when the protection level is set to 'P' with FTPSClient on active mode.
+        Added KeyManagerUtils class to simplify provision of client certificates.
+      </action>
+      <action issue="NET-273" dev="sebb" type="add">
+        FEAT response parsing. Added FTPClient methods: boolean hasFeature(feature [,option]),
+        String fetaureValue(feature), String[] featureValues(feature)
+      </action>
+      <action issue="NET-379" dev="sebb" type="add">
+        FTPClient - support for processing arbitrary commands that only use the control channel
+      </action>
+      <action issue="NET-378" dev="sebb" type="add">
+        FTP listing should support MLST and MLSD.
+      </action>
+      <action issue="NET-377" dev="sebb" type="update">
+        NLST does not take notice of HiddenFiles setting.
+      </action>
+      <action issue="NET-373" dev="sebb" type="update">
+        NNTP Listgroups not working - broken server implementation.
+      </action>
+      <action issue="NET-375" dev="sebb" type="update">
+        DotTerminatedMessageReader should extend BufferedReader, rather than Reader.
+      </action>
+      <action issue="NET-374" dev="sebb" type="update">
+        ParserInitializationException doesn't use standard JDK exception chaining
+      </action>
+      <action issue="NET-372" dev="sebb" type="add">
+        FTPSClient: java.security.cert.CertificateException: No X509TrustManager implementation available if trustManager == null
+      </action>
+      <action issue="NET-371" dev="sebb" type="add">
+        Create TrustManagerFactory to provide custom TrustManagers.
+      </action>
+      <action issue="NET-354" dev="sebb" type="fix" due-to="Leif John Korshavn">
+        FTPSClient not properly supporting CCC and PROT P.
+      </action>
+      <action issue="NET-368" dev="sebb" type="update">
+        Threader.thread should accept an Iterable rather than a List.
+      </action>
+      <action issue="NET-327" dev="sebb" type="add" due-to="Bogdan Drozdowski" due-to-email="bogdandr # op . pl">
+        "Unconnected sockets not implemented" when using FTPSClient
+        Added disconnect() override which resets the socket factories to their defaults
+      </action>
+      <action issue="NET-350" dev="sebb" type="add" due-to="Bogdan Drozdowski" due-to-email="bogdandr # op . pl">
+        "java.net.SocketException: Broken pipe" when calling "TelnetClient.sendAYT()"
+        Added SocketClient#isAvailable() method to perform additional checks on a socket.
+      </action>
+      <action issue="NET-237" dev="sebb" type="add">
+        Add streaming methods (corresponding to array methods) to NNTPClient.
+      </action>
+      <action issue="NET-365" dev="sebb" type="fix">
+        FTPClient.listFiles() does not work properly, if remote server speaks German.
+        Match non-space{3} instead of A-Za-z{3}
+      </action>
+      <action issue="NET-366" dev="sebb" type="fix">
+        FTPClientConfig: setServerLanguageCode and setShortMonthNames do not work.
+        Ensure that config is passed to all parsers that can use it.
+      </action>
+      <action issue="NET-276" dev="sebb" type="fix">
+        NNTPClient has problems with group listings for large groups.
+      </action>
+      <action issue="NET-185" dev="sebb" type="fix">
+        Possible NPE in Threader.java
+      </action>
+      <action issue="NET-364" dev="sebb" type="fix">
+        nntp.Article is very inefficient and incorrect.
+      </action>
+      <action issue="NET-314" dev="sebb" type="add" due-to="Bogdan Drozdowski" due-to-email="bogdandr # op . pl">
+        The FTP client should autodetect the control encoding.
+      </action>
+      <action issue="NET-363" dev="sebb" type="fix" due-to="daniel damon">
+        Can't connect to a server behind firewall in passive mode.
+      </action>
+      <action issue="NET-348" dev="sebb" type="fix">
+        Queue is full TelnetInputStream.
+      </action>
+      <action issue="NET-361" dev="sebb" type="add">
+        Implement Telnet Command sender.
+      </action>
+      <action issue="NET-345" dev="sebb" type="fix" due-to="Archie Cobbs">
+        Telnet client: not properly handling IAC bytes within subnegotiation messages:
+        - failing to double IACs on output
+        - failing to de-double IACs in input
+      </action>
+      <action issue="NET-343" dev="sebb" type="add" due-to="Archie Cobbs">
+        Telnet client: Support Client-initiated Subnegotiation Messages.
+      </action>
+      <action issue="NET-344" dev="sebb" type="add" due-to="Archie Cobbs">
+        Telnet client: Support Listener Notification of Incoming Data.
+      </action>
+      <action issue="NET-270" dev="sebb" type="fix">
+        Incorrect error handling in method initiateListParsing of FTPClient.
+      </action>
+      <action issue="NET-352" dev="sebb" type="add" due-to="Bogdan Drozdowski" due-to-email="bogdandr # op . pl">
+        SASL PLAIN and CRAM-MD5 authentication.
+      </action>
+      <action issue="NET-357" dev="sebb" type="add" due-to="Bogdan Drozdowski" due-to-email="bogdandr # op . pl">
+        The POP3 client does not support SSL/TLS connections.
+      </action>
+      <action dev="sebb" type="remove">
+        Removed deprecated unused fields from FTPSClient:
+        - KEYSTORE_ALGORITHM, PROVIDER, STORE_TYPE, TRUSTSTORE_ALGORITHM
+      </action>
+      <action issue="NET-258" dev="sebb" type="fix">
+        Implement A Keepalive Mechanism. Control channel keepalive implemented for the following methods:
+        appendFile, storeFile, storeUniqueFile, retrieveFile.
+      </action>
+      <action issue="NET-289" dev="sebb" type="fix" due-to="Luc Claes">
+        StackOverflowError in Threader.
+      </action>
+      <action issue="NET-317" dev="sebb" type="fix">
+        POP3MessageInfo fields should be final.
+      </action>
+      <action issue="NET-252" dev="sebb" type="fix">
+        Get rid of using deprecated API in VMSFTPEntryParser.
+      </action>
+      <action issue="NET-330" dev="sebb" type="remove">
+        The method VMSFTPEntryParser.parseFileList(InputStream listStream) should not be present.
+      </action>
+      <action issue="NET-303" dev="sebb" type="fix">
+        FTPFileEntryParser API samples are wrong.
+      </action>
+      <action issue="NET-229" dev="sebb" type="add">
+        Use properties file (/systemType.properties) to handle new OS-type auto-detection.
+      </action>
+      <action issue="NET-332" dev="sebb" type="add">
+        Commons net ftp cannot handle unknown type parser and should allow override of parser through vm argument.
+        The system property "org.apache.commons.net.ftp.systemType" can be used to provide the system type.
+      </action>
+      <action issue="NET-286" dev="sebb" type="fix">
+        Unhandled SecurityException in DefaultFTPFileEntryParserFactory.createFileEntryParser when using applets.
+      </action>
+      <action issue="NET-360" dev="sebb" type="fix">
+        DefaultFTPFileEntryParserFactory.createFileEntryParser(String key) always tries to load a class.
+      </action>
+      <action issue="NET-156" dev="sebb" type="add">
+        New FTPClient method to retrieve all directory names in the current working directory.
+        Added methods listDirectories(), listDirectories(String path).
+      </action>
+      <action issue="NET-353" dev="sebb" type="add" due-to="Bogdan Drozdowski" due-to-email="bogdandr # op . pl">
+        The SMTPClient does not support authentication.
+      </action>
+      <action issue="NET-356" dev="sebb" type="add" due-to="Bogdan Drozdowski" due-to-email="bogdandr # op . pl">
+        The SMTP client does not support SSL/TLS connections.
+      </action>
+      <action issue="NET-358" dev="sebb" type="add">
+        Implement copy Listener in FTPClient file operations.
+      </action>
+      <action issue="NET-359" dev="sebb" type="fix">
+        CopyStreamAdapter unconditionally resets the CopyStreamEvent source and is inefficient.
+      </action>
+      <action issue="NET-355" dev="sebb" type="fix">
+        examples.nntp.NNTPUtils does not compile
+      </action>
+      <action issue="NET-351" dev="sebb" type="add" due-to="Bogdan Drozdowski" due-to-email="bogdandr # op . pl">
+        APOP authentication fails most of the time.
+        Fix by adding leading 0 if necessary.
+      </action>
+    </release>
+    <release version="2.2" date="Nov 22, 2010"
+      description="
+This is primarily a maintenance release, but it also includes new features and enhancements.
+
+  Users of version 2.0 are encouraged to upgrade to 2.2, as this release includes some important bug fixes.
+
+  See the detailed list of changes below for full description of all bug fixes and enhancements.
+
+">
+      <action issue="NET-334" dev="sebb" type="fix">
+        FromNetASCIIInputStream can throw a NullPointerException
+      </action>
+      <action issue="NET-341" dev="sebb" type="fix">
+        FTPClient.remoteAppend(String filename) uses STOR instead of APPE
+      </action>
+      <action issue="NET-339" dev="sebb" type="fix">
+        Incorrect parsing of timestamp on Windows CE
+        Fix parsing to allow for new-style DOS listing using 24hr clock rather than AM/PM
+      </action>
+      <action issue="NET-338" dev="sebb" type="add">
+        ftp.FTPClient.initiateListParsing(String parserKey, String pathname)
+        can call createFileEntryParser with null systemName.
+        Fix this by adding getSystemType() which does not return null, and deprecating getSystemName().
+      </action>
+      <action issue="NET-244" dev="sebb" type="add">
+        Add support for FTPFileFilter filters. New classes FTPFileFilter, FTPFileFilters, new methods:
+        FTPListParseEngine#getFiles(FTPFileFilter filter)
+        FTPClient.listFiles(String pathname, FTPFileFilter filter)
+      </action>
+      <action issue="NET-313" dev="sebb" type="fix">
+        Optionally enable EPSV with IPv4; Only send EPRT with IPv6.
+        Fix incorrect port used with EPRT. Allow activeMaxPort == activeMinPort in getActivePort() method.
+      </action>
+      <action issue="NET-328" dev="sebb" type="fix">
+        FromNetASCIIInputStream.read(byte[], int, int) may change length passed to superclass if not doing conversion
+      </action>
+      <action issue="NET-74" dev="sebb" type="add">
+        Testcase to show WindowSizeOptionHandler is working OK
+      </action>
+      <action issue="NET-330" dev="sebb" type="fix">
+        The method VMSFTPEntryParser.parseFileList(InputStream listStream) should not be present.
+        Partial fix - marked method as deprecated and to be removed
+      </action>
+      <action issue="NET-180" dev="sebb" type="fix">
+        Telnet EOR is "consumed" by TelnetInputStream when in BINARY transmission.
+        Send notification to TelnetNotificationHandler.
+      </action>
+      <action issue="NET-329" dev="sebb" type="fix">
+        TelnetInoutStream#__read() bug in the __receiveState handling for the _STATE_IAC state.
+      </action>
+      <action issue="NET-283" dev="sebb" type="fix">
+        SocketClient should ensure input and output streams are closed
+      </action>
+      <action issue="NET-302" dev="sebb" type="fix">
+        FTP: initiateListParsing should not cache entryParser
+      </action>
+      <action issue="NET-282" dev="rwinston" type="fix">
+        Improvement to isInRange method in SubnetUtil.SubnetInfo class
+      </action>
+      <action issue="NET-266" dev="rwinston" type="fix">
+        FTPClient.listFiles() corrupts file name in certain circumstances
+      </action>
+      <action issue="NET-264" dev="sebb" type="fix">
+        Telnet spyStream NullPointerException
+      </action>
+      <action dev="sebb" type="update">
+        Deprecated the following unused fields from org.apache.commons.net.ftp.FTPSClient:
+        KEYSTORE_ALGORITHM, PROVIDER, STORE_TYPE, TRUSTSTORE_ALGORITHM
+      </action>
+      <action dev="niallp" type="fix">
+        Fix site reports
+      </action>
+      <action issue="NET-285" dev="rwinston" type="fix">
+        Add support for setting external host ip/port range
+      </action>
+      <action issue="NET-290" dev="rwinston" type="fix">
+        Add fix and testcase for DotTerminatedMessageReader
+      </action>
+      <action issue="NET-288" dev="rwinston" type="fix">
+        Add support for IPv6 EPRT/EPSV
+      </action>
+      <action issue="NET-305" dev="rwinston" type="fix">
+        Fix SubnetUtils for /32 subnets and add inclusive host count flag
+      </action>
+      <action issue="NET-300" dev="rwinston" type="fix">
+        Fix NPE when listHiddenFiles was on
+      </action>
+      <action issue="NET-215" dev="rwinston" type="fix">
+        UNIXFTPEntryParser didn't preserve trailing whitespace in files
+      </action>
+      <action issue="NET-236" dev="rwinston" type="fix">
+        method SubnetUtils.SubnetInfo.isInRange(addr) returns incorrect result
+      </action>
+      <action issue="NET-242" dev="rwinston" type="fix">
+        Method createServerSocket of FTPSSocketFactory never called and thus UseClientMode is incorrect in a secured ftp transfer
+        using active mode.
+      </action>
+      <action issue="NET-248" dev="rwinston" type="fix">
+        Fix inconsistent command list in FTPCommand
+      </action>
+      <action issue="NET-250" dev="rwinston" type="fix">
+        DefaultFTPFileEntryParserFactory did not work with Netware FTP server returning "NETWARE TYPE: L8"
+      </action>
+      <action issue="NET-257" dev="rwinston" type="fix">
+        FTP.getReplyStrings() returned array of null Strings
+      </action>
+      <action issue="NET-259" dev="rwinston" type="fix">
+        UnixFTPEntryParser regex did not match some directory entries
+      </action>
+      <action issue="NET-260" dev="rwinston" type="fix">
+        SubnetUtils.SubnetInfo.isInRange(...) returned incorrect values
+      </action>
+      <action issue="NET-261" dev="rwinston" type="update">
+        SubnetUtils.SubnetInfo.isInRange(...) behavior not documented
+      </action>
+      <action issue="NET-262" dev="rwinston" type="fix">
+        SubnetUtils did not handle /31 and /32 CIDRs well
+      </action>
+      <action issue="NET-265" dev="rwinston" type="fix">
+        UnixFTPEntryParser failed to parse entry in certain conditions
+      </action>
+      <action issue="NET-266" dev="rwinston" type="fix">
+        FTPClient.listFiles() corrupted file name in certain circumstances
+      </action>
+      <action issue="NET-251" dev="rwinston" type="update">
+        Moved class "ThreadContainer" from Threader.java into its own source file
+      </action>
+      <action issue="NET-256" dev="rwinston" type="fix">
+        FTPSClient should accept a pre-configured SSLContext
+      </action>
+      <action issue="NET-263" dev="rwinston" type="add">
+        SubnetUtils / SubNetInfo toString() implementations
+      </action>
+      <action dev="rwinston" type="fix">
+        Improve NNTPClient handling of invalid articles
+      </action>
+      <action dev="rwinston" type="update">
+        Refactor examples package.
+      </action>
+      <action dev="sebb" type="add">
+        Javadoc fixes, improvements, and refactoring.
+      </action>
+      <action issue="NET-245" dev="rwinston" type="fix">
+        Apply MFMT patch
+      </action>
+      <action issue="NET-279" dev="rwinston" type="fix">
+        Fix copying of reply lines collection
+      </action>
+      <action issue="NET-277" dev="rwinston" type="fix">
+        Fix incorrect NNTP constant
+      </action>
+      <action issue="NET-274" dev="rwinston" type="fix">
+        Restore socket state after CCC command
+      </action>
+      <action issue="NET-275" dev="rwinston" type="fix">
+        Example code in FTPClient doesn't compile
+      </action>
+      <action dev="rwinston" type="fix">
+        Fix inconsistent handling of socket read/write buffer size
+      </action>
+      <action issue="NET-294" dev="sebb" type="fix">
+        UnixFTPEntryParser fails to parse some entries
+      </action>
+    </release>
+
+    <release version="2.1" description="Not released" />
+
+    <release version="2.0" date="October 20, 2008" description="Java 5.0 release">
+      <action dev="rwinston" type="fix" issue="NET-307">
+        One of the "connect" method in class org.apache.commons.net.SocketClient doesn't handle connection timeout properly
+      </action>
+      <action dev="rwinston" type="update">
+        Add null check in TelnetClient::disconnect().
+      </action>
+      <action dev="rwinston" type="remove">
+        Remove deprecated FTPFileIterator and FTPFileList classes.
+      </action>
+      <action dev="rwinston" type="add">
+        Add connection timeout functionality to SocketClient.
+      </action>
+      <action dev="rwinston" type="update">
+        Make the KeyManager and TrustManager settable (niklas@protocol7.com).
+      </action>
+      <action dev="rwinston" type="update">
+        Patch FTPSClient to set default SSLServerSocketFactory. Thanks niklas@protocol7.com
+      </action>
+      <action dev="rwinston" type="fix" issue="NET-68">
+        Patch to prevent TFTPClient dropping last packet. Thanks palm@poplarware.com
+      </action>
+      <action dev="rwinston" type="update">
+        Change isConnected() method to delegate to underlying socket connection.
+      </action>
+      <action dev="rwinston" type="add">
+        FTPS (TLS and SSL) is now supported. Thanks to Jose Juan Montiel, Paul Ferraro, and Satoshi Ishigami.
+      </action>
+      <action dev="rwinston" type="update">
+        Commons::Net now uses Maven 2. The project.xml has been replaced with a pom.xml, and the source tree layout
+        has been changed accordingly.
+      </action>
+      <action dev="rwinston" type="remove">
+        Removed old ftp2 proposal directories.
+      </action>
+      <action dev="rwinston" type="update">
+        Commons::Net now uses JDK regex functionality, saving on an extra [oro] dependency. There are now
+        no external dependencies required.
+      </action>
+      <action dev="rwinston" type="fix">
+        Various syntactic issues (FindBugs issues, JDK 5.0 generics support)
+      </action>
+      <action dev="dfs" type="fix">
+        Applied Rob Hasselbaum's
+        rhasselbaum -> alumni.ithaca.edu
+        patch for PR 38688 fixing a
+        TelnetInputStream hang.
+      </action>
+      <action dev="dfs" type="update">
+        Exposed control connection of FTP
+        class via _controlInput_ and _controlOutput_
+        protected member variables in response
+        to PR 38309 reported by
+        josejuan.montiel@gmail.com.
+      </action>
+      <action dev="dfs" type="fix">
+        Reverted PR 32859 patch to TFTPClient
+        because it caused final packets to not
+        be sent.
+      </action>
+      <action dev="rwinston" type="update" issue="NET-36">
+        Make FTPClient extend SocketClient instead of TelnetClient. From jhindsley@providerlink.com
+      </action>
+      <action dev="rwinston" type="fix" issue="NET-39">
+        Adds an "e" symbolic link flag to the Unix FTP parser. From denisgaebler@netscape.net
+      </action>
+      <action dev="rwinston" type="fix" issue="NET-119">
+        Allow hidden files to be listed. Thanks to mario@ops.co.at
+      </action>
+      <action dev="rwinston" type="update">
+        Remove reflective check for Socket::isConnected() (no longer needed)
+      </action>
+      <action dev="rwinston" type="add" issue="NET-136">
+        Added WindowSizeOptionHandler for TelnetClient. Thanks to yuvalkashtan@gmail.com
+      </action>
+      <action dev="rwinston" type="update">
+        Refactored *Client classes under net/ package into separate subpackages, and move PrintCommandListener
+        out of the examples/ package.
+      </action>
+      <action dev="rwinston" type="add">
+        Added an ant target to the Maven build to generate an FTP-only jar file, for clients who
+        wish to use only FTP-based functionality.
+      </action>
+      <action dev="rwinston" type="update">
+        Custom SocketFactory interface has been replaced with the JDK SocketFactory implementation. Added
+        ServerSocketFactory instance to SocketClient.
+      </action>
+      <action dev="rwinston" type="update">
+        Removed redundant FTP.IMAGE_FILE_TYPE flag.
+      </action>
+      <action dev="rwinston" type="update">
+        Added heavily updated MVSFTPEntryParser from henrik.sorensen@balcab.ch
+      </action>
+      <action dev="rwinston" type="remove">
+        Removed deprecated classes FTPFileListParser, FTPFileListParserImpl, and DefaultFTPFileListParser. Also
+        removed associated deprecated methods from FTPClient.
+      </action>
+      <action dev="rwinston" type="fix" issue="NET-164">
+        Added encoding to FingerClient. From Ulrich Mayring.
+      </action>
+      <action dev="rwinston" type="fix" issue="NET-24">
+        Catch BindException in RCommandClient::connect().
+      </action>
+      <action dev="rwinston" type="fix" issue="NET-178">
+        Add encoding specifier to SMTPClient.
+      </action>
+      <action dev="rwinston" type="add">
+        Add setters for socket send/receive buffer size to SocketClient.
+      </action>
+      <action dev="rwinston" type="fix" issue="NET-177">
+        Fix PASV specifiers that broke previously. From Chris Eagle.
+      </action>
+      <action dev="rwinston" type="fix" issue="NET-182">
+        Catch NPE in FTP parser factory method.
+      </action>
+      <action dev="rwinston" type="fix" issue="NET-172">
+        Don't bind a UDP socket to NTP protocol port.
+      </action>
+      <action dev="rwinston" type="fix">
+        Better handling of user and group names with embedded spaces in FTP listings.
+      </action>
+      <action dev="rwinston" type="fix" issue="NET-173">
+        Add configurable multiline parsing.
+      </action>
+      <action dev="rwinston" type="fix" issue="NET-188">
+        Add fix for broken leap year date parsing.
+      </action>
+      <action dev="rwinston" type="add">
+        Add SubnetUtils class (suggested by Kenny McLeod)
+      </action>
+      <action dev="rwinston" type="fix" issue="NET-169">
+        Add Unix-type handling for UNKNOWN Type: L8 syst() message systems.
+      </action>
+      <action dev="rwinston" type="fix" issue="NET-198">
+        Allow FTPTimestampParserImpl to take a predefined Calendar instance representing current time.
+      </action>
+      <action dev="sebb" type="fix" issue="NET-194">
+        Replace Exception with IOException
+      </action>
+      <action dev="sebb" type="update" issue="NET-214">
+        VMS file permission parsing
+      </action>
+      <action dev="sebb" type="fix" issue="NET-208">
+        TelnetInputStream swallows interruptedexception as IOException
+      </action>
+      <action dev="sebb" type="fix" issue="NET-223">
+        the data connection socket is not closed when an IOException occurred
+      </action>
+      <action dev="sebb" type="fix" issue="NET-230">
+        ParserInitializationException when connecting to a Unix FTP server: comparison string must be upper case
+      </action>
+      <action dev="sebb" type="fix" issue="NET-225">
+        FTPFileEntryParserImpl.preParse() doesn't remove unparsable entries at the end of the file list
+      </action>
+    </release>
+
+
+    <!-- 1.5.0 has not yet been released, so comment out the section until it is ready for release -->
+    <!-- <release version="1.5.0" date="" description=""> <action dev="dfs" type="fix" issue="NET-3"> TelnetInputStream.java: 
+      Applied Rob Hasselbaum's rhasselbaum@alumni.ithaca.edu patch for PR 38688 fixing a TelnetInputStream hang. </action> <action 
+      dev="rwinston" type="fix" issue="NET-73"> TelnetInputStream.java: Fixing another potential deadlock for telnet and FTP (patch 
+      courtesy Rob Hasselbaum). </action> <action dev="dfs" type="update" issue="NET-57"> FTP.java: Exposed control connection 
+      of FTP class via _controlInput_ and _controlOutput_ protected member variables in response to PR 38309 reported by josejuan.montiel@gmail.com. 
+      </action> <action dev="rwinston" type="fix" issue="NET-68"> TFTPClient.java: Fix bug causing final packets to not be sent. 
+      </action> <action dev="rwinston" type="fix" issue="NET-161"> TFTPClient.java: Fix sendFile() (related to NET-68). </action> 
+      <action dev="rwinston" type="fix" issue="NET-181"> TFTPClient.java: block number wraparound. </action> <action dev="scohen" 
+      type="fix" issue="NET-16"> UNIXFTPEntryParser.java: support for group names with spaces (patch courtesy D. Kilzer). </action> 
+      <action dev="scohen" type="fix" issue="NET-62"> DefaultFTPFileEntryParserFactory.java: Wrap NoClassDefFoundError in FTP parser 
+      exception when ORO is not available. </action> <action dev="rwinston" type="add" issue="NET-33"> FTPClient.java: Fix closing 
+      FTP ServerSocket after timeout </action> <action dev="rwinston" type="add"> FTPClientConfig.java: Added an FTP parser for 
+      Netware FTP servers. Tested on Novell Netware 6.5. </action> <action dev="rwinston" type="fix" issue="NET-188"> FTPTimestampParserImpl.java: 
+      Fix leap year date parsing bug. </action> <action dev="rwinston" type="fix"> Article.java: Fix minor issues with NNTP parsing. 
+      </action> </release> -->
+
+
+    <release version="1.4.1" date="December 3, 2005" description="fix release to restore jdk 1.3 compatability">
+      <action dev="scohen" type="fix">
+        Applied patches for defect 37113. Code incompatible with jdk 1.3. Original patch submitted by Andrea Rombald
+      </action>
+      <action dev="scohen" type="fix">
+        Applied patches for defect 37522. updated project.xml to correct compatibility level.
+      </action>
+    </release>
+
+    <release version="1.4.0" date="May 7, 2005" description="Some additions and enhancements">
+      <action dev="dfs" type="fix">
+        Fixed typo in method name.
+        FTP.removeCommandListener() was missing
+        the L. Problem reported by
+        Per.Lindberger@linkon.se.
+      </action>
+      <action dev="rwinston" type="fix">
+        Applied fix for PR 33942 and PR 31793. Original patch submitted by mario@ops.co.at
+      </action>
+      <action dev="rwinston" type="fix">
+        TFTPClient was ignoring final ACK (PR 32859). Thanks to perttu.auramo@ekahau.com
+      </action>
+      <action dev="rwinston" type="fix">
+        Applied fix for ACL parsing in the FTP client (PR 33972). Submitted by robertalasch@yahoo.com
+      </action>
+      <action dev="rwinston" type="fix">
+        Added missing NTP/SNTP unit tests to the codebase.
+      </action>
+      <action dev="dfs" type="fix">
+        Applied fix for POP3Client returning empty reply strings (PR 34133). Thanks to sammy_c@lineone.net
+      </action>
+      <action dev="rwinston" type="fix">
+        NTP port parameter was being ignored (PR 34219). Fixed by felix.eichhorn@3soft.de
+      </action>
+      <action dev="scohen" type="add">
+        An FTP parser for MVS was added. Submitted by wnoto@openfinance.com
+      </action>
+      <action dev="scohen" type="add">
+        Added functionality for extensible parsing of FTP responses, using a configurable format string. This should enable the
+        FTP client to operate across many different locales and date formats.
+      </action>
+    </release>
+
+    <release version="1.3.0" date="December 15, 2004" description="many fixes and enhancements">
+      <action dev="rwinston" type="fix">
+        Applied patch for PR 31793. Thanks to mario@ops.co.at
+      </action>
+      <action dev="rwinston" type="add">
+        Added message threading functionality to the NNTP client.
+      </action>
+      <action dev="rwinston" type="update">
+        Added return code 521 to FTPReply.java - this should obviate the need for the Ant FTP task to manually declare it.
+      </action>
+      <action dev="rwinston" type="fix">
+        Add explicit notify() in TelnetInputStream::read(), so available() returns an accurate value. Thanks to
+        tpalkot@gmail.com.
+      </action>
+      <action dev="rwinston" type="add">
+        Added SNTP/NTP components into the Commons-Net codebase, courtesy of
+        Jason Matthews.
+      </action>
+      <action dev="rwinston" type="add">
+        Added POP3 test suite, courtesy of Mike George mike.george@comcast.net.
+      </action>
+      <action dev="scohen" type="fix">
+        Applied fix for FTPClient returning null for certain timestamp formats (BUG #30737)
+      </action>
+      <action dev="rwinston" type="fix">
+        Build.xml fixes - dont include example classes in redistributable
+        .jar, remove test dependency from javadoc target, and exclude private members from generated javadoc.
+      </action>
+      <action dev="rwinston" type="fix">
+        Fixed bug in TFTPClient::setMaxTimeout(), spotted by steve@widge.net
+      </action>
+      <action dev="dfs" type="fix">
+        Some changes to facilitate compilation under JDK 5.0
+      </action>
+      <action dev="rwinston" type="fix">
+        Return correct NNTP article count when high and low watermarks are 0.
+        Spotted by jmordax@terra.es
+      </action>
+      <action dev="rwinston" type="fix">
+        Remove trailing null byte in TFTP packets. Thanks to gerard.dens@alcatel.be
+      </action>
+      <action dev="dfs" type="fix">
+        Many javadoc fixes.
+      </action>
+      <action dev="rwinston" type="update">
+        Allow FTPClient to set transfer buffer size.
+      </action>
+      <action dev="rwinston" type="update">
+        Ensure consistent handling of encoding throughout FTPClient
+        operations. Patch submitted by leif@tanukisoftware.com.
+      </action>
+      <action dev="dfs" type="fix">
+        Fix TelnetClient zombie thread issue
+      </action>
+
+
+    </release>
+    <release version="1.3.0-dev" date="July 28, 2004" description="regression fix">
+      <action dev="dfs" type="fix">
+        Fixed regression from migration to new parsers. Most of the
+        new parsers parsed the file size as an integer instead of a
+        long. Changed all of them to set the size to long. This
+        problem was detected by the reporter of:
+        https://issues.apache.org/bugzilla/show_bug.cgi?id=30345
+      </action>
+    </release>
+    <release version="1.2.2" date="June 25, 2004" description="fix release">
+      <action dev="scohen" type="fix">
+        fixed bug in the way FTPClient.listFiles worked when a directory was not
+        specified. Current directory was not being 'remembered'. This was most
+        problematic in the dependent ftp task of Ant.
+      </action>
+      <action dev="scohen" type="fix">
+        fixed handling of certain unusual "special" file types in the Unix parser.
+      </action>
+    </release>
+
+    <release version="1.2.1" date="May 6, 2004" description="fix release">
+      <action dev="scohen" type="fix">
+        changed code that rendered package uncompilable under JDK 1.2
+      </action>
+    </release>
+
+    <release version="1.2.0" date="April 30, 2004" description="autodetection of system for listings">
+      <action dev="scohen" type="fix">
+        Mario Ivankovits mario@ops.co.at added
+        functionality supporting correct handling of the &quot;dirstyle&quot;
+        attribute of NT and OS400 servers that allows them to mimic Unix ftp servers.
+        and a bug fix affecting handling of sticky and suid bits on Unix FTP servers.
+      </action>
+      <action dev="scohen" type="add">
+        Mario Ivankovits mario@ops.co.at added parser for OS400.
+      </action>
+      <action dev="jbrekke,scohen" type="fix">
+        Added a functional junit test testing list parsing against real servers
+        and fix several bugs found through this test.
+      </action>
+      <action dev="dfs" type="add">
+        Ted Wise ctwise@bellsouth.net provided a
+        patch to add the XHDR extended NNTP command.
+      </action>
+      <action dev="scohen,dfs" type="update">
+        Deprecated FTPFileListParser interface, DefaultFTPFileListParser
+        class, and the FTPClient.listFiles methods that accepted an
+        FTPFileListParser parameter. These deprecated classes and methods
+        will be removed in version 2.0.
+      </action>
+      <action dev="scohen" type="add">
+        Added org.apache.commons.net.parser.FTPFileEntryParserFactory
+        interface and a default implementation:
+        DefaultFTPFileEntryParserFactory. This addition facilitates the
+        autodetection of which FTPFileEntryParser to use to generate
+        listings. FTPClient.listFiles methods were added that implement
+        autodetection.
+      </action>
+    </release>
+
+    <!-- Not yet released; probably never will be <release version="1.1.1" date="TBD" description="last jdk1.1 compatible 
+      release"> <action dev="scohen" type="fix"> Removed all JDK 1.1 incompatibilities that had been introduced unintentionally 
+      in previous versions. Release 1.1.1 is the last JDK 1.1 compatible release. Any future 1.1.x maintenance releases will remain 
+      JDK !.1 compatible, but version 1.2 may break compatibility and will be guaranteed to work with only J2SE 1.2 and later. 
+      </action> </release> -->
+    <release version="1.1.0" date="October 23, 2003" description="many enhancements and bug fixes">
+      <action dev="dfs" type="add">
+        Rory Winston Rory.Winston@telewest.co.uk provided
+        patches to add the following extended NNTP commands to
+        NNTPClient: XOVER, AUTHINFO USER, AUTHINFO PASS, and
+        LIST ACTIVE.
+      </action>
+      <action dev="dfs" type="fix">
+        Changed connection hooks for FTP, SMTP, POP3, and NNTP classes
+        to force use of an 8-bit US-ASCII superset (ISO-8859-1) for
+        protocol communication. This was necessary because
+        InputStreamReader and OutputStreamWriter use the default
+        client-side character set encoding. fasselin@ca.ibm.com
+        reported failure of SMTP on OS/390 which has EBCDIC as the
+        native character set.
+      </action>
+
+      <action dev="dfs" type="fix">
+        Applied variation of fix suggested by Matthieu Recouly
+        matthieu.recouly@laposte.net so that
+        UnixFTPEntryParser may handle listings of the form:
+        "drwxr-xr-x 1 usernameftp 512 Jan 29 23:32 prog"
+        where the space between user name and group is omitted.
+      </action>
+      <action dev="dfs" type="fix">
+        Applied patch from Stephane Este-Gracias
+        sestegra@free.fr that fixes the parsing of
+        VMS listings by VMSFTPEntryParser..
+      </action>
+      <action dev="brekke" type="fix">
+        If the buffer queue run full, the run() method sometimes hangs forever.
+        Changed wait() to wait(100) as with other changes in TelnetInputStream.
+        Fix submitted From: J. Matysiak ( j.matysiak@cenit.de ).
+      </action>
+      <action dev="brekke" type="fix">
+        FTP.smnt(String dir) was not passing on the dir to the SMNT command as an argument.
+      </action>
+      <action dev="brekke" type="add">
+        Added a link to the FAQ currently hosted on the Apache Wiki.
+      </action>
+      <action dev="dfs" type="update">
+        Changed package private NNTP._reader and NNTP._writer member
+        variables to protected NNTP._reader_ and NNTP._writer_
+        variables as suggested by issue report 16995 to facilitate
+        extending NNTPClient functionality in subclasses.
+      </action>
+      <action dev="dfs" type="update">
+        Changed name of FTPClient.__openDataConnection() to
+        FTPClient._openDataConnection_() to remain consistent
+        with the convention in the code that protected members
+        are of the form _foo_. At some point __openDataConnection()
+        had been changed from private to protected.
+      </action>
+      <action dev="brekke" type="add">
+        Added terminal option support to the telnet client with tests.
+        From Bruno D'Avanzo ( b.davanzo@inwind.it ).
+      </action>
+      <action dev="scohen" type="add">
+        New parsers merged with mainline with support for old list parsers.
+      </action>
+    </release>
+
+    <release version="1.0.0" date="February 23, 2003" description="first jakarta-commons release">
+      <action dev="brekke" type="add">
+        Added a migration document for moving from NetComponents to Commons/Net.
+      </action>
+      <action dev="brekke" type="fix">
+        Moved the ftp2 tree with tests to a proposal directory and setup
+        a build for that code. This can grow in this area so users don't
+        think it is production ready.
+      </action>
+      <action dev="dfs" type="fix">
+        Cleaned up license header on some source.
+      </action>
+      <action dev="dfs" type="fix">
+        Moved .io and .util to .net.io and .net.util in preparation for
+        1.0 release.
+      </action>
+      <action dev="dfs" type="fix">
+        Fixed typo in NNTP.removeProtocolCommandListener() method name. It
+        was missing an L. From: joev@atg.com.
+      </action>
+      <action dev="brekke" type="add">
+        Various site updates including this changes doc and publish
+        date information.
+      </action>
+      <action dev="dfs" type="fix">
+        Patch for restarting FTP file transfers. The offset was not
+        being sent immediately before the data transfer command on
+        account. The bug was apparently introduced in NetComponents
+        when it was decided to always send a PORT command before each data
+        transfer to avoid socket reuse problems on Windows.
+        From: Tapan Karecha ( tapan@india.hp.com ).
+      </action>
+      <action dev="dfs" type="fix">
+        Applied a fix for potential deadlock in TelnetInputStream by
+        changing a wait() to a wait(100).
+        From: Tapan Karecha ( tapan@india.hp.com ).
+      </action>
+      <action dev="dfs" type="update">
+        FTP examples now use passive ftp connections.
+      </action>
+    </release>
+  </body>
+</document>
diff --git a/src/main/java/org/apache/commons/net/examples/ntp/NTPClient.java b/src/main/java/org/apache/commons/net/examples/ntp/NTPClient.java
index 2c753c43b..8b2ff648a 100644
--- a/src/main/java/org/apache/commons/net/examples/ntp/NTPClient.java
+++ b/src/main/java/org/apache/commons/net/examples/ntp/NTPClient.java
@@ -1,181 +1,181 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.net.examples.ntp;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.SocketException;
-import java.net.UnknownHostException;
-import java.text.NumberFormat;
-
-import org.apache.commons.net.ntp.NTPUDPClient;
-import org.apache.commons.net.ntp.NtpUtils;
-import org.apache.commons.net.ntp.NtpV3Packet;
-import org.apache.commons.net.ntp.TimeInfo;
-import org.apache.commons.net.ntp.TimeStamp;
-
-/**
- * This is an example program demonstrating how to use the NTPUDPClient
- * class. This program sends a Datagram client request packet to a
- * Network time Protocol (NTP) service port on a specified server,
- * retrieves the time, and prints it to standard output along with
- * the fields from the NTP message header (e.g. stratum level, reference id,
- * poll interval, root delay, mode, ...)
- * See <A HREF="ftp://ftp.rfc-editor.org/in-notes/rfc868.txt"> the spec </A>
- * for details.
- * <p>
- * Usage: NTPClient <hostname-or-address-list>
- * </p>
- * <p>
- * Example: NTPClient clock.psu.edu
- * </p>
- */
-public final class NTPClient
-{
-
-    private static final NumberFormat numberFormat = new java.text.DecimalFormat("0.00");
-
-    public static void main(final String[] args)
-    {
-        if (args.length == 0) {
-            System.err.println("Usage: NTPClient <hostname-or-address-list>");
-            System.exit(1);
-        }
-
-        final NTPUDPClient client = new NTPUDPClient();
-        // We want to timeout if a response takes longer than 10 seconds
-        client.setDefaultTimeout(10000);
-        try {
-            client.open();
-            for (final String arg : args)
-            {
-                System.out.println();
-                try {
-                    final InetAddress hostAddr = InetAddress.getByName(arg);
-                    System.out.println("> " + hostAddr.getHostName() + "/" + hostAddr.getHostAddress());
-                    final TimeInfo info = client.getTime(hostAddr);
-                    processResponse(info);
-                } catch (final IOException ioe) {
-                    ioe.printStackTrace();
-                }
-            }
-        } catch (final SocketException e) {
-            e.printStackTrace();
-        }
-
-        client.close();
-    }
-
-    /**
-     * Process <code>TimeInfo</code> object and print its details.
-     * @param info <code>TimeInfo</code> object.
-     */
-    public static void processResponse(final TimeInfo info)
-    {
-        final NtpV3Packet message = info.getMessage();
-        final int stratum = message.getStratum();
-        final String refType;
-        if (stratum <= 0) {
-            refType = "(Unspecified or Unavailable)";
-        } else if (stratum == 1) {
-            refType = "(Primary Reference; e.g., GPS)"; // GPS, radio clock, etc.
-        } else {
-            refType = "(Secondary Reference; e.g. via NTP or SNTP)";
-        }
-        // stratum should be 0..15...
-        System.out.println(" Stratum: " + stratum + " " + refType);
-        final int version = message.getVersion();
-        final int li = message.getLeapIndicator();
-        System.out.println(" leap=" + li + ", version="
-                + version + ", precision=" + message.getPrecision());
-
-        System.out.println(" mode: " + message.getModeName() + " (" + message.getMode() + ")");
-        final int poll = message.getPoll();
-        // poll value typically btwn MINPOLL (4) and MAXPOLL (14)
-        System.out.println(" poll: " + (poll <= 0 ? 1 : (int) Math.pow(2, poll))
-                + " seconds" + " (2 ** " + poll + ")");
-        final double disp = message.getRootDispersionInMillisDouble();
-        System.out.println(" rootdelay=" + numberFormat.format(message.getRootDelayInMillisDouble())
-                + ", rootdispersion(ms): " + numberFormat.format(disp));
-
-        final int refId = message.getReferenceId();
-        String refAddr = NtpUtils.getHostAddress(refId);
-        String refName = null;
-        if (refId != 0) {
-            if (refAddr.equals("127.127.1.0")) {
-                refName = "LOCAL"; // This is the ref address for the Local Clock
-            } else if (stratum >= 2) {
-                // If reference id has 127.127 prefix then it uses its own reference clock
-                // defined in the form 127.127.clock-type.unit-num (e.g. 127.127.8.0 mode 5
-                // for GENERIC DCF77 AM; see refclock.htm from the NTP software distribution.
-                if (!refAddr.startsWith("127.127")) {
-                    try {
-                        final InetAddress addr = InetAddress.getByName(refAddr);
-                        final String name = addr.getHostName();
-                        if (name != null && !name.equals(refAddr)) {
-                            refName = name;
-                        }
-                    } catch (final UnknownHostException e) {
-                        // some stratum-2 servers sync to ref clock device but fudge stratum level higher... (e.g. 2)
-                        // ref not valid host maybe it's a reference clock name?
-                        // otherwise just show the ref IP address.
-                        refName = NtpUtils.getReferenceClock(message);
-                    }
-                }
-            } else if (version >= 3 && (stratum == 0 || stratum == 1)) {
-                refName = NtpUtils.getReferenceClock(message);
-                // refname usually have at least 3 characters (e.g. GPS, WWV, LCL, etc.)
-            }
-            // otherwise give up on naming the beast...
-        }
-        if (refName != null && refName.length() > 1) {
-            refAddr += " (" + refName + ")";
-        }
-        System.out.println(" Reference Identifier:\t" + refAddr);
-
-        final TimeStamp refNtpTime = message.getReferenceTimeStamp();
-        System.out.println(" Reference Timestamp:\t" + refNtpTime + "  " + refNtpTime.toDateString());
-
-        // Originate Time is time request sent by client (t1)
-        final TimeStamp origNtpTime = message.getOriginateTimeStamp();
-        System.out.println(" Originate Timestamp:\t" + origNtpTime + "  " + origNtpTime.toDateString());
-
-        final long destTimeMillis = info.getReturnTime();
-        // Receive Time is time request received by server (t2)
-        final TimeStamp rcvNtpTime = message.getReceiveTimeStamp();
-        System.out.println(" Receive Timestamp:\t" + rcvNtpTime + "  " + rcvNtpTime.toDateString());
-
-        // Transmit time is time reply sent by server (t3)
-        final TimeStamp xmitNtpTime = message.getTransmitTimeStamp();
-        System.out.println(" Transmit Timestamp:\t" + xmitNtpTime + "  " + xmitNtpTime.toDateString());
-
-        // Destination time is time reply received by client (t4)
-        final TimeStamp destNtpTime = TimeStamp.getNtpTime(destTimeMillis);
-        System.out.println(" Destination Timestamp:\t" + destNtpTime + "  " + destNtpTime.toDateString());
-
-        info.computeDetails(); // compute offset/delay if not already done
-        final Long offsetMillis = info.getOffset();
-        final Long delayMillis = info.getDelay();
-        final String delay = delayMillis == null ? "N/A" : delayMillis.toString();
-        final String offset = offsetMillis == null ? "N/A" : offsetMillis.toString();
-
-        System.out.println(" Roundtrip delay(ms)=" + delay
-                + ", clock offset(ms)=" + offset); // offset in ms
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.net.examples.ntp;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.SocketException;
+import java.net.UnknownHostException;
+import java.text.NumberFormat;
+
+import org.apache.commons.net.ntp.NTPUDPClient;
+import org.apache.commons.net.ntp.NtpUtils;
+import org.apache.commons.net.ntp.NtpV3Packet;
+import org.apache.commons.net.ntp.TimeInfo;
+import org.apache.commons.net.ntp.TimeStamp;
+
+/**
+ * This is an example program demonstrating how to use the NTPUDPClient
+ * class. This program sends a Datagram client request packet to a
+ * Network time Protocol (NTP) service port on a specified server,
+ * retrieves the time, and prints it to standard output along with
+ * the fields from the NTP message header (e.g. stratum level, reference id,
+ * poll interval, root delay, mode, ...)
+ * See <A HREF="ftp://ftp.rfc-editor.org/in-notes/rfc868.txt"> the spec </A>
+ * for details.
+ * <p>
+ * Usage: NTPClient <hostname-or-address-list>
+ * </p>
+ * <p>
+ * Example: NTPClient clock.psu.edu
+ * </p>
+ */
+public final class NTPClient
+{
+
+    private static final NumberFormat numberFormat = new java.text.DecimalFormat("0.00");
+
+    public static void main(final String[] args)
+    {
+        if (args.length == 0) {
+            System.err.println("Usage: NTPClient <hostname-or-address-list>");
+            System.exit(1);
+        }
+
+        final NTPUDPClient client = new NTPUDPClient();
+        // We want to timeout if a response takes longer than 10 seconds
+        client.setDefaultTimeout(10000);
+        try {
+            client.open();
+            for (final String arg : args)
+            {
+                System.out.println();
+                try {
+                    final InetAddress hostAddr = InetAddress.getByName(arg);
+                    System.out.println("> " + hostAddr.getHostName() + "/" + hostAddr.getHostAddress());
+                    final TimeInfo info = client.getTime(hostAddr);
+                    processResponse(info);
+                } catch (final IOException ioe) {
+                    ioe.printStackTrace();
+                }
+            }
+        } catch (final SocketException e) {
+            e.printStackTrace();
+        }
+
+        client.close();
+    }
+
+    /**
+     * Process <code>TimeInfo</code> object and print its details.
+     * @param info <code>TimeInfo</code> object.
+     */
+    public static void processResponse(final TimeInfo info)
+    {
+        final NtpV3Packet message = info.getMessage();
+        final int stratum = message.getStratum();
+        final String refType;
+        if (stratum <= 0) {
+            refType = "(Unspecified or Unavailable)";
+        } else if (stratum == 1) {
+            refType = "(Primary Reference; e.g., GPS)"; // GPS, radio clock, etc.
+        } else {
+            refType = "(Secondary Reference; e.g. via NTP or SNTP)";
+        }
+        // stratum should be 0..15...
+        System.out.println(" Stratum: " + stratum + " " + refType);
+        final int version = message.getVersion();
+        final int li = message.getLeapIndicator();
+        System.out.println(" leap=" + li + ", version="
+                + version + ", precision=" + message.getPrecision());
+
+        System.out.println(" mode: " + message.getModeName() + " (" + message.getMode() + ")");
+        final int poll = message.getPoll();
+        // poll value typically btwn MINPOLL (4) and MAXPOLL (14)
+        System.out.println(" poll: " + (poll <= 0 ? 1 : (int) Math.pow(2, poll))
+                + " seconds" + " (2 ** " + poll + ")");
+        final double disp = message.getRootDispersionInMillisDouble();
+        System.out.println(" rootdelay=" + numberFormat.format(message.getRootDelayInMillisDouble())
+                + ", rootdispersion(ms): " + numberFormat.format(disp));
+
+        final int refId = message.getReferenceId();
+        String refAddr = NtpUtils.getHostAddress(refId);
+        String refName = null;
+        if (refId != 0) {
+            if (refAddr.equals("127.127.1.0")) {
+                refName = "LOCAL"; // This is the ref address for the Local Clock
+            } else if (stratum >= 2) {
+                // If reference id has 127.127 prefix then it uses its own reference clock
+                // defined in the form 127.127.clock-type.unit-num (e.g. 127.127.8.0 mode 5
+                // for GENERIC DCF77 AM; see refclock.htm from the NTP software distribution.
+                if (!refAddr.startsWith("127.127")) {
+                    try {
+                        final InetAddress addr = InetAddress.getByName(refAddr);
+                        final String name = addr.getHostName();
+                        if (name != null && !name.equals(refAddr)) {
+                            refName = name;
+                        }
+                    } catch (final UnknownHostException e) {
+                        // some stratum-2 servers sync to ref clock device but fudge stratum level higher... (e.g. 2)
+                        // ref not valid host maybe it's a reference clock name?
+                        // otherwise just show the ref IP address.
+                        refName = NtpUtils.getReferenceClock(message);
+                    }
+                }
+            } else if (version >= 3 && (stratum == 0 || stratum == 1)) {
+                refName = NtpUtils.getReferenceClock(message);
+                // refname usually have at least 3 characters (e.g. GPS, WWV, LCL, etc.)
+            }
+            // otherwise give up on naming the beast...
+        }
+        if (refName != null && refName.length() > 1) {
+            refAddr += " (" + refName + ")";
+        }
+        System.out.println(" Reference Identifier:\t" + refAddr);
+
+        final TimeStamp refNtpTime = message.getReferenceTimeStamp();
+        System.out.println(" Reference Timestamp:\t" + refNtpTime + "  " + refNtpTime.toDateString());
+
+        // Originate Time is time request sent by client (t1)
+        final TimeStamp origNtpTime = message.getOriginateTimeStamp();
+        System.out.println(" Originate Timestamp:\t" + origNtpTime + "  " + origNtpTime.toDateString());
+
+        final long destTimeMillis = info.getReturnTime();
+        // Receive Time is time request received by server (t2)
+        final TimeStamp rcvNtpTime = message.getReceiveTimeStamp();
+        System.out.println(" Receive Timestamp:\t" + rcvNtpTime + "  " + rcvNtpTime.toDateString());
+
+        // Transmit time is time reply sent by server (t3)
+        final TimeStamp xmitNtpTime = message.getTransmitTimeStamp();
+        System.out.println(" Transmit Timestamp:\t" + xmitNtpTime + "  " + xmitNtpTime.toDateString());
+
+        // Destination time is time reply received by client (t4)
+        final TimeStamp destNtpTime = TimeStamp.getNtpTime(destTimeMillis);
+        System.out.println(" Destination Timestamp:\t" + destNtpTime + "  " + destNtpTime.toDateString());
+
+        info.computeDetails(); // compute offset/delay if not already done
+        final Long offsetMillis = info.getOffset();
+        final Long delayMillis = info.getDelay();
+        final String delay = delayMillis == null ? "N/A" : delayMillis.toString();
+        final String offset = offsetMillis == null ? "N/A" : offsetMillis.toString();
+
+        System.out.println(" Roundtrip delay(ms)=" + delay
+                + ", clock offset(ms)=" + offset); // offset in ms
+    }
+
+}
diff --git a/src/main/java/org/apache/commons/net/examples/ntp/TimeClient.java b/src/main/java/org/apache/commons/net/examples/ntp/TimeClient.java
index 3eb56c375..cfd49375b 100644
--- a/src/main/java/org/apache/commons/net/examples/ntp/TimeClient.java
+++ b/src/main/java/org/apache/commons/net/examples/ntp/TimeClient.java
@@ -1,101 +1,101 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.net.examples.ntp;
-
-import java.io.IOException;
-import java.net.InetAddress;
-
-import org.apache.commons.net.time.TimeTCPClient;
-import org.apache.commons.net.time.TimeUDPClient;
-
-/**
- * This is an example program demonstrating how to use the TimeTCPClient
- * and TimeUDPClient classes.
- * This program connects to the default time service port of a
- * specified server, retrieves the time, and prints it to standard output.
- * See <A HREF="ftp://ftp.rfc-editor.org/in-notes/rfc868.txt"> the spec </A>
- * for details.  The default is to use the TCP port.  Use the -udp flag to
- * use the UDP port.
- * <p>
- * Usage: TimeClient [-udp] <hostname>
- * </p>
- */
-public final class TimeClient
-{
-
-    public static void main(final String[] args)
-    {
-
-        if (args.length == 1)
-        {
-            try
-            {
-                timeTCP(args[0]);
-            }
-            catch (final IOException e)
-            {
-                e.printStackTrace();
-                System.exit(1);
-            }
-        }
-        else if (args.length == 2 && args[0].equals("-udp"))
-        {
-            try
-            {
-                timeUDP(args[1]);
-            }
-            catch (final IOException e)
-            {
-                e.printStackTrace();
-                System.exit(1);
-            }
-        }
-        else
-        {
-            System.err.println("Usage: TimeClient [-udp] <hostname>");
-            System.exit(1);
-        }
-
-    }
-
-    public static void timeTCP(final String host) throws IOException
-    {
-        final TimeTCPClient client = new TimeTCPClient();
-    try {
-          // We want to timeout if a response takes longer than 60 seconds
-          client.setDefaultTimeout(60000);
-      client.connect(host);
-          System.out.println(client.getDate());
-    } finally {
-          client.disconnect();
-    }
-    }
-
-    public static void timeUDP(final String host) throws IOException
-    {
-        final TimeUDPClient client = new TimeUDPClient();
-
-        // We want to timeout if a response takes longer than 60 seconds
-        client.setDefaultTimeout(60000);
-        client.open();
-        System.out.println(client.getDate(InetAddress.getByName(host)));
-        client.close();
-    }
-
-}
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.net.examples.ntp;
+
+import java.io.IOException;
+import java.net.InetAddress;
+
+import org.apache.commons.net.time.TimeTCPClient;
+import org.apache.commons.net.time.TimeUDPClient;
+
+/**
+ * This is an example program demonstrating how to use the TimeTCPClient
+ * and TimeUDPClient classes.
+ * This program connects to the default time service port of a
+ * specified server, retrieves the time, and prints it to standard output.
+ * See <A HREF="ftp://ftp.rfc-editor.org/in-notes/rfc868.txt"> the spec </A>
+ * for details.  The default is to use the TCP port.  Use the -udp flag to
+ * use the UDP port.
+ * <p>
+ * Usage: TimeClient [-udp] <hostname>
+ * </p>
+ */
+public final class TimeClient
+{
+
+    public static void main(final String[] args)
+    {
+
+        if (args.length == 1)
+        {
+            try
+            {
+                timeTCP(args[0]);
+            }
+            catch (final IOException e)
+            {
+                e.printStackTrace();
+                System.exit(1);
+            }
+        }
+        else if (args.length == 2 && args[0].equals("-udp"))
+        {
+            try
+            {
+                timeUDP(args[1]);
+            }
+            catch (final IOException e)
+            {
+                e.printStackTrace();
+                System.exit(1);
+            }
+        }
+        else
+        {
+            System.err.println("Usage: TimeClient [-udp] <hostname>");
+            System.exit(1);
+        }
+
+    }
+
+    public static void timeTCP(final String host) throws IOException
+    {
+        final TimeTCPClient client = new TimeTCPClient();
+    try {
+          // We want to timeout if a response takes longer than 60 seconds
+          client.setDefaultTimeout(60000);
+      client.connect(host);
+          System.out.println(client.getDate());
+    } finally {
+          client.disconnect();
+    }
+    }
+
+    public static void timeUDP(final String host) throws IOException
+    {
+        final TimeUDPClient client = new TimeUDPClient();
+
+        // We want to timeout if a response takes longer than 60 seconds
+        client.setDefaultTimeout(60000);
+        client.open();
+        System.out.println(client.getDate(InetAddress.getByName(host)));
+        client.close();
+    }
+
+}
+
diff --git a/src/main/java/org/apache/commons/net/ftp/FTPListParseEngine.java b/src/main/java/org/apache/commons/net/ftp/FTPListParseEngine.java
index a55a45878..63d504904 100644
--- a/src/main/java/org/apache/commons/net/ftp/FTPListParseEngine.java
+++ b/src/main/java/org/apache/commons/net/ftp/FTPListParseEngine.java
@@ -1,333 +1,333 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.net.ftp;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.ListIterator;
-import java.util.stream.Collectors;
-
-import org.apache.commons.net.util.Charsets;
-
-
-/**
- * This class handles the entire process of parsing a listing of
- * file entries from the server.
- * <p>
- * This object defines a two-part parsing mechanism.
- * <p>
- * The first part is comprised of reading the raw input into an internal
- * list of strings.  Every item in this list corresponds to an actual
- * file.  All extraneous matter emitted by the server will have been
- * removed by the end of this phase.  This is accomplished in conjunction
- * with the FTPFileEntryParser associated with this engine, by calling
- * its methods <code>readNextEntry()</code> - which handles the issue of
- * what delimits one entry from another, usually but not always a line
- * feed and <code>preParse()</code> - which handles removal of
- * extraneous matter such as the preliminary lines of a listing, removal
- * of duplicates on versioning systems, etc.
- * <p>
- * The second part is composed of the actual parsing, again in conjunction
- * with the particular parser used by this engine.  This is controlled
- * by an iterator over the internal list of strings.  This may be done
- * either in block mode, by calling the <code>getNext()</code> and
- * <code>getPrevious()</code> methods to provide "paged" output of less
- * than the whole list at one time, or by calling the
- * <code>getFiles()</code> method to return the entire list.
- * <p>
- * Examples:
- * <p>
- * Paged access:
- * <pre>
- *    FTPClient f=FTPClient();
- *    f.connect(server);
- *    f.login(username, password);
- *    FTPListParseEngine engine = f.initiateListParsing(directory);
- *
- *    while (engine.hasNext()) {
- *       FTPFile[] files = engine.getNext(25);  // "page size" you want
- *       //do whatever you want with these files, display them, etc.
- *       //expensive FTPFile objects not created until needed.
- *    }
- * </pre>
- * <p>
- * For unpaged access, simply use FTPClient.listFiles().  That method
- * uses this class transparently.
- */
-public class FTPListParseEngine {
-    /**
-     * An empty immutable {@code FTPFile} array.
-     */
-    private static final FTPFile[] EMPTY_FTP_FILE_ARRAY = new FTPFile[0];
-    private List<String> entries = new LinkedList<>();
-
-    private ListIterator<String> internalIterator = entries.listIterator();
-    private final FTPFileEntryParser parser;
-
-    // Should invalid files (parse failures) be allowed?
-    private final boolean saveUnparseableEntries;
-
-    public FTPListParseEngine(final FTPFileEntryParser parser) {
-        this(parser, null);
-    }
-
-    /**
-     * Intended for use by FTPClient only
-     * @since 3.4
-     */
-    FTPListParseEngine(final FTPFileEntryParser parser, final FTPClientConfig configuration) {
-        this.parser = parser;
-        if (configuration != null) {
-            this.saveUnparseableEntries = configuration.getUnparseableEntries();
-        } else {
-            this.saveUnparseableEntries = false;
-        }
-    }
-
-    /**
-     * Returns an array of FTPFile objects containing the whole list of
-     * files returned by the server as read by this object's parser.
-     *
-     * @return an array of FTPFile objects containing the whole list of
-     *         files returned by the server as read by this object's parser.
-     * None of the entries will be null
-     * @throws IOException - not ever thrown, may be removed in a later release
-     */
-    public FTPFile[] getFiles()
-    throws IOException // TODO remove; not actually thrown
-    {
-        return getFiles(FTPFileFilters.NON_NULL);
-    }
-
-    /**
-     * Returns an array of FTPFile objects containing the whole list of
-     * files returned by the server as read by this object's parser.
-     * The files are filtered before being added to the array.
-     *
-     * @param filter FTPFileFilter, must not be <code>null</code>.
-     *
-     * @return an array of FTPFile objects containing the whole list of
-     *         files returned by the server as read by this object's parser.
-     * <p><b>
-     * NOTE:</b> This array may contain null members if any of the
-     * individual file listings failed to parse.  The caller should
-     * check each entry for null before referencing it, or use the
-     * a filter such as {@link FTPFileFilters#NON_NULL} which does not
-     * allow null entries.
-     * @since 2.2
-     * @throws IOException - not ever thrown, may be removed in a later release
-     */
-    public FTPFile[] getFiles(final FTPFileFilter filter)
-    throws IOException // TODO remove; not actually thrown
-    {
-        return getFileList(filter).toArray(EMPTY_FTP_FILE_ARRAY);
-    }
-
-    /**
-     * Returns a list of FTPFile objects containing the whole list of
-     * files returned by the server as read by this object's parser.
-     * The files are filtered before being added to the array.
-     *
-     * @param filter FTPFileFilter, must not be <code>null</code>.
-     *
-     * @return a list of FTPFile objects containing the whole list of
-     *         files returned by the server as read by this object's parser.
-     * <p><b>
-     * NOTE:</b> This array may contain null members if any of the
-     * individual file listings failed to parse.  The caller should
-     * check each entry for null before referencing it, or use the
-     * a filter such as {@link FTPFileFilters#NON_NULL} which does not
-     * allow null entries.
-     * @since 3.9.0
-     */
-    public List<FTPFile> getFileList(final FTPFileFilter filter)
-    {
-        return entries.stream().map(e -> {
-            final FTPFile file = parser.parseFTPEntry(e);
-            return file == null && saveUnparseableEntries ? new FTPFile(e) : file;
-        }).filter(file -> filter.accept(file)).collect(Collectors.toList());
-    }
-
-    /**
-     * Returns an array of at most <code>quantityRequested</code> FTPFile
-     * objects starting at this object's internal iterator's current position.
-     * If fewer than <code>quantityRequested</code> such
-     * elements are available, the returned array will have a length equal
-     * to the number of entries at and after after the current position.
-     * If no such entries are found, this array will have a length of 0.
-     *
-     * After this method is called this object's internal iterator is advanced
-     * by a number of positions equal to the size of the array returned.
-     *
-     * @param quantityRequested
-     * the maximum number of entries we want to get.
-     *
-     * @return an array of at most <code>quantityRequested</code> FTPFile
-     * objects starting at the current position of this iterator within its
-     * list and at least the number of elements which  exist in the list at
-     * and after its current position.
-     * <p><b>
-     * NOTE:</b> This array may contain null members if any of the
-     * individual file listings failed to parse.  The caller should
-     * check each entry for null before referencing it.
-     */
-    public FTPFile[] getNext(final int quantityRequested) {
-        final List<FTPFile> tmpResults = new LinkedList<>();
-        int count = quantityRequested;
-        while (count > 0 && this.internalIterator.hasNext()) {
-            final String entry = this.internalIterator.next();
-            FTPFile temp = this.parser.parseFTPEntry(entry);
-            if (temp == null && saveUnparseableEntries) {
-                temp = new FTPFile(entry);
-            }
-            tmpResults.add(temp);
-            count--;
-        }
-        return tmpResults.toArray(EMPTY_FTP_FILE_ARRAY);
-
-    }
-
-    /**
-     * Returns an array of at most <code>quantityRequested</code> FTPFile
-     * objects starting at this object's internal iterator's current position,
-     * and working back toward the beginning.
-     *
-     * If fewer than <code>quantityRequested</code> such
-     * elements are available, the returned array will have a length equal
-     * to the number of entries at and after after the current position.
-     * If no such entries are found, this array will have a length of 0.
-     *
-     * After this method is called this object's internal iterator is moved
-     * back by a number of positions equal to the size of the array returned.
-     *
-     * @param quantityRequested
-     * the maximum number of entries we want to get.
-     *
-     * @return an array of at most <code>quantityRequested</code> FTPFile
-     * objects starting at the current position of this iterator within its
-     * list and at least the number of elements which  exist in the list at
-     * and after its current position.  This array will be in the same order
-     * as the underlying list (not reversed).
-     * <p><b>
-     * NOTE:</b> This array may contain null members if any of the
-     * individual file listings failed to parse.  The caller should
-     * check each entry for null before referencing it.
-     */
-    public FTPFile[] getPrevious(final int quantityRequested) {
-        final List<FTPFile> tmpResults = new LinkedList<>();
-        int count = quantityRequested;
-        while (count > 0 && this.internalIterator.hasPrevious()) {
-            final String entry = this.internalIterator.previous();
-            FTPFile temp = this.parser.parseFTPEntry(entry);
-            if (temp == null && saveUnparseableEntries) {
-                temp = new FTPFile(entry);
-            }
-            tmpResults.add(0,temp);
-            count--;
-        }
-        return tmpResults.toArray(EMPTY_FTP_FILE_ARRAY);
-    }
-
-    /**
-     * convenience method to allow clients to know whether this object's
-     * internal iterator's current position is at the end of the list.
-     *
-     * @return true if internal iterator is not at end of list, false
-     * otherwise.
-     */
-    public boolean hasNext() {
-        return internalIterator.hasNext();
-    }
-
-    /**
-     * convenience method to allow clients to know whether this object's
-     * internal iterator's current position is at the beginning of the list.
-     *
-     * @return true if internal iterator is not at beginning of list, false
-     * otherwise.
-     */
-    public boolean hasPrevious() {
-        return internalIterator.hasPrevious();
-    }
-
-    /**
-     * Internal method for reading (and closing) the input into the <code>entries</code> list. After this method has
-     * completed, <code>entries</code> will contain a collection of entries (as defined by
-     * <code>FTPFileEntryParser.readNextEntry()</code>), but this may contain various non-entry preliminary lines from
-     * the server output, duplicates, and other data that will not be part of the final listing.
-     *
-     * @param inputStream The socket stream on which the input will be read.
-     * @param charsetName The encoding to use.
-     *
-     * @throws IOException thrown on any failure to read the stream
-     */
-    private void read(final InputStream inputStream, final String charsetName) throws IOException {
-        try (final BufferedReader reader = new BufferedReader(
-            new InputStreamReader(inputStream, Charsets.toCharset(charsetName)))) {
-
-            String line = this.parser.readNextEntry(reader);
-
-            while (line != null) {
-                this.entries.add(line);
-                line = this.parser.readNextEntry(reader);
-            }
-        }
-    }
-
-    /**
-     * Do not use.
-     * @param inputStream the stream from which to read
-     * @throws IOException on error
-     * @deprecated use {@link #readServerList(InputStream, String)} instead
-    */
-    @Deprecated
-    public void readServerList(final InputStream inputStream) throws IOException {
-        readServerList(inputStream, null);
-    }
-
-    /**
-     * Reads (and closes) the initial reading and preparsing of the list returned by the server. After this method has
-     * completed, this object will contain a list of unparsed entries (Strings) each referring to a unique file on the
-     * server.
-     *
-     * @param inputStream input stream provided by the server socket.
-     * @param charsetName the encoding to be used for reading the stream
-     *
-     * @throws IOException thrown on any failure to read from the sever.
-     */
-    public void readServerList(final InputStream inputStream, final String charsetName) throws IOException {
-        this.entries = new LinkedList<>();
-        read(inputStream, charsetName);
-        this.parser.preParse(this.entries);
-        resetIterator();
-    }
-
-    // DEPRECATED METHODS - for API compatibility only - DO NOT USE
-
-    /**
-     * resets this object's internal iterator to the beginning of the list.
-     */
-    public void resetIterator() {
-        this.internalIterator = this.entries.listIterator();
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.net.ftp;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.stream.Collectors;
+
+import org.apache.commons.net.util.Charsets;
+
+
+/**
+ * This class handles the entire process of parsing a listing of
+ * file entries from the server.
+ * <p>
+ * This object defines a two-part parsing mechanism.
+ * <p>
+ * The first part is comprised of reading the raw input into an internal
+ * list of strings.  Every item in this list corresponds to an actual
+ * file.  All extraneous matter emitted by the server will have been
+ * removed by the end of this phase.  This is accomplished in conjunction
+ * with the FTPFileEntryParser associated with this engine, by calling
+ * its methods <code>readNextEntry()</code> - which handles the issue of
+ * what delimits one entry from another, usually but not always a line
+ * feed and <code>preParse()</code> - which handles removal of
+ * extraneous matter such as the preliminary lines of a listing, removal
+ * of duplicates on versioning systems, etc.
+ * <p>
+ * The second part is composed of the actual parsing, again in conjunction
+ * with the particular parser used by this engine.  This is controlled
+ * by an iterator over the internal list of strings.  This may be done
+ * either in block mode, by calling the <code>getNext()</code> and
+ * <code>getPrevious()</code> methods to provide "paged" output of less
+ * than the whole list at one time, or by calling the
+ * <code>getFiles()</code> method to return the entire list.
+ * <p>
+ * Examples:
+ * <p>
+ * Paged access:
+ * <pre>
+ *    FTPClient f=FTPClient();
+ *    f.connect(server);
+ *    f.login(username, password);
+ *    FTPListParseEngine engine = f.initiateListParsing(directory);
+ *
+ *    while (engine.hasNext()) {
+ *       FTPFile[] files = engine.getNext(25);  // "page size" you want
+ *       //do whatever you want with these files, display them, etc.
+ *       //expensive FTPFile objects not created until needed.
+ *    }
+ * </pre>
+ * <p>
+ * For unpaged access, simply use FTPClient.listFiles().  That method
+ * uses this class transparently.
+ */
+public class FTPListParseEngine {
+    /**
+     * An empty immutable {@code FTPFile} array.
+     */
+    private static final FTPFile[] EMPTY_FTP_FILE_ARRAY = new FTPFile[0];
+    private List<String> entries = new LinkedList<>();
+
+    private ListIterator<String> internalIterator = entries.listIterator();
+    private final FTPFileEntryParser parser;
+
+    // Should invalid files (parse failures) be allowed?
+    private final boolean saveUnparseableEntries;
+
+    public FTPListParseEngine(final FTPFileEntryParser parser) {
+        this(parser, null);
+    }
+
+    /**
+     * Intended for use by FTPClient only
+     * @since 3.4
+     */
+    FTPListParseEngine(final FTPFileEntryParser parser, final FTPClientConfig configuration) {
+        this.parser = parser;
+        if (configuration != null) {
+            this.saveUnparseableEntries = configuration.getUnparseableEntries();
+        } else {
+            this.saveUnparseableEntries = false;
+        }
+    }
+
+    /**
+     * Returns an array of FTPFile objects containing the whole list of
+     * files returned by the server as read by this object's parser.
+     *
+     * @return an array of FTPFile objects containing the whole list of
+     *         files returned by the server as read by this object's parser.
+     * None of the entries will be null
+     * @throws IOException - not ever thrown, may be removed in a later release
+     */
+    public FTPFile[] getFiles()
+    throws IOException // TODO remove; not actually thrown
+    {
+        return getFiles(FTPFileFilters.NON_NULL);
+    }
+
+    /**
+     * Returns an array of FTPFile objects containing the whole list of
+     * files returned by the server as read by this object's parser.
+     * The files are filtered before being added to the array.
+     *
+     * @param filter FTPFileFilter, must not be <code>null</code>.
+     *
+     * @return an array of FTPFile objects containing the whole list of
+     *         files returned by the server as read by this object's parser.
+     * <p><b>
+     * NOTE:</b> This array may contain null members if any of the
+     * individual file listings failed to parse.  The caller should
+     * check each entry for null before referencing it, or use the
+     * a filter such as {@link FTPFileFilters#NON_NULL} which does not
+     * allow null entries.
+     * @since 2.2
+     * @throws IOException - not ever thrown, may be removed in a later release
+     */
+    public FTPFile[] getFiles(final FTPFileFilter filter)
+    throws IOException // TODO remove; not actually thrown
+    {
+        return getFileList(filter).toArray(EMPTY_FTP_FILE_ARRAY);
+    }
+
+    /**
+     * Returns a list of FTPFile objects containing the whole list of
+     * files returned by the server as read by this object's parser.
+     * The files are filtered before being added to the array.
+     *
+     * @param filter FTPFileFilter, must not be <code>null</code>.
+     *
+     * @return a list of FTPFile objects containing the whole list of
+     *         files returned by the server as read by this object's parser.
+     * <p><b>
+     * NOTE:</b> This array may contain null members if any of the
+     * individual file listings failed to parse.  The caller should
+     * check each entry for null before referencing it, or use the
+     * a filter such as {@link FTPFileFilters#NON_NULL} which does not
+     * allow null entries.
+     * @since 3.9.0
+     */
+    public List<FTPFile> getFileList(final FTPFileFilter filter)
+    {
+        return entries.stream().map(e -> {
+            final FTPFile file = parser.parseFTPEntry(e);
+            return file == null && saveUnparseableEntries ? new FTPFile(e) : file;
+        }).filter(file -> filter.accept(file)).collect(Collectors.toList());
+    }
+
+    /**
+     * Returns an array of at most <code>quantityRequested</code> FTPFile
+     * objects starting at this object's internal iterator's current position.
+     * If fewer than <code>quantityRequested</code> such
+     * elements are available, the returned array will have a length equal
+     * to the number of entries at and after after the current position.
+     * If no such entries are found, this array will have a length of 0.
+     *
+     * After this method is called this object's internal iterator is advanced
+     * by a number of positions equal to the size of the array returned.
+     *
+     * @param quantityRequested
+     * the maximum number of entries we want to get.
+     *
+     * @return an array of at most <code>quantityRequested</code> FTPFile
+     * objects starting at the current position of this iterator within its
+     * list and at least the number of elements which  exist in the list at
+     * and after its current position.
+     * <p><b>
+     * NOTE:</b> This array may contain null members if any of the
+     * individual file listings failed to parse.  The caller should
+     * check each entry for null before referencing it.
+     */
+    public FTPFile[] getNext(final int quantityRequested) {
+        final List<FTPFile> tmpResults = new LinkedList<>();
+        int count = quantityRequested;
+        while (count > 0 && this.internalIterator.hasNext()) {
+            final String entry = this.internalIterator.next();
+            FTPFile temp = this.parser.parseFTPEntry(entry);
+            if (temp == null && saveUnparseableEntries) {
+                temp = new FTPFile(entry);
+            }
+            tmpResults.add(temp);
+            count--;
+        }
+        return tmpResults.toArray(EMPTY_FTP_FILE_ARRAY);
+
+    }
+
+    /**
+     * Returns an array of at most <code>quantityRequested</code> FTPFile
+     * objects starting at this object's internal iterator's current position,
+     * and working back toward the beginning.
+     *
+     * If fewer than <code>quantityRequested</code> such
+     * elements are available, the returned array will have a length equal
+     * to the number of entries at and after after the current position.
+     * If no such entries are found, this array will have a length of 0.
+     *
+     * After this method is called this object's internal iterator is moved
+     * back by a number of positions equal to the size of the array returned.
+     *
+     * @param quantityRequested
+     * the maximum number of entries we want to get.
+     *
+     * @return an array of at most <code>quantityRequested</code> FTPFile
+     * objects starting at the current position of this iterator within its
+     * list and at least the number of elements which  exist in the list at
+     * and after its current position.  This array will be in the same order
+     * as the underlying list (not reversed).
+     * <p><b>
+     * NOTE:</b> This array may contain null members if any of the
+     * individual file listings failed to parse.  The caller should
+     * check each entry for null before referencing it.
+     */
+    public FTPFile[] getPrevious(final int quantityRequested) {
+        final List<FTPFile> tmpResults = new LinkedList<>();
+        int count = quantityRequested;
+        while (count > 0 && this.internalIterator.hasPrevious()) {
+            final String entry = this.internalIterator.previous();
+            FTPFile temp = this.parser.parseFTPEntry(entry);
+            if (temp == null && saveUnparseableEntries) {
+                temp = new FTPFile(entry);
+            }
+            tmpResults.add(0,temp);
+            count--;
+        }
+        return tmpResults.toArray(EMPTY_FTP_FILE_ARRAY);
+    }
+
+    /**
+     * convenience method to allow clients to know whether this object's
+     * internal iterator's current position is at the end of the list.
+     *
+     * @return true if internal iterator is not at end of list, false
+     * otherwise.
+     */
+    public boolean hasNext() {
+        return internalIterator.hasNext();
+    }
+
+    /**
+     * convenience method to allow clients to know whether this object's
+     * internal iterator's current position is at the beginning of the list.
+     *
+     * @return true if internal iterator is not at beginning of list, false
+     * otherwise.
+     */
+    public boolean hasPrevious() {
+        return internalIterator.hasPrevious();
+    }
+
+    /**
+     * Internal method for reading (and closing) the input into the <code>entries</code> list. After this method has
+     * completed, <code>entries</code> will contain a collection of entries (as defined by
+     * <code>FTPFileEntryParser.readNextEntry()</code>), but this may contain various non-entry preliminary lines from
+     * the server output, duplicates, and other data that will not be part of the final listing.
+     *
+     * @param inputStream The socket stream on which the input will be read.
+     * @param charsetName The encoding to use.
+     *
+     * @throws IOException thrown on any failure to read the stream
+     */
+    private void read(final InputStream inputStream, final String charsetName) throws IOException {
+        try (final BufferedReader reader = new BufferedReader(
+            new InputStreamReader(inputStream, Charsets.toCharset(charsetName)))) {
+
+            String line = this.parser.readNextEntry(reader);
+
+            while (line != null) {
+                this.entries.add(line);
+                line = this.parser.readNextEntry(reader);
+            }
+        }
+    }
+
+    /**
+     * Do not use.
+     * @param inputStream the stream from which to read
+     * @throws IOException on error
+     * @deprecated use {@link #readServerList(InputStream, String)} instead
+    */
+    @Deprecated
+    public void readServerList(final InputStream inputStream) throws IOException {
+        readServerList(inputStream, null);
+    }
+
+    /**
+     * Reads (and closes) the initial reading and preparsing of the list returned by the server. After this method has
+     * completed, this object will contain a list of unparsed entries (Strings) each referring to a unique file on the
+     * server.
+     *
+     * @param inputStream input stream provided by the server socket.
+     * @param charsetName the encoding to be used for reading the stream
+     *
+     * @throws IOException thrown on any failure to read from the sever.
+     */
+    public void readServerList(final InputStream inputStream, final String charsetName) throws IOException {
+        this.entries = new LinkedList<>();
+        read(inputStream, charsetName);
+        this.parser.preParse(this.entries);
+        resetIterator();
+    }
+
+    // DEPRECATED METHODS - for API compatibility only - DO NOT USE
+
+    /**
+     * resets this object's internal iterator to the beginning of the list.
+     */
+    public void resetIterator() {
+        this.internalIterator = this.entries.listIterator();
+    }
+
+}
diff --git a/src/main/java/org/apache/commons/net/ftp/FTPSClient.java b/src/main/java/org/apache/commons/net/ftp/FTPSClient.java
index 3d864643f..df4de5cfa 100644
--- a/src/main/java/org/apache/commons/net/ftp/FTPSClient.java
+++ b/src/main/java/org/apache/commons/net/ftp/FTPSClient.java
@@ -1,914 +1,914 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.net.ftp;
-
-import java.io.BufferedReader;
-import java.io.BufferedWriter;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.io.OutputStreamWriter;
-import java.net.Socket;
-
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.KeyManager;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLException;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-
-import org.apache.commons.net.util.Base64;
-import org.apache.commons.net.util.SSLContextUtils;
-import org.apache.commons.net.util.SSLSocketUtils;
-import org.apache.commons.net.util.TrustManagerUtils;
-
-/**
- * FTP over SSL processing. If desired, the JVM property -Djavax.net.debug=all can be used to
- * see wire-level SSL details.
- *
- * Warning: the hostname is not verified against the certificate by default, use
- * {@link #setHostnameVerifier(HostnameVerifier)} or {@link #setEndpointCheckingEnabled(boolean)}
- * (on Java 1.7+) to enable verification. Verification is only performed on client mode connections.
- * @since 2.0
- */
-public class FTPSClient extends FTPClient {
-
-// From http://www.iana.org/assignments/port-numbers
-
-//    ftps-data   989/tcp    ftp protocol, data, over TLS/SSL
-//    ftps-data   989/udp    ftp protocol, data, over TLS/SSL
-//    ftps        990/tcp    ftp protocol, control, over TLS/SSL
-//    ftps        990/udp    ftp protocol, control, over TLS/SSL
-
-    public static final int DEFAULT_FTPS_DATA_PORT = 989;
-    public static final int DEFAULT_FTPS_PORT = 990;
-
-    /** The value that I can set in PROT command  (C = Clear, P = Protected) */
-    private static final String[] PROT_COMMAND_VALUE = {"C","E","S","P"};
-    /** Default PROT Command */
-    private static final String DEFAULT_PROT = "C";
-    /** Default secure socket protocol name, i.e. TLS */
-    private static final String DEFAULT_PROTOCOL = "TLS";
-
-    /** The AUTH (Authentication/Security Mechanism) command. */
-    private static final String CMD_AUTH = "AUTH";
-    /**  The ADAT (Authentication/Security Data) command. */
-    private static final String CMD_ADAT = "ADAT";
-    /**  The PROT (Data Channel Protection Level) command. */
-    private static final String CMD_PROT = "PROT";
-    /**  The PBSZ (Protection Buffer Size) command. */
-    private static final String CMD_PBSZ = "PBSZ";
-    /**  The MIC (Integrity Protected Command) command. */
-    private static final String CMD_MIC = "MIC";
-    /**  The CONF (Confidentiality Protected Command) command. */
-    private static final String CMD_CONF = "CONF";
-    /**  The ENC (Privacy Protected Command) command. */
-    private static final String CMD_ENC = "ENC";
-    /**  The CCC (Clear Command Channel) command. */
-    private static final String CMD_CCC = "CCC";
-
-    /** @deprecated - not used - may be removed in a future release */
-    @Deprecated
-    public static String KEYSTORE_ALGORITHM;
-    /** @deprecated - not used - may be removed in a future release */
-    @Deprecated
-    public static String TRUSTSTORE_ALGORITHM;
-    /** @deprecated - not used - may be removed in a future release */
-    @Deprecated
-    public static String PROVIDER;
-    /** @deprecated - not used - may be removed in a future release */
-    @Deprecated
-    public static String STORE_TYPE;
-    /** The security mode. (True - Implicit Mode / False - Explicit Mode) */
-    private final boolean isImplicit;
-    /** The secure socket protocol to be used, e.g. SSL/TLS. */
-    private final String protocol;
-    /** The AUTH Command value */
-    private String auth = DEFAULT_PROTOCOL;
-    /** The context object. */
-    private SSLContext context;
-    /** The socket object. */
-    private Socket plainSocket;
-    /** Controls whether a new SSL session may be established by this socket. Default true. */
-    private boolean isCreation = true;
-    /** The use client mode flag. */
-    private boolean isClientMode = true;
-
-    /** The need client auth flag. */
-    private boolean isNeedClientAuth;
-
-    /** The want client auth flag. */
-    private boolean isWantClientAuth;
-
-    /** The cipher suites */
-    private String[] suites;
-
-    /** The protocol versions */
-    private String[] protocols;
-
-    /** The FTPS {@link TrustManager} implementation, default validate only
-     * {@link TrustManagerUtils#getValidateServerCertificateTrustManager()}.
-     */
-    private TrustManager trustManager = TrustManagerUtils.getValidateServerCertificateTrustManager();
-
-    /** The {@link KeyManager}, default null (i.e. use system default). */
-    private KeyManager keyManager;
-
-    /** The {@link HostnameVerifier} to use post-TLS, default null (i.e. no verification). */
-    private HostnameVerifier hostnameVerifier;
-
-    /** Use Java 1.7+ HTTPS Endpoint Identification Algorithm. */
-    private boolean tlsEndpointChecking;
-
-    /**
-     * Constructor for FTPSClient, calls {@link #FTPSClient(String, boolean)}.
-     *
-     * Sets protocol to {@link #DEFAULT_PROTOCOL} - i.e. TLS - and security mode to explicit (isImplicit = false)
-     */
-    public FTPSClient() {
-        this(DEFAULT_PROTOCOL, false);
-    }
-
-    /**
-     * Constructor for FTPSClient, using {@link #DEFAULT_PROTOCOL} - i.e. TLS
-     * Calls {@link #FTPSClient(String, boolean)}
-     * @param isImplicit The security mode (Implicit/Explicit).
-     */
-    public FTPSClient(final boolean isImplicit) {
-        this(DEFAULT_PROTOCOL, isImplicit);
-    }
-
-
-    /**
-     * Constructor for FTPSClient, using {@link #DEFAULT_PROTOCOL} - i.e. TLS
-     * The default TrustManager is set from {@link TrustManagerUtils#getValidateServerCertificateTrustManager()}
-     * @param isImplicit The security mode(Implicit/Explicit).
-     * @param context A pre-configured SSL Context
-     */
-    public FTPSClient(final boolean isImplicit, final SSLContext context) {
-        this(DEFAULT_PROTOCOL, isImplicit);
-        this.context = context;
-    }
-
-    /**
-     * Constructor for FTPSClient, using {@link #DEFAULT_PROTOCOL} - i.e. TLS
-     * and isImplicit {@code false}
-     * Calls {@link #FTPSClient(boolean, SSLContext)}
-     * @param context A pre-configured SSL Context
-     */
-    public FTPSClient(final SSLContext context) {
-        this(false, context);
-    }
-
-
-    /**
-     * Constructor for FTPSClient, using explict mode, calls {@link #FTPSClient(String, boolean)}.
-     *
-     * @param protocol the protocol to use
-     */
-    public FTPSClient(final String protocol) {
-        this(protocol, false);
-    }
-
-    /**
-     * Constructor for FTPSClient allowing specification of protocol
-     * and security mode. If isImplicit is true, the port is set to
-     * {@link #DEFAULT_FTPS_PORT} i.e. 990.
-     * The default TrustManager is set from {@link TrustManagerUtils#getValidateServerCertificateTrustManager()}
-     * @param protocol the protocol
-     * @param isImplicit The security mode(Implicit/Explicit).
-     */
-    public FTPSClient(final String protocol, final boolean isImplicit) {
-        this.protocol = protocol;
-        this.isImplicit = isImplicit;
-        if (isImplicit) {
-            setDefaultPort(DEFAULT_FTPS_PORT);
-        }
-    }
-
-    /**
-     * Because there are so many connect() methods,
-     * the _connectAction_() method is provided as a means of performing
-     * some action immediately after establishing a connection,
-     * rather than reimplementing all of the connect() methods.
-     * @throws IOException If it throw by _connectAction_.
-     * @see org.apache.commons.net.SocketClient#_connectAction_()
-     */
-    @Override
-    protected void _connectAction_() throws IOException {
-        // Implicit mode.
-        if (isImplicit) {
-            applySocketAttributes();
-            sslNegotiation();
-        }
-        super._connectAction_();
-        // Explicit mode.
-        if (!isImplicit) {
-            execAUTH();
-            sslNegotiation();
-        }
-    }
-
-    /**
-     * Returns a socket of the data connection.
-     * Wrapped as an {@link SSLSocket}, which carries out handshake processing.
-     * @param command The int representation of the FTP command to send.
-     * @param arg The arguments to the FTP command.
-     * If this parameter is set to null, then the command is sent with
-     * no arguments.
-     * @return corresponding to the established data connection.
-     * Null is returned if an FTP protocol error is reported at any point
-     * during the establishment and initialization of the connection.
-     * @throws IOException If there is any problem with the connection.
-     * @see FTPClient#_openDataConnection_(int, String)
-     * @deprecated (3.3) Use {@link FTPClient#_openDataConnection_(FTPCmd, String)} instead
-     */
-    @Override
-    // Strictly speaking this is not needed, but it works round a Clirr bug
-    // So rather than invoke the parent code, we do it here
-    @Deprecated
-    protected Socket _openDataConnection_(final int command, final String arg)
-            throws IOException {
-        return _openDataConnection_(FTPCommand.getCommand(command), arg);
-    }
-
-    /**
-     * Returns a socket of the data connection. Wrapped as an {@link SSLSocket}, which carries out handshake processing.
-     *
-     * @param command The textual representation of the FTP command to send.
-     * @param arg The arguments to the FTP command. If this parameter is set to null, then the command is sent with no
-     *        arguments.
-     * @return corresponding to the established data connection. Null is returned if an FTP protocol error is reported
-     *         at any point during the establishment and initialization of the connection.
-     * @throws IOException If there is any problem with the connection.
-     * @see FTPClient#_openDataConnection_(int, String)
-     * @since 3.2
-     */
-    @Override
-    protected Socket _openDataConnection_(final String command, final String arg) throws IOException {
-        final Socket socket = super._openDataConnection_(command, arg);
-        _prepareDataSocket_(socket);
-        if (socket instanceof SSLSocket) {
-            final SSLSocket sslSocket = (SSLSocket) socket;
-
-            sslSocket.setUseClientMode(isClientMode);
-            sslSocket.setEnableSessionCreation(isCreation);
-
-            // server mode
-            if (!isClientMode) {
-                sslSocket.setNeedClientAuth(isNeedClientAuth);
-                sslSocket.setWantClientAuth(isWantClientAuth);
-            }
-            if (suites != null) {
-                sslSocket.setEnabledCipherSuites(suites);
-            }
-            if (protocols != null) {
-                sslSocket.setEnabledProtocols(protocols);
-            }
-            sslSocket.startHandshake();
-        }
-
-        return socket;
-    }
-
-        /**
-         * Performs any custom initialization for a newly created SSLSocket (before the SSL handshake happens). Called
-         * by {@link #_openDataConnection_(int, String)} immediately after creating the socket. The default
-         * implementation is a no-op
-         *
-         * @param socket the socket to set up
-         * @throws IOException on error
-         * @since 3.1
-         */
-        protected void _prepareDataSocket_(final Socket socket)
-            throws IOException {
-    }
-
-    /**
-     * Check the value that can be set in PROT Command value.
-     * @param prot Data Channel Protection Level.
-     * @return True - A set point is right / False - A set point is not right
-     */
-    private boolean checkPROTValue(final String prot) {
-        for (final String element : PROT_COMMAND_VALUE)
-        {
-            if (element.equals(prot)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Create SSL socket from plain socket.
-     *
-     * @param socket
-     * @return SSL Socket
-     * @throws IOException
-     */
-    private SSLSocket createSSLSocket(final Socket socket) throws IOException {
-        if (socket != null) {
-            final SSLSocketFactory f = context.getSocketFactory();
-            return (SSLSocket) f.createSocket(socket, _hostname_, socket.getPort(), false);
-        }
-        return null;
-    }
-
-    /**
-     * Closes the connection to the FTP server and restores
-     * connection parameters to the default values.
-     * <p>
-     * Calls {@code setSocketFactory(null)} and {@code setServerSocketFactory(null)}
-     * to reset the factories that may have been changed during the session,
-     * e.g. by {@link #execPROT(String)}
-     * @throws IOException If an error occurs while disconnecting.
-     * @since 3.0
-     */
-    @Override
-    public void disconnect() throws IOException
-    {
-        super.disconnect();
-        if (plainSocket != null) {
-            plainSocket.close();
-        }
-        setSocketFactory(null);
-        setServerSocketFactory(null);
-    }
-
-    /**
-     * Send the ADAT command with the specified authentication data.
-     * @param data The data to send with the command.
-     * @return server reply.
-     * @throws IOException If an I/O error occurs while sending
-     * the command.
-     * @since 3.0
-     */
-    public int execADAT(final byte[] data) throws IOException
-    {
-        if (data != null)
-        {
-            return sendCommand(CMD_ADAT, Base64.encodeBase64StringUnChunked(data));
-        }
-        return sendCommand(CMD_ADAT);
-    }
-
-    /**
-     * AUTH command.
-     * @throws SSLException If it server reply code not equal "234" and "334".
-     * @throws IOException If an I/O error occurs while either sending
-     * the command.
-     */
-    protected void execAUTH() throws SSLException, IOException {
-        final int replyCode = sendCommand(CMD_AUTH, auth);
-        if (FTPReply.SECURITY_MECHANISM_IS_OK == replyCode) {
-            // replyCode = 334
-            // I carry out an ADAT command.
-        } else if (FTPReply.SECURITY_DATA_EXCHANGE_COMPLETE != replyCode) {
-            throw new SSLException(getReplyString());
-        }
-    }
-
-    /**
-     * Send the AUTH command with the specified mechanism.
-     * @param mechanism The mechanism name to send with the command.
-     * @return server reply.
-     * @throws IOException If an I/O error occurs while sending
-     * the command.
-     * @since 3.0
-     */
-    public int execAUTH(final String mechanism) throws IOException
-    {
-        return sendCommand(CMD_AUTH, mechanism);
-    }
-
-    /**
-     * Send the CCC command to the server.
-     * The CCC (Clear Command Channel) command causes the underlying {@link SSLSocket} instance  to be assigned
-     * to a plain {@link Socket} instances
-     * @return server reply.
-     * @throws IOException If an I/O error occurs while sending
-     * the command.
-     * @since 3.0
-     */
-    public int execCCC() throws IOException
-    {
-        final int repCode = sendCommand(CMD_CCC);
-// This will be performed by sendCommand(String, String)
-//        if (FTPReply.isPositiveCompletion(repCode)) {
-//            _socket_.close();
-//            _socket_ = plainSocket;
-//            _controlInput_ = new BufferedReader(
-//                new InputStreamReader(
-//                    _socket_.getInputStream(), getControlEncoding()));
-//            _controlOutput_ = new BufferedWriter(
-//                new OutputStreamWriter(
-//                    _socket_.getOutputStream(), getControlEncoding()));
-//        }
-        return repCode;
-    }
-
-    /**
-     * Send the CONF command with the specified data.
-     * @param data The data to send with the command.
-     * @return server reply.
-     * @throws IOException If an I/O error occurs while sending
-     * the command.
-     * @since 3.0
-     */
-    public int execCONF(final byte[] data) throws IOException
-    {
-        if (data != null)
-        {
-            return sendCommand(CMD_CONF, Base64.encodeBase64StringUnChunked(data));
-        }
-        return sendCommand(CMD_CONF, ""); // perhaps "=" or just sendCommand(String)?
-    }
-
-    /**
-     * Send the ENC command with the specified data.
-     * @param data The data to send with the command.
-     * @return server reply.
-     * @throws IOException If an I/O error occurs while sending
-     * the command.
-     * @since 3.0
-     */
-    public int execENC(final byte[] data) throws IOException
-    {
-        if (data != null)
-        {
-            return sendCommand(CMD_ENC, Base64.encodeBase64StringUnChunked(data));
-        }
-        return sendCommand(CMD_ENC, ""); // perhaps "=" or just sendCommand(String)?
-    }
-
-    /**
-     * Send the MIC command with the specified data.
-     * @param data The data to send with the command.
-     * @return server reply.
-     * @throws IOException If an I/O error occurs while sending
-     * the command.
-     * @since 3.0
-     */
-    public int execMIC(final byte[] data) throws IOException
-    {
-        if (data != null)
-        {
-            return sendCommand(CMD_MIC, Base64.encodeBase64StringUnChunked(data));
-        }
-        return sendCommand(CMD_MIC, ""); // perhaps "=" or just sendCommand(String)?
-    }
-
-    /**
-     * PBSZ command. pbsz value: 0 to (2^32)-1 decimal integer.
-     * @param pbsz Protection Buffer Size.
-     * @throws SSLException If the server reply code does not equal "200".
-     * @throws IOException If an I/O error occurs while sending
-     * the command.
-     * @see #parsePBSZ(long)
-     */
-    public void execPBSZ(final long pbsz) throws SSLException, IOException {
-        if (pbsz < 0 || 4294967295L < pbsz) { // 32-bit unsigned number
-            throw new IllegalArgumentException();
-        }
-        final int status = sendCommand(CMD_PBSZ, String.valueOf(pbsz));
-        if (FTPReply.COMMAND_OK != status) {
-            throw new SSLException(getReplyString());
-        }
-    }
-
-    /**
-     * PROT command.
-     * <ul>
-     * <li>C - Clear</li>
-     * <li>S - Safe(SSL protocol only)</li>
-     * <li>E - Confidential(SSL protocol only)</li>
-     * <li>P - Private</li>
-     * </ul>
-     * <b>N.B.</b> the method calls
-     *  {@link #setSocketFactory(javax.net.SocketFactory)} and
-     *  {@link #setServerSocketFactory(javax.net.ServerSocketFactory)}
-     *
-     * @param prot Data Channel Protection Level, if {@code null}, use {@link #DEFAULT_PROT}.
-     * @throws SSLException If the server reply code does not equal  {@code 200}.
-     * @throws IOException If an I/O error occurs while sending
-     * the command.
-     */
-    public void execPROT(String prot) throws SSLException, IOException {
-        if (prot == null) {
-            prot = DEFAULT_PROT;
-        }
-        if (!checkPROTValue(prot)) {
-            throw new IllegalArgumentException();
-        }
-        if (FTPReply.COMMAND_OK != sendCommand(CMD_PROT, prot)) {
-            throw new SSLException(getReplyString());
-        }
-        if (DEFAULT_PROT.equals(prot)) {
-            setSocketFactory(null);
-            setServerSocketFactory(null);
-        } else {
-            setSocketFactory(new FTPSSocketFactory(context));
-            setServerSocketFactory(new FTPSServerSocketFactory(context));
-            initSslContext();
-        }
-    }
-
-    /**
-     * Extract the data from a reply with a prefix, e.g. PBSZ=1234 => 1234
-     * @param prefix the prefix to find
-     * @param reply where to find the prefix
-     * @return the remainder of the string after the prefix, or null if the prefix was not present.
-     */
-    private String extractPrefixedData(final String prefix, final String reply) {
-        final int idx = reply.indexOf(prefix);
-        if (idx == -1) {
-            return null;
-        }
-        // N.B. Cannot use trim before substring as leading space would affect the offset.
-        return reply.substring(idx+prefix.length()).trim();
-    }
-
-    /**
-     * Return AUTH command use value.
-     * @return AUTH command use value.
-     */
-    public String getAuthValue() {
-        return this.auth;
-    }
-
-    /**
-     * Returns the names of the cipher suites which could be enabled
-     * for use on this connection.
-     * When the underlying {@link Socket} is not an {@link SSLSocket} instance, returns null.
-     * @return An array of cipher suite names, or <code>null</code>
-     */
-    public String[] getEnabledCipherSuites() {
-        if (_socket_ instanceof SSLSocket) {
-            return ((SSLSocket)_socket_).getEnabledCipherSuites();
-        }
-        return null;
-    }
-
-    /**
-     * Returns the names of the protocol versions which are currently
-     * enabled for use on this connection.
-     * When the underlying {@link Socket} is not an {@link SSLSocket} instance, returns null.
-     * @return An array of protocols, or <code>null</code>
-     */
-    public String[] getEnabledProtocols() {
-        if (_socket_ instanceof SSLSocket) {
-            return ((SSLSocket)_socket_).getEnabledProtocols();
-        }
-        return null;
-    }
-
-    /**
-     * Returns true if new SSL sessions may be established by this socket.
-     * When the underlying {@link Socket} instance is not SSL-enabled (i.e. an
-     * instance of {@link SSLSocket} with {@link SSLSocket}{@link #getEnableSessionCreation()}) enabled,
-     * this returns False.
-     * @return true - Indicates that sessions may be created;
-     * this is the default.
-     * false - indicates that an existing session must be resumed.
-     */
-    public boolean getEnableSessionCreation() {
-        if (_socket_ instanceof SSLSocket) {
-            return ((SSLSocket)_socket_).getEnableSessionCreation();
-        }
-        return false;
-    }
-
-    /**
-     * Get the currently configured {@link HostnameVerifier}.
-     * The verifier is only used on client mode connections.
-     * @return A HostnameVerifier instance.
-     * @since 3.4
-     */
-    public HostnameVerifier getHostnameVerifier()
-    {
-        return hostnameVerifier;
-    }
-
-    /**
-     * Gets the {@link KeyManager} instance.
-     *
-     * @return The {@link KeyManager} instance
-     */
-    private KeyManager getKeyManager() {
-        return keyManager;
-    }
-
-    /**
-     * Returns true if the socket will require client authentication.
-     * When the underlying {@link Socket} is not an {@link SSLSocket} instance, returns false.
-     * @return true - If the server mode socket should request
-     * that the client authenticate itself.
-     */
-    public boolean getNeedClientAuth() {
-        if (_socket_ instanceof SSLSocket) {
-            return ((SSLSocket)_socket_).getNeedClientAuth();
-        }
-        return false;
-    }
-
-    /**
-     * Get the currently configured {@link TrustManager}.
-     *
-     * @return A TrustManager instance.
-     */
-    public TrustManager getTrustManager() {
-        return trustManager;
-    }
-
-    /**
-     * Returns true if the socket is set to use client mode
-     * in its first handshake.
-     * When the underlying {@link Socket} is not an {@link SSLSocket} instance, returns false.
-     * @return true - If the socket should start its first handshake
-     * in "client" mode.
-     */
-    public boolean getUseClientMode() {
-        if (_socket_ instanceof SSLSocket) {
-            return ((SSLSocket)_socket_).getUseClientMode();
-        }
-        return false;
-    }
-
-    /**
-     * Returns true if the socket will request client authentication.
-     * When the underlying {@link Socket} is not an {@link SSLSocket} instance, returns false.
-     * @return true - If the server mode socket should request
-     * that the client authenticate itself.
-     */
-    public boolean getWantClientAuth() {
-        if (_socket_ instanceof SSLSocket) {
-            return ((SSLSocket)_socket_).getWantClientAuth();
-        }
-        return false;
-    }
-
-    /**
-     * Performs a lazy init of the SSL context
-     * @throws IOException
-     */
-    private void initSslContext() throws IOException {
-        if (context == null) {
-            context = SSLContextUtils.createSSLContext(protocol, getKeyManager(), getTrustManager());
-        }
-    }
-
-    /**
-     * Return whether or not endpoint identification using the HTTPS algorithm
-     * on Java 1.7+ is enabled. The default behavior is for this to be disabled.
-     *
-     * This check is only performed on client mode connections.
-     *
-     * @return True if enabled, false if not.
-     * @since 3.4
-     */
-    public boolean isEndpointCheckingEnabled()
-    {
-        return tlsEndpointChecking;
-    }
-
-    /**
-     * Parses the given ADAT response line and base64-decodes the data.
-     * @param reply The ADAT reply to parse.
-     * @return the data in the reply, base64-decoded.
-     * @since 3.0
-     */
-    public byte[] parseADATReply(final String reply)
-    {
-        if (reply == null) {
-            return null;
-        }
-        return Base64.decodeBase64(extractPrefixedData("ADAT=", reply));
-    }
-
-    /**
-     * PBSZ command. pbsz value: 0 to (2^32)-1 decimal integer.
-     * Issues the command and parses the response to return the negotiated value.
-     *
-     * @param pbsz Protection Buffer Size.
-     * @throws SSLException If the server reply code does not equal "200".
-     * @throws IOException If an I/O error occurs while sending
-     * the command.
-     * @return the negotiated value.
-     * @see #execPBSZ(long)
-     * @since 3.0
-     */
-    public long parsePBSZ(final long pbsz) throws SSLException, IOException {
-        execPBSZ(pbsz);
-        long minvalue = pbsz;
-        final String remainder = extractPrefixedData("PBSZ=", getReplyString());
-        if (remainder != null) {
-            final long replysz = Long.parseLong(remainder);
-            if (replysz < minvalue) {
-                minvalue = replysz;
-            }
-        }
-        return minvalue;
-    }
-
-    /**
-     * Send an FTP command.
-     * A successful CCC (Clear Command Channel) command causes the underlying {@link SSLSocket}
-     * instance to be assigned to a plain {@link Socket}
-     * @param command The FTP command.
-     * @return server reply.
-     * @throws IOException If an I/O error occurs while sending the command.
-     * @throws SSLException if a CCC command fails
-     * @see org.apache.commons.net.ftp.FTP#sendCommand(String)
-     */
-    // Would like to remove this method, but that will break any existing clients that are using CCC
-    @Override
-    public int sendCommand(final String command, final String args) throws IOException {
-        final int repCode = super.sendCommand(command, args);
-        /* If CCC is issued, restore socket i/o streams to unsecured versions */
-        if (CMD_CCC.equals(command)) {
-            if (FTPReply.COMMAND_OK != repCode) {
-                throw new SSLException(getReplyString());
-            }
-            _socket_.close();
-            _socket_ = plainSocket;
-            _controlInput_ = new BufferedReader(
-                new InputStreamReader(
-                    _socket_ .getInputStream(), getControlEncoding()));
-            _controlOutput_ = new BufferedWriter(
-                new OutputStreamWriter(
-                    _socket_.getOutputStream(), getControlEncoding()));
-        }
-        return repCode;
-    }
-
-    /**
-     * Set AUTH command use value.
-     * This processing is done before connected processing.
-     * @param auth AUTH command use value.
-     */
-    public void setAuthValue(final String auth) {
-        this.auth = auth;
-    }
-
-    /**
-     * Controls which particular cipher suites are enabled for use on this
-     * connection. Called before server negotiation.
-     * @param cipherSuites The cipher suites.
-     */
-    public void setEnabledCipherSuites(final String[] cipherSuites) {
-        suites = cipherSuites.clone();
-    }
-
-    /**
-     * Controls which particular protocol versions are enabled for use on this
-     * connection. I perform setting before a server negotiation.
-     * @param protocolVersions The protocol versions.
-     */
-    public void setEnabledProtocols(final String[] protocolVersions) {
-        protocols = protocolVersions.clone();
-    }
-
-    /**
-     * Controls whether a new SSL session may be established by this socket.
-     * @param isCreation The established socket flag.
-     */
-    public void setEnabledSessionCreation(final boolean isCreation) {
-        this.isCreation = isCreation;
-    }
-
-    /**
-     * Automatic endpoint identification checking using the HTTPS algorithm
-     * is supported on Java 1.7+. The default behavior is for this to be disabled.
-     *
-     * This check is only performed on client mode connections.
-     *
-     * @param enable Enable automatic endpoint identification checking using the HTTPS algorithm on Java 1.7+.
-     * @since 3.4
-     */
-    public void setEndpointCheckingEnabled(final boolean enable)
-    {
-        tlsEndpointChecking = enable;
-    }
-
-    /**
-     * Override the default {@link HostnameVerifier} to use.
-     * The verifier is only used on client mode connections.
-     * @param newHostnameVerifier The HostnameVerifier implementation to set or <code>null</code> to disable.
-     * @since 3.4
-     */
-    public void setHostnameVerifier(final HostnameVerifier newHostnameVerifier)
-    {
-        hostnameVerifier = newHostnameVerifier;
-    }
-
-    /**
-    * Set a {@link KeyManager} to use
-    *
-    * @param keyManager The KeyManager implementation to set.
-    * @see org.apache.commons.net.util.KeyManagerUtils
-    */
-    public void setKeyManager(final KeyManager keyManager) {
-        this.keyManager = keyManager;
-    }
-
-    /**
-     * Configures the socket to require client authentication.
-     * @param isNeedClientAuth The need client auth flag.
-     */
-    public void setNeedClientAuth(final boolean isNeedClientAuth) {
-        this.isNeedClientAuth = isNeedClientAuth;
-    }
-
-    // DEPRECATED - for API compatibility only - DO NOT USE
-
-    /**
-     * Override the default {@link TrustManager} to use; if set to {@code null},
-     * the default TrustManager from the JVM will be used.
-     *
-     * @param trustManager The TrustManager implementation to set, may be {@code null}
-     * @see org.apache.commons.net.util.TrustManagerUtils
-     */
-    public void setTrustManager(final TrustManager trustManager) {
-        this.trustManager = trustManager;
-    }
-
-    /**
-     * Configures the socket to use client (or server) mode in its first
-     * handshake.
-     * @param isClientMode The use client mode flag.
-     */
-    public void setUseClientMode(final boolean isClientMode) {
-        this.isClientMode = isClientMode;
-    }
-
-    /**
-     * Configures the socket to request client authentication,
-     * but only if such a request is appropriate to the cipher
-     * suite negotiated.
-     * @param isWantClientAuth The want client auth flag.
-     */
-    public void setWantClientAuth(final boolean isWantClientAuth) {
-        this.isWantClientAuth = isWantClientAuth;
-    }
-
-    /**
-     * SSL/TLS negotiation. Acquires an SSL socket of a control
-     * connection and carries out handshake processing.
-     * @throws IOException If server negotiation fails
-     */
-    protected void sslNegotiation() throws IOException {
-        plainSocket = _socket_;
-        initSslContext();
-        final SSLSocket socket = createSSLSocket(_socket_);
-        socket.setEnableSessionCreation(isCreation);
-        socket.setUseClientMode(isClientMode);
-
-        // client mode
-        if (isClientMode) {
-            if (tlsEndpointChecking) {
-                SSLSocketUtils.enableEndpointNameVerification(socket);
-            }
-        } else { // server mode
-            socket.setNeedClientAuth(isNeedClientAuth);
-            socket.setWantClientAuth(isWantClientAuth);
-        }
-
-        if (protocols != null) {
-            socket.setEnabledProtocols(protocols);
-        }
-        if (suites != null) {
-            socket.setEnabledCipherSuites(suites);
-        }
-        socket.startHandshake();
-
-        // TODO the following setup appears to duplicate that in the super class methods
-        _socket_ = socket;
-        _controlInput_ = new BufferedReader(new InputStreamReader(
-                socket .getInputStream(), getControlEncoding()));
-        _controlOutput_ = new BufferedWriter(new OutputStreamWriter(
-                socket.getOutputStream(), getControlEncoding()));
-
-        if (isClientMode && (hostnameVerifier != null &&
-            !hostnameVerifier.verify(_hostname_, socket.getSession()))) {
-            throw new SSLHandshakeException("Hostname doesn't match certificate");
-        }
-    }
-
-}
-/* kate: indent-width 4; replace-tabs on; */
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.net.ftp;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
+import java.net.Socket;
+
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.KeyManager;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLException;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+
+import org.apache.commons.net.util.Base64;
+import org.apache.commons.net.util.SSLContextUtils;
+import org.apache.commons.net.util.SSLSocketUtils;
+import org.apache.commons.net.util.TrustManagerUtils;
+
+/**
+ * FTP over SSL processing. If desired, the JVM property -Djavax.net.debug=all can be used to
+ * see wire-level SSL details.
+ *
+ * Warning: the hostname is not verified against the certificate by default, use
+ * {@link #setHostnameVerifier(HostnameVerifier)} or {@link #setEndpointCheckingEnabled(boolean)}
+ * (on Java 1.7+) to enable verification. Verification is only performed on client mode connections.
+ * @since 2.0
+ */
+public class FTPSClient extends FTPClient {
+
+// From http://www.iana.org/assignments/port-numbers
+
+//    ftps-data   989/tcp    ftp protocol, data, over TLS/SSL
+//    ftps-data   989/udp    ftp protocol, data, over TLS/SSL
+//    ftps        990/tcp    ftp protocol, control, over TLS/SSL
+//    ftps        990/udp    ftp protocol, control, over TLS/SSL
+
+    public static final int DEFAULT_FTPS_DATA_PORT = 989;
+    public static final int DEFAULT_FTPS_PORT = 990;
+
+    /** The value that I can set in PROT command  (C = Clear, P = Protected) */
+    private static final String[] PROT_COMMAND_VALUE = {"C","E","S","P"};
+    /** Default PROT Command */
+    private static final String DEFAULT_PROT = "C";
+    /** Default secure socket protocol name, i.e. TLS */
+    private static final String DEFAULT_PROTOCOL = "TLS";
+
+    /** The AUTH (Authentication/Security Mechanism) command. */
+    private static final String CMD_AUTH = "AUTH";
+    /**  The ADAT (Authentication/Security Data) command. */
+    private static final String CMD_ADAT = "ADAT";
+    /**  The PROT (Data Channel Protection Level) command. */
+    private static final String CMD_PROT = "PROT";
+    /**  The PBSZ (Protection Buffer Size) command. */
+    private static final String CMD_PBSZ = "PBSZ";
+    /**  The MIC (Integrity Protected Command) command. */
+    private static final String CMD_MIC = "MIC";
+    /**  The CONF (Confidentiality Protected Command) command. */
+    private static final String CMD_CONF = "CONF";
+    /**  The ENC (Privacy Protected Command) command. */
+    private static final String CMD_ENC = "ENC";
+    /**  The CCC (Clear Command Channel) command. */
+    private static final String CMD_CCC = "CCC";
+
+    /** @deprecated - not used - may be removed in a future release */
+    @Deprecated
+    public static String KEYSTORE_ALGORITHM;
+    /** @deprecated - not used - may be removed in a future release */
+    @Deprecated
+    public static String TRUSTSTORE_ALGORITHM;
+    /** @deprecated - not used - may be removed in a future release */
+    @Deprecated
+    public static String PROVIDER;
+    /** @deprecated - not used - may be removed in a future release */
+    @Deprecated
+    public static String STORE_TYPE;
+    /** The security mode. (True - Implicit Mode / False - Explicit Mode) */
+    private final boolean isImplicit;
+    /** The secure socket protocol to be used, e.g. SSL/TLS. */
+    private final String protocol;
+    /** The AUTH Command value */
+    private String auth = DEFAULT_PROTOCOL;
+    /** The context object. */
+    private SSLContext context;
+    /** The socket object. */
+    private Socket plainSocket;
+    /** Controls whether a new SSL session may be established by this socket. Default true. */
+    private boolean isCreation = true;
+    /** The use client mode flag. */
+    private boolean isClientMode = true;
+
+    /** The need client auth flag. */
+    private boolean isNeedClientAuth;
+
+    /** The want client auth flag. */
+    private boolean isWantClientAuth;
+
+    /** The cipher suites */
+    private String[] suites;
+
+    /** The protocol versions */
+    private String[] protocols;
+
+    /** The FTPS {@link TrustManager} implementation, default validate only
+     * {@link TrustManagerUtils#getValidateServerCertificateTrustManager()}.
+     */
+    private TrustManager trustManager = TrustManagerUtils.getValidateServerCertificateTrustManager();
+
+    /** The {@link KeyManager}, default null (i.e. use system default). */
+    private KeyManager keyManager;
+
+    /** The {@link HostnameVerifier} to use post-TLS, default null (i.e. no verification). */
+    private HostnameVerifier hostnameVerifier;
+
+    /** Use Java 1.7+ HTTPS Endpoint Identification Algorithm. */
+    private boolean tlsEndpointChecking;
+
+    /**
+     * Constructor for FTPSClient, calls {@link #FTPSClient(String, boolean)}.
+     *
+     * Sets protocol to {@link #DEFAULT_PROTOCOL} - i.e. TLS - and security mode to explicit (isImplicit = false)
+     */
+    public FTPSClient() {
+        this(DEFAULT_PROTOCOL, false);
+    }
+
+    /**
+     * Constructor for FTPSClient, using {@link #DEFAULT_PROTOCOL} - i.e. TLS
+     * Calls {@link #FTPSClient(String, boolean)}
+     * @param isImplicit The security mode (Implicit/Explicit).
+     */
+    public FTPSClient(final boolean isImplicit) {
+        this(DEFAULT_PROTOCOL, isImplicit);
+    }
+
+
+    /**
+     * Constructor for FTPSClient, using {@link #DEFAULT_PROTOCOL} - i.e. TLS
+     * The default TrustManager is set from {@link TrustManagerUtils#getValidateServerCertificateTrustManager()}
+     * @param isImplicit The security mode(Implicit/Explicit).
+     * @param context A pre-configured SSL Context
+     */
+    public FTPSClient(final boolean isImplicit, final SSLContext context) {
+        this(DEFAULT_PROTOCOL, isImplicit);
+        this.context = context;
+    }
+
+    /**
+     * Constructor for FTPSClient, using {@link #DEFAULT_PROTOCOL} - i.e. TLS
+     * and isImplicit {@code false}
+     * Calls {@link #FTPSClient(boolean, SSLContext)}
+     * @param context A pre-configured SSL Context
+     */
+    public FTPSClient(final SSLContext context) {
+        this(false, context);
+    }
+
+
+    /**
+     * Constructor for FTPSClient, using explict mode, calls {@link #FTPSClient(String, boolean)}.
+     *
+     * @param protocol the protocol to use
+     */
+    public FTPSClient(final String protocol) {
+        this(protocol, false);
+    }
+
+    /**
+     * Constructor for FTPSClient allowing specification of protocol
+     * and security mode. If isImplicit is true, the port is set to
+     * {@link #DEFAULT_FTPS_PORT} i.e. 990.
+     * The default TrustManager is set from {@link TrustManagerUtils#getValidateServerCertificateTrustManager()}
+     * @param protocol the protocol
+     * @param isImplicit The security mode(Implicit/Explicit).
+     */
+    public FTPSClient(final String protocol, final boolean isImplicit) {
+        this.protocol = protocol;
+        this.isImplicit = isImplicit;
+        if (isImplicit) {
+            setDefaultPort(DEFAULT_FTPS_PORT);
+        }
+    }
+
+    /**
+     * Because there are so many connect() methods,
+     * the _connectAction_() method is provided as a means of performing
+     * some action immediately after establishing a connection,
+     * rather than reimplementing all of the connect() methods.
+     * @throws IOException If it throw by _connectAction_.
+     * @see org.apache.commons.net.SocketClient#_connectAction_()
+     */
+    @Override
+    protected void _connectAction_() throws IOException {
+        // Implicit mode.
+        if (isImplicit) {
+            applySocketAttributes();
+            sslNegotiation();
+        }
+        super._connectAction_();
+        // Explicit mode.
+        if (!isImplicit) {
+            execAUTH();
+            sslNegotiation();
+        }
+    }
+
+    /**
+     * Returns a socket of the data connection.
+     * Wrapped as an {@link SSLSocket}, which carries out handshake processing.
+     * @param command The int representation of the FTP command to send.
+     * @param arg The arguments to the FTP command.
+     * If this parameter is set to null, then the command is sent with
+     * no arguments.
+     * @return corresponding to the established data connection.
+     * Null is returned if an FTP protocol error is reported at any point
+     * during the establishment and initialization of the connection.
+     * @throws IOException If there is any problem with the connection.
+     * @see FTPClient#_openDataConnection_(int, String)
+     * @deprecated (3.3) Use {@link FTPClient#_openDataConnection_(FTPCmd, String)} instead
+     */
+    @Override
+    // Strictly speaking this is not needed, but it works round a Clirr bug
+    // So rather than invoke the parent code, we do it here
+    @Deprecated
+    protected Socket _openDataConnection_(final int command, final String arg)
+            throws IOException {
+        return _openDataConnection_(FTPCommand.getCommand(command), arg);
+    }
+
+    /**
+     * Returns a socket of the data connection. Wrapped as an {@link SSLSocket}, which carries out handshake processing.
+     *
+     * @param command The textual representation of the FTP command to send.
+     * @param arg The arguments to the FTP command. If this parameter is set to null, then the command is sent with no
+     *        arguments.
+     * @return corresponding to the established data connection. Null is returned if an FTP protocol error is reported
+     *         at any point during the establishment and initialization of the connection.
+     * @throws IOException If there is any problem with the connection.
+     * @see FTPClient#_openDataConnection_(int, String)
+     * @since 3.2
+     */
+    @Override
+    protected Socket _openDataConnection_(final String command, final String arg) throws IOException {
+        final Socket socket = super._openDataConnection_(command, arg);
+        _prepareDataSocket_(socket);
+        if (socket instanceof SSLSocket) {
+            final SSLSocket sslSocket = (SSLSocket) socket;
+
+            sslSocket.setUseClientMode(isClientMode);
+            sslSocket.setEnableSessionCreation(isCreation);
+
+            // server mode
+            if (!isClientMode) {
+                sslSocket.setNeedClientAuth(isNeedClientAuth);
+                sslSocket.setWantClientAuth(isWantClientAuth);
+            }
+            if (suites != null) {
+                sslSocket.setEnabledCipherSuites(suites);
+            }
+            if (protocols != null) {
+                sslSocket.setEnabledProtocols(protocols);
+            }
+            sslSocket.startHandshake();
+        }
+
+        return socket;
+    }
+
+        /**
+         * Performs any custom initialization for a newly created SSLSocket (before the SSL handshake happens). Called
+         * by {@link #_openDataConnection_(int, String)} immediately after creating the socket. The default
+         * implementation is a no-op
+         *
+         * @param socket the socket to set up
+         * @throws IOException on error
+         * @since 3.1
+         */
+        protected void _prepareDataSocket_(final Socket socket)
+            throws IOException {
+    }
+
+    /**
+     * Check the value that can be set in PROT Command value.
+     * @param prot Data Channel Protection Level.
+     * @return True - A set point is right / False - A set point is not right
+     */
+    private boolean checkPROTValue(final String prot) {
+        for (final String element : PROT_COMMAND_VALUE)
+        {
+            if (element.equals(prot)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Create SSL socket from plain socket.
+     *
+     * @param socket
+     * @return SSL Socket
+     * @throws IOException
+     */
+    private SSLSocket createSSLSocket(final Socket socket) throws IOException {
+        if (socket != null) {
+            final SSLSocketFactory f = context.getSocketFactory();
+            return (SSLSocket) f.createSocket(socket, _hostname_, socket.getPort(), false);
+        }
+        return null;
+    }
+
+    /**
+     * Closes the connection to the FTP server and restores
+     * connection parameters to the default values.
+     * <p>
+     * Calls {@code setSocketFactory(null)} and {@code setServerSocketFactory(null)}
+     * to reset the factories that may have been changed during the session,
+     * e.g. by {@link #execPROT(String)}
+     * @throws IOException If an error occurs while disconnecting.
+     * @since 3.0
+     */
+    @Override
+    public void disconnect() throws IOException
+    {
+        super.disconnect();
+        if (plainSocket != null) {
+            plainSocket.close();
+        }
+        setSocketFactory(null);
+        setServerSocketFactory(null);
+    }
+
+    /**
+     * Send the ADAT command with the specified authentication data.
+     * @param data The data to send with the command.
+     * @return server reply.
+     * @throws IOException If an I/O error occurs while sending
+     * the command.
+     * @since 3.0
+     */
+    public int execADAT(final byte[] data) throws IOException
+    {
+        if (data != null)
+        {
+            return sendCommand(CMD_ADAT, Base64.encodeBase64StringUnChunked(data));
+        }
+        return sendCommand(CMD_ADAT);
+    }
+
+    /**
+     * AUTH command.
+     * @throws SSLException If it server reply code not equal "234" and "334".
+     * @throws IOException If an I/O error occurs while either sending
+     * the command.
+     */
+    protected void execAUTH() throws SSLException, IOException {
+        final int replyCode = sendCommand(CMD_AUTH, auth);
+        if (FTPReply.SECURITY_MECHANISM_IS_OK == replyCode) {
+            // replyCode = 334
+            // I carry out an ADAT command.
+        } else if (FTPReply.SECURITY_DATA_EXCHANGE_COMPLETE != replyCode) {
+            throw new SSLException(getReplyString());
+        }
+    }
+
+    /**
+     * Send the AUTH command with the specified mechanism.
+     * @param mechanism The mechanism name to send with the command.
+     * @return server reply.
+     * @throws IOException If an I/O error occurs while sending
+     * the command.
+     * @since 3.0
+     */
+    public int execAUTH(final String mechanism) throws IOException
+    {
+        return sendCommand(CMD_AUTH, mechanism);
+    }
+
+    /**
+     * Send the CCC command to the server.
+     * The CCC (Clear Command Channel) command causes the underlying {@link SSLSocket} instance  to be assigned
+     * to a plain {@link Socket} instances
+     * @return server reply.
+     * @throws IOException If an I/O error occurs while sending
+     * the command.
+     * @since 3.0
+     */
+    public int execCCC() throws IOException
+    {
+        final int repCode = sendCommand(CMD_CCC);
+// This will be performed by sendCommand(String, String)
+//        if (FTPReply.isPositiveCompletion(repCode)) {
+//            _socket_.close();
+//            _socket_ = plainSocket;
+//            _controlInput_ = new BufferedReader(
+//                new InputStreamReader(
+//                    _socket_.getInputStream(), getControlEncoding()));
+//            _controlOutput_ = new BufferedWriter(
+//                new OutputStreamWriter(
+//                    _socket_.getOutputStream(), getControlEncoding()));
+//        }
+        return repCode;
+    }
+
+    /**
+     * Send the CONF command with the specified data.
+     * @param data The data to send with the command.
+     * @return server reply.
+     * @throws IOException If an I/O error occurs while sending
+     * the command.
+     * @since 3.0
+     */
+    public int execCONF(final byte[] data) throws IOException
+    {
+        if (data != null)
+        {
+            return sendCommand(CMD_CONF, Base64.encodeBase64StringUnChunked(data));
+        }
+        return sendCommand(CMD_CONF, ""); // perhaps "=" or just sendCommand(String)?
+    }
+
+    /**
+     * Send the ENC command with the specified data.
+     * @param data The data to send with the command.
+     * @return server reply.
+     * @throws IOException If an I/O error occurs while sending
+     * the command.
+     * @since 3.0
+     */
+    public int execENC(final byte[] data) throws IOException
+    {
+        if (data != null)
+        {
+            return sendCommand(CMD_ENC, Base64.encodeBase64StringUnChunked(data));
+        }
+        return sendCommand(CMD_ENC, ""); // perhaps "=" or just sendCommand(String)?
+    }
+
+    /**
+     * Send the MIC command with the specified data.
+     * @param data The data to send with the command.
+     * @return server reply.
+     * @throws IOException If an I/O error occurs while sending
+     * the command.
+     * @since 3.0
+     */
+    public int execMIC(final byte[] data) throws IOException
+    {
+        if (data != null)
+        {
+            return sendCommand(CMD_MIC, Base64.encodeBase64StringUnChunked(data));
+        }
+        return sendCommand(CMD_MIC, ""); // perhaps "=" or just sendCommand(String)?
+    }
+
+    /**
+     * PBSZ command. pbsz value: 0 to (2^32)-1 decimal integer.
+     * @param pbsz Protection Buffer Size.
+     * @throws SSLException If the server reply code does not equal "200".
+     * @throws IOException If an I/O error occurs while sending
+     * the command.
+     * @see #parsePBSZ(long)
+     */
+    public void execPBSZ(final long pbsz) throws SSLException, IOException {
+        if (pbsz < 0 || 4294967295L < pbsz) { // 32-bit unsigned number
+            throw new IllegalArgumentException();
+        }
+        final int status = sendCommand(CMD_PBSZ, String.valueOf(pbsz));
+        if (FTPReply.COMMAND_OK != status) {
+            throw new SSLException(getReplyString());
+        }
+    }
+
+    /**
+     * PROT command.
+     * <ul>
+     * <li>C - Clear</li>
+     * <li>S - Safe(SSL protocol only)</li>
+     * <li>E - Confidential(SSL protocol only)</li>
+     * <li>P - Private</li>
+     * </ul>
+     * <b>N.B.</b> the method calls
+     *  {@link #setSocketFactory(javax.net.SocketFactory)} and
+     *  {@link #setServerSocketFactory(javax.net.ServerSocketFactory)}
+     *
+     * @param prot Data Channel Protection Level, if {@code null}, use {@link #DEFAULT_PROT}.
+     * @throws SSLException If the server reply code does not equal  {@code 200}.
+     * @throws IOException If an I/O error occurs while sending
+     * the command.
+     */
+    public void execPROT(String prot) throws SSLException, IOException {
+        if (prot == null) {
+            prot = DEFAULT_PROT;
+        }
+        if (!checkPROTValue(prot)) {
+            throw new IllegalArgumentException();
+        }
+        if (FTPReply.COMMAND_OK != sendCommand(CMD_PROT, prot)) {
+            throw new SSLException(getReplyString());
+        }
+        if (DEFAULT_PROT.equals(prot)) {
+            setSocketFactory(null);
+            setServerSocketFactory(null);
+        } else {
+            setSocketFactory(new FTPSSocketFactory(context));
+            setServerSocketFactory(new FTPSServerSocketFactory(context));
+            initSslContext();
+        }
+    }
+
+    /**
+     * Extract the data from a reply with a prefix, e.g. PBSZ=1234 => 1234
+     * @param prefix the prefix to find
+     * @param reply where to find the prefix
+     * @return the remainder of the string after the prefix, or null if the prefix was not present.
+     */
+    private String extractPrefixedData(final String prefix, final String reply) {
+        final int idx = reply.indexOf(prefix);
+        if (idx == -1) {
+            return null;
+        }
+        // N.B. Cannot use trim before substring as leading space would affect the offset.
+        return reply.substring(idx+prefix.length()).trim();
+    }
+
+    /**
+     * Return AUTH command use value.
+     * @return AUTH command use value.
+     */
+    public String getAuthValue() {
+        return this.auth;
+    }
+
+    /**
+     * Returns the names of the cipher suites which could be enabled
+     * for use on this connection.
+     * When the underlying {@link Socket} is not an {@link SSLSocket} instance, returns null.
+     * @return An array of cipher suite names, or <code>null</code>
+     */
+    public String[] getEnabledCipherSuites() {
+        if (_socket_ instanceof SSLSocket) {
+            return ((SSLSocket)_socket_).getEnabledCipherSuites();
+        }
+        return null;
+    }
+
+    /**
+     * Returns the names of the protocol versions which are currently
+     * enabled for use on this connection.
+     * When the underlying {@link Socket} is not an {@link SSLSocket} instance, returns null.
+     * @return An array of protocols, or <code>null</code>
+     */
+    public String[] getEnabledProtocols() {
+        if (_socket_ instanceof SSLSocket) {
+            return ((SSLSocket)_socket_).getEnabledProtocols();
+        }
+        return null;
+    }
+
+    /**
+     * Returns true if new SSL sessions may be established by this socket.
+     * When the underlying {@link Socket} instance is not SSL-enabled (i.e. an
+     * instance of {@link SSLSocket} with {@link SSLSocket}{@link #getEnableSessionCreation()}) enabled,
+     * this returns False.
+     * @return true - Indicates that sessions may be created;
+     * this is the default.
+     * false - indicates that an existing session must be resumed.
+     */
+    public boolean getEnableSessionCreation() {
+        if (_socket_ instanceof SSLSocket) {
+            return ((SSLSocket)_socket_).getEnableSessionCreation();
+        }
+        return false;
+    }
+
+    /**
+     * Get the currently configured {@link HostnameVerifier}.
+     * The verifier is only used on client mode connections.
+     * @return A HostnameVerifier instance.
+     * @since 3.4
+     */
+    public HostnameVerifier getHostnameVerifier()
+    {
+        return hostnameVerifier;
+    }
+
+    /**
+     * Gets the {@link KeyManager} instance.
+     *
+     * @return The {@link KeyManager} instance
+     */
+    private KeyManager getKeyManager() {
+        return keyManager;
+    }
+
+    /**
+     * Returns true if the socket will require client authentication.
+     * When the underlying {@link Socket} is not an {@link SSLSocket} instance, returns false.
+     * @return true - If the server mode socket should request
+     * that the client authenticate itself.
+     */
+    public boolean getNeedClientAuth() {
+        if (_socket_ instanceof SSLSocket) {
+            return ((SSLSocket)_socket_).getNeedClientAuth();
+        }
+        return false;
+    }
+
+    /**
+     * Get the currently configured {@link TrustManager}.
+     *
+     * @return A TrustManager instance.
+     */
+    public TrustManager getTrustManager() {
+        return trustManager;
+    }
+
+    /**
+     * Returns true if the socket is set to use client mode
+     * in its first handshake.
+     * When the underlying {@link Socket} is not an {@link SSLSocket} instance, returns false.
+     * @return true - If the socket should start its first handshake
+     * in "client" mode.
+     */
+    public boolean getUseClientMode() {
+        if (_socket_ instanceof SSLSocket) {
+            return ((SSLSocket)_socket_).getUseClientMode();
+        }
+        return false;
+    }
+
+    /**
+     * Returns true if the socket will request client authentication.
+     * When the underlying {@link Socket} is not an {@link SSLSocket} instance, returns false.
+     * @return true - If the server mode socket should request
+     * that the client authenticate itself.
+     */
+    public boolean getWantClientAuth() {
+        if (_socket_ instanceof SSLSocket) {
+            return ((SSLSocket)_socket_).getWantClientAuth();
+        }
+        return false;
+    }
+
+    /**
+     * Performs a lazy init of the SSL context
+     * @throws IOException
+     */
+    private void initSslContext() throws IOException {
+        if (context == null) {
+            context = SSLContextUtils.createSSLContext(protocol, getKeyManager(), getTrustManager());
+        }
+    }
+
+    /**
+     * Return whether or not endpoint identification using the HTTPS algorithm
+     * on Java 1.7+ is enabled. The default behavior is for this to be disabled.
+     *
+     * This check is only performed on client mode connections.
+     *
+     * @return True if enabled, false if not.
+     * @since 3.4
+     */
+    public boolean isEndpointCheckingEnabled()
+    {
+        return tlsEndpointChecking;
+    }
+
+    /**
+     * Parses the given ADAT response line and base64-decodes the data.
+     * @param reply The ADAT reply to parse.
+     * @return the data in the reply, base64-decoded.
+     * @since 3.0
+     */
+    public byte[] parseADATReply(final String reply)
+    {
+        if (reply == null) {
+            return null;
+        }
+        return Base64.decodeBase64(extractPrefixedData("ADAT=", reply));
+    }
+
+    /**
+     * PBSZ command. pbsz value: 0 to (2^32)-1 decimal integer.
+     * Issues the command and parses the response to return the negotiated value.
+     *
+     * @param pbsz Protection Buffer Size.
+     * @throws SSLException If the server reply code does not equal "200".
+     * @throws IOException If an I/O error occurs while sending
+     * the command.
+     * @return the negotiated value.
+     * @see #execPBSZ(long)
+     * @since 3.0
+     */
+    public long parsePBSZ(final long pbsz) throws SSLException, IOException {
+        execPBSZ(pbsz);
+        long minvalue = pbsz;
+        final String remainder = extractPrefixedData("PBSZ=", getReplyString());
+        if (remainder != null) {
+            final long replysz = Long.parseLong(remainder);
+            if (replysz < minvalue) {
+                minvalue = replysz;
+            }
+        }
+        return minvalue;
+    }
+
+    /**
+     * Send an FTP command.
+     * A successful CCC (Clear Command Channel) command causes the underlying {@link SSLSocket}
+     * instance to be assigned to a plain {@link Socket}
+     * @param command The FTP command.
+     * @return server reply.
+     * @throws IOException If an I/O error occurs while sending the command.
+     * @throws SSLException if a CCC command fails
+     * @see org.apache.commons.net.ftp.FTP#sendCommand(String)
+     */
+    // Would like to remove this method, but that will break any existing clients that are using CCC
+    @Override
+    public int sendCommand(final String command, final String args) throws IOException {
+        final int repCode = super.sendCommand(command, args);
+        /* If CCC is issued, restore socket i/o streams to unsecured versions */
+        if (CMD_CCC.equals(command)) {
+            if (FTPReply.COMMAND_OK != repCode) {
+                throw new SSLException(getReplyString());
+            }
+            _socket_.close();
+            _socket_ = plainSocket;
+            _controlInput_ = new BufferedReader(
+                new InputStreamReader(
+                    _socket_ .getInputStream(), getControlEncoding()));
+            _controlOutput_ = new BufferedWriter(
+                new OutputStreamWriter(
+                    _socket_.getOutputStream(), getControlEncoding()));
+        }
+        return repCode;
+    }
+
+    /**
+     * Set AUTH command use value.
+     * This processing is done before connected processing.
+     * @param auth AUTH command use value.
+     */
+    public void setAuthValue(final String auth) {
+        this.auth = auth;
+    }
+
+    /**
+     * Controls which particular cipher suites are enabled for use on this
+     * connection. Called before server negotiation.
+     * @param cipherSuites The cipher suites.
+     */
+    public void setEnabledCipherSuites(final String[] cipherSuites) {
+        suites = cipherSuites.clone();
+    }
+
+    /**
+     * Controls which particular protocol versions are enabled for use on this
+     * connection. I perform setting before a server negotiation.
+     * @param protocolVersions The protocol versions.
+     */
+    public void setEnabledProtocols(final String[] protocolVersions) {
+        protocols = protocolVersions.clone();
+    }
+
+    /**
+     * Controls whether a new SSL session may be established by this socket.
+     * @param isCreation The established socket flag.
+     */
+    public void setEnabledSessionCreation(final boolean isCreation) {
+        this.isCreation = isCreation;
+    }
+
+    /**
+     * Automatic endpoint identification checking using the HTTPS algorithm
+     * is supported on Java 1.7+. The default behavior is for this to be disabled.
+     *
+     * This check is only performed on client mode connections.
+     *
+     * @param enable Enable automatic endpoint identification checking using the HTTPS algorithm on Java 1.7+.
+     * @since 3.4
+     */
+    public void setEndpointCheckingEnabled(final boolean enable)
+    {
+        tlsEndpointChecking = enable;
+    }
+
+    /**
+     * Override the default {@link HostnameVerifier} to use.
+     * The verifier is only used on client mode connections.
+     * @param newHostnameVerifier The HostnameVerifier implementation to set or <code>null</code> to disable.
+     * @since 3.4
+     */
+    public void setHostnameVerifier(final HostnameVerifier newHostnameVerifier)
+    {
+        hostnameVerifier = newHostnameVerifier;
+    }
+
+    /**
+    * Set a {@link KeyManager} to use
+    *
+    * @param keyManager The KeyManager implementation to set.
+    * @see org.apache.commons.net.util.KeyManagerUtils
+    */
+    public void setKeyManager(final KeyManager keyManager) {
+        this.keyManager = keyManager;
+    }
+
+    /**
+     * Configures the socket to require client authentication.
+     * @param isNeedClientAuth The need client auth flag.
+     */
+    public void setNeedClientAuth(final boolean isNeedClientAuth) {
+        this.isNeedClientAuth = isNeedClientAuth;
+    }
+
+    // DEPRECATED - for API compatibility only - DO NOT USE
+
+    /**
+     * Override the default {@link TrustManager} to use; if set to {@code null},
+     * the default TrustManager from the JVM will be used.
+     *
+     * @param trustManager The TrustManager implementation to set, may be {@code null}
+     * @see org.apache.commons.net.util.TrustManagerUtils
+     */
+    public void setTrustManager(final TrustManager trustManager) {
+        this.trustManager = trustManager;
+    }
+
+    /**
+     * Configures the socket to use client (or server) mode in its first
+     * handshake.
+     * @param isClientMode The use client mode flag.
+     */
+    public void setUseClientMode(final boolean isClientMode) {
+        this.isClientMode = isClientMode;
+    }
+
+    /**
+     * Configures the socket to request client authentication,
+     * but only if such a request is appropriate to the cipher
+     * suite negotiated.
+     * @param isWantClientAuth The want client auth flag.
+     */
+    public void setWantClientAuth(final boolean isWantClientAuth) {
+        this.isWantClientAuth = isWantClientAuth;
+    }
+
+    /**
+     * SSL/TLS negotiation. Acquires an SSL socket of a control
+     * connection and carries out handshake processing.
+     * @throws IOException If server negotiation fails
+     */
+    protected void sslNegotiation() throws IOException {
+        plainSocket = _socket_;
+        initSslContext();
+        final SSLSocket socket = createSSLSocket(_socket_);
+        socket.setEnableSessionCreation(isCreation);
+        socket.setUseClientMode(isClientMode);
+
+        // client mode
+        if (isClientMode) {
+            if (tlsEndpointChecking) {
+                SSLSocketUtils.enableEndpointNameVerification(socket);
+            }
+        } else { // server mode
+            socket.setNeedClientAuth(isNeedClientAuth);
+            socket.setWantClientAuth(isWantClientAuth);
+        }
+
+        if (protocols != null) {
+            socket.setEnabledProtocols(protocols);
+        }
+        if (suites != null) {
+            socket.setEnabledCipherSuites(suites);
+        }
+        socket.startHandshake();
+
+        // TODO the following setup appears to duplicate that in the super class methods
+        _socket_ = socket;
+        _controlInput_ = new BufferedReader(new InputStreamReader(
+                socket .getInputStream(), getControlEncoding()));
+        _controlOutput_ = new BufferedWriter(new OutputStreamWriter(
+                socket.getOutputStream(), getControlEncoding()));
+
+        if (isClientMode && (hostnameVerifier != null &&
+            !hostnameVerifier.verify(_hostname_, socket.getSession()))) {
+            throw new SSLHandshakeException("Hostname doesn't match certificate");
+        }
+    }
+
+}
+/* kate: indent-width 4; replace-tabs on; */
diff --git a/src/main/java/org/apache/commons/net/nntp/Threader.java b/src/main/java/org/apache/commons/net/nntp/Threader.java
index 55f476ec7..481fcde09 100644
--- a/src/main/java/org/apache/commons/net/nntp/Threader.java
+++ b/src/main/java/org/apache/commons/net/nntp/Threader.java
@@ -1,464 +1,464 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.commons.net.nntp;
-
-/**
- * This is an implementation of a message threading algorithm, as originally devised by Zamie Zawinski.
- * See <a href="http://www.jwz.org/doc/threading.html">http://www.jwz.org/doc/threading.html</a> for details.
- * For his Java implementation, see
- * <a href="http://lxr.mozilla.org/mozilla/source/grendel/sources/grendel/view/Threader.java">
- * http://lxr.mozilla.org/mozilla/source/grendel/sources/grendel/view/Threader.java</a>
- */
-
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-public class Threader {
-
-    /**
-     *
-     * @param threadable
-     * @param idTable
-     */
-    private void buildContainer(final Threadable threadable, final HashMap<String,ThreadContainer> idTable) {
-        String id = threadable.messageThreadId();
-        ThreadContainer container = idTable.get(id);
-        int bogusIdCount = 0;
-
-        // A ThreadContainer exists for this id already. This should be a forward reference, but may
-        // be a duplicate id, in which case we will need to generate a bogus placeholder id
-        if (container != null) {
-            if (container.threadable != null) { // oops! duplicate ids...
-                bogusIdCount++ ; // Avoid dead local store warning
-                id = "<Bogus-id:" + (bogusIdCount) + ">";
-                container = null;
-            } else {
-                // The container just contained a forward reference to this message, so let's
-                // fill in the threadable field of the container with this message
-                container.threadable = threadable;
-            }
-        }
-
-        // No container exists for that message Id. Create one and insert it into the hash table.
-        if (container == null) {
-            container = new ThreadContainer();
-            container.threadable = threadable;
-            idTable.put(id, container);
-        }
-
-        // Iterate through all of the references and create ThreadContainers for any references that
-        // don't have them.
-        ThreadContainer parentRef = null;
-        {
-            final String[] references = threadable.messageThreadReferences();
-            for (final String refString : references)
-            {
-                ThreadContainer ref = idTable.get(refString);
-
-                // if this id doesnt have a container, create one
-                if (ref == null) {
-                    ref = new ThreadContainer();
-                    idTable.put(refString, ref);
-                }
-
-                // Link references together in the order they appear in the References: header,
-                // IF they dont have a have a parent already &&
-                // IF it will not cause a circular reference
-                if ((parentRef != null)
-                    && (ref.parent == null)
-                    && (parentRef != ref)
-                    && !(ref.findChild(parentRef))) {
-                    // Link ref into the parent's child list
-                    ref.parent = parentRef;
-                    ref.next = parentRef.child;
-                    parentRef.child = ref;
-                }
-                parentRef = ref;
-            }
-        }
-
-        // parentRef is now set to the container of the last element in the references field. make that
-        // be the parent of this container, unless doing so causes a circular reference
-        if (parentRef != null
-            && (parentRef == container || container.findChild(parentRef)))
-        {
-            parentRef = null;
-        }
-
-        // if it has a parent already, its because we saw this message in a References: field, and presumed
-        // a parent based on the other entries in that field. Now that we have the actual message, we can
-        // throw away the old parent and use this new one
-        if (container.parent != null) {
-            ThreadContainer rest, prev;
-
-            for (prev = null, rest = container.parent.child;
-                rest != null;
-                prev = rest, rest = rest.next) {
-                if (rest == container) {
-                    break;
-                }
-            }
-
-            if (rest == null) {
-                throw new RuntimeException(
-                    "Didnt find "
-                        + container
-                        + " in parent"
-                        + container.parent);
-            }
-
-            // Unlink this container from the parent's child list
-            if (prev == null) {
-                container.parent.child = container.next;
-            } else {
-                prev.next = container.next;
-            }
-
-            container.next = null;
-            container.parent = null;
-        }
-
-        // If we have a parent, link container into the parents child list
-        if (parentRef != null) {
-            container.parent = parentRef;
-            container.next = parentRef.child;
-            parentRef.child = container;
-        }
-    }
-
-    /**
-     * Find the root set of all existing ThreadContainers
-     * @param idTable
-     * @return root the ThreadContainer representing the root node
-     */
-    private ThreadContainer findRootSet(final HashMap<String, ThreadContainer> idTable) {
-        final ThreadContainer root = new ThreadContainer();
-        for (final Map.Entry<String, ThreadContainer> entry : idTable.entrySet()) {
-            final ThreadContainer c = entry.getValue();
-            if (c.parent == null) {
-                if (c.next != null) {
-                    throw new RuntimeException("c.next is " + c.next.toString());
-                }
-                c.next = root.child;
-                root.child = c;
-            }
-        }
-        return root;
-    }
-
-    /**
-     *  If any two members of the root set have the same subject, merge them.
-     *  This is to attempt to accomodate messages without References: headers.
-     * @param root
-     */
-    private void gatherSubjects(final ThreadContainer root) {
-
-        int count = 0;
-
-        for (ThreadContainer c = root.child; c != null; c = c.next) {
-            count++;
-        }
-
-        // TODO verify this will avoid rehashing
-        HashMap<String, ThreadContainer> subjectTable = new HashMap<>((int) (count * 1.2), (float) 0.9);
-        count = 0;
-
-        for (ThreadContainer c = root.child; c != null; c = c.next) {
-            Threadable threadable = c.threadable;
-
-            // No threadable? If so, it is a dummy node in the root set.
-            // Only root set members may be dummies, and they alway have at least 2 kids
-            // Take the first kid as representative of the subject
-            if (threadable == null) {
-                threadable = c.child.threadable;
-            }
-
-            final String subj = threadable.simplifiedSubject();
-
-            if (subj == null || subj.isEmpty()) {
-                continue;
-            }
-
-            final ThreadContainer old = subjectTable.get(subj);
-
-            // Add this container to the table iff:
-            // - There exists no container with this subject
-            // - or this is a dummy container and the old one is not - the dummy one is
-            // more interesting as a root, so put it in the table instead
-            // - The container in the table has a "Re:" version of this subject, and
-            // this container has a non-"Re:" version of this subject. The non-"Re:" version
-            // is the more interesting of the two.
-            if (old == null
-                || (c.threadable == null && old.threadable != null)
-                || (old.threadable != null
-                    && old.threadable.subjectIsReply()
-                    && c.threadable != null
-                    && !c.threadable.subjectIsReply())) {
-                subjectTable.put(subj, c);
-                count++;
-            }
-        }
-
-        // If the table is empty, we're done
-        if (count == 0) {
-            return;
-        }
-
-        // subjectTable is now populated with one entry for each subject which occurs in the
-        // root set. Iterate over the root set, and gather together the difference.
-        ThreadContainer prev, c, rest;
-        for (prev = null, c = root.child, rest = c.next;
-            c != null;
-            prev = c, c = rest, rest = (rest == null ? null : rest.next)) {
-            Threadable threadable = c.threadable;
-
-            // is it a dummy node?
-            if (threadable == null) {
-                threadable = c.child.threadable;
-            }
-
-            final String subj = threadable.simplifiedSubject();
-
-            // Dont thread together all subjectless messages
-            if (subj == null || subj.isEmpty()) {
-                continue;
-            }
-
-            final ThreadContainer old = subjectTable.get(subj);
-
-            if (old == c) { // That's us
-                continue;
-            }
-
-            // We have now found another container in the root set with the same subject
-            // Remove the "second" message from the root set
-            if (prev == null) {
-                root.child = c.next;
-            } else {
-                prev.next = c.next;
-            }
-            c.next = null;
-
-            if (old.threadable == null && c.threadable == null) {
-                // both dummies - merge them
-                ThreadContainer tail;
-                for (tail = old.child;
-                    tail != null && tail.next != null;
-                    tail = tail.next) {
-                    // do nothing
-                }
-
-                if (tail != null) { // protect against possible NPE
-                    tail.next = c.child;
-                }
-
-                for (tail = c.child; tail != null; tail = tail.next) {
-                    tail.parent = old;
-                }
-
-                c.child = null;
-            } else if (
-                old.threadable == null
-                    || (c.threadable != null
-                        && c.threadable.subjectIsReply()
-                        && !old.threadable.subjectIsReply())) {
-                // Else if old is empty, or c has "Re:" and old does not  ==> make this message a child of old
-                c.parent = old;
-                c.next = old.child;
-                old.child = c;
-            } else {
-                // else make the old and new messages be children of a new dummy container.
-                // We create a new container object for old.msg and empty the old container
-                final ThreadContainer newc = new ThreadContainer();
-                newc.threadable = old.threadable;
-                newc.child = old.child;
-
-                for (ThreadContainer tail = newc.child;
-                    tail != null;
-                    tail = tail.next)
-                {
-                    tail.parent = newc;
-                }
-
-                old.threadable = null;
-                old.child = null;
-
-                c.parent = old;
-                newc.parent = old;
-
-                // Old is now a dummy- give it 2 kids , c and newc
-                old.child = c;
-                c.next = newc;
-            }
-            // We've done a merge, so keep the same prev
-            c = prev;
-        }
-
-        subjectTable.clear();
-        subjectTable = null;
-
-    }
-
-    /**
-     * Delete any empty or dummy ThreadContainers
-     * @param parent
-     */
-    private void pruneEmptyContainers(final ThreadContainer parent) {
-        ThreadContainer container, prev, next;
-        for (prev = null, container = parent.child, next = container.next;
-            container != null;
-            prev = container,
-                container = next,
-                next = (container == null ? null : container.next)) {
-
-            // Is it empty and without any children? If so,delete it
-            if (container.threadable == null && container.child == null) {
-                if (prev == null) {
-                    parent.child = container.next;
-                } else {
-                    prev.next = container.next;
-                }
-
-                // Set container to prev so that prev keeps its same value the next time through the loop
-                container = prev;
-            }
-
-            // Else if empty, with kids, and (not at root or only one kid)
-            else if (
-                container.threadable == null
-                    && container.child != null
-                    && (container.parent != null
-                        || container.child.next == null)) {
-                // We have an invalid/expired message with kids. Promote the kids to this level.
-                ThreadContainer tail;
-                final ThreadContainer kids = container.child;
-
-                // Remove this container and replace with 'kids'.
-                if (prev == null) {
-                    parent.child = kids;
-                } else {
-                    prev.next = kids;
-                }
-
-                // Make each child's parent be this level's parent -> i.e. promote the children.
-                // Make the last child's next point to this container's next
-                // i.e. splice kids into the list in place of container
-                for (tail = kids; tail.next != null; tail = tail.next) {
-                    tail.parent = container.parent;
-                }
-
-                tail.parent = container.parent;
-                tail.next = container.next;
-
-                // next currently points to the item after the inserted items in the chain - reset that so we process the newly
-                // promoted items next time round
-                next = kids;
-
-                // Set container to prev so that prev keeps its same value the next time through the loop
-                container = prev;
-            } else if (container.child != null) {
-                // A real message , with kids
-                // Iterate over the children
-                pruneEmptyContainers(container);
-            }
-        }
-    }
-
-    /**
-     * The client passes in a list of Iterable objects, and
-     * the Threader constructs a connected 'graph' of messages
-     * @param messages iterable of messages to thread, must not be empty
-     * @return null if messages == null or root.child == null or messages list is empty
-     * @since 3.0
-     */
-    public Threadable thread(final Iterable<? extends Threadable> messages) {
-        if (messages == null) {
-            return null;
-        }
-
-        HashMap<String,ThreadContainer> idTable = new HashMap<>();
-
-        // walk through each Threadable element
-        for (final Threadable t : messages) {
-            if (!t.isDummy()) {
-                buildContainer(t, idTable);
-            }
-        }
-
-        if (idTable.isEmpty()) {
-            return null;
-        }
-
-        final ThreadContainer root = findRootSet(idTable);
-        idTable.clear();
-        idTable = null;
-
-        pruneEmptyContainers(root);
-
-        root.reverseChildren();
-        gatherSubjects(root);
-
-        if (root.next != null) {
-            throw new RuntimeException("root node has a next:" + root);
-        }
-
-        for (ThreadContainer r = root.child; r != null; r = r.next) {
-            if (r.threadable == null) {
-                r.threadable = r.child.threadable.makeDummy();
-            }
-        }
-
-        final Threadable result = (root.child == null ? null : root.child.threadable);
-        root.flush();
-
-        return result;
-    }
-
-    /**
-     * The client passes in a list of Threadable objects, and
-     * the Threader constructs a connected 'graph' of messages
-     * @param messages list of messages to thread, must not be empty
-     * @return null if messages == null or root.child == null or messages list is empty
-     * @since 2.2
-     */
-    public Threadable thread(final List<? extends Threadable> messages) {
-        return thread((Iterable<? extends Threadable>)messages);
-    }
-
-
-    // DEPRECATED METHODS - for API compatibility only - DO NOT USE
-
-    /**
-     * The client passes in an array of Threadable objects, and
-     * the Threader constructs a connected 'graph' of messages
-     * @param messages array of messages to thread, must not be empty
-     * @return null if messages == null or root.child == null or messages array is empty
-     * @deprecated (2.2) prefer {@link #thread(List)}
-     */
-    @Deprecated
-    public Threadable thread(final Threadable[] messages) {
-        if (messages == null) {
-            return null;
-        }
-        return thread(Arrays.asList(messages));
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.commons.net.nntp;
+
+/**
+ * This is an implementation of a message threading algorithm, as originally devised by Zamie Zawinski.
+ * See <a href="http://www.jwz.org/doc/threading.html">http://www.jwz.org/doc/threading.html</a> for details.
+ * For his Java implementation, see
+ * <a href="http://lxr.mozilla.org/mozilla/source/grendel/sources/grendel/view/Threader.java">
+ * http://lxr.mozilla.org/mozilla/source/grendel/sources/grendel/view/Threader.java</a>
+ */
+
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class Threader {
+
+    /**
+     *
+     * @param threadable
+     * @param idTable
+     */
+    private void buildContainer(final Threadable threadable, final HashMap<String,ThreadContainer> idTable) {
+        String id = threadable.messageThreadId();
+        ThreadContainer container = idTable.get(id);
+        int bogusIdCount = 0;
+
+        // A ThreadContainer exists for this id already. This should be a forward reference, but may
+        // be a duplicate id, in which case we will need to generate a bogus placeholder id
+        if (container != null) {
+            if (container.threadable != null) { // oops! duplicate ids...
+                bogusIdCount++ ; // Avoid dead local store warning
+                id = "<Bogus-id:" + (bogusIdCount) + ">";
+                container = null;
+            } else {
+                // The container just contained a forward reference to this message, so let's
+                // fill in the threadable field of the container with this message
+                container.threadable = threadable;
+            }
+        }
+
+        // No container exists for that message Id. Create one and insert it into the hash table.
+        if (container == null) {
+            container = new ThreadContainer();
+            container.threadable = threadable;
+            idTable.put(id, container);
+        }
+
+        // Iterate through all of the references and create ThreadContainers for any references that
+        // don't have them.
+        ThreadContainer parentRef = null;
+        {
+            final String[] references = threadable.messageThreadReferences();
+            for (final String refString : references)
+            {
+                ThreadContainer ref = idTable.get(refString);
+
+                // if this id doesnt have a container, create one
+                if (ref == null) {
+                    ref = new ThreadContainer();
+                    idTable.put(refString, ref);
+                }
+
+                // Link references together in the order they appear in the References: header,
+                // IF they dont have a have a parent already &&
+                // IF it will not cause a circular reference
+                if ((parentRef != null)
+                    && (ref.parent == null)
+                    && (parentRef != ref)
+                    && !(ref.findChild(parentRef))) {
+                    // Link ref into the parent's child list
+                    ref.parent = parentRef;
+                    ref.next = parentRef.child;
+                    parentRef.child = ref;
+                }
+                parentRef = ref;
+            }
+        }
+
+        // parentRef is now set to the container of the last element in the references field. make that
+        // be the parent of this container, unless doing so causes a circular reference
+        if (parentRef != null
+            && (parentRef == container || container.findChild(parentRef)))
+        {
+            parentRef = null;
+        }
+
+        // if it has a parent already, its because we saw this message in a References: field, and presumed
+        // a parent based on the other entries in that field. Now that we have the actual message, we can
+        // throw away the old parent and use this new one
+        if (container.parent != null) {
+            ThreadContainer rest, prev;
+
+            for (prev = null, rest = container.parent.child;
+                rest != null;
+                prev = rest, rest = rest.next) {
+                if (rest == container) {
+                    break;
+                }
+            }
+
+            if (rest == null) {
+                throw new RuntimeException(
+                    "Didnt find "
+                        + container
+                        + " in parent"
+                        + container.parent);
+            }
+
+            // Unlink this container from the parent's child list
+            if (prev == null) {
+                container.parent.child = container.next;
+            } else {
+                prev.next = container.next;
+            }
+
+            container.next = null;
+            container.parent = null;
+        }
+
+        // If we have a parent, link container into the parents child list
+        if (parentRef != null) {
+            container.parent = parentRef;
+            container.next = parentRef.child;
+            parentRef.child = container;
+        }
+    }
+
+    /**
+     * Find the root set of all existing ThreadContainers
+     * @param idTable
+     * @return root the ThreadContainer representing the root node
+     */
+    private ThreadContainer findRootSet(final HashMap<String, ThreadContainer> idTable) {
+        final ThreadContainer root = new ThreadContainer();
+        for (final Map.Entry<String, ThreadContainer> entry : idTable.entrySet()) {
+            final ThreadContainer c = entry.getValue();
+            if (c.parent == null) {
+                if (c.next != null) {
+                    throw new RuntimeException("c.next is " + c.next.toString());
+                }
+                c.next = root.child;
+                root.child = c;
+            }
+        }
+        return root;
+    }
+
+    /**
+     *  If any two members of the root set have the same subject, merge them.
+     *  This is to attempt to accomodate messages without References: headers.
+     * @param root
+     */
+    private void gatherSubjects(final ThreadContainer root) {
+
+        int count = 0;
+
+        for (ThreadContainer c = root.child; c != null; c = c.next) {
+            count++;
+        }
+
+        // TODO verify this will avoid rehashing
+        HashMap<String, ThreadContainer> subjectTable = new HashMap<>((int) (count * 1.2), (float) 0.9);
+        count = 0;
+
+        for (ThreadContainer c = root.child; c != null; c = c.next) {
+            Threadable threadable = c.threadable;
+
+            // No threadable? If so, it is a dummy node in the root set.
+            // Only root set members may be dummies, and they alway have at least 2 kids
+            // Take the first kid as representative of the subject
+            if (threadable == null) {
+                threadable = c.child.threadable;
+            }
+
+            final String subj = threadable.simplifiedSubject();
+
+            if (subj == null || subj.isEmpty()) {
+                continue;
+            }
+
+            final ThreadContainer old = subjectTable.get(subj);
+
+            // Add this container to the table iff:
+            // - There exists no container with this subject
+            // - or this is a dummy container and the old one is not - the dummy one is
+            // more interesting as a root, so put it in the table instead
+            // - The container in the table has a "Re:" version of this subject, and
+            // this container has a non-"Re:" version of this subject. The non-"Re:" version
+            // is the more interesting of the two.
+            if (old == null
+                || (c.threadable == null && old.threadable != null)
+                || (old.threadable != null
+                    && old.threadable.subjectIsReply()
+                    && c.threadable != null
+                    && !c.threadable.subjectIsReply())) {
+                subjectTable.put(subj, c);
+                count++;
+            }
+        }
+
+        // If the table is empty, we're done
+        if (count == 0) {
+            return;
+        }
+
+        // subjectTable is now populated with one entry for each subject which occurs in the
+        // root set. Iterate over the root set, and gather together the difference.
+        ThreadContainer prev, c, rest;
+        for (prev = null, c = root.child, rest = c.next;
+            c != null;
+            prev = c, c = rest, rest = (rest == null ? null : rest.next)) {
+            Threadable threadable = c.threadable;
+
+            // is it a dummy node?
+            if (threadable == null) {
+                threadable = c.child.threadable;
+            }
+
+            final String subj = threadable.simplifiedSubject();
+
+            // Dont thread together all subjectless messages
+            if (subj == null || subj.isEmpty()) {
+                continue;
+            }
+
+            final ThreadContainer old = subjectTable.get(subj);
+
+            if (old == c) { // That's us
+                continue;
+            }
+
+            // We have now found another container in the root set with the same subject
+            // Remove the "second" message from the root set
+            if (prev == null) {
+                root.child = c.next;
+            } else {
+                prev.next = c.next;
+            }
+            c.next = null;
+
+            if (old.threadable == null && c.threadable == null) {
+                // both dummies - merge them
+                ThreadContainer tail;
+                for (tail = old.child;
+                    tail != null && tail.next != null;
+                    tail = tail.next) {
+                    // do nothing
+                }
+
+                if (tail != null) { // protect against possible NPE
+                    tail.next = c.child;
+                }
+
+                for (tail = c.child; tail != null; tail = tail.next) {
+                    tail.parent = old;
+                }
+
+                c.child = null;
+            } else if (
+                old.threadable == null
+                    || (c.threadable != null
+                        && c.threadable.subjectIsReply()
+                        && !old.threadable.subjectIsReply())) {
+                // Else if old is empty, or c has "Re:" and old does not  ==> make this message a child of old
+                c.parent = old;
+                c.next = old.child;
+                old.child = c;
+            } else {
+                // else make the old and new messages be children of a new dummy container.
+                // We create a new container object for old.msg and empty the old container
+                final ThreadContainer newc = new ThreadContainer();
+                newc.threadable = old.threadable;
+                newc.child = old.child;
+
+                for (ThreadContainer tail = newc.child;
+                    tail != null;
+                    tail = tail.next)
+                {
+                    tail.parent = newc;
+                }
+
+                old.threadable = null;
+                old.child = null;
+
+                c.parent = old;
+                newc.parent = old;
+
+                // Old is now a dummy- give it 2 kids , c and newc
+                old.child = c;
+                c.next = newc;
+            }
+            // We've done a merge, so keep the same prev
+            c = prev;
+        }
+
+        subjectTable.clear();
+        subjectTable = null;
+
+    }
+
+    /**
+     * Delete any empty or dummy ThreadContainers
+     * @param parent
+     */
+    private void pruneEmptyContainers(final ThreadContainer parent) {
+        ThreadContainer container, prev, next;
+        for (prev = null, container = parent.child, next = container.next;
+            container != null;
+            prev = container,
+                container = next,
+                next = (container == null ? null : container.next)) {
+
+            // Is it empty and without any children? If so,delete it
+            if (container.threadable == null && container.child == null) {
+                if (prev == null) {
+                    parent.child = container.next;
+                } else {
+                    prev.next = container.next;
+                }
+
+                // Set container to prev so that prev keeps its same value the next time through the loop
+                container = prev;
+            }
+
+            // Else if empty, with kids, and (not at root or only one kid)
+            else if (
+                container.threadable == null
+                    && container.child != null
+                    && (container.parent != null
+                        || container.child.next == null)) {
+                // We have an invalid/expired message with kids. Promote the kids to this level.
+                ThreadContainer tail;
+                final ThreadContainer kids = container.child;
+
+                // Remove this container and replace with 'kids'.
+                if (prev == null) {
+                    parent.child = kids;
+                } else {
+                    prev.next = kids;
+                }
+
+                // Make each child's parent be this level's parent -> i.e. promote the children.
+                // Make the last child's next point to this container's next
+                // i.e. splice kids into the list in place of container
+                for (tail = kids; tail.next != null; tail = tail.next) {
+                    tail.parent = container.parent;
+                }
+
+                tail.parent = container.parent;
+                tail.next = container.next;
+
+                // next currently points to the item after the inserted items in the chain - reset that so we process the newly
+                // promoted items next time round
+                next = kids;
+
+                // Set container to prev so that prev keeps its same value the next time through the loop
+                container = prev;
+            } else if (container.child != null) {
+                // A real message , with kids
+                // Iterate over the children
+                pruneEmptyContainers(container);
+            }
+        }
+    }
+
+    /**
+     * The client passes in a list of Iterable objects, and
+     * the Threader constructs a connected 'graph' of messages
+     * @param messages iterable of messages to thread, must not be empty
+     * @return null if messages == null or root.child == null or messages list is empty
+     * @since 3.0
+     */
+    public Threadable thread(final Iterable<? extends Threadable> messages) {
+        if (messages == null) {
+            return null;
+        }
+
+        HashMap<String,ThreadContainer> idTable = new HashMap<>();
+
+        // walk through each Threadable element
+        for (final Threadable t : messages) {
+            if (!t.isDummy()) {
+                buildContainer(t, idTable);
+            }
+        }
+
+        if (idTable.isEmpty()) {
+            return null;
+        }
+
+        final ThreadContainer root = findRootSet(idTable);
+        idTable.clear();
+        idTable = null;
+
+        pruneEmptyContainers(root);
+
+        root.reverseChildren();
+        gatherSubjects(root);
+
+        if (root.next != null) {
+            throw new RuntimeException("root node has a next:" + root);
+        }
+
+        for (ThreadContainer r = root.child; r != null; r = r.next) {
+            if (r.threadable == null) {
+                r.threadable = r.child.threadable.makeDummy();
+            }
+        }
+
+        final Threadable result = (root.child == null ? null : root.child.threadable);
+        root.flush();
+
+        return result;
+    }
+
+    /**
+     * The client passes in a list of Threadable objects, and
+     * the Threader constructs a connected 'graph' of messages
+     * @param messages list of messages to thread, must not be empty
+     * @return null if messages == null or root.child == null or messages list is empty
+     * @since 2.2
+     */
+    public Threadable thread(final List<? extends Threadable> messages) {
+        return thread((Iterable<? extends Threadable>)messages);
+    }
+
+
+    // DEPRECATED METHODS - for API compatibility only - DO NOT USE
+
+    /**
+     * The client passes in an array of Threadable objects, and
+     * the Threader constructs a connected 'graph' of messages
+     * @param messages array of messages to thread, must not be empty
+     * @return null if messages == null or root.child == null or messages array is empty
+     * @deprecated (2.2) prefer {@link #thread(List)}
+     */
+    @Deprecated
+    public Threadable thread(final Threadable[] messages) {
+        if (messages == null) {
+            return null;
+        }
+        return thread(Arrays.asList(messages));
+    }
+
+}
diff --git a/src/main/java/org/apache/commons/net/ntp/NTPUDPClient.java b/src/main/java/org/apache/commons/net/ntp/NTPUDPClient.java
index 3bce8f7da..5939a4ca4 100644
--- a/src/main/java/org/apache/commons/net/ntp/NTPUDPClient.java
+++ b/src/main/java/org/apache/commons/net/ntp/NTPUDPClient.java
@@ -1,144 +1,144 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.net.ntp;
-
-import java.io.IOException;
-import java.net.DatagramPacket;
-import java.net.InetAddress;
-
-import org.apache.commons.net.DatagramSocketClient;
-
-/**
- * The NTPUDPClient class is a UDP implementation of a client for the
- * Network Time Protocol (NTP) described in RFC 1305 as well as the
- * Simple Network Time Protocol (SNTP) in RFC-2030. To use the class,
- * merely open a local datagram socket with <a href="#open"> open </a>
- * and call <a href="#getTime"> getTime </a> to retrieve the time. Then call
- * <a href="org.apache.commons.net.DatagramSocketClient.html#close"> close </a>
- * to close the connection properly.
- * Successive calls to <a href="#getTime"> getTime </a> are permitted
- * without re-establishing a connection.  That is because UDP is a
- * connectionless protocol and the Network Time Protocol is stateless.
- *
- */
-
-public final class NTPUDPClient extends DatagramSocketClient
-{
-    /** The default NTP port.  It is set to 123 according to RFC 1305. */
-    public static final int DEFAULT_PORT = 123;
-
-    private int version = NtpV3Packet.VERSION_3;
-
-    /**
-     * Retrieves the time information from the specified server on the
-     * default NTP port and returns it. The time is the number of miliiseconds
-     * since 00:00 (midnight) 1 January 1900 UTC, as specified by RFC 1305.
-     * This method reads the raw NTP packet and constructs a <i>TimeInfo</i>
-     * object that allows access to all the fields of the NTP message header.
-     * <p>
-     * @param host The address of the server.
-     * @return The time value retrieved from the server.
-     * @throws IOException If an error occurs while retrieving the time.
-     */
-    public TimeInfo getTime(final InetAddress host) throws IOException
-    {
-        return getTime(host, NtpV3Packet.NTP_PORT);
-    }
-
-    /**
-     * Retrieves the time information from the specified server and port and
-     * returns it. The time is the number of miliiseconds since
-     * 00:00 (midnight) 1 January 1900 UTC, as specified by RFC 1305.
-     * This method reads the raw NTP packet and constructs a <i>TimeInfo</i>
-     * object that allows access to all the fields of the NTP message header.
-     * <p>
-     * @param host The address of the server.
-     * @param port The port of the service.
-     * @return The time value retrieved from the server.
-     * @throws IOException If an error occurs while retrieving the time or if
-     *                     received packet does not match the request.
-     */
-    public TimeInfo getTime(final InetAddress host, final int port) throws IOException
-    {
-        // if not connected then open to next available UDP port
-        if (!isOpen())
-        {
-            open();
-        }
-
-        final NtpV3Packet message = new NtpV3Impl();
-        message.setMode(NtpV3Packet.MODE_CLIENT);
-        message.setVersion(version);
-        final DatagramPacket sendPacket = message.getDatagramPacket();
-        sendPacket.setAddress(host);
-        sendPacket.setPort(port);
-
-        final NtpV3Packet recMessage = new NtpV3Impl();
-        final DatagramPacket receivePacket = recMessage.getDatagramPacket();
-
-        /*
-         * Must minimize the time between getting the current time,
-         * timestamping the packet, and sending it out which
-         * introduces an error in the delay time.
-         * No extraneous logging and initializations here !!!
-         */
-        final TimeStamp now = TimeStamp.getCurrentTime();
-
-        // Note that if you do not set the transmit time field then originating time
-        // in server response is all 0's which is "Thu Feb 07 01:28:16 EST 2036".
-        message.setTransmitTime(now);
-
-        _socket_.send(sendPacket);
-        _socket_.receive(receivePacket);
-
-        final long returnTimeMillis = System.currentTimeMillis();
-
-        // Prevent invalid time information if response does not match request
-        if (!now.equals(recMessage.getOriginateTimeStamp()))
-        {
-            throw new IOException("Originate time does not match the request");
-        }
-
-        // create TimeInfo message container but don't pre-compute the details yet
-        return new TimeInfo(recMessage, returnTimeMillis, false);
-    }
-
-    /**
-     * Returns the NTP protocol version number that client sets on request packet
-     * that is sent to remote host (e.g. 3=NTP v3, 4=NTP v4, etc.)
-     *
-     * @return  the NTP protocol version number that client sets on request packet.
-     * @see #setVersion(int)
-     */
-    public int getVersion()
-    {
-        return version;
-    }
-
-    /**
-     * Sets the NTP protocol version number that client sets on request packet
-     * communicate with remote host.
-     *
-     * @param version the NTP protocol version number
-     */
-    public void setVersion(final int version)
-    {
-        this.version = version;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.net.ntp;
+
+import java.io.IOException;
+import java.net.DatagramPacket;
+import java.net.InetAddress;
+
+import org.apache.commons.net.DatagramSocketClient;
+
+/**
+ * The NTPUDPClient class is a UDP implementation of a client for the
+ * Network Time Protocol (NTP) described in RFC 1305 as well as the
+ * Simple Network Time Protocol (SNTP) in RFC-2030. To use the class,
+ * merely open a local datagram socket with <a href="#open"> open </a>
+ * and call <a href="#getTime"> getTime </a> to retrieve the time. Then call
+ * <a href="org.apache.commons.net.DatagramSocketClient.html#close"> close </a>
+ * to close the connection properly.
+ * Successive calls to <a href="#getTime"> getTime </a> are permitted
+ * without re-establishing a connection.  That is because UDP is a
+ * connectionless protocol and the Network Time Protocol is stateless.
+ *
+ */
+
+public final class NTPUDPClient extends DatagramSocketClient
+{
+    /** The default NTP port.  It is set to 123 according to RFC 1305. */
+    public static final int DEFAULT_PORT = 123;
+
+    private int version = NtpV3Packet.VERSION_3;
+
+    /**
+     * Retrieves the time information from the specified server on the
+     * default NTP port and returns it. The time is the number of miliiseconds
+     * since 00:00 (midnight) 1 January 1900 UTC, as specified by RFC 1305.
+     * This method reads the raw NTP packet and constructs a <i>TimeInfo</i>
+     * object that allows access to all the fields of the NTP message header.
+     * <p>
+     * @param host The address of the server.
+     * @return The time value retrieved from the server.
+     * @throws IOException If an error occurs while retrieving the time.
+     */
+    public TimeInfo getTime(final InetAddress host) throws IOException
+    {
+        return getTime(host, NtpV3Packet.NTP_PORT);
+    }
+
+    /**
+     * Retrieves the time information from the specified server and port and
+     * returns it. The time is the number of miliiseconds since
+     * 00:00 (midnight) 1 January 1900 UTC, as specified by RFC 1305.
+     * This method reads the raw NTP packet and constructs a <i>TimeInfo</i>
+     * object that allows access to all the fields of the NTP message header.
+     * <p>
+     * @param host The address of the server.
+     * @param port The port of the service.
+     * @return The time value retrieved from the server.
+     * @throws IOException If an error occurs while retrieving the time or if
+     *                     received packet does not match the request.
+     */
+    public TimeInfo getTime(final InetAddress host, final int port) throws IOException
+    {
+        // if not connected then open to next available UDP port
+        if (!isOpen())
+        {
+            open();
+        }
+
+        final NtpV3Packet message = new NtpV3Impl();
+        message.setMode(NtpV3Packet.MODE_CLIENT);
+        message.setVersion(version);
+        final DatagramPacket sendPacket = message.getDatagramPacket();
+        sendPacket.setAddress(host);
+        sendPacket.setPort(port);
+
+        final NtpV3Packet recMessage = new NtpV3Impl();
+        final DatagramPacket receivePacket = recMessage.getDatagramPacket();
+
+        /*
+         * Must minimize the time between getting the current time,
+         * timestamping the packet, and sending it out which
+         * introduces an error in the delay time.
+         * No extraneous logging and initializations here !!!
+         */
+        final TimeStamp now = TimeStamp.getCurrentTime();
+
+        // Note that if you do not set the transmit time field then originating time
+        // in server response is all 0's which is "Thu Feb 07 01:28:16 EST 2036".
+        message.setTransmitTime(now);
+
+        _socket_.send(sendPacket);
+        _socket_.receive(receivePacket);
+
+        final long returnTimeMillis = System.currentTimeMillis();
+
+        // Prevent invalid time information if response does not match request
+        if (!now.equals(recMessage.getOriginateTimeStamp()))
+        {
+            throw new IOException("Originate time does not match the request");
+        }
+
+        // create TimeInfo message container but don't pre-compute the details yet
+        return new TimeInfo(recMessage, returnTimeMillis, false);
+    }
+
+    /**
+     * Returns the NTP protocol version number that client sets on request packet
+     * that is sent to remote host (e.g. 3=NTP v3, 4=NTP v4, etc.)
+     *
+     * @return  the NTP protocol version number that client sets on request packet.
+     * @see #setVersion(int)
+     */
+    public int getVersion()
+    {
+        return version;
+    }
+
+    /**
+     * Sets the NTP protocol version number that client sets on request packet
+     * communicate with remote host.
+     *
+     * @param version the NTP protocol version number
+     */
+    public void setVersion(final int version)
+    {
+        this.version = version;
+    }
+
+}
diff --git a/src/main/java/org/apache/commons/net/ntp/NtpUtils.java b/src/main/java/org/apache/commons/net/ntp/NtpUtils.java
index 2e406c662..6164779bd 100644
--- a/src/main/java/org/apache/commons/net/ntp/NtpUtils.java
+++ b/src/main/java/org/apache/commons/net/ntp/NtpUtils.java
@@ -1,115 +1,115 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.net.ntp;
-
-/**
- * Common NtpUtils Helper class.
- *
- */
-public final class NtpUtils {
-
-    /**
-      * Returns 32-bit integer address to IPv4 address string "%d.%d.%d.%d" format.
-      *
-      * @param address  the 32-bit address
-      * @return  the raw IP address in a string format.
-      */
-     public static String getHostAddress(final int address)
-     {
-          return ((address >>> 24) & 0xFF) + "." +
-                 ((address >>> 16) & 0xFF) + "." +
-                 ((address >>>  8) & 0xFF) + "." +
-                 ((address >>>  0) & 0xFF);
-     }
-
-    /**
-     * Return human-readable name of message mode type (RFC 1305).
-     *
-     * @param mode the mode type
-     * @return mode name
-     */
-    public static String getModeName(final int mode)
-    {
-        switch (mode) {
-            case NtpV3Packet.MODE_RESERVED:
-                return "Reserved";
-            case NtpV3Packet.MODE_SYMMETRIC_ACTIVE:
-                return "Symmetric Active";
-            case NtpV3Packet.MODE_SYMMETRIC_PASSIVE:
-                return "Symmetric Passive";
-            case NtpV3Packet.MODE_CLIENT:
-                return "Client";
-            case NtpV3Packet.MODE_SERVER:
-                return "Server";
-            case NtpV3Packet.MODE_BROADCAST:
-                return "Broadcast";
-            case NtpV3Packet.MODE_CONTROL_MESSAGE:
-                return "Control";
-            case NtpV3Packet.MODE_PRIVATE:
-                return "Private";
-            default:
-                return "Unknown";
-        }
-    }
-
-    /**
-     * Returns NTP packet reference identifier as IP address.
-     *
-     * @param packet  NTP packet
-     * @return  the packet reference id (as IP address) in "%d.%d.%d.%d" format.
-     */
-     public static String getRefAddress(final NtpV3Packet packet)
-     {
-         final int address = (packet == null) ? 0 : packet.getReferenceId();
-         return getHostAddress(address);
-     }
-
-    /**
-     * Get refId as reference clock string (e.g. GPS, WWV, LCL). If string is
-     * invalid (non-ASCII character) then returns empty string "".
-     * For details refer to the <A HREF="http://www.eecis.udel.edu/~mills/ntp/html/refclock.html#list">Comprehensive
-     * List of Clock Drivers</A>.
-     *
-     * @param message the message to check
-     * @return reference clock string if primary NTP server
-     */
-    public static String getReferenceClock(final NtpV3Packet message) {
-        if (message == null) {
-            return "";
-        }
-        final int refId = message.getReferenceId();
-        if (refId == 0) {
-            return "";
-        }
-        final StringBuilder buf = new StringBuilder(4);
-        // start at highest-order byte (0x4c434c00 -> LCL)
-        for (int shiftBits = 24; shiftBits >= 0; shiftBits -= 8)
-        {
-            final char c = (char) ((refId >>> shiftBits) & 0xff);
-            if (c == 0) { // 0-terminated ASCII string
-                break;
-            }
-            if (!Character.isLetterOrDigit(c)) {
-                return "";
-            }
-            buf.append(c);
-        }
-        return buf.toString();
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.net.ntp;
+
+/**
+ * Common NtpUtils Helper class.
+ *
+ */
+public final class NtpUtils {
+
+    /**
+      * Returns 32-bit integer address to IPv4 address string "%d.%d.%d.%d" format.
+      *
+      * @param address  the 32-bit address
+      * @return  the raw IP address in a string format.
+      */
+     public static String getHostAddress(final int address)
+     {
+          return ((address >>> 24) & 0xFF) + "." +
+                 ((address >>> 16) & 0xFF) + "." +
+                 ((address >>>  8) & 0xFF) + "." +
+                 ((address >>>  0) & 0xFF);
+     }
+
+    /**
+     * Return human-readable name of message mode type (RFC 1305).
+     *
+     * @param mode the mode type
+     * @return mode name
+     */
+    public static String getModeName(final int mode)
+    {
+        switch (mode) {
+            case NtpV3Packet.MODE_RESERVED:
+                return "Reserved";
+            case NtpV3Packet.MODE_SYMMETRIC_ACTIVE:
+                return "Symmetric Active";
+            case NtpV3Packet.MODE_SYMMETRIC_PASSIVE:
+                return "Symmetric Passive";
+            case NtpV3Packet.MODE_CLIENT:
+                return "Client";
+            case NtpV3Packet.MODE_SERVER:
+                return "Server";
+            case NtpV3Packet.MODE_BROADCAST:
+                return "Broadcast";
+            case NtpV3Packet.MODE_CONTROL_MESSAGE:
+                return "Control";
+            case NtpV3Packet.MODE_PRIVATE:
+                return "Private";
+            default:
+                return "Unknown";
+        }
+    }
+
+    /**
+     * Returns NTP packet reference identifier as IP address.
+     *
+     * @param packet  NTP packet
+     * @return  the packet reference id (as IP address) in "%d.%d.%d.%d" format.
+     */
+     public static String getRefAddress(final NtpV3Packet packet)
+     {
+         final int address = (packet == null) ? 0 : packet.getReferenceId();
+         return getHostAddress(address);
+     }
+
+    /**
+     * Get refId as reference clock string (e.g. GPS, WWV, LCL). If string is
+     * invalid (non-ASCII character) then returns empty string "".
+     * For details refer to the <A HREF="http://www.eecis.udel.edu/~mills/ntp/html/refclock.html#list">Comprehensive
+     * List of Clock Drivers</A>.
+     *
+     * @param message the message to check
+     * @return reference clock string if primary NTP server
+     */
+    public static String getReferenceClock(final NtpV3Packet message) {
+        if (message == null) {
+            return "";
+        }
+        final int refId = message.getReferenceId();
+        if (refId == 0) {
+            return "";
+        }
+        final StringBuilder buf = new StringBuilder(4);
+        // start at highest-order byte (0x4c434c00 -> LCL)
+        for (int shiftBits = 24; shiftBits >= 0; shiftBits -= 8)
+        {
+            final char c = (char) ((refId >>> shiftBits) & 0xff);
+            if (c == 0) { // 0-terminated ASCII string
+                break;
+            }
+            if (!Character.isLetterOrDigit(c)) {
+                return "";
+            }
+            buf.append(c);
+        }
+        return buf.toString();
+    }
+
+}
diff --git a/src/main/java/org/apache/commons/net/ntp/NtpV3Impl.java b/src/main/java/org/apache/commons/net/ntp/NtpV3Impl.java
index 02fb0031a..318a7145b 100644
--- a/src/main/java/org/apache/commons/net/ntp/NtpV3Impl.java
+++ b/src/main/java/org/apache/commons/net/ntp/NtpV3Impl.java
@@ -1,699 +1,699 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.net.ntp;
-
-import java.net.DatagramPacket;
-
-/**
- * Implementation of NtpV3Packet with methods converting Java objects to/from
- * the Network Time Protocol (NTP) data message header format described in RFC-1305.
- *
- */
-public class NtpV3Impl implements NtpV3Packet
-{
-
-    private static final int MODE_INDEX = 0;
-    private static final int MODE_SHIFT = 0;
-
-    private static final int VERSION_INDEX = 0;
-    private static final int VERSION_SHIFT = 3;
-
-    private static final int LI_INDEX = 0;
-    private static final int LI_SHIFT = 6;
-
-    private static final int STRATUM_INDEX = 1;
-    private static final int POLL_INDEX = 2;
-    private static final int PRECISION_INDEX = 3;
-
-    private static final int ROOT_DELAY_INDEX = 4;
-    private static final int ROOT_DISPERSION_INDEX = 8;
-    private static final int REFERENCE_ID_INDEX = 12;
-
-    private static final int REFERENCE_TIMESTAMP_INDEX = 16;
-    private static final int ORIGINATE_TIMESTAMP_INDEX = 24;
-    private static final int RECEIVE_TIMESTAMP_INDEX = 32;
-    private static final int TRANSMIT_TIMESTAMP_INDEX = 40;
-
-//    private static final int KEY_IDENTIFIER_INDEX = 48;
-//    private static final int MESSAGE_DIGEST = 54; /* len 16 bytes */
-
-    /**
-     * Convert byte to unsigned integer.
-     * Java only has signed types so we have to do
-     * more work to get unsigned ops.
-     *
-     * @param b input byte
-     * @return unsigned int value of byte
-     */
-    protected static final int ui(final byte b)
-    {
-        final int i = b & 0xFF;
-        return i;
-    }
-
-    /**
-     * Convert byte to unsigned long.
-     * Java only has signed types so we have to do
-     * more work to get unsigned ops
-     *
-     * @param b input byte
-     * @return unsigned long value of byte
-     */
-    protected static final long ul(final byte b)
-    {
-        final long i = b & 0xFF;
-        return i;
-    }
-
-    private final byte[] buf = new byte[48];
-
-    private volatile DatagramPacket dp;
-
-    /** Creates a new instance of NtpV3Impl */
-    public NtpV3Impl()
-    {
-    }
-
-    /**
-     * Compares this object against the specified object.
-     * The result is <code>true</code> if and only if the argument is
-     * not <code>null</code> and is a <code>NtpV3Impl</code> object that
-     * contains the same values as this object.
-     *
-     * @param   obj   the object to compare with.
-     * @return  <code>true</code> if the objects are the same;
-     *          <code>false</code> otherwise.
-     * @since 3.4
-     */
-    @Override
-    public boolean equals(final Object obj)
-    {
-        if (this == obj) {
-            return true;
-        }
-        if (obj == null || getClass() != obj.getClass()) {
-            return false;
-        }
-        final NtpV3Impl other = (NtpV3Impl) obj;
-        return java.util.Arrays.equals(buf, other.buf);
-    }
-
-    /**
-     * Returns the datagram packet with the NTP details already filled in.
-     *
-     * @return a datagram packet.
-     */
-    @Override
-    public synchronized DatagramPacket getDatagramPacket()
-    {
-        if (dp == null) {
-            dp = new DatagramPacket(buf, buf.length);
-            dp.setPort(NTP_PORT);
-        }
-        return dp;
-    }
-
-    /**
-     * @return 4 bytes as 32-bit int
-     */
-    private int getInt(final int index)
-    {
-        final int i = ui(buf[index]) << 24 |
-                ui(buf[index + 1]) << 16 |
-                ui(buf[index + 2]) << 8 |
-                ui(buf[index + 3]);
-
-        return i;
-    }
-
-    /**
-     * Returns leap indicator as defined in RFC-1305 which is a two-bit code:
-     *  0=no warning
-     *  1=last minute has 61 seconds
-     *  2=last minute has 59 seconds
-     *  3=alarm condition (clock not synchronized)
-     *
-     * @return leap indicator as defined in RFC-1305.
-     */
-    @Override
-    public int getLeapIndicator()
-    {
-        return (ui(buf[LI_INDEX]) >> LI_SHIFT) & 0x3;
-    }
-
-    /**
-     * Get Long value represented by bits starting at specified index.
-     *
-     * @return 8 bytes as 64-bit long
-     */
-    private long getLong(final int index)
-    {
-        final long i = ul(buf[index]) << 56 |
-                ul(buf[index + 1]) << 48 |
-                ul(buf[index + 2]) << 40 |
-                ul(buf[index + 3]) << 32 |
-                ul(buf[index + 4]) << 24 |
-                ul(buf[index + 5]) << 16 |
-                ul(buf[index + 6]) << 8 |
-                ul(buf[index + 7]);
-        return i;
-    }
-
-    /**
-     * Returns mode as defined in RFC-1305 which is a 3-bit integer
-     * whose value is indicated by the MODE_xxx parameters.
-     *
-     * @return mode as defined in RFC-1305.
-     */
-    @Override
-    public int getMode()
-    {
-        return (ui(buf[MODE_INDEX]) >> MODE_SHIFT) & 0x7;
-    }
-
-    /**
-     * Return human-readable name of message mode type as described in
-     * RFC 1305.
-     * @return mode name as string.
-     */
-    @Override
-    public String getModeName()
-    {
-        return NtpUtils.getModeName(getMode());
-    }
-
-    /**
-     * Returns the originate time as defined in RFC-1305.
-     *
-     * @return the originate time.
-     * Never returns null.
-     */
-    @Override
-    public TimeStamp getOriginateTimeStamp()
-    {
-        return getTimestamp(ORIGINATE_TIMESTAMP_INDEX);
-    }
-
-    /**
-     * Returns poll interval as defined in RFC-1305, which is an eight-bit
-     * signed integer indicating the maximum interval between successive
-     * messages, in seconds to the nearest power of two (e.g. value of six
-     * indicates an interval of 64 seconds. The values that can appear in
-     * this field range from NTP_MINPOLL to NTP_MAXPOLL inclusive.
-     *
-     * @return poll interval as defined in RFC-1305.
-     */
-    @Override
-    public int getPoll()
-    {
-        return buf[POLL_INDEX];
-    }
-
-    /**
-     * Returns precision as defined in RFC-1305 encoded as an 8-bit signed
-     * integer (seconds to nearest power of two).
-     * Values normally range from -6 to -20.
-     *
-     * @return precision as defined in RFC-1305.
-     */
-    @Override
-    public int getPrecision()
-    {
-        return buf[PRECISION_INDEX];
-    }
-
-    /**
-     * Returns receive timestamp as defined in RFC-1305.
-     *
-     * @return the receive time.
-     * Never returns null.
-     */
-    @Override
-    public TimeStamp getReceiveTimeStamp()
-    {
-        return getTimestamp(RECEIVE_TIMESTAMP_INDEX);
-    }
-
-    /**
-     * Returns the reference id as defined in RFC-1305, which is
-     * a 32-bit integer whose value is dependent on several criteria.
-     *
-     * @return the reference id as defined in RFC-1305.
-     */
-    @Override
-    public int getReferenceId()
-    {
-        return getInt(REFERENCE_ID_INDEX);
-    }
-
-    /**
-     * Returns the reference id string. String cannot be null but
-     * value is dependent on the version of the NTP spec supported
-     * and stratum level. Value can be an empty string, clock type string,
-     * IP address, or a hex string.
-     *
-     * @return the reference id string.
-     */
-    @Override
-    public String getReferenceIdString()
-    {
-        final int version = getVersion();
-        final int stratum = getStratum();
-        if (version == VERSION_3 || version == VERSION_4) {
-            if (stratum == 0 || stratum == 1) {
-                return idAsString(); // 4-character ASCII string (e.g. GPS, USNO)
-            }
-            // in NTPv4 servers this is latest transmit timestamp of ref source
-            if (version == VERSION_4) {
-                return idAsHex();
-            }
-        }
-
-        // Stratum 2 and higher this is a four-octet IPv4 address
-        // of the primary reference host.
-        if (stratum >= 2) {
-            return idAsIPAddress();
-        }
-        return idAsHex();
-    }
-
-    /**
-     * Returns the reference time as defined in RFC-1305.
-     *
-     * @return the reference time as <code>TimeStamp</code> object.
-     * Never returns null.
-     */
-    @Override
-    public TimeStamp getReferenceTimeStamp()
-    {
-        return getTimestamp(REFERENCE_TIMESTAMP_INDEX);
-    }
-
-    /**
-     * Return root delay as defined in RFC-1305, which is the total roundtrip delay
-     * to the primary reference source, in seconds. Values can take positive and
-     * negative values, depending on clock precision and skew.
-     *
-     * @return root delay as defined in RFC-1305.
-     */
-    @Override
-    public int getRootDelay()
-    {
-        return getInt(ROOT_DELAY_INDEX);
-    }
-
-    /**
-     * Return root delay as defined in RFC-1305 in milliseconds, which is
-     * the total roundtrip delay to the primary reference source, in
-     * seconds. Values can take positive and negative values, depending
-     * on clock precision and skew.
-     *
-     * @return root delay in milliseconds
-     */
-    @Override
-    public double getRootDelayInMillisDouble()
-    {
-        final double l = getRootDelay();
-        return l / 65.536;
-    }
-
-    /**
-     * Returns root dispersion as defined in RFC-1305.
-     * @return root dispersion.
-     */
-    @Override
-    public int getRootDispersion()
-    {
-        return getInt(ROOT_DISPERSION_INDEX);
-    }
-
-    /**
-     * Returns root dispersion (as defined in RFC-1305) in milliseconds.
-     *
-     * @return root dispersion in milliseconds
-     */
-    @Override
-    public long getRootDispersionInMillis()
-    {
-        final long l = getRootDispersion();
-        return (l * 1000) / 65536L;
-    }
-
-    /**
-     * Returns root dispersion (as defined in RFC-1305) in milliseconds
-     * as double precision value.
-     *
-     * @return root dispersion in milliseconds
-     */
-    @Override
-    public double getRootDispersionInMillisDouble()
-    {
-        final double l = getRootDispersion();
-        return l / 65.536;
-    }
-
-    /**
-     * Returns Stratum as defined in RFC-1305, which indicates the stratum level
-     * of the local clock, with values defined as follows: 0=unspecified,
-     * 1=primary ref clock, and all others a secondary reference (via NTP).
-     *
-     * @return Stratum level as defined in RFC-1305.
-     */
-    @Override
-    public int getStratum()
-    {
-        return ui(buf[STRATUM_INDEX]);
-    }
-
-    /**
-     * Get NTP Timestamp at specified starting index.
-     *
-     * @param index index into data array
-     * @return TimeStamp object for 64 bits starting at index
-     */
-    private TimeStamp getTimestamp(final int index)
-    {
-        return new TimeStamp(getLong(index));
-    }
-
-    /**
-     * Returns the transmit timestamp as defined in RFC-1305.
-     *
-     * @return the transmit timestamp as defined in RFC-1305.
-     * Never returns a null object.
-     */
-    @Override
-    public TimeStamp getTransmitTimeStamp()
-    {
-        return getTimestamp(TRANSMIT_TIMESTAMP_INDEX);
-    }
-
-    /**
-     * Return type of time packet. The values (e.g. NTP, TIME, ICMP, ...)
-     * correspond to the protocol used to obtain the timing information.
-     *
-     * @return packet type string identifier which in this case is "NTP".
-     */
-    @Override
-    public String getType()
-    {
-        return "NTP";
-    }
-
-    /**
-     * Returns NTP version number as defined in RFC-1305.
-     *
-     * @return NTP version number.
-     */
-    @Override
-    public int getVersion()
-    {
-        return (ui(buf[VERSION_INDEX]) >> VERSION_SHIFT) & 0x7;
-    }
-
-    /**
-     * Computes a hashcode for this object. The result is the exclusive
-     * OR of the values of this object stored as a byte array.
-     *
-     * @return  a hash code value for this object.
-     * @since 3.4
-     */
-    @Override
-    public int hashCode()
-    {
-        return java.util.Arrays.hashCode(buf);
-    }
-
-    private String idAsHex()
-    {
-        return Integer.toHexString(getReferenceId());
-    }
-
-    /**
-     * Returns Reference id as dotted IP address.
-     * @return refId as IP address string.
-     */
-    private String idAsIPAddress()
-    {
-        return ui(buf[REFERENCE_ID_INDEX]) + "." +
-                ui(buf[REFERENCE_ID_INDEX + 1]) + "." +
-                ui(buf[REFERENCE_ID_INDEX + 2]) + "." +
-                ui(buf[REFERENCE_ID_INDEX + 3]);
-    }
-
-    private String idAsString()
-    {
-        final StringBuilder id = new StringBuilder();
-        for (int i = 0; i <= 3; i++) {
-            final char c = (char) buf[REFERENCE_ID_INDEX + i];
-            if (c == 0) {  // 0-terminated string
-                break;
-            }
-            id.append(c);
-        }
-        return id.toString();
-    }
-
-    /**
-     * Set the contents of this object from source datagram packet.
-     *
-     * @param srcDp source DatagramPacket to copy contents from, never null.
-     * @throws IllegalArgumentException if srcDp is null or byte length is less than minimum length of 48 bytes
-     */
-    @Override
-    public void setDatagramPacket(final DatagramPacket srcDp)
-    {
-        if (srcDp == null || srcDp.getLength() < buf.length) {
-            throw new IllegalArgumentException();
-        }
-        final byte[] incomingBuf = srcDp.getData();
-        int len = srcDp.getLength();
-        if (len > buf.length) {
-            len = buf.length;
-        }
-        System.arraycopy(incomingBuf, 0, buf, 0, len);
-        final DatagramPacket dp = getDatagramPacket();
-        dp.setAddress(srcDp.getAddress());
-        final int port = srcDp.getPort();
-        dp.setPort(port > 0 ? port : NTP_PORT);
-        dp.setData(buf);
-    }
-
-    /**
-     * Set integer value at index position.
-     *
-     * @param idx index position
-     * @param value 32-bit int value
-     */
-    private void setInt(final int idx, int value)
-    {
-        for (int i=3; i >= 0; i--) {
-            buf[idx + i] = (byte) (value & 0xff);
-            value >>>= 8; // shift right one-byte
-        }
-    }
-
-    /**
-     * Set leap indicator as defined in RFC-1305.
-     *
-     * @param li leap indicator.
-     */
-    @Override
-    public void setLeapIndicator(final int li)
-    {
-        buf[LI_INDEX] = (byte) (buf[LI_INDEX] & 0x3F | ((li & 0x3) << LI_SHIFT));
-    }
-
-    /**
-     * Set mode as defined in RFC-1305.
-     *
-     * @param mode the mode to set
-     */
-    @Override
-    public void setMode(final int mode)
-    {
-        buf[MODE_INDEX] = (byte) (buf[MODE_INDEX] & 0xF8 | mode & 0x7);
-    }
-
-    /**
-     * Set originate timestamp given NTP TimeStamp object.
-     * If <code>ts</code> is null then zero time is used.
-     *
-     * @param ts NTP timestamp
-     */
-    @Override
-    public void setOriginateTimeStamp(final TimeStamp ts)
-    {
-        setTimestamp(ORIGINATE_TIMESTAMP_INDEX, ts);
-    }
-
-    /**
-     * Set poll interval as defined in RFC-1305.
-     *
-     * @param poll poll interval.
-     */
-    @Override
-    public void setPoll(final int poll)
-    {
-        buf[POLL_INDEX] = (byte) (poll & 0xFF);
-    }
-
-    /**
-     * Set precision as defined in RFC-1305.
-     * @param precision the precision to set
-     * @since 3.4
-     */
-    @Override
-    public void setPrecision(final int precision)
-    {
-        buf[PRECISION_INDEX] = (byte) (precision & 0xFF);
-    }
-
-    /**
-     * Set receive timestamp given NTP TimeStamp object.
-     * If <code>ts</code> is null then zero time is used.
-     *
-     * @param ts timestamp
-     */
-    @Override
-    public void setReceiveTimeStamp(final TimeStamp ts)
-    {
-        setTimestamp(RECEIVE_TIMESTAMP_INDEX, ts);
-    }
-
-    /**
-     * Set reference clock identifier field with 32-bit unsigned integer value.
-     * See RFC-1305 for description.
-     *
-     * @param refId reference clock identifier.
-     */
-    @Override
-    public void setReferenceId(final int refId)
-    {
-        setInt(REFERENCE_ID_INDEX, refId);
-    }
-
-    /**
-     * Set Reference time with NTP timestamp. If <code>ts</code> is null
-     * then zero time is used.
-     *
-     * @param ts NTP timestamp
-     */
-    @Override
-    public void setReferenceTime(final TimeStamp ts)
-    {
-        setTimestamp(REFERENCE_TIMESTAMP_INDEX, ts);
-    }
-
-    /**
-     * Set root delay as defined in RFC-1305.
-     *
-     * @param delay root delay
-     * @since 3.4
-     */
-    @Override
-    public void setRootDelay(final int delay)
-    {
-        setInt(ROOT_DELAY_INDEX, delay);
-    }
-
-    /**
-     * Set root dispersion as defined in RFC-1305.
-     *
-     * @param dispersion root dispersion
-     * @since 3.4
-     */
-    @Override
-    public void setRootDispersion(final int dispersion)
-    {
-        setInt(ROOT_DISPERSION_INDEX, dispersion);
-    }
-
-    /**
-     * Set stratum level as defined in RFC-1305.
-     *
-     * @param stratum stratum level.
-     */
-    @Override
-    public void setStratum(final int stratum)
-    {
-        buf[STRATUM_INDEX] = (byte) (stratum & 0xFF);
-    }
-
-    /**
-     * Sets the NTP timestamp at the given array index.
-     *
-     * @param index index into the byte array.
-     * @param t TimeStamp.
-     */
-    private void setTimestamp(final int index, final TimeStamp t)
-    {
-        long ntpTime = (t == null) ? 0 : t.ntpValue();
-        // copy 64-bits from Long value into 8 x 8-bit bytes of array
-        // one byte at a time shifting 8-bits for each position.
-        for (int i = 7; i >= 0; i--) {
-            buf[index + i] = (byte) (ntpTime & 0xFF);
-            ntpTime >>>= 8; // shift to next byte
-        }
-        // buf[index] |= 0x80;  // only set if 1900 baseline....
-    }
-
-    /**
-     * Set transmit time with NTP timestamp.
-     * If <code>ts</code> is null then zero time is used.
-     *
-     * @param ts NTP timestamp
-     */
-    @Override
-    public void setTransmitTime(final TimeStamp ts)
-    {
-        setTimestamp(TRANSMIT_TIMESTAMP_INDEX, ts);
-    }
-
-    /**
-     * Set NTP version as defined in RFC-1305.
-     *
-     * @param version NTP version.
-     */
-    @Override
-    public void setVersion(final int version)
-    {
-        buf[VERSION_INDEX] = (byte) (buf[VERSION_INDEX] & 0xC7 | ((version & 0x7) << VERSION_SHIFT));
-    }
-
-    /**
-     * Returns details of NTP packet as a string.
-     *
-     * @return details of NTP packet as a string.
-     */
-    @Override
-    public String toString()
-    {
-        return "[" +
-                "version:" + getVersion() +
-                ", mode:" + getMode() +
-                ", poll:" + getPoll() +
-                ", precision:" + getPrecision() +
-                ", delay:" + getRootDelay() +
-                ", dispersion(ms):" + getRootDispersionInMillisDouble() +
-                ", id:" + getReferenceIdString() +
-                ", xmitTime:" + getTransmitTimeStamp().toDateString() +
-                " ]";
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.net.ntp;
+
+import java.net.DatagramPacket;
+
+/**
+ * Implementation of NtpV3Packet with methods converting Java objects to/from
+ * the Network Time Protocol (NTP) data message header format described in RFC-1305.
+ *
+ */
+public class NtpV3Impl implements NtpV3Packet
+{
+
+    private static final int MODE_INDEX = 0;
+    private static final int MODE_SHIFT = 0;
+
+    private static final int VERSION_INDEX = 0;
+    private static final int VERSION_SHIFT = 3;
+
+    private static final int LI_INDEX = 0;
+    private static final int LI_SHIFT = 6;
+
+    private static final int STRATUM_INDEX = 1;
+    private static final int POLL_INDEX = 2;
+    private static final int PRECISION_INDEX = 3;
+
+    private static final int ROOT_DELAY_INDEX = 4;
+    private static final int ROOT_DISPERSION_INDEX = 8;
+    private static final int REFERENCE_ID_INDEX = 12;
+
+    private static final int REFERENCE_TIMESTAMP_INDEX = 16;
+    private static final int ORIGINATE_TIMESTAMP_INDEX = 24;
+    private static final int RECEIVE_TIMESTAMP_INDEX = 32;
+    private static final int TRANSMIT_TIMESTAMP_INDEX = 40;
+
+//    private static final int KEY_IDENTIFIER_INDEX = 48;
+//    private static final int MESSAGE_DIGEST = 54; /* len 16 bytes */
+
+    /**
+     * Convert byte to unsigned integer.
+     * Java only has signed types so we have to do
+     * more work to get unsigned ops.
+     *
+     * @param b input byte
+     * @return unsigned int value of byte
+     */
+    protected static final int ui(final byte b)
+    {
+        final int i = b & 0xFF;
+        return i;
+    }
+
+    /**
+     * Convert byte to unsigned long.
+     * Java only has signed types so we have to do
+     * more work to get unsigned ops
+     *
+     * @param b input byte
+     * @return unsigned long value of byte
+     */
+    protected static final long ul(final byte b)
+    {
+        final long i = b & 0xFF;
+        return i;
+    }
+
+    private final byte[] buf = new byte[48];
+
+    private volatile DatagramPacket dp;
+
+    /** Creates a new instance of NtpV3Impl */
+    public NtpV3Impl()
+    {
+    }
+
+    /**
+     * Compares this object against the specified object.
+     * The result is <code>true</code> if and only if the argument is
+     * not <code>null</code> and is a <code>NtpV3Impl</code> object that
+     * contains the same values as this object.
+     *
+     * @param   obj   the object to compare with.
+     * @return  <code>true</code> if the objects are the same;
+     *          <code>false</code> otherwise.
+     * @since 3.4
+     */
+    @Override
+    public boolean equals(final Object obj)
+    {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null || getClass() != obj.getClass()) {
+            return false;
+        }
+        final NtpV3Impl other = (NtpV3Impl) obj;
+        return java.util.Arrays.equals(buf, other.buf);
+    }
+
+    /**
+     * Returns the datagram packet with the NTP details already filled in.
+     *
+     * @return a datagram packet.
+     */
+    @Override
+    public synchronized DatagramPacket getDatagramPacket()
+    {
+        if (dp == null) {
+            dp = new DatagramPacket(buf, buf.length);
+            dp.setPort(NTP_PORT);
+        }
+        return dp;
+    }
+
+    /**
+     * @return 4 bytes as 32-bit int
+     */
+    private int getInt(final int index)
+    {
+        final int i = ui(buf[index]) << 24 |
+                ui(buf[index + 1]) << 16 |
+                ui(buf[index + 2]) << 8 |
+                ui(buf[index + 3]);
+
+        return i;
+    }
+
+    /**
+     * Returns leap indicator as defined in RFC-1305 which is a two-bit code:
+     *  0=no warning
+     *  1=last minute has 61 seconds
+     *  2=last minute has 59 seconds
+     *  3=alarm condition (clock not synchronized)
+     *
+     * @return leap indicator as defined in RFC-1305.
+     */
+    @Override
+    public int getLeapIndicator()
+    {
+        return (ui(buf[LI_INDEX]) >> LI_SHIFT) & 0x3;
+    }
+
+    /**
+     * Get Long value represented by bits starting at specified index.
+     *
+     * @return 8 bytes as 64-bit long
+     */
+    private long getLong(final int index)
+    {
+        final long i = ul(buf[index]) << 56 |
+                ul(buf[index + 1]) << 48 |
+                ul(buf[index + 2]) << 40 |
+                ul(buf[index + 3]) << 32 |
+                ul(buf[index + 4]) << 24 |
+                ul(buf[index + 5]) << 16 |
+                ul(buf[index + 6]) << 8 |
+                ul(buf[index + 7]);
+        return i;
+    }
+
+    /**
+     * Returns mode as defined in RFC-1305 which is a 3-bit integer
+     * whose value is indicated by the MODE_xxx parameters.
+     *
+     * @return mode as defined in RFC-1305.
+     */
+    @Override
+    public int getMode()
+    {
+        return (ui(buf[MODE_INDEX]) >> MODE_SHIFT) & 0x7;
+    }
+
+    /**
+     * Return human-readable name of message mode type as described in
+     * RFC 1305.
+     * @return mode name as string.
+     */
+    @Override
+    public String getModeName()
+    {
+        return NtpUtils.getModeName(getMode());
+    }
+
+    /**
+     * Returns the originate time as defined in RFC-1305.
+     *
+     * @return the originate time.
+     * Never returns null.
+     */
+    @Override
+    public TimeStamp getOriginateTimeStamp()
+    {
+        return getTimestamp(ORIGINATE_TIMESTAMP_INDEX);
+    }
+
+    /**
+     * Returns poll interval as defined in RFC-1305, which is an eight-bit
+     * signed integer indicating the maximum interval between successive
+     * messages, in seconds to the nearest power of two (e.g. value of six
+     * indicates an interval of 64 seconds. The values that can appear in
+     * this field range from NTP_MINPOLL to NTP_MAXPOLL inclusive.
+     *
+     * @return poll interval as defined in RFC-1305.
+     */
+    @Override
+    public int getPoll()
+    {
+        return buf[POLL_INDEX];
+    }
+
+    /**
+     * Returns precision as defined in RFC-1305 encoded as an 8-bit signed
+     * integer (seconds to nearest power of two).
+     * Values normally range from -6 to -20.
+     *
+     * @return precision as defined in RFC-1305.
+     */
+    @Override
+    public int getPrecision()
+    {
+        return buf[PRECISION_INDEX];
+    }
+
+    /**
+     * Returns receive timestamp as defined in RFC-1305.
+     *
+     * @return the receive time.
+     * Never returns null.
+     */
+    @Override
+    public TimeStamp getReceiveTimeStamp()
+    {
+        return getTimestamp(RECEIVE_TIMESTAMP_INDEX);
+    }
+
+    /**
+     * Returns the reference id as defined in RFC-1305, which is
+     * a 32-bit integer whose value is dependent on several criteria.
+     *
+     * @return the reference id as defined in RFC-1305.
+     */
+    @Override
+    public int getReferenceId()
+    {
+        return getInt(REFERENCE_ID_INDEX);
+    }
+
+    /**
+     * Returns the reference id string. String cannot be null but
+     * value is dependent on the version of the NTP spec supported
+     * and stratum level. Value can be an empty string, clock type string,
+     * IP address, or a hex string.
+     *
+     * @return the reference id string.
+     */
+    @Override
+    public String getReferenceIdString()
+    {
+        final int version = getVersion();
+        final int stratum = getStratum();
+        if (version == VERSION_3 || version == VERSION_4) {
+            if (stratum == 0 || stratum == 1) {
+                return idAsString(); // 4-character ASCII string (e.g. GPS, USNO)
+            }
+            // in NTPv4 servers this is latest transmit timestamp of ref source
+            if (version == VERSION_4) {
+                return idAsHex();
+            }
+        }
+
+        // Stratum 2 and higher this is a four-octet IPv4 address
+        // of the primary reference host.
+        if (stratum >= 2) {
+            return idAsIPAddress();
+        }
+        return idAsHex();
+    }
+
+    /**
+     * Returns the reference time as defined in RFC-1305.
+     *
+     * @return the reference time as <code>TimeStamp</code> object.
+     * Never returns null.
+     */
+    @Override
+    public TimeStamp getReferenceTimeStamp()
+    {
+        return getTimestamp(REFERENCE_TIMESTAMP_INDEX);
+    }
+
+    /**
+     * Return root delay as defined in RFC-1305, which is the total roundtrip delay
+     * to the primary reference source, in seconds. Values can take positive and
+     * negative values, depending on clock precision and skew.
+     *
+     * @return root delay as defined in RFC-1305.
+     */
+    @Override
+    public int getRootDelay()
+    {
+        return getInt(ROOT_DELAY_INDEX);
+    }
+
+    /**
+     * Return root delay as defined in RFC-1305 in milliseconds, which is
+     * the total roundtrip delay to the primary reference source, in
+     * seconds. Values can take positive and negative values, depending
+     * on clock precision and skew.
+     *
+     * @return root delay in milliseconds
+     */
+    @Override
+    public double getRootDelayInMillisDouble()
+    {
+        final double l = getRootDelay();
+        return l / 65.536;
+    }
+
+    /**
+     * Returns root dispersion as defined in RFC-1305.
+     * @return root dispersion.
+     */
+    @Override
+    public int getRootDispersion()
+    {
+        return getInt(ROOT_DISPERSION_INDEX);
+    }
+
+    /**
+     * Returns root dispersion (as defined in RFC-1305) in milliseconds.
+     *
+     * @return root dispersion in milliseconds
+     */
+    @Override
+    public long getRootDispersionInMillis()
+    {
+        final long l = getRootDispersion();
+        return (l * 1000) / 65536L;
+    }
+
+    /**
+     * Returns root dispersion (as defined in RFC-1305) in milliseconds
+     * as double precision value.
+     *
+     * @return root dispersion in milliseconds
+     */
+    @Override
+    public double getRootDispersionInMillisDouble()
+    {
+        final double l = getRootDispersion();
+        return l / 65.536;
+    }
+
+    /**
+     * Returns Stratum as defined in RFC-1305, which indicates the stratum level
+     * of the local clock, with values defined as follows: 0=unspecified,
+     * 1=primary ref clock, and all others a secondary reference (via NTP).
+     *
+     * @return Stratum level as defined in RFC-1305.
+     */
+    @Override
+    public int getStratum()
+    {
+        return ui(buf[STRATUM_INDEX]);
+    }
+
+    /**
+     * Get NTP Timestamp at specified starting index.
+     *
+     * @param index index into data array
+     * @return TimeStamp object for 64 bits starting at index
+     */
+    private TimeStamp getTimestamp(final int index)
+    {
+        return new TimeStamp(getLong(index));
+    }
+
+    /**
+     * Returns the transmit timestamp as defined in RFC-1305.
+     *
+     * @return the transmit timestamp as defined in RFC-1305.
+     * Never returns a null object.
+     */
+    @Override
+    public TimeStamp getTransmitTimeStamp()
+    {
+        return getTimestamp(TRANSMIT_TIMESTAMP_INDEX);
+    }
+
+    /**
+     * Return type of time packet. The values (e.g. NTP, TIME, ICMP, ...)
+     * correspond to the protocol used to obtain the timing information.
+     *
+     * @return packet type string identifier which in this case is "NTP".
+     */
+    @Override
+    public String getType()
+    {
+        return "NTP";
+    }
+
+    /**
+     * Returns NTP version number as defined in RFC-1305.
+     *
+     * @return NTP version number.
+     */
+    @Override
+    public int getVersion()
+    {
+        return (ui(buf[VERSION_INDEX]) >> VERSION_SHIFT) & 0x7;
+    }
+
+    /**
+     * Computes a hashcode for this object. The result is the exclusive
+     * OR of the values of this object stored as a byte array.
+     *
+     * @return  a hash code value for this object.
+     * @since 3.4
+     */
+    @Override
+    public int hashCode()
+    {
+        return java.util.Arrays.hashCode(buf);
+    }
+
+    private String idAsHex()
+    {
+        return Integer.toHexString(getReferenceId());
+    }
+
+    /**
+     * Returns Reference id as dotted IP address.
+     * @return refId as IP address string.
+     */
+    private String idAsIPAddress()
+    {
+        return ui(buf[REFERENCE_ID_INDEX]) + "." +
+                ui(buf[REFERENCE_ID_INDEX + 1]) + "." +
+                ui(buf[REFERENCE_ID_INDEX + 2]) + "." +
+                ui(buf[REFERENCE_ID_INDEX + 3]);
+    }
+
+    private String idAsString()
+    {
+        final StringBuilder id = new StringBuilder();
+        for (int i = 0; i <= 3; i++) {
+            final char c = (char) buf[REFERENCE_ID_INDEX + i];
+            if (c == 0) {  // 0-terminated string
+                break;
+            }
+            id.append(c);
+        }
+        return id.toString();
+    }
+
+    /**
+     * Set the contents of this object from source datagram packet.
+     *
+     * @param srcDp source DatagramPacket to copy contents from, never null.
+     * @throws IllegalArgumentException if srcDp is null or byte length is less than minimum length of 48 bytes
+     */
+    @Override
+    public void setDatagramPacket(final DatagramPacket srcDp)
+    {
+        if (srcDp == null || srcDp.getLength() < buf.length) {
+            throw new IllegalArgumentException();
+        }
+        final byte[] incomingBuf = srcDp.getData();
+        int len = srcDp.getLength();
+        if (len > buf.length) {
+            len = buf.length;
+        }
+        System.arraycopy(incomingBuf, 0, buf, 0, len);
+        final DatagramPacket dp = getDatagramPacket();
+        dp.setAddress(srcDp.getAddress());
+        final int port = srcDp.getPort();
+        dp.setPort(port > 0 ? port : NTP_PORT);
+        dp.setData(buf);
+    }
+
+    /**
+     * Set integer value at index position.
+     *
+     * @param idx index position
+     * @param value 32-bit int value
+     */
+    private void setInt(final int idx, int value)
+    {
+        for (int i=3; i >= 0; i--) {
+            buf[idx + i] = (byte) (value & 0xff);
+            value >>>= 8; // shift right one-byte
+        }
+    }
+
+    /**
+     * Set leap indicator as defined in RFC-1305.
+     *
+     * @param li leap indicator.
+     */
+    @Override
+    public void setLeapIndicator(final int li)
+    {
+        buf[LI_INDEX] = (byte) (buf[LI_INDEX] & 0x3F | ((li & 0x3) << LI_SHIFT));
+    }
+
+    /**
+     * Set mode as defined in RFC-1305.
+     *
+     * @param mode the mode to set
+     */
+    @Override
+    public void setMode(final int mode)
+    {
+        buf[MODE_INDEX] = (byte) (buf[MODE_INDEX] & 0xF8 | mode & 0x7);
+    }
+
+    /**
+     * Set originate timestamp given NTP TimeStamp object.
+     * If <code>ts</code> is null then zero time is used.
+     *
+     * @param ts NTP timestamp
+     */
+    @Override
+    public void setOriginateTimeStamp(final TimeStamp ts)
+    {
+        setTimestamp(ORIGINATE_TIMESTAMP_INDEX, ts);
+    }
+
+    /**
+     * Set poll interval as defined in RFC-1305.
+     *
+     * @param poll poll interval.
+     */
+    @Override
+    public void setPoll(final int poll)
+    {
+        buf[POLL_INDEX] = (byte) (poll & 0xFF);
+    }
+
+    /**
+     * Set precision as defined in RFC-1305.
+     * @param precision the precision to set
+     * @since 3.4
+     */
+    @Override
+    public void setPrecision(final int precision)
+    {
+        buf[PRECISION_INDEX] = (byte) (precision & 0xFF);
+    }
+
+    /**
+     * Set receive timestamp given NTP TimeStamp object.
+     * If <code>ts</code> is null then zero time is used.
+     *
+     * @param ts timestamp
+     */
+    @Override
+    public void setReceiveTimeStamp(final TimeStamp ts)
+    {
+        setTimestamp(RECEIVE_TIMESTAMP_INDEX, ts);
+    }
+
+    /**
+     * Set reference clock identifier field with 32-bit unsigned integer value.
+     * See RFC-1305 for description.
+     *
+     * @param refId reference clock identifier.
+     */
+    @Override
+    public void setReferenceId(final int refId)
+    {
+        setInt(REFERENCE_ID_INDEX, refId);
+    }
+
+    /**
+     * Set Reference time with NTP timestamp. If <code>ts</code> is null
+     * then zero time is used.
+     *
+     * @param ts NTP timestamp
+     */
+    @Override
+    public void setReferenceTime(final TimeStamp ts)
+    {
+        setTimestamp(REFERENCE_TIMESTAMP_INDEX, ts);
+    }
+
+    /**
+     * Set root delay as defined in RFC-1305.
+     *
+     * @param delay root delay
+     * @since 3.4
+     */
+    @Override
+    public void setRootDelay(final int delay)
+    {
+        setInt(ROOT_DELAY_INDEX, delay);
+    }
+
+    /**
+     * Set root dispersion as defined in RFC-1305.
+     *
+     * @param dispersion root dispersion
+     * @since 3.4
+     */
+    @Override
+    public void setRootDispersion(final int dispersion)
+    {
+        setInt(ROOT_DISPERSION_INDEX, dispersion);
+    }
+
+    /**
+     * Set stratum level as defined in RFC-1305.
+     *
+     * @param stratum stratum level.
+     */
+    @Override
+    public void setStratum(final int stratum)
+    {
+        buf[STRATUM_INDEX] = (byte) (stratum & 0xFF);
+    }
+
+    /**
+     * Sets the NTP timestamp at the given array index.
+     *
+     * @param index index into the byte array.
+     * @param t TimeStamp.
+     */
+    private void setTimestamp(final int index, final TimeStamp t)
+    {
+        long ntpTime = (t == null) ? 0 : t.ntpValue();
+        // copy 64-bits from Long value into 8 x 8-bit bytes of array
+        // one byte at a time shifting 8-bits for each position.
+        for (int i = 7; i >= 0; i--) {
+            buf[index + i] = (byte) (ntpTime & 0xFF);
+            ntpTime >>>= 8; // shift to next byte
+        }
+        // buf[index] |= 0x80;  // only set if 1900 baseline....
+    }
+
+    /**
+     * Set transmit time with NTP timestamp.
+     * If <code>ts</code> is null then zero time is used.
+     *
+     * @param ts NTP timestamp
+     */
+    @Override
+    public void setTransmitTime(final TimeStamp ts)
+    {
+        setTimestamp(TRANSMIT_TIMESTAMP_INDEX, ts);
+    }
+
+    /**
+     * Set NTP version as defined in RFC-1305.
+     *
+     * @param version NTP version.
+     */
+    @Override
+    public void setVersion(final int version)
+    {
+        buf[VERSION_INDEX] = (byte) (buf[VERSION_INDEX] & 0xC7 | ((version & 0x7) << VERSION_SHIFT));
+    }
+
+    /**
+     * Returns details of NTP packet as a string.
+     *
+     * @return details of NTP packet as a string.
+     */
+    @Override
+    public String toString()
+    {
+        return "[" +
+                "version:" + getVersion() +
+                ", mode:" + getMode() +
+                ", poll:" + getPoll() +
+                ", precision:" + getPrecision() +
+                ", delay:" + getRootDelay() +
+                ", dispersion(ms):" + getRootDispersionInMillisDouble() +
+                ", id:" + getReferenceIdString() +
+                ", xmitTime:" + getTransmitTimeStamp().toDateString() +
+                " ]";
+    }
+
+}
diff --git a/src/main/java/org/apache/commons/net/ntp/NtpV3Packet.java b/src/main/java/org/apache/commons/net/ntp/NtpV3Packet.java
index a1446ed15..d97128547 100644
--- a/src/main/java/org/apache/commons/net/ntp/NtpV3Packet.java
+++ b/src/main/java/org/apache/commons/net/ntp/NtpV3Packet.java
@@ -1,259 +1,259 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.net.ntp;
-
-import java.net.DatagramPacket;
-
-/**
- * Interface for a NtpV3Packet with get/set methods corresponding to the fields
- * in the NTP Data Message Header described in RFC 1305.
- *
- */
-public interface NtpV3Packet
-{
-
-    /**
-     * Standard NTP UDP port
-     */
-    int NTP_PORT = 123;
-
-    int LI_NO_WARNING = 0;
-    int LI_LAST_MINUTE_HAS_61_SECONDS = 1;
-    int LI_LAST_MINUTE_HAS_59_SECONDS = 2;
-    int LI_ALARM_CONDITION = 3;
-
-    /* mode options */
-    int MODE_RESERVED = 0;
-    int MODE_SYMMETRIC_ACTIVE = 1;
-    int MODE_SYMMETRIC_PASSIVE = 2;
-    int MODE_CLIENT = 3;
-    int MODE_SERVER = 4;
-    int MODE_BROADCAST = 5;
-    int MODE_CONTROL_MESSAGE = 6;
-    int MODE_PRIVATE = 7;
-
-    int NTP_MINPOLL = 4;  // 16 seconds
-    int NTP_MAXPOLL = 14; // 16284 seconds
-
-    int NTP_MINCLOCK = 1;
-    int NTP_MAXCLOCK = 10;
-
-    int VERSION_3 = 3;
-    int VERSION_4 = 4;
-
-    /* possible getType values such that other time-related protocols can
-     * have its information represented as NTP packets
-     */
-    String TYPE_NTP = "NTP";         // RFC-1305/2030
-    String TYPE_ICMP = "ICMP";       // RFC-792
-    String TYPE_TIME = "TIME";       // RFC-868
-    String TYPE_DAYTIME = "DAYTIME"; // RFC-867
-
-    /**
-     * @return a datagram packet with the NTP parts already filled in
-     */
-    DatagramPacket getDatagramPacket();
-
-    /**
-     * @return leap indicator as defined in RFC-1305
-     */
-    int getLeapIndicator();
-
-    /**
-     * @return mode as defined in RFC-1305
-     */
-    int getMode();
-
-    /**
-     * @return mode as human readable string; e.g. 3=Client
-     */
-    String getModeName();
-
-    /**
-     * @return the originate time as defined in RFC-1305
-     */
-    TimeStamp getOriginateTimeStamp();
-
-    /**
-     * @return poll interval as defined in RFC-1305.
-     * Field range between NTP_MINPOLL and NTP_MAXPOLL.
-     */
-    int getPoll();
-
-    /**
-     * @return precision as defined in RFC-1305
-     */
-    int getPrecision();
-
-    /**
-     * @return the receive time as defined in RFC-1305
-     */
-    TimeStamp getReceiveTimeStamp();
-
-    /**
-     * @return the reference id (32-bit code) as defined in RFC-1305
-     */
-    int getReferenceId();
-
-    /**
-     * @return the reference id string
-     */
-    String getReferenceIdString();
-
-    /**
-     * @return the reference time as defined in RFC-1305
-     */
-    TimeStamp getReferenceTimeStamp();
-
-    /**
-     * @return root delay as defined in RFC-1305
-     */
-    int getRootDelay();
-
-    /**
-     * @return root delay in milliseconds
-     */
-    double getRootDelayInMillisDouble();
-
-    /**
-     * @return root dispersion as defined in RFC-1305
-     */
-    int getRootDispersion();
-
-    /**
-     * @return root dispersion in milliseconds
-     */
-    long getRootDispersionInMillis();
-
-    /**
-     * @return root dispersion in milliseconds
-     */
-    double getRootDispersionInMillisDouble();
-
-    /**
-     * @return stratum as defined in RFC-1305
-     */
-    int getStratum();
-
-    /**
-     * @return the transmit timestamp as defined in RFC-1305
-     */
-    TimeStamp getTransmitTimeStamp();
-
-    /**
-     * Return type of time packet. The values (e.g. NTP, TIME, ICMP, ...)
-     * correspond to the protocol used to obtain the timing information.
-     *
-     * @return packet type string identifier
-     */
-    String getType();
-
-    /**
-     * @return version as defined in RFC-1305
-     */
-    int getVersion();
-
-    /**
-     * Set the contents of this object from the datagram packet
-     * @param dp the packet
-     */
-    void setDatagramPacket(DatagramPacket dp);
-
-    /**
-     * Set leap indicator.
-     * @param li - leap indicator code
-     */
-    void setLeapIndicator(int li);
-
-    /**
-     * Set mode as defined in RFC-1305
-     * @param mode the mode to set
-     */
-    void setMode(int mode);
-
-    /**
-     * Set originate timestamp given NTP TimeStamp object.
-     * @param ts - timestamp
-     */
-    void setOriginateTimeStamp(TimeStamp ts);
-
-    /**
-     * Set poll interval as defined in RFC-1305.
-     * Field range between NTP_MINPOLL and NTP_MAXPOLL.
-     * @param poll the interval to set
-     */
-    void setPoll(int poll);
-
-    /**
-     * Set precision as defined in RFC-1305
-     * @param precision Precision
-     * @since 3.4
-     */
-    void setPrecision(int precision);
-
-    /**
-     * Set receive timestamp given NTP TimeStamp object.
-     * @param ts - timestamp
-     */
-    void setReceiveTimeStamp(TimeStamp ts);
-
-    /**
-     * Set reference clock identifier field.
-     * @param refId the clock id field to set
-     */
-    void setReferenceId(int refId);
-
-    /**
-     * Set the reference timestamp given NTP TimeStamp object.
-     * @param ts - timestamp
-     */
-    void setReferenceTime(TimeStamp ts);
-
-    /**
-     * Set root delay as defined in RFC-1305
-     * @param delay the delay to set
-     * @since 3.4
-    */
-    void setRootDelay(int delay);
-
-    /**
-     *
-     * @param dispersion the value to set
-     * @since 3.4
-     */
-    void setRootDispersion(int dispersion);
-
-    /**
-     * Set stratum as defined in RFC-1305
-     * @param stratum the stratum to set
-     */
-    void setStratum(int stratum);
-
-    /**
-     * Set the transmit timestamp given NTP TimeStamp object.
-     * @param ts - timestamp
-     */
-    void setTransmitTime(TimeStamp ts);
-
-    /**
-     * Set version as defined in RFC-1305
-     * @param version the version to set
-     */
-    void setVersion(int version);
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.net.ntp;
+
+import java.net.DatagramPacket;
+
+/**
+ * Interface for a NtpV3Packet with get/set methods corresponding to the fields
+ * in the NTP Data Message Header described in RFC 1305.
+ *
+ */
+public interface NtpV3Packet
+{
+
+    /**
+     * Standard NTP UDP port
+     */
+    int NTP_PORT = 123;
+
+    int LI_NO_WARNING = 0;
+    int LI_LAST_MINUTE_HAS_61_SECONDS = 1;
+    int LI_LAST_MINUTE_HAS_59_SECONDS = 2;
+    int LI_ALARM_CONDITION = 3;
+
+    /* mode options */
+    int MODE_RESERVED = 0;
+    int MODE_SYMMETRIC_ACTIVE = 1;
+    int MODE_SYMMETRIC_PASSIVE = 2;
+    int MODE_CLIENT = 3;
+    int MODE_SERVER = 4;
+    int MODE_BROADCAST = 5;
+    int MODE_CONTROL_MESSAGE = 6;
+    int MODE_PRIVATE = 7;
+
+    int NTP_MINPOLL = 4;  // 16 seconds
+    int NTP_MAXPOLL = 14; // 16284 seconds
+
+    int NTP_MINCLOCK = 1;
+    int NTP_MAXCLOCK = 10;
+
+    int VERSION_3 = 3;
+    int VERSION_4 = 4;
+
+    /* possible getType values such that other time-related protocols can
+     * have its information represented as NTP packets
+     */
+    String TYPE_NTP = "NTP";         // RFC-1305/2030
+    String TYPE_ICMP = "ICMP";       // RFC-792
+    String TYPE_TIME = "TIME";       // RFC-868
+    String TYPE_DAYTIME = "DAYTIME"; // RFC-867
+
+    /**
+     * @return a datagram packet with the NTP parts already filled in
+     */
+    DatagramPacket getDatagramPacket();
+
+    /**
+     * @return leap indicator as defined in RFC-1305
+     */
+    int getLeapIndicator();
+
+    /**
+     * @return mode as defined in RFC-1305
+     */
+    int getMode();
+
+    /**
+     * @return mode as human readable string; e.g. 3=Client
+     */
+    String getModeName();
+
+    /**
+     * @return the originate time as defined in RFC-1305
+     */
+    TimeStamp getOriginateTimeStamp();
+
+    /**
+     * @return poll interval as defined in RFC-1305.
+     * Field range between NTP_MINPOLL and NTP_MAXPOLL.
+     */
+    int getPoll();
+
+    /**
+     * @return precision as defined in RFC-1305
+     */
+    int getPrecision();
+
+    /**
+     * @return the receive time as defined in RFC-1305
+     */
+    TimeStamp getReceiveTimeStamp();
+
+    /**
+     * @return the reference id (32-bit code) as defined in RFC-1305
+     */
+    int getReferenceId();
+
+    /**
+     * @return the reference id string
+     */
+    String getReferenceIdString();
+
+    /**
+     * @return the reference time as defined in RFC-1305
+     */
+    TimeStamp getReferenceTimeStamp();
+
+    /**
+     * @return root delay as defined in RFC-1305
+     */
+    int getRootDelay();
+
+    /**
+     * @return root delay in milliseconds
+     */
+    double getRootDelayInMillisDouble();
+
+    /**
+     * @return root dispersion as defined in RFC-1305
+     */
+    int getRootDispersion();
+
+    /**
+     * @return root dispersion in milliseconds
+     */
+    long getRootDispersionInMillis();
+
+    /**
+     * @return root dispersion in milliseconds
+     */
+    double getRootDispersionInMillisDouble();
+
+    /**
+     * @return stratum as defined in RFC-1305
+     */
+    int getStratum();
+
+    /**
+     * @return the transmit timestamp as defined in RFC-1305
+     */
+    TimeStamp getTransmitTimeStamp();
+
+    /**
+     * Return type of time packet. The values (e.g. NTP, TIME, ICMP, ...)
+     * correspond to the protocol used to obtain the timing information.
+     *
+     * @return packet type string identifier
+     */
+    String getType();
+
+    /**
+     * @return version as defined in RFC-1305
+     */
+    int getVersion();
+
+    /**
+     * Set the contents of this object from the datagram packet
+     * @param dp the packet
+     */
+    void setDatagramPacket(DatagramPacket dp);
+
+    /**
+     * Set leap indicator.
+     * @param li - leap indicator code
+     */
+    void setLeapIndicator(int li);
+
+    /**
+     * Set mode as defined in RFC-1305
+     * @param mode the mode to set
+     */
+    void setMode(int mode);
+
+    /**
+     * Set originate timestamp given NTP TimeStamp object.
+     * @param ts - timestamp
+     */
+    void setOriginateTimeStamp(TimeStamp ts);
+
+    /**
+     * Set poll interval as defined in RFC-1305.
+     * Field range between NTP_MINPOLL and NTP_MAXPOLL.
+     * @param poll the interval to set
+     */
+    void setPoll(int poll);
+
+    /**
+     * Set precision as defined in RFC-1305
+     * @param precision Precision
+     * @since 3.4
+     */
+    void setPrecision(int precision);
+
+    /**
+     * Set receive timestamp given NTP TimeStamp object.
+     * @param ts - timestamp
+     */
+    void setReceiveTimeStamp(TimeStamp ts);
+
+    /**
+     * Set reference clock identifier field.
+     * @param refId the clock id field to set
+     */
+    void setReferenceId(int refId);
+
+    /**
+     * Set the reference timestamp given NTP TimeStamp object.
+     * @param ts - timestamp
+     */
+    void setReferenceTime(TimeStamp ts);
+
+    /**
+     * Set root delay as defined in RFC-1305
+     * @param delay the delay to set
+     * @since 3.4
+    */
+    void setRootDelay(int delay);
+
+    /**
+     *
+     * @param dispersion the value to set
+     * @since 3.4
+     */
+    void setRootDispersion(int dispersion);
+
+    /**
+     * Set stratum as defined in RFC-1305
+     * @param stratum the stratum to set
+     */
+    void setStratum(int stratum);
+
+    /**
+     * Set the transmit timestamp given NTP TimeStamp object.
+     * @param ts - timestamp
+     */
+    void setTransmitTime(TimeStamp ts);
+
+    /**
+     * Set version as defined in RFC-1305
+     * @param version the version to set
+     */
+    void setVersion(int version);
+
+}
diff --git a/src/main/java/org/apache/commons/net/ntp/TimeInfo.java b/src/main/java/org/apache/commons/net/ntp/TimeInfo.java
index e0a1d42f1..685419b57 100644
--- a/src/main/java/org/apache/commons/net/ntp/TimeInfo.java
+++ b/src/main/java/org/apache/commons/net/ntp/TimeInfo.java
@@ -1,343 +1,343 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.net.ntp;
-
-import java.net.DatagramPacket;
-import java.net.InetAddress;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Wrapper class to network time packet messages (NTP, etc) that computes
- * related timing info and stats.
- */
-public class TimeInfo {
-
-    private final NtpV3Packet message;
-    private List<String> comments;
-    private Long delayMillis;
-    private Long offsetMillis;
-
-    /**
-     * time at which time message packet was received by local machine
-     */
-    private final long returnTimeMillis;
-
-    /**
-     * flag indicating that the TimeInfo details was processed and delay/offset were computed
-     */
-    private boolean detailsComputed;
-
-    /**
-     * Create TimeInfo object with raw packet message and destination time received.
-     *
-     * @param message NTP message packet
-     * @param returnTimeMillis  destination receive time
-     * @throws IllegalArgumentException if message is null
-     */
-    public TimeInfo(final NtpV3Packet message, final long returnTimeMillis) {
-        this(message, returnTimeMillis, null, true);
-    }
-
-    /**
-     * Create TimeInfo object with raw packet message and destination time received.
-     * Auto-computes details if computeDetails flag set otherwise this is delayed
-     * until computeDetails() is called. Delayed computation is for fast
-     * intialization when sub-millisecond timing is needed.
-     *
-     * @param msgPacket NTP message packet
-     * @param returnTimeMillis  destination receive time
-     * @param doComputeDetails  flag to pre-compute delay/offset values
-     * @throws IllegalArgumentException if message is null
-     */
-    public TimeInfo(final NtpV3Packet msgPacket, final long returnTimeMillis, final boolean doComputeDetails)
-    {
-            this(msgPacket, returnTimeMillis, null, doComputeDetails);
-    }
-
-    /**
-     * Create TimeInfo object with raw packet message and destination time received.
-     *
-     * @param message NTP message packet
-     * @param returnTimeMillis  destination receive time
-     * @param comments List of errors/warnings identified during processing
-     * @throws IllegalArgumentException if message is null
-     */
-    public TimeInfo(final NtpV3Packet message, final long returnTimeMillis, final List<String> comments)
-    {
-            this(message, returnTimeMillis, comments, true);
-    }
-
-    /**
-     * Create TimeInfo object with raw packet message and destination time received.
-     * Auto-computes details if computeDetails flag set otherwise this is delayed
-     * until computeDetails() is called. Delayed computation is for fast
-     * intialization when sub-millisecond timing is needed.
-     *
-     * @param message NTP message packet
-     * @param returnTimeMillis  destination receive time
-     * @param comments  list of comments used to store errors/warnings with message
-     * @param doComputeDetails  flag to pre-compute delay/offset values
-     * @throws IllegalArgumentException if message is null
-     */
-    public TimeInfo(final NtpV3Packet message, final long returnTimeMillis, final List<String> comments,
-                   final boolean doComputeDetails)
-    {
-        if (message == null) {
-            throw new IllegalArgumentException("message cannot be null");
-        }
-        this.returnTimeMillis = returnTimeMillis;
-        this.message = message;
-        this.comments = comments;
-        if (doComputeDetails) {
-            computeDetails();
-        }
-    }
-
-    /**
-     * Add comment (error/warning) to list of comments associated
-     * with processing of NTP parameters. If comment list not create
-     * then one will be created.
-     *
-     * @param comment the comment
-     */
-    public void addComment(final String comment)
-    {
-        if (comments == null) {
-            comments = new ArrayList<>();
-        }
-        comments.add(comment);
-    }
-
-    /**
-     * Compute and validate details of the NTP message packet. Computed
-     * fields include the offset and delay.
-     */
-    public void computeDetails()
-    {
-        if (detailsComputed) {
-            return; // details already computed - do nothing
-        }
-        detailsComputed = true;
-        if (comments == null) {
-            comments = new ArrayList<>();
-        }
-
-        final TimeStamp origNtpTime = message.getOriginateTimeStamp();
-        final long origTimeMillis = origNtpTime.getTime();
-
-        // Receive Time is time request received by server (t2)
-        final TimeStamp rcvNtpTime = message.getReceiveTimeStamp();
-        final long rcvTimeMillis = rcvNtpTime.getTime();
-
-        // Transmit time is time reply sent by server (t3)
-        final TimeStamp xmitNtpTime = message.getTransmitTimeStamp();
-        final long xmitTimeMillis = xmitNtpTime.getTime();
-
-        /*
-         * Round-trip network delay and local clock offset (or time drift) is calculated
-         * according to this standard NTP equation:
-         *
-         * LocalClockOffset = ((ReceiveTimestamp - OriginateTimestamp) +
-         *                     (TransmitTimestamp - DestinationTimestamp)) / 2
-         *
-         * equations from RFC-1305 (NTPv3)
-         *      roundtrip delay = (t4 - t1) - (t3 - t2)
-         *      local clock offset = ((t2 - t1) + (t3 - t4)) / 2
-         *
-         * It takes into account network delays and assumes that they are symmetrical.
-         *
-         * Note the typo in SNTP RFCs 1769/2030 which state that the delay
-         * is (T4 - T1) - (T2 - T3) with the "T2" and "T3" switched.
-         */
-        if (origNtpTime.ntpValue() == 0)
-        {
-            // without originate time cannot determine when packet went out
-            // might be via a broadcast NTP packet...
-            if (xmitNtpTime.ntpValue() != 0)
-            {
-                offsetMillis = Long.valueOf(xmitTimeMillis - returnTimeMillis);
-                comments.add("Error: zero orig time -- cannot compute delay");
-            } else {
-                comments.add("Error: zero orig time -- cannot compute delay/offset");
-            }
-        } else if (rcvNtpTime.ntpValue() == 0 || xmitNtpTime.ntpValue() == 0) {
-            comments.add("Warning: zero rcvNtpTime or xmitNtpTime");
-            // assert destTime >= origTime since network delay cannot be negative
-            if (origTimeMillis > returnTimeMillis) {
-                comments.add("Error: OrigTime > DestRcvTime");
-            } else {
-                // without receive or xmit time cannot figure out processing time
-                // so delay is simply the network travel time
-                delayMillis = Long.valueOf(returnTimeMillis - origTimeMillis);
-            }
-            // TODO: is offset still valid if rcvNtpTime=0 || xmitNtpTime=0 ???
-            // Could always hash origNtpTime (sendTime) but if host doesn't set it
-            // then it's an malformed ntp host anyway and we don't care?
-            // If server is in broadcast mode then we never send out a query in first place...
-            if (rcvNtpTime.ntpValue() != 0)
-            {
-                // xmitTime is 0 just use rcv time
-                offsetMillis = Long.valueOf(rcvTimeMillis - origTimeMillis);
-            } else if (xmitNtpTime.ntpValue() != 0)
-            {
-                // rcvTime is 0 just use xmitTime time
-                offsetMillis = Long.valueOf(xmitTimeMillis - returnTimeMillis);
-            }
-        } else
-        {
-             long delayValueMillis = returnTimeMillis - origTimeMillis;
-             // assert xmitTime >= rcvTime: difference typically < 1ms
-             if (xmitTimeMillis < rcvTimeMillis)
-             {
-                 // server cannot send out a packet before receiving it...
-                 comments.add("Error: xmitTime < rcvTime"); // time-travel not allowed
-             } else
-             {
-                 // subtract processing time from round-trip network delay
-                 final long deltaMillis = xmitTimeMillis - rcvTimeMillis;
-                 // in normal cases the processing delta is less than
-                 // the total roundtrip network travel time.
-                 if (deltaMillis <= delayValueMillis)
-                 {
-                     delayValueMillis -= deltaMillis; // delay = (t4 - t1) - (t3 - t2)
-                 } else // if delta - delayValue == 1 ms then it's a round-off error
-                 // e.g. delay=3ms, processing=4ms
-                 if (deltaMillis - delayValueMillis == 1)
-                 {
-                     // delayValue == 0 -> local clock saw no tick change but destination clock did
-                     if (delayValueMillis != 0)
-                     {
-                         comments.add("Info: processing time > total network time by 1 ms -> assume zero delay");
-                         delayValueMillis = 0;
-                     }
-                 } else {
-                    comments.add("Warning: processing time > total network time");
-                }
-             }
-             delayMillis = Long.valueOf(delayValueMillis);
-            if (origTimeMillis > returnTimeMillis) {
-                comments.add("Error: OrigTime > DestRcvTime");
-            }
-
-            offsetMillis = Long.valueOf(((rcvTimeMillis - origTimeMillis) + (xmitTimeMillis - returnTimeMillis)) / 2);
-        }
-    }
-
-    /**
-     * Compares this object against the specified object.
-     * The result is <code>true</code> if and only if the argument is
-     * not <code>null</code> and is a <code>TimeStamp</code> object that
-     * contains the same values as this object.
-     *
-     * @param   obj   the object to compare with.
-     * @return  <code>true</code> if the objects are the same;
-     *          <code>false</code> otherwise.
-     * @since 3.4
-     */
-    @Override
-    public boolean equals(final Object obj)
-    {
-        if (this == obj) {
-            return true;
-        }
-        if (obj == null || getClass() != obj.getClass()) {
-            return false;
-        }
-        final TimeInfo other = (TimeInfo) obj;
-        return returnTimeMillis == other.returnTimeMillis && message.equals(other.message);
-    }
-
-    /**
-     * Get host address from message datagram if available
-     * @return host address of available otherwise null
-     * @since 3.4
-     */
-    public InetAddress getAddress() {
-        final DatagramPacket pkt = message.getDatagramPacket();
-        return pkt == null ? null : pkt.getAddress();
-    }
-
-    /**
-     * Return list of comments (if any) during processing of NTP packet.
-     *
-     * @return List or null if not yet computed
-     */
-    public List<String> getComments()
-    {
-        return comments;
-    }
-
-    /**
-     * Get round-trip network delay. If null then could not compute the delay.
-     *
-     * @return Long or null if delay not available.
-     */
-    public Long getDelay()
-    {
-        return delayMillis;
-    }
-
-    /**
-     * Returns NTP message packet.
-     *
-     * @return NTP message packet.
-     */
-    public NtpV3Packet getMessage()
-    {
-        return message;
-    }
-
-    /**
-     * Get clock offset needed to adjust local clock to match remote clock. If null then could not
-     * compute the offset.
-     *
-     * @return Long or null if offset not available.
-     */
-    public Long getOffset()
-    {
-        return offsetMillis;
-    }
-
-    /**
-     * Returns time at which time message packet was received by local machine.
-     *
-     * @return packet return time.
-     */
-    public long getReturnTime()
-    {
-        return returnTimeMillis;
-    }
-
-    /**
-     * Computes a hashcode for this object. The result is the exclusive
-     * OR of the return time and the message hash code.
-     *
-     * @return  a hash code value for this object.
-     * @since 3.4
-     */
-    @Override
-    public int hashCode()
-    {
-        final int prime = 31;
-        int result = (int)returnTimeMillis;
-        result = prime * result + message.hashCode();
-        return result;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.net.ntp;
+
+import java.net.DatagramPacket;
+import java.net.InetAddress;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Wrapper class to network time packet messages (NTP, etc) that computes
+ * related timing info and stats.
+ */
+public class TimeInfo {
+
+    private final NtpV3Packet message;
+    private List<String> comments;
+    private Long delayMillis;
+    private Long offsetMillis;
+
+    /**
+     * time at which time message packet was received by local machine
+     */
+    private final long returnTimeMillis;
+
+    /**
+     * flag indicating that the TimeInfo details was processed and delay/offset were computed
+     */
+    private boolean detailsComputed;
+
+    /**
+     * Create TimeInfo object with raw packet message and destination time received.
+     *
+     * @param message NTP message packet
+     * @param returnTimeMillis  destination receive time
+     * @throws IllegalArgumentException if message is null
+     */
+    public TimeInfo(final NtpV3Packet message, final long returnTimeMillis) {
+        this(message, returnTimeMillis, null, true);
+    }
+
+    /**
+     * Create TimeInfo object with raw packet message and destination time received.
+     * Auto-computes details if computeDetails flag set otherwise this is delayed
+     * until computeDetails() is called. Delayed computation is for fast
+     * intialization when sub-millisecond timing is needed.
+     *
+     * @param msgPacket NTP message packet
+     * @param returnTimeMillis  destination receive time
+     * @param doComputeDetails  flag to pre-compute delay/offset values
+     * @throws IllegalArgumentException if message is null
+     */
+    public TimeInfo(final NtpV3Packet msgPacket, final long returnTimeMillis, final boolean doComputeDetails)
+    {
+            this(msgPacket, returnTimeMillis, null, doComputeDetails);
+    }
+
+    /**
+     * Create TimeInfo object with raw packet message and destination time received.
+     *
+     * @param message NTP message packet
+     * @param returnTimeMillis  destination receive time
+     * @param comments List of errors/warnings identified during processing
+     * @throws IllegalArgumentException if message is null
+     */
+    public TimeInfo(final NtpV3Packet message, final long returnTimeMillis, final List<String> comments)
+    {
+            this(message, returnTimeMillis, comments, true);
+    }
+
+    /**
+     * Create TimeInfo object with raw packet message and destination time received.
+     * Auto-computes details if computeDetails flag set otherwise this is delayed
+     * until computeDetails() is called. Delayed computation is for fast
+     * intialization when sub-millisecond timing is needed.
+     *
+     * @param message NTP message packet
+     * @param returnTimeMillis  destination receive time
+     * @param comments  list of comments used to store errors/warnings with message
+     * @param doComputeDetails  flag to pre-compute delay/offset values
+     * @throws IllegalArgumentException if message is null
+     */
+    public TimeInfo(final NtpV3Packet message, final long returnTimeMillis, final List<String> comments,
+                   final boolean doComputeDetails)
+    {
+        if (message == null) {
+            throw new IllegalArgumentException("message cannot be null");
+        }
+        this.returnTimeMillis = returnTimeMillis;
+        this.message = message;
+        this.comments = comments;
+        if (doComputeDetails) {
+            computeDetails();
+        }
+    }
+
+    /**
+     * Add comment (error/warning) to list of comments associated
+     * with processing of NTP parameters. If comment list not create
+     * then one will be created.
+     *
+     * @param comment the comment
+     */
+    public void addComment(final String comment)
+    {
+        if (comments == null) {
+            comments = new ArrayList<>();
+        }
+        comments.add(comment);
+    }
+
+    /**
+     * Compute and validate details of the NTP message packet. Computed
+     * fields include the offset and delay.
+     */
+    public void computeDetails()
+    {
+        if (detailsComputed) {
+            return; // details already computed - do nothing
+        }
+        detailsComputed = true;
+        if (comments == null) {
+            comments = new ArrayList<>();
+        }
+
+        final TimeStamp origNtpTime = message.getOriginateTimeStamp();
+        final long origTimeMillis = origNtpTime.getTime();
+
+        // Receive Time is time request received by server (t2)
+        final TimeStamp rcvNtpTime = message.getReceiveTimeStamp();
+        final long rcvTimeMillis = rcvNtpTime.getTime();
+
+        // Transmit time is time reply sent by server (t3)
+        final TimeStamp xmitNtpTime = message.getTransmitTimeStamp();
+        final long xmitTimeMillis = xmitNtpTime.getTime();
+
+        /*
+         * Round-trip network delay and local clock offset (or time drift) is calculated
+         * according to this standard NTP equation:
+         *
+         * LocalClockOffset = ((ReceiveTimestamp - OriginateTimestamp) +
+         *                     (TransmitTimestamp - DestinationTimestamp)) / 2
+         *
+         * equations from RFC-1305 (NTPv3)
+         *      roundtrip delay = (t4 - t1) - (t3 - t2)
+         *      local clock offset = ((t2 - t1) + (t3 - t4)) / 2
+         *
+         * It takes into account network delays and assumes that they are symmetrical.
+         *
+         * Note the typo in SNTP RFCs 1769/2030 which state that the delay
+         * is (T4 - T1) - (T2 - T3) with the "T2" and "T3" switched.
+         */
+        if (origNtpTime.ntpValue() == 0)
+        {
+            // without originate time cannot determine when packet went out
+            // might be via a broadcast NTP packet...
+            if (xmitNtpTime.ntpValue() != 0)
+            {
+                offsetMillis = Long.valueOf(xmitTimeMillis - returnTimeMillis);
+                comments.add("Error: zero orig time -- cannot compute delay");
+            } else {
+                comments.add("Error: zero orig time -- cannot compute delay/offset");
+            }
+        } else if (rcvNtpTime.ntpValue() == 0 || xmitNtpTime.ntpValue() == 0) {
+            comments.add("Warning: zero rcvNtpTime or xmitNtpTime");
+            // assert destTime >= origTime since network delay cannot be negative
+            if (origTimeMillis > returnTimeMillis) {
+                comments.add("Error: OrigTime > DestRcvTime");
+            } else {
+                // without receive or xmit time cannot figure out processing time
+                // so delay is simply the network travel time
+                delayMillis = Long.valueOf(returnTimeMillis - origTimeMillis);
+            }
+            // TODO: is offset still valid if rcvNtpTime=0 || xmitNtpTime=0 ???
+            // Could always hash origNtpTime (sendTime) but if host doesn't set it
+            // then it's an malformed ntp host anyway and we don't care?
+            // If server is in broadcast mode then we never send out a query in first place...
+            if (rcvNtpTime.ntpValue() != 0)
+            {
+                // xmitTime is 0 just use rcv time
+                offsetMillis = Long.valueOf(rcvTimeMillis - origTimeMillis);
+            } else if (xmitNtpTime.ntpValue() != 0)
+            {
+                // rcvTime is 0 just use xmitTime time
+                offsetMillis = Long.valueOf(xmitTimeMillis - returnTimeMillis);
+            }
+        } else
+        {
+             long delayValueMillis = returnTimeMillis - origTimeMillis;
+             // assert xmitTime >= rcvTime: difference typically < 1ms
+             if (xmitTimeMillis < rcvTimeMillis)
+             {
+                 // server cannot send out a packet before receiving it...
+                 comments.add("Error: xmitTime < rcvTime"); // time-travel not allowed
+             } else
+             {
+                 // subtract processing time from round-trip network delay
+                 final long deltaMillis = xmitTimeMillis - rcvTimeMillis;
+                 // in normal cases the processing delta is less than
+                 // the total roundtrip network travel time.
+                 if (deltaMillis <= delayValueMillis)
+                 {
+                     delayValueMillis -= deltaMillis; // delay = (t4 - t1) - (t3 - t2)
+                 } else // if delta - delayValue == 1 ms then it's a round-off error
+                 // e.g. delay=3ms, processing=4ms
+                 if (deltaMillis - delayValueMillis == 1)
+                 {
+                     // delayValue == 0 -> local clock saw no tick change but destination clock did
+                     if (delayValueMillis != 0)
+                     {
+                         comments.add("Info: processing time > total network time by 1 ms -> assume zero delay");
+                         delayValueMillis = 0;
+                     }
+                 } else {
+                    comments.add("Warning: processing time > total network time");
+                }
+             }
+             delayMillis = Long.valueOf(delayValueMillis);
+            if (origTimeMillis > returnTimeMillis) {
+                comments.add("Error: OrigTime > DestRcvTime");
+            }
+
+            offsetMillis = Long.valueOf(((rcvTimeMillis - origTimeMillis) + (xmitTimeMillis - returnTimeMillis)) / 2);
+        }
+    }
+
+    /**
+     * Compares this object against the specified object.
+     * The result is <code>true</code> if and only if the argument is
+     * not <code>null</code> and is a <code>TimeStamp</code> object that
+     * contains the same values as this object.
+     *
+     * @param   obj   the object to compare with.
+     * @return  <code>true</code> if the objects are the same;
+     *          <code>false</code> otherwise.
+     * @since 3.4
+     */
+    @Override
+    public boolean equals(final Object obj)
+    {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null || getClass() != obj.getClass()) {
+            return false;
+        }
+        final TimeInfo other = (TimeInfo) obj;
+        return returnTimeMillis == other.returnTimeMillis && message.equals(other.message);
+    }
+
+    /**
+     * Get host address from message datagram if available
+     * @return host address of available otherwise null
+     * @since 3.4
+     */
+    public InetAddress getAddress() {
+        final DatagramPacket pkt = message.getDatagramPacket();
+        return pkt == null ? null : pkt.getAddress();
+    }
+
+    /**
+     * Return list of comments (if any) during processing of NTP packet.
+     *
+     * @return List or null if not yet computed
+     */
+    public List<String> getComments()
+    {
+        return comments;
+    }
+
+    /**
+     * Get round-trip network delay. If null then could not compute the delay.
+     *
+     * @return Long or null if delay not available.
+     */
+    public Long getDelay()
+    {
+        return delayMillis;
+    }
+
+    /**
+     * Returns NTP message packet.
+     *
+     * @return NTP message packet.
+     */
+    public NtpV3Packet getMessage()
+    {
+        return message;
+    }
+
+    /**
+     * Get clock offset needed to adjust local clock to match remote clock. If null then could not
+     * compute the offset.
+     *
+     * @return Long or null if offset not available.
+     */
+    public Long getOffset()
+    {
+        return offsetMillis;
+    }
+
+    /**
+     * Returns time at which time message packet was received by local machine.
+     *
+     * @return packet return time.
+     */
+    public long getReturnTime()
+    {
+        return returnTimeMillis;
+    }
+
+    /**
+     * Computes a hashcode for this object. The result is the exclusive
+     * OR of the return time and the message hash code.
+     *
+     * @return  a hash code value for this object.
+     * @since 3.4
+     */
+    @Override
+    public int hashCode()
+    {
+        final int prime = 31;
+        int result = (int)returnTimeMillis;
+        result = prime * result + message.hashCode();
+        return result;
+    }
+
+}
diff --git a/src/main/java/org/apache/commons/net/ntp/TimeStamp.java b/src/main/java/org/apache/commons/net/ntp/TimeStamp.java
index 9b888b762..a552a4183 100644
--- a/src/main/java/org/apache/commons/net/ntp/TimeStamp.java
+++ b/src/main/java/org/apache/commons/net/ntp/TimeStamp.java
@@ -1,468 +1,468 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.net.ntp;
-
-import java.io.IOException;
-import java.io.Serializable;
-import java.text.DateFormat;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.Locale;
-import java.util.TimeZone;
-
-/**
- * TimeStamp class represents the Network Time Protocol (NTP) timestamp
- * as defined in RFC-1305 and SNTP (RFC-2030). It is represented as a
- * 64-bit unsigned fixed-point number in seconds relative to 0-hour on 1-January-1900.
- * The 32-bit low-order bits are the fractional seconds whose precision is
- * about 200 picoseconds. Assumes overflow date when date passes MAX_LONG
- * and reverts back to 0 is 2036 and not 1900. Test for most significant
- * bit: if MSB=0 then 2036 basis is used otherwise 1900 if MSB=1.
- * <p>
- * Methods exist to convert NTP timestamps to and from the equivalent Java date
- * representation, which is the number of milliseconds since the standard base
- * time known as "the epoch", namely January 1, 1970, 00:00:00 GMT.
- * </p>
- *
- * @see java.util.Date
- */
-public class TimeStamp implements Serializable, Comparable<TimeStamp>
-{
-    private static final long serialVersionUID = 8139806907588338737L;
-
-    /**
-     * Baseline NTP time if bit-0=0 is 7-Feb-2036 @ 06:28:16 UTC
-     */
-    protected static final long msb0baseTime = 2085978496000L;
-
-    /**
-     * Baseline NTP time if bit-0=1 is 1-Jan-1900 @ 01:00:00 UTC
-     */
-    protected static final long msb1baseTime = -2208988800000L;
-
-    /**
-     * Default NTP date string format. E.g. Fri, Sep 12 2003 21:06:23.860.
-     * See <code>java.text.SimpleDateFormat</code> for code descriptions.
-     */
-    public static final String NTP_DATE_FORMAT = "EEE, MMM dd yyyy HH:mm:ss.SSS";
-
-    /**
-     * Left-pad 8-character hex string with 0's
-     *
-     * @param buf - StringBuilder which is appended with leading 0's.
-     * @param l - a long.
-     */
-    private static void appendHexString(final StringBuilder buf, final long l)
-    {
-        final String s = Long.toHexString(l);
-        for (int i = s.length(); i < 8; i++) {
-            buf.append('0');
-        }
-        buf.append(s);
-    }
-
-    /**
-     * Convert NTP timestamp hexstring (e.g. "c1a089bd.fc904f6d") to the NTP
-     * 64-bit unsigned fixed-point number.
-     * @param hexString the string to convert
-     *
-     * @return NTP 64-bit timestamp value.
-     * @throws NumberFormatException - if the string does not contain a parsable timestamp.
-     */
-    protected static long decodeNtpHexString(final String hexString)
-            throws NumberFormatException
-    {
-        if (hexString == null) {
-            throw new NumberFormatException("null");
-        }
-        final int ind = hexString.indexOf('.');
-        if (ind == -1) {
-            if (hexString.isEmpty()) {
-                return 0;
-            }
-            return Long.parseLong(hexString, 16) << 32; // no decimal
-        }
-
-        return Long.parseLong(hexString.substring(0, ind), 16) << 32 |
-                Long.parseLong(hexString.substring(ind + 1), 16);
-    }
-    /**
-     * Constructs a NTP timestamp object and initializes it so that
-     * it represents the time at which it was allocated, measured to the
-     * nearest millisecond.
-     * @return NTP timestamp object set to the current time.
-     * @see     System#currentTimeMillis()
-     */
-    public static TimeStamp getCurrentTime()
-    {
-        return getNtpTime(System.currentTimeMillis());
-    }
-
-    // initialization of static time bases
-    /*
-    static {
-        TimeZone utcZone = TimeZone.getTimeZone("UTC");
-        Calendar calendar = Calendar.getInstance(utcZone);
-        calendar.set(1900, Calendar.JANUARY, 1, 0, 0, 0);
-        calendar.set(Calendar.MILLISECOND, 0);
-        msb1baseTime = calendar.getTime().getTime();
-        calendar.set(2036, Calendar.FEBRUARY, 7, 6, 28, 16);
-        calendar.set(Calendar.MILLISECOND, 0);
-        msb0baseTime = calendar.getTime().getTime();
-    }
-    */
-
-    /**
-     * Helper method to convert Java time to NTP timestamp object.
-     * Note that Java time (milliseconds) by definition has less precision
-     * then NTP time (picoseconds) so converting Ntptime to Javatime and back
-     * to Ntptime loses precision. For example, Tue, Dec 17 2002 09:07:24.810
-     * is represented by a single Java-based time value of f22cd1fc8a, but its
-     * NTP equivalent are all values from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.
-     * @param   dateMillis   the milliseconds since January 1, 1970, 00:00:00 GMT.
-     * @return NTP timestamp object at the specified date.
-     */
-    public static TimeStamp getNtpTime(final long dateMillis)
-    {
-        return new TimeStamp(toNtpTime(dateMillis));
-    }
-
-    /**
-     * Converts 64-bit NTP timestamp to Java standard time.
-     *
-     * Note that java time (milliseconds) by definition has less precision
-     * then NTP time (picoseconds) so converting NTP timestamp to java time and back
-     * to NTP timestamp loses precision. For example, Tue, Dec 17 2002 09:07:24.810 EST
-     * is represented by a single Java-based time value of f22cd1fc8a, but its
-     * NTP equivalent are all values ranging from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.
-     *
-     * @param ntpTimeValue the input time
-     * @return the number of milliseconds since January 1, 1970, 00:00:00 GMT
-     * represented by this NTP timestamp value.
-     */
-    public static long getTime(final long ntpTimeValue)
-    {
-        final long seconds = (ntpTimeValue >>> 32) & 0xffffffffL;     // high-order 32-bits
-        long fraction = ntpTimeValue & 0xffffffffL;             // low-order 32-bits
-
-        // Use round-off on fractional part to preserve going to lower precision
-        fraction = Math.round(1000D * fraction / 0x100000000L);
-
-        /*
-         * If the most significant bit (MSB) on the seconds field is set we use
-         * a different time base. The following text is a quote from RFC-2030 (SNTP v4):
-         *
-         *  If bit 0 is set, the UTC time is in the range 1968-2036 and UTC time
-         *  is reckoned from 0h 0m 0s UTC on 1 January 1900. If bit 0 is not set,
-         *  the time is in the range 2036-2104 and UTC time is reckoned from
-         *  6h 28m 16s UTC on 7 February 2036.
-         */
-        final long msb = seconds & 0x80000000L;
-        if (msb == 0) {
-            // use base: 7-Feb-2036 @ 06:28:16 UTC
-            return msb0baseTime + (seconds * 1000) + fraction;
-        }
-        // use base: 1-Jan-1900 @ 01:00:00 UTC
-        return msb1baseTime + (seconds * 1000) + fraction;
-    }
-
-    /**
-     * Parses the string argument as a NTP hexidecimal timestamp representation string
-     * (e.g. "c1a089bd.fc904f6d").
-     *
-     * @param s - hexstring.
-     * @return the Timestamp represented by the argument in hexidecimal.
-     * @throws NumberFormatException - if the string does not contain a parsable timestamp.
-     */
-    public static TimeStamp parseNtpString(final String s)
-            throws NumberFormatException
-    {
-        return new TimeStamp(decodeNtpHexString(s));
-    }
-
-    /**
-     * Converts Java time to 64-bit NTP time representation.
-     *
-     * @param millis Java time
-     * @return NTP timestamp representation of Java time value.
-     */
-    protected static long toNtpTime(final long millis)
-    {
-        final boolean useBase1 = millis < msb0baseTime;    // time < Feb-2036
-        final long baseTimeMillis;
-        if (useBase1) {
-            baseTimeMillis = millis - msb1baseTime; // dates <= Feb-2036
-        } else {
-            // if base0 needed for dates >= Feb-2036
-            baseTimeMillis = millis - msb0baseTime;
-        }
-
-        long seconds = baseTimeMillis / 1000;
-        final long fraction = ((baseTimeMillis % 1000) * 0x100000000L) / 1000;
-
-        if (useBase1) {
-            seconds |= 0x80000000L; // set high-order bit if msb1baseTime 1900 used
-        }
-
-        return seconds << 32 | fraction;
-    }
-
-    /**
-     * Converts 64-bit NTP timestamp value to a <code>String</code>.
-     * The NTP timestamp value is represented as hex string with
-     * seconds separated by fractional seconds by a decimal point;
-     * e.g. c1a089bd.fc904f6d == Tue, Dec 10 2002 10:41:49.986
-     * @param ntpTime the 64 bit timestamp
-     *
-     * @return NTP timestamp 64-bit long value as hex string with seconds
-     * separated by fractional seconds.
-     */
-    public static String toString(final long ntpTime)
-    {
-        final StringBuilder buf = new StringBuilder();
-        // high-order second bits (32..63) as hexstring
-        appendHexString(buf, (ntpTime >>> 32) & 0xffffffffL);
-
-        // low-order fractional seconds bits (0..31) as hexstring
-        buf.append('.');
-        appendHexString(buf, ntpTime & 0xffffffffL);
-
-        return buf.toString();
-    }
-
-    /**
-     * NTP timestamp value: 64-bit unsigned fixed-point number as defined in RFC-1305
-     * with high-order 32 bits the seconds field and the low-order 32-bits the
-     * fractional field.
-     */
-    private final long ntpTime;
-
-    private DateFormat simpleFormatter;
-
-    private DateFormat utcFormatter;
-
-    /**
-     * Constructs a newly allocated NTP timestamp object
-     * that represents the Java Date argument.
-     *
-     * @param d - the Date to be represented by the Timestamp object.
-     */
-    public TimeStamp(final Date d)
-    {
-        ntpTime = d == null ? 0 : toNtpTime(d.getTime());
-    }
-
-    /**
-     * Constructs a newly allocated NTP timestamp object
-     * that represents the native 64-bit long argument.
-     * @param ntpTime the timestamp
-     */
-    public TimeStamp(final long ntpTime)
-    {
-        this.ntpTime = ntpTime;
-    }
-
-    /**
-     * Constructs a newly allocated NTP timestamp object
-     * that represents the value represented by the string
-     * in hexdecimal form (e.g. "c1a089bd.fc904f6d").
-     * @param hexStamp the hex timestamp
-     *
-     * @throws NumberFormatException - if the string does not contain a parsable timestamp.
-     */
-    public TimeStamp(final String hexStamp) throws NumberFormatException
-    {
-        ntpTime = decodeNtpHexString(hexStamp);
-    }
-
-    /**
-     * Compares two Timestamps numerically.
-     *
-     * @param   anotherTimeStamp - the <code>TimeStamp</code> to be compared.
-     * @return  the value <code>0</code> if the argument TimeStamp is equal to
-     *          this TimeStamp; a value less than <code>0</code> if this TimeStamp
-     *          is numerically less than the TimeStamp argument; and a
-     *          value greater than <code>0</code> if this TimeStamp is
-     *          numerically greater than the TimeStamp argument
-     *          (signed comparison).
-     */
-    @Override
-    public int compareTo(final TimeStamp anotherTimeStamp)
-    {
-        final long thisVal = this.ntpTime;
-        final long anotherVal = anotherTimeStamp.ntpTime;
-        return (Long.compare(thisVal, anotherVal));
-    }
-
-    /**
-     * Compares this object against the specified object.
-     * The result is <code>true</code> if and only if the argument is
-     * not <code>null</code> and is a <code>Long</code> object that
-     * contains the same <code>long</code> value as this object.
-     *
-     * @param   obj   the object to compare with.
-     * @return  <code>true</code> if the objects are the same;
-     *          <code>false</code> otherwise.
-     */
-    @Override
-    public boolean equals(final Object obj)
-    {
-        if (obj instanceof TimeStamp) {
-            return ntpTime == ((TimeStamp) obj).ntpValue();
-        }
-        return false;
-    }
-
-    /**
-     * Converts NTP timestamp to Java Date object.
-     *
-     * @return NTP Timestamp in Java Date
-     */
-    public Date getDate()
-    {
-        return new Date(getTime(ntpTime));
-    }
-
-    /**
-     * Returns low-order 32-bits representing the fractional seconds.
-     *
-     * @return fractional seconds represented by this NTP timestamp.
-     */
-    public long getFraction()
-    {
-        return ntpTime & 0xffffffffL;
-    }
-
-    /**
-     * Returns high-order 32-bits representing the seconds of this NTP timestamp.
-     *
-     * @return seconds represented by this NTP timestamp.
-     */
-    public long getSeconds()
-    {
-        return (ntpTime >>> 32) & 0xffffffffL;
-    }
-
-    /**
-     * Converts NTP timestamp to Java standard time.
-     *
-     * @return the number of milliseconds since January 1, 1970, 00:00:00 GMT
-     * represented by this NTP timestamp value.
-     */
-    public long getTime()
-    {
-        return getTime(ntpTime);
-    }
-
-    /**
-     * Computes a hashcode for this Timestamp. The result is the exclusive
-     * OR of the two halves of the primitive <code>long</code> value
-     * represented by this <code>TimeStamp</code> object. That is, the hashcode
-     * is the value of the expression:
-     * <blockquote><pre>
-     * {@code (int)(this.ntpValue()^(this.ntpValue() >>> 32))}
-     * </pre></blockquote>
-     *
-     * @return  a hash code value for this object.
-     */
-    @Override
-    public int hashCode()
-    {
-        return (int) (ntpTime ^ (ntpTime >>> 32));
-    }
-
-    /**
-     * Returns the value of this Timestamp as a long value.
-     *
-     * @return the 64-bit long value represented by this object.
-     */
-    public long ntpValue()
-    {
-        return ntpTime;
-    }
-
-    /**
-     * Converts this <code>TimeStamp</code> object to a <code>String</code>
-     * of the form:
-     * <blockquote><pre>
-     * EEE, MMM dd yyyy HH:mm:ss.SSS</pre></blockquote>
-     * See java.text.SimpleDataFormat for code descriptions.
-     *
-     * @return  a string representation of this date.
-     */
-    public String toDateString()
-    {
-        if (simpleFormatter == null) {
-            simpleFormatter = new SimpleDateFormat(NTP_DATE_FORMAT, Locale.US);
-            simpleFormatter.setTimeZone(TimeZone.getDefault());
-        }
-        final Date ntpDate = getDate();
-        return simpleFormatter.format(ntpDate);
-    }
-
-    /**
-     * Converts this <code>TimeStamp</code> object to a <code>String</code>.
-     * The NTP timestamp 64-bit long value is represented as hex string with
-     * seconds separated by fractional seconds by a decimal point;
-     * e.g. c1a089bd.fc904f6d == Tue, Dec 10 2002 10:41:49.986
-     *
-     * @return NTP timestamp 64-bit long value as hex string with seconds
-     * separated by fractional seconds.
-     */
-    @Override
-    public String toString()
-    {
-        return toString(ntpTime);
-    }
-
-    /**
-     * Converts this <code>TimeStamp</code> object to a <code>String</code>
-     * of the form:
-     * <blockquote><pre>
-     * EEE, MMM dd yyyy HH:mm:ss.SSS UTC</pre></blockquote>
-     * See java.text.SimpleDataFormat for code descriptions.
-     *
-     * @return  a string representation of this date in UTC.
-     */
-    public String toUTCString()
-    {
-        if (utcFormatter == null) {
-            utcFormatter = new SimpleDateFormat(NTP_DATE_FORMAT + " 'UTC'",
-                    Locale.US);
-            utcFormatter.setTimeZone(TimeZone.getTimeZone("UTC"));
-        }
-        final Date ntpDate = getDate();
-        return utcFormatter.format(ntpDate);
-    }
-
-    /*
-        Serialization is unnecessary for this class.
-        Reject attempts to do so until such time as the Serializable attribute can be dropped.
-     */
-
-    private void writeObject(final java.io.ObjectOutputStream out) throws IOException
-    {
-        throw new UnsupportedOperationException("Serialization is not supported");
-    }
-
-    private void readObject(final java.io.ObjectInputStream in) throws IOException, ClassNotFoundException
-    {
-        throw new UnsupportedOperationException("Serialization is not supported");
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.net.ntp;
+
+import java.io.IOException;
+import java.io.Serializable;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+import java.util.TimeZone;
+
+/**
+ * TimeStamp class represents the Network Time Protocol (NTP) timestamp
+ * as defined in RFC-1305 and SNTP (RFC-2030). It is represented as a
+ * 64-bit unsigned fixed-point number in seconds relative to 0-hour on 1-January-1900.
+ * The 32-bit low-order bits are the fractional seconds whose precision is
+ * about 200 picoseconds. Assumes overflow date when date passes MAX_LONG
+ * and reverts back to 0 is 2036 and not 1900. Test for most significant
+ * bit: if MSB=0 then 2036 basis is used otherwise 1900 if MSB=1.
+ * <p>
+ * Methods exist to convert NTP timestamps to and from the equivalent Java date
+ * representation, which is the number of milliseconds since the standard base
+ * time known as "the epoch", namely January 1, 1970, 00:00:00 GMT.
+ * </p>
+ *
+ * @see java.util.Date
+ */
+public class TimeStamp implements Serializable, Comparable<TimeStamp>
+{
+    private static final long serialVersionUID = 8139806907588338737L;
+
+    /**
+     * Baseline NTP time if bit-0=0 is 7-Feb-2036 @ 06:28:16 UTC
+     */
+    protected static final long msb0baseTime = 2085978496000L;
+
+    /**
+     * Baseline NTP time if bit-0=1 is 1-Jan-1900 @ 01:00:00 UTC
+     */
+    protected static final long msb1baseTime = -2208988800000L;
+
+    /**
+     * Default NTP date string format. E.g. Fri, Sep 12 2003 21:06:23.860.
+     * See <code>java.text.SimpleDateFormat</code> for code descriptions.
+     */
+    public static final String NTP_DATE_FORMAT = "EEE, MMM dd yyyy HH:mm:ss.SSS";
+
+    /**
+     * Left-pad 8-character hex string with 0's
+     *
+     * @param buf - StringBuilder which is appended with leading 0's.
+     * @param l - a long.
+     */
+    private static void appendHexString(final StringBuilder buf, final long l)
+    {
+        final String s = Long.toHexString(l);
+        for (int i = s.length(); i < 8; i++) {
+            buf.append('0');
+        }
+        buf.append(s);
+    }
+
+    /**
+     * Convert NTP timestamp hexstring (e.g. "c1a089bd.fc904f6d") to the NTP
+     * 64-bit unsigned fixed-point number.
+     * @param hexString the string to convert
+     *
+     * @return NTP 64-bit timestamp value.
+     * @throws NumberFormatException - if the string does not contain a parsable timestamp.
+     */
+    protected static long decodeNtpHexString(final String hexString)
+            throws NumberFormatException
+    {
+        if (hexString == null) {
+            throw new NumberFormatException("null");
+        }
+        final int ind = hexString.indexOf('.');
+        if (ind == -1) {
+            if (hexString.isEmpty()) {
+                return 0;
+            }
+            return Long.parseLong(hexString, 16) << 32; // no decimal
+        }
+
+        return Long.parseLong(hexString.substring(0, ind), 16) << 32 |
+                Long.parseLong(hexString.substring(ind + 1), 16);
+    }
+    /**
+     * Constructs a NTP timestamp object and initializes it so that
+     * it represents the time at which it was allocated, measured to the
+     * nearest millisecond.
+     * @return NTP timestamp object set to the current time.
+     * @see     System#currentTimeMillis()
+     */
+    public static TimeStamp getCurrentTime()
+    {
+        return getNtpTime(System.currentTimeMillis());
+    }
+
+    // initialization of static time bases
+    /*
+    static {
+        TimeZone utcZone = TimeZone.getTimeZone("UTC");
+        Calendar calendar = Calendar.getInstance(utcZone);
+        calendar.set(1900, Calendar.JANUARY, 1, 0, 0, 0);
+        calendar.set(Calendar.MILLISECOND, 0);
+        msb1baseTime = calendar.getTime().getTime();
+        calendar.set(2036, Calendar.FEBRUARY, 7, 6, 28, 16);
+        calendar.set(Calendar.MILLISECOND, 0);
+        msb0baseTime = calendar.getTime().getTime();
+    }
+    */
+
+    /**
+     * Helper method to convert Java time to NTP timestamp object.
+     * Note that Java time (milliseconds) by definition has less precision
+     * then NTP time (picoseconds) so converting Ntptime to Javatime and back
+     * to Ntptime loses precision. For example, Tue, Dec 17 2002 09:07:24.810
+     * is represented by a single Java-based time value of f22cd1fc8a, but its
+     * NTP equivalent are all values from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.
+     * @param   dateMillis   the milliseconds since January 1, 1970, 00:00:00 GMT.
+     * @return NTP timestamp object at the specified date.
+     */
+    public static TimeStamp getNtpTime(final long dateMillis)
+    {
+        return new TimeStamp(toNtpTime(dateMillis));
+    }
+
+    /**
+     * Converts 64-bit NTP timestamp to Java standard time.
+     *
+     * Note that java time (milliseconds) by definition has less precision
+     * then NTP time (picoseconds) so converting NTP timestamp to java time and back
+     * to NTP timestamp loses precision. For example, Tue, Dec 17 2002 09:07:24.810 EST
+     * is represented by a single Java-based time value of f22cd1fc8a, but its
+     * NTP equivalent are all values ranging from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.
+     *
+     * @param ntpTimeValue the input time
+     * @return the number of milliseconds since January 1, 1970, 00:00:00 GMT
+     * represented by this NTP timestamp value.
+     */
+    public static long getTime(final long ntpTimeValue)
+    {
+        final long seconds = (ntpTimeValue >>> 32) & 0xffffffffL;     // high-order 32-bits
+        long fraction = ntpTimeValue & 0xffffffffL;             // low-order 32-bits
+
+        // Use round-off on fractional part to preserve going to lower precision
+        fraction = Math.round(1000D * fraction / 0x100000000L);
+
+        /*
+         * If the most significant bit (MSB) on the seconds field is set we use
+         * a different time base. The following text is a quote from RFC-2030 (SNTP v4):
+         *
+         *  If bit 0 is set, the UTC time is in the range 1968-2036 and UTC time
+         *  is reckoned from 0h 0m 0s UTC on 1 January 1900. If bit 0 is not set,
+         *  the time is in the range 2036-2104 and UTC time is reckoned from
+         *  6h 28m 16s UTC on 7 February 2036.
+         */
+        final long msb = seconds & 0x80000000L;
+        if (msb == 0) {
+            // use base: 7-Feb-2036 @ 06:28:16 UTC
+            return msb0baseTime + (seconds * 1000) + fraction;
+        }
+        // use base: 1-Jan-1900 @ 01:00:00 UTC
+        return msb1baseTime + (seconds * 1000) + fraction;
+    }
+
+    /**
+     * Parses the string argument as a NTP hexidecimal timestamp representation string
+     * (e.g. "c1a089bd.fc904f6d").
+     *
+     * @param s - hexstring.
+     * @return the Timestamp represented by the argument in hexidecimal.
+     * @throws NumberFormatException - if the string does not contain a parsable timestamp.
+     */
+    public static TimeStamp parseNtpString(final String s)
+            throws NumberFormatException
+    {
+        return new TimeStamp(decodeNtpHexString(s));
+    }
+
+    /**
+     * Converts Java time to 64-bit NTP time representation.
+     *
+     * @param millis Java time
+     * @return NTP timestamp representation of Java time value.
+     */
+    protected static long toNtpTime(final long millis)
+    {
+        final boolean useBase1 = millis < msb0baseTime;    // time < Feb-2036
+        final long baseTimeMillis;
+        if (useBase1) {
+            baseTimeMillis = millis - msb1baseTime; // dates <= Feb-2036
+        } else {
+            // if base0 needed for dates >= Feb-2036
+            baseTimeMillis = millis - msb0baseTime;
+        }
+
+        long seconds = baseTimeMillis / 1000;
+        final long fraction = ((baseTimeMillis % 1000) * 0x100000000L) / 1000;
+
+        if (useBase1) {
+            seconds |= 0x80000000L; // set high-order bit if msb1baseTime 1900 used
+        }
+
+        return seconds << 32 | fraction;
+    }
+
+    /**
+     * Converts 64-bit NTP timestamp value to a <code>String</code>.
+     * The NTP timestamp value is represented as hex string with
+     * seconds separated by fractional seconds by a decimal point;
+     * e.g. c1a089bd.fc904f6d == Tue, Dec 10 2002 10:41:49.986
+     * @param ntpTime the 64 bit timestamp
+     *
+     * @return NTP timestamp 64-bit long value as hex string with seconds
+     * separated by fractional seconds.
+     */
+    public static String toString(final long ntpTime)
+    {
+        final StringBuilder buf = new StringBuilder();
+        // high-order second bits (32..63) as hexstring
+        appendHexString(buf, (ntpTime >>> 32) & 0xffffffffL);
+
+        // low-order fractional seconds bits (0..31) as hexstring
+        buf.append('.');
+        appendHexString(buf, ntpTime & 0xffffffffL);
+
+        return buf.toString();
+    }
+
+    /**
+     * NTP timestamp value: 64-bit unsigned fixed-point number as defined in RFC-1305
+     * with high-order 32 bits the seconds field and the low-order 32-bits the
+     * fractional field.
+     */
+    private final long ntpTime;
+
+    private DateFormat simpleFormatter;
+
+    private DateFormat utcFormatter;
+
+    /**
+     * Constructs a newly allocated NTP timestamp object
+     * that represents the Java Date argument.
+     *
+     * @param d - the Date to be represented by the Timestamp object.
+     */
+    public TimeStamp(final Date d)
+    {
+        ntpTime = d == null ? 0 : toNtpTime(d.getTime());
+    }
+
+    /**
+     * Constructs a newly allocated NTP timestamp object
+     * that represents the native 64-bit long argument.
+     * @param ntpTime the timestamp
+     */
+    public TimeStamp(final long ntpTime)
+    {
+        this.ntpTime = ntpTime;
+    }
+
+    /**
+     * Constructs a newly allocated NTP timestamp object
+     * that represents the value represented by the string
+     * in hexdecimal form (e.g. "c1a089bd.fc904f6d").
+     * @param hexStamp the hex timestamp
+     *
+     * @throws NumberFormatException - if the string does not contain a parsable timestamp.
+     */
+    public TimeStamp(final String hexStamp) throws NumberFormatException
+    {
+        ntpTime = decodeNtpHexString(hexStamp);
+    }
+
+    /**
+     * Compares two Timestamps numerically.
+     *
+     * @param   anotherTimeStamp - the <code>TimeStamp</code> to be compared.
+     * @return  the value <code>0</code> if the argument TimeStamp is equal to
+     *          this TimeStamp; a value less than <code>0</code> if this TimeStamp
+     *          is numerically less than the TimeStamp argument; and a
+     *          value greater than <code>0</code> if this TimeStamp is
+     *          numerically greater than the TimeStamp argument
+     *          (signed comparison).
+     */
+    @Override
+    public int compareTo(final TimeStamp anotherTimeStamp)
+    {
+        final long thisVal = this.ntpTime;
+        final long anotherVal = anotherTimeStamp.ntpTime;
+        return (Long.compare(thisVal, anotherVal));
+    }
+
+    /**
+     * Compares this object against the specified object.
+     * The result is <code>true</code> if and only if the argument is
+     * not <code>null</code> and is a <code>Long</code> object that
+     * contains the same <code>long</code> value as this object.
+     *
+     * @param   obj   the object to compare with.
+     * @return  <code>true</code> if the objects are the same;
+     *          <code>false</code> otherwise.
+     */
+    @Override
+    public boolean equals(final Object obj)
+    {
+        if (obj instanceof TimeStamp) {
+            return ntpTime == ((TimeStamp) obj).ntpValue();
+        }
+        return false;
+    }
+
+    /**
+     * Converts NTP timestamp to Java Date object.
+     *
+     * @return NTP Timestamp in Java Date
+     */
+    public Date getDate()
+    {
+        return new Date(getTime(ntpTime));
+    }
+
+    /**
+     * Returns low-order 32-bits representing the fractional seconds.
+     *
+     * @return fractional seconds represented by this NTP timestamp.
+     */
+    public long getFraction()
+    {
+        return ntpTime & 0xffffffffL;
+    }
+
+    /**
+     * Returns high-order 32-bits representing the seconds of this NTP timestamp.
+     *
+     * @return seconds represented by this NTP timestamp.
+     */
+    public long getSeconds()
+    {
+        return (ntpTime >>> 32) & 0xffffffffL;
+    }
+
+    /**
+     * Converts NTP timestamp to Java standard time.
+     *
+     * @return the number of milliseconds since January 1, 1970, 00:00:00 GMT
+     * represented by this NTP timestamp value.
+     */
+    public long getTime()
+    {
+        return getTime(ntpTime);
+    }
+
+    /**
+     * Computes a hashcode for this Timestamp. The result is the exclusive
+     * OR of the two halves of the primitive <code>long</code> value
+     * represented by this <code>TimeStamp</code> object. That is, the hashcode
+     * is the value of the expression:
+     * <blockquote><pre>
+     * {@code (int)(this.ntpValue()^(this.ntpValue() >>> 32))}
+     * </pre></blockquote>
+     *
+     * @return  a hash code value for this object.
+     */
+    @Override
+    public int hashCode()
+    {
+        return (int) (ntpTime ^ (ntpTime >>> 32));
+    }
+
+    /**
+     * Returns the value of this Timestamp as a long value.
+     *
+     * @return the 64-bit long value represented by this object.
+     */
+    public long ntpValue()
+    {
+        return ntpTime;
+    }
+
+    /**
+     * Converts this <code>TimeStamp</code> object to a <code>String</code>
+     * of the form:
+     * <blockquote><pre>
+     * EEE, MMM dd yyyy HH:mm:ss.SSS</pre></blockquote>
+     * See java.text.SimpleDataFormat for code descriptions.
+     *
+     * @return  a string representation of this date.
+     */
+    public String toDateString()
+    {
+        if (simpleFormatter == null) {
+            simpleFormatter = new SimpleDateFormat(NTP_DATE_FORMAT, Locale.US);
+            simpleFormatter.setTimeZone(TimeZone.getDefault());
+        }
+        final Date ntpDate = getDate();
+        return simpleFormatter.format(ntpDate);
+    }
+
+    /**
+     * Converts this <code>TimeStamp</code> object to a <code>String</code>.
+     * The NTP timestamp 64-bit long value is represented as hex string with
+     * seconds separated by fractional seconds by a decimal point;
+     * e.g. c1a089bd.fc904f6d == Tue, Dec 10 2002 10:41:49.986
+     *
+     * @return NTP timestamp 64-bit long value as hex string with seconds
+     * separated by fractional seconds.
+     */
+    @Override
+    public String toString()
+    {
+        return toString(ntpTime);
+    }
+
+    /**
+     * Converts this <code>TimeStamp</code> object to a <code>String</code>
+     * of the form:
+     * <blockquote><pre>
+     * EEE, MMM dd yyyy HH:mm:ss.SSS UTC</pre></blockquote>
+     * See java.text.SimpleDataFormat for code descriptions.
+     *
+     * @return  a string representation of this date in UTC.
+     */
+    public String toUTCString()
+    {
+        if (utcFormatter == null) {
+            utcFormatter = new SimpleDateFormat(NTP_DATE_FORMAT + " 'UTC'",
+                    Locale.US);
+            utcFormatter.setTimeZone(TimeZone.getTimeZone("UTC"));
+        }
+        final Date ntpDate = getDate();
+        return utcFormatter.format(ntpDate);
+    }
+
+    /*
+        Serialization is unnecessary for this class.
+        Reject attempts to do so until such time as the Serializable attribute can be dropped.
+     */
+
+    private void writeObject(final java.io.ObjectOutputStream out) throws IOException
+    {
+        throw new UnsupportedOperationException("Serialization is not supported");
+    }
+
+    private void readObject(final java.io.ObjectInputStream in) throws IOException, ClassNotFoundException
+    {
+        throw new UnsupportedOperationException("Serialization is not supported");
+    }
+
+}
diff --git a/src/main/java/org/apache/commons/net/pop3/POP3Client.java b/src/main/java/org/apache/commons/net/pop3/POP3Client.java
index 112d76a8d..542026b71 100644
--- a/src/main/java/org/apache/commons/net/pop3/POP3Client.java
+++ b/src/main/java/org/apache/commons/net/pop3/POP3Client.java
@@ -24 +23,0 @@ import java.security.NoSuchAlgorithmException;
-import java.util.Arrays;
@@ -222 +221,3 @@ public class POP3Client extends POP3
-        Arrays.setAll(messages, i -> parseStatus(en.next()));
+        for (int line = 0; line < messages.length; line++) {
+            messages[line] = parseStatus(en.next());
+        }
@@ -292 +293,3 @@ public class POP3Client extends POP3
-        Arrays.setAll(messages, i -> parseUID(en.next()));
+        for (int line = 0; line < messages.length; line++) {
+            messages[line] = parseUID(en.next());
+        }
diff --git a/src/main/java/org/apache/commons/net/smtp/AuthenticatingSMTPClient.java b/src/main/java/org/apache/commons/net/smtp/AuthenticatingSMTPClient.java
index 7c6409b8c..6204ccd59 100644
--- a/src/main/java/org/apache/commons/net/smtp/AuthenticatingSMTPClient.java
+++ b/src/main/java/org/apache/commons/net/smtp/AuthenticatingSMTPClient.java
@@ -25 +24,0 @@ import java.security.spec.InvalidKeySpecException;
-import java.util.Arrays;
@@ -325 +324,4 @@ public class AuthenticatingSMTPClient extends SMTPSClient
-        Arrays.setAll(res, i -> Integer.parseInt(parts[i]));
+        for (int i = 0; i < parts.length; i++)
+        {
+            res[i] = Integer.parseInt (parts[i]);
+        }
diff --git a/src/main/java/org/apache/commons/net/util/SubnetUtils.java b/src/main/java/org/apache/commons/net/util/SubnetUtils.java
index 1a18afd55..359ee7ebd 100644
--- a/src/main/java/org/apache/commons/net/util/SubnetUtils.java
+++ b/src/main/java/org/apache/commons/net/util/SubnetUtils.java
@@ -98 +98 @@ public class SubnetUtils {
-            for (int add = low(), j = 0; add <= high(); ++add, ++j) {
+            for (int add = low(), j=0; add <= high(); ++add, ++j) {
diff --git a/src/test/java/org/apache/commons/net/tftp/TFTPServer.java b/src/test/java/org/apache/commons/net/tftp/TFTPServer.java
index 5e322954c..cddedf422 100644
--- a/src/test/java/org/apache/commons/net/tftp/TFTPServer.java
+++ b/src/test/java/org/apache/commons/net/tftp/TFTPServer.java
@@ -1,947 +1,947 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.net.tftp;
-
-import java.io.BufferedInputStream;
-import java.io.BufferedOutputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.io.PrintStream;
-import java.net.InetAddress;
-import java.net.NetworkInterface;
-import java.net.SocketTimeoutException;
-import java.util.Enumeration;
-import java.util.HashSet;
-
-import org.apache.commons.net.io.FromNetASCIIOutputStream;
-import org.apache.commons.net.io.ToNetASCIIInputStream;
-
-/**
- * A fully multi-threaded tftp server. Can handle multiple clients at the same time. Implements RFC
- * 1350 and wrapping block numbers for large file support.
- *
- * To launch, just create an instance of the class. An IOException will be thrown if the server
- * fails to start for reasons such as port in use, port denied, etc.
- *
- * To stop, use the shutdown method.
- *
- * To check to see if the server is still running (or if it stopped because of an error), call the
- * isRunning() method.
- *
- * By default, events are not logged to stdout/stderr. This can be changed with the
- * setLog and setLogError methods.
- *
- * <p>
- * Example usage is below:
- *
- * <code>
- * public static void main(String[] args) throws Exception
- *  {
- *      if (args.length != 1)
- *      {
- *          System.out
- *                  .println("You must provide 1 argument - the base path for the server to serve from.");
- *          System.exit(1);
- *      }
- *
- *      TFTPServer ts = new TFTPServer(new File(args[0]), new File(args[0]), GET_AND_PUT);
- *      ts.setSocketTimeout(2000);
- *
- *      System.out.println("TFTP Server running.  Press enter to stop.");
- *      new InputStreamReader(System.in).read();
- *
- *      ts.shutdown();
- *      System.out.println("Server shut down.");
- *      System.exit(0);
- *  }
- *
- * </code>
- *
- * @since 2.0
- */
-
-public class TFTPServer implements Runnable
-{
-    public enum ServerMode { GET_ONLY, PUT_ONLY, GET_AND_PUT}
-    /*
-     * An instance of an ongoing transfer.
-     */
-    private class TFTPTransfer implements Runnable
-    {
-        private final TFTPPacket tftpPacket_;
-
-        private boolean shutdownTransfer;
-
-        TFTP transferTftp_;
-
-        public TFTPTransfer(final TFTPPacket tftpPacket)
-        {
-            tftpPacket_ = tftpPacket;
-        }
-
-        /*
-         * Utility method to make sure that paths provided by tftp clients do not get outside of the
-         * serverRoot directory.
-         */
-        private File buildSafeFile(final File serverDirectory, final String fileName, final boolean createSubDirs)
-                throws IOException
-        {
-            File temp = new File(serverDirectory, fileName);
-            temp = temp.getCanonicalFile();
-
-            if (!isSubdirectoryOf(serverDirectory, temp))
-            {
-                throw new IOException("Cannot access files outside of tftp server root.");
-            }
-
-            // ensure directory exists (if requested)
-            if (createSubDirs)
-            {
-                createDirectory(temp.getParentFile());
-            }
-
-            return temp;
-        }
-
-        /*
-         * recursively create subdirectories
-         */
-        private void createDirectory(final File file) throws IOException
-        {
-            final File parent = file.getParentFile();
-            if (parent == null)
-            {
-                throw new IOException("Unexpected error creating requested directory");
-            }
-            if (!parent.exists())
-            {
-                // recurse...
-                createDirectory(parent);
-            }
-
-            if (!parent.isDirectory()) {
-                throw new IOException(
-                        "Invalid directory path - file in the way of requested folder");
-            }
-            if (file.isDirectory())
-            {
-                return;
-            }
-            final boolean result = file.mkdir();
-            if (!result)
-            {
-                throw new IOException("Couldn't create requested directory");
-            }
-        }
-
-        /*
-         * Handle a tftp read request.
-         */
-        private void handleRead(final TFTPReadRequestPacket trrp) throws IOException, TFTPPacketException
-        {
-            InputStream is = null;
-            try
-            {
-                if (mode_ == ServerMode.PUT_ONLY)
-                {
-                    transferTftp_.bufferedSend(new TFTPErrorPacket(trrp.getAddress(), trrp
-                            .getPort(), TFTPErrorPacket.ILLEGAL_OPERATION,
-                            "Read not allowed by server."));
-                    return;
-                }
-
-                try
-                {
-                    is = new BufferedInputStream(new FileInputStream(buildSafeFile(
-                            serverReadDirectory_, trrp.getFilename(), false)));
-                }
-                catch (final FileNotFoundException e)
-                {
-                    transferTftp_.bufferedSend(new TFTPErrorPacket(trrp.getAddress(), trrp
-                            .getPort(), TFTPErrorPacket.FILE_NOT_FOUND, e.getMessage()));
-                    return;
-                }
-                catch (final Exception e)
-                {
-                    transferTftp_.bufferedSend(new TFTPErrorPacket(trrp.getAddress(), trrp
-                            .getPort(), TFTPErrorPacket.UNDEFINED, e.getMessage()));
-                    return;
-                }
-
-                if (trrp.getMode() == TFTP.NETASCII_MODE)
-                {
-                    is = new ToNetASCIIInputStream(is);
-                }
-
-                final byte[] temp = new byte[TFTPDataPacket.MAX_DATA_LENGTH];
-
-                TFTPPacket answer;
-
-                int block = 1;
-                boolean sendNext = true;
-
-                int readLength = TFTPDataPacket.MAX_DATA_LENGTH;
-
-                TFTPDataPacket lastSentData = null;
-
-                // We are reading a file, so when we read less than the
-                // requested bytes, we know that we are at the end of the file.
-                while (readLength == TFTPDataPacket.MAX_DATA_LENGTH && !shutdownTransfer)
-                {
-                    if (sendNext)
-                    {
-                        readLength = is.read(temp);
-                        if (readLength == -1)
-                        {
-                            readLength = 0;
-                        }
-
-                        lastSentData = new TFTPDataPacket(trrp.getAddress(), trrp.getPort(), block,
-                                temp, 0, readLength);
-                        sendData(transferTftp_, lastSentData); // send the data
-                    }
-
-                    answer = null;
-
-                    int timeoutCount = 0;
-
-                    while (!shutdownTransfer
-                            && (answer == null || !answer.getAddress().equals(trrp.getAddress()) || answer
-                                    .getPort() != trrp.getPort()))
-                    {
-                        // listen for an answer.
-                        if (answer != null)
-                        {
-                            // The answer that we got didn't come from the
-                            // expected source, fire back an error, and continue
-                            // listening.
-                            log_.println("TFTP Server ignoring message from unexpected source.");
-                            transferTftp_.bufferedSend(new TFTPErrorPacket(answer.getAddress(),
-                                    answer.getPort(), TFTPErrorPacket.UNKNOWN_TID,
-                                    "Unexpected Host or Port"));
-                        }
-                        try
-                        {
-                            answer = transferTftp_.bufferedReceive();
-                        }
-                        catch (final SocketTimeoutException e)
-                        {
-                            if (timeoutCount >= maxTimeoutRetries_)
-                            {
-                                throw e;
-                            }
-                            // didn't get an ack for this data. need to resend
-                            // it.
-                            timeoutCount++;
-                            transferTftp_.bufferedSend(lastSentData);
-                            continue;
-                        }
-                    }
-
-                    if (answer == null || !(answer instanceof TFTPAckPacket))
-                    {
-                        if (!shutdownTransfer)
-                        {
-                            logError_
-                                    .println("Unexpected response from tftp client during transfer ("
-                                            + answer + ").  Transfer aborted.");
-                        }
-                        break;
-                    }
-                    // once we get here, we know we have an answer packet
-                    // from the correct host.
-                    final TFTPAckPacket ack = (TFTPAckPacket) answer;
-                    if (ack.getBlockNumber() != block)
-                    {
-                        /*
-                         * The origional tftp spec would have called on us to resend the
-                         * previous data here, however, that causes the SAS Syndrome.
-                         * http://www.faqs.org/rfcs/rfc1123.html section 4.2.3.1 The modified
-                         * spec says that we ignore a duplicate ack. If the packet was really
-                         * lost, we will time out on receive, and resend the previous data at
-                         * that point.
-                         */
-                        sendNext = false;
-                    }
-                    else
-                    {
-                        // send the next block
-                        block++;
-                        if (block > 65535)
-                        {
-                            // wrap the block number
-                            block = 0;
-                        }
-                        sendNext = true;
-                    }
-                }
-            }
-            finally
-            {
-                try
-                {
-                    if (is != null)
-                    {
-                        is.close();
-                    }
-                }
-                catch (final IOException e)
-                {
-                    // noop
-                }
-            }
-        }
-
-        /*
-         * handle a tftp write request.
-         */
-        private void handleWrite(final TFTPWriteRequestPacket twrp) throws IOException,
-                TFTPPacketException
-        {
-            OutputStream bos = null;
-            try
-            {
-                if (mode_ == ServerMode.GET_ONLY)
-                {
-                    transferTftp_.bufferedSend(new TFTPErrorPacket(twrp.getAddress(), twrp
-                            .getPort(), TFTPErrorPacket.ILLEGAL_OPERATION,
-                            "Write not allowed by server."));
-                    return;
-                }
-
-                int lastBlock = 0;
-                final String fileName = twrp.getFilename();
-
-                try
-                {
-                    final File temp = buildSafeFile(serverWriteDirectory_, fileName, true);
-                    if (temp.exists())
-                    {
-                        transferTftp_.bufferedSend(new TFTPErrorPacket(twrp.getAddress(), twrp
-                                .getPort(), TFTPErrorPacket.FILE_EXISTS, "File already exists"));
-                        return;
-                    }
-                    bos = new BufferedOutputStream(new FileOutputStream(temp));
-
-                    if (twrp.getMode() == TFTP.NETASCII_MODE)
-                    {
-                        bos = new FromNetASCIIOutputStream(bos);
-                    }
-                }
-                catch (final Exception e)
-                {
-                    transferTftp_.bufferedSend(new TFTPErrorPacket(twrp.getAddress(), twrp
-                            .getPort(), TFTPErrorPacket.UNDEFINED, e.getMessage()));
-                    return;
-                }
-
-                TFTPAckPacket lastSentAck = new TFTPAckPacket(twrp.getAddress(), twrp.getPort(), 0);
-                sendData(transferTftp_, lastSentAck); // send the data
-
-                while (true)
-                {
-                    // get the response - ensure it is from the right place.
-                    TFTPPacket dataPacket = null;
-
-                    int timeoutCount = 0;
-
-                    while (!shutdownTransfer
-                            && (dataPacket == null
-                                    || !dataPacket.getAddress().equals(twrp.getAddress()) || dataPacket
-                                    .getPort() != twrp.getPort()))
-                    {
-                        // listen for an answer.
-                        if (dataPacket != null)
-                        {
-                            // The data that we got didn't come from the
-                            // expected source, fire back an error, and continue
-                            // listening.
-                            log_.println("TFTP Server ignoring message from unexpected source.");
-                            transferTftp_.bufferedSend(new TFTPErrorPacket(dataPacket.getAddress(),
-                                    dataPacket.getPort(), TFTPErrorPacket.UNKNOWN_TID,
-                                    "Unexpected Host or Port"));
-                        }
-
-                        try
-                        {
-                            dataPacket = transferTftp_.bufferedReceive();
-                        }
-                        catch (final SocketTimeoutException e)
-                        {
-                            if (timeoutCount >= maxTimeoutRetries_)
-                            {
-                                throw e;
-                            }
-                            // It didn't get our ack. Resend it.
-                            transferTftp_.bufferedSend(lastSentAck);
-                            timeoutCount++;
-                            continue;
-                        }
-                    }
-
-                    if (dataPacket instanceof TFTPWriteRequestPacket)
-                    {
-                        // it must have missed our initial ack. Send another.
-                        lastSentAck = new TFTPAckPacket(twrp.getAddress(), twrp.getPort(), 0);
-                        transferTftp_.bufferedSend(lastSentAck);
-                    }
-                    else if (dataPacket == null || !(dataPacket instanceof TFTPDataPacket))
-                    {
-                        if (!shutdownTransfer)
-                        {
-                            logError_
-                                    .println("Unexpected response from tftp client during transfer ("
-                                            + dataPacket + ").  Transfer aborted.");
-                        }
-                        break;
-                    }
-                    else
-                    {
-                        final int block = ((TFTPDataPacket) dataPacket).getBlockNumber();
-                        final byte[] data = ((TFTPDataPacket) dataPacket).getData();
-                        final int dataLength = ((TFTPDataPacket) dataPacket).getDataLength();
-                        final int dataOffset = ((TFTPDataPacket) dataPacket).getDataOffset();
-
-                        if (block > lastBlock || lastBlock == 65535 && block == 0)
-                        {
-                            // it might resend a data block if it missed our ack
-                            // - don't rewrite the block.
-                            bos.write(data, dataOffset, dataLength);
-                            lastBlock = block;
-                        }
-
-                        lastSentAck = new TFTPAckPacket(twrp.getAddress(), twrp.getPort(), block);
-                        sendData(transferTftp_, lastSentAck); // send the data
-                        if (dataLength < TFTPDataPacket.MAX_DATA_LENGTH)
-                        {
-                            // end of stream signal - The tranfer is complete.
-                            bos.close();
-
-                            // But my ack may be lost - so listen to see if I
-                            // need to resend the ack.
-                            for (int i = 0; i < maxTimeoutRetries_; i++)
-                            {
-                                try
-                                {
-                                    dataPacket = transferTftp_.bufferedReceive();
-                                }
-                                catch (final SocketTimeoutException e)
-                                {
-                                    // this is the expected route - the client
-                                    // shouldn't be sending any more packets.
-                                    break;
-                                }
-
-                                if (dataPacket != null
-                                        && (!dataPacket.getAddress().equals(twrp.getAddress()) || dataPacket
-                                                .getPort() != twrp.getPort()))
-                                {
-                                    // make sure it was from the right client...
-                                    transferTftp_
-                                            .bufferedSend(new TFTPErrorPacket(dataPacket
-                                                    .getAddress(), dataPacket.getPort(),
-                                                    TFTPErrorPacket.UNKNOWN_TID,
-                                                    "Unexpected Host or Port"));
-                                }
-                                else
-                                {
-                                    // This means they sent us the last
-                                    // datapacket again, must have missed our
-                                    // ack. resend it.
-                                    transferTftp_.bufferedSend(lastSentAck);
-                                }
-                            }
-
-                            // all done.
-                            break;
-                        }
-                    }
-                }
-            }
-            finally
-            {
-                if (bos != null)
-                {
-                    bos.close();
-                }
-            }
-        }
-
-        /*
-         * recursively check to see if one directory is a parent of another.
-         */
-        private boolean isSubdirectoryOf(final File parent, final File child)
-        {
-            final File childsParent = child.getParentFile();
-            if (childsParent == null)
-            {
-                return false;
-            }
-            if (childsParent.equals(parent))
-            {
-                return true;
-            }
-            return isSubdirectoryOf(parent, childsParent);
-        }
-
-        @Override
-        public void run()
-        {
-            try
-            {
-                transferTftp_ = newTFTP();
-
-                transferTftp_.beginBufferedOps();
-                transferTftp_.setDefaultTimeout(socketTimeout_);
-
-                transferTftp_.open();
-
-                if (tftpPacket_ instanceof TFTPReadRequestPacket)
-                {
-                    handleRead((TFTPReadRequestPacket) tftpPacket_);
-                }
-                else if (tftpPacket_ instanceof TFTPWriteRequestPacket)
-                {
-                    handleWrite((TFTPWriteRequestPacket) tftpPacket_);
-                }
-                else
-                {
-                    log_.println("Unsupported TFTP request (" + tftpPacket_ + ") - ignored.");
-                }
-            }
-            catch (final Exception e)
-            {
-                if (!shutdownTransfer)
-                {
-                    logError_
-                            .println("Unexpected Error in during TFTP file transfer.  Transfer aborted. "
-                                    + e);
-                }
-            }
-            finally
-            {
-                try
-                {
-                    if (transferTftp_ != null && transferTftp_.isOpen())
-                    {
-                        transferTftp_.endBufferedOps();
-                        transferTftp_.close();
-                    }
-                }
-                catch (final Exception e)
-                {
-                    // noop
-                }
-                synchronized(transfers_)
-                {
-                    transfers_.remove(this);
-                }
-            }
-        }
-
-        public void shutdown()
-        {
-            shutdownTransfer = true;
-            try
-            {
-                transferTftp_.close();
-            }
-            catch (final RuntimeException e)
-            {
-                // noop
-            }
-        }
-    }
-
-    private static final int DEFAULT_TFTP_PORT = 69;
-    /* /dev/null output stream (default) */
-    private static final PrintStream nullStream = new PrintStream(
-            new OutputStream() {
-                @Override
-                public void write(final byte[] b) throws IOException {}
-                @Override
-                public void write(final int b){}
-                }
-            );
-    private final HashSet<TFTPTransfer> transfers_ = new HashSet<>();
-    private volatile boolean shutdownServer;
-    private TFTP serverTftp_;
-    private File serverReadDirectory_;
-    private File serverWriteDirectory_;
-    private final int port_;
-    private final InetAddress laddr_;
-
-    private Exception serverException;
-
-    private final ServerMode mode_;
-    // don't have access to a logger api, so we will log to these streams, which
-    // by default are set to a no-op logger
-    private PrintStream log_;
-
-    private PrintStream logError_;
-    private int maxTimeoutRetries_ = 3;
-    private int socketTimeout_;
-
-
-    private Thread serverThread;
-
-    /**
-     * Start a TFTP Server on the specified port. Gets and Puts occur in the specified directory.
-     *
-     * The server will start in another thread, allowing this constructor to return immediately.
-     *
-     * If a get or a put comes in with a relative path that tries to get outside of the
-     * serverDirectory, then the get or put will be denied.
-     *
-     * GET_ONLY mode only allows gets, PUT_ONLY mode only allows puts, and GET_AND_PUT allows both.
-     * Modes are defined as int constants in this class.
-     *
-     * @param serverReadDirectory directory for GET requests
-     * @param serverWriteDirectory directory for PUT requests
-     * @param port The local port to bind to.
-     * @param localaddr The local address to bind to.
-     * @param mode A value as specified above.
-     * @param log Stream to write log message to. If not provided, uses System.out
-     * @param errorLog Stream to write error messages to. If not provided, uses System.err.
-     * @throws IOException if the server directory is invalid or does not exist.
-     */
-    public TFTPServer(final File serverReadDirectory, final File serverWriteDirectory, final int port,
-        final InetAddress localaddr, final ServerMode mode, final PrintStream log, final PrintStream errorLog)
-        throws IOException
-    {
-        port_ = port;
-        mode_ = mode;
-        laddr_ = localaddr;
-        log_ = log == null ? nullStream: log;
-        logError_ = errorLog == null ? nullStream : errorLog;
-        launch(serverReadDirectory, serverWriteDirectory);
-    }
-
-    /**
-     * Start a TFTP Server on the specified port. Gets and Puts occur in the specified directory.
-     *
-     * The server will start in another thread, allowing this constructor to return immediately.
-     *
-     * If a get or a put comes in with a relative path that tries to get outside of the
-     * serverDirectory, then the get or put will be denied.
-     *
-     * GET_ONLY mode only allows gets, PUT_ONLY mode only allows puts, and GET_AND_PUT allows both.
-     * Modes are defined as int constants in this class.
-     *
-     * @param serverReadDirectory directory for GET requests
-     * @param serverWriteDirectory directory for PUT requests
-     * @param port the port to use
-     * @param localiface The local network interface to bind to.
-     *  The interface's first address wil be used.
-     * @param mode A value as specified above.
-     * @param log Stream to write log message to. If not provided, uses System.out
-     * @param errorLog Stream to write error messages to. If not provided, uses System.err.
-     * @throws IOException if the server directory is invalid or does not exist.
-     */
-    public TFTPServer(final File serverReadDirectory, final File serverWriteDirectory, final int port,
-        final NetworkInterface localiface, final ServerMode mode, final PrintStream log, final PrintStream errorLog)
-        throws IOException
-    {
-        mode_ = mode;
-        port_= port;
-        InetAddress iaddr = null;
-        if (localiface != null)
-        {
-            final Enumeration<InetAddress> ifaddrs = localiface.getInetAddresses();
-            if ((ifaddrs != null) && ifaddrs.hasMoreElements()) {
-                iaddr = ifaddrs.nextElement();
-            }
-        }
-        log_ = log == null ? nullStream: log;
-        logError_ = errorLog == null ? nullStream : errorLog;
-        laddr_ = iaddr;
-        launch(serverReadDirectory, serverWriteDirectory);
-    }
-
-    /**
-     * Start a TFTP Server on the specified port. Gets and Puts occur in the specified directory.
-     *
-     * The server will start in another thread, allowing this constructor to return immediately.
-     *
-     * If a get or a put comes in with a relative path that tries to get outside of the
-     * serverDirectory, then the get or put will be denied.
-     *
-     * GET_ONLY mode only allows gets, PUT_ONLY mode only allows puts, and GET_AND_PUT allows both.
-     * Modes are defined as int constants in this class.
-     *
-     * @param serverReadDirectory directory for GET requests
-     * @param serverWriteDirectory directory for PUT requests
-     * @param port the port to use
-     * @param mode A value as specified above.
-     * @param log Stream to write log message to. If not provided, uses System.out
-     * @param errorLog Stream to write error messages to. If not provided, uses System.err.
-     * @throws IOException if the server directory is invalid or does not exist.
-     */
-    public TFTPServer(final File serverReadDirectory, final File serverWriteDirectory, final int port, final ServerMode mode,
-            final PrintStream log, final PrintStream errorLog) throws IOException
-    {
-        port_ = port;
-        mode_ = mode;
-        log_ = log == null ? nullStream: log;
-        logError_ = errorLog == null ? nullStream : errorLog;
-        laddr_ = null;
-        launch(serverReadDirectory, serverWriteDirectory);
-    }
-
-    /**
-     * Start a TFTP Server on the default port (69). Gets and Puts occur in the specified
-     * directories.
-     *
-     * The server will start in another thread, allowing this constructor to return immediately.
-     *
-     * If a get or a put comes in with a relative path that tries to get outside of the
-     * serverDirectory, then the get or put will be denied.
-     *
-     * GET_ONLY mode only allows gets, PUT_ONLY mode only allows puts, and GET_AND_PUT allows both.
-     * Modes are defined as int constants in this class.
-     *
-     * @param serverReadDirectory directory for GET requests
-     * @param serverWriteDirectory directory for PUT requests
-     * @param mode A value as specified above.
-     * @throws IOException if the server directory is invalid or does not exist.
-     */
-    public TFTPServer(final File serverReadDirectory, final File serverWriteDirectory, final ServerMode mode)
-            throws IOException
-    {
-        this(serverReadDirectory, serverWriteDirectory, DEFAULT_TFTP_PORT, mode, null, null);
-    }
-
-    @Override
-    protected void finalize() throws Throwable
-    {
-        shutdown();
-    }
-
-    /**
-     * Get the current value for maxTimeoutRetries
-     * @return the max allowed number of retries
-     */
-    public int getMaxTimeoutRetries()
-    {
-        return maxTimeoutRetries_;
-    }
-
-    /**
-     * The current socket timeout used during transfers in milliseconds.
-     * @return the timeout value
-     */
-    public int getSocketTimeout()
-    {
-        return socketTimeout_;
-    }
-
-    /**
-     * check if the server thread is still running.
-     *
-     * @return true if running, false if stopped.
-     * @throws Exception throws the exception that stopped the server if the server is stopped from
-     *             an exception.
-     */
-    public boolean isRunning() throws Exception
-    {
-        if (shutdownServer && serverException != null)
-        {
-            throw serverException;
-        }
-        return !shutdownServer;
-    }
-
-    /*
-     * start the server, throw an error if it can't start.
-     */
-    private void launch(final File serverReadDirectory, final File serverWriteDirectory) throws IOException
-    {
-        log_.println("Starting TFTP Server on port " + port_ + ".  Read directory: "
-                + serverReadDirectory + " Write directory: " + serverWriteDirectory
-                + " Server Mode is " + mode_);
-
-        serverReadDirectory_ = serverReadDirectory.getCanonicalFile();
-        if (!serverReadDirectory_.exists() || !serverReadDirectory.isDirectory())
-        {
-            throw new IOException("The server read directory " + serverReadDirectory_
-                    + " does not exist");
-        }
-
-        serverWriteDirectory_ = serverWriteDirectory.getCanonicalFile();
-        if (!serverWriteDirectory_.exists() || !serverWriteDirectory.isDirectory())
-        {
-            throw new IOException("The server write directory " + serverWriteDirectory_
-                    + " does not exist");
-        }
-
-        serverTftp_ = new TFTP();
-
-        // This is the value used in response to each client.
-        socketTimeout_ = serverTftp_.getDefaultTimeout();
-
-        // we want the server thread to listen forever.
-        serverTftp_.setDefaultTimeout(0);
-
-        if (laddr_ != null) {
-            serverTftp_.open(port_, laddr_);
-        } else {
-            serverTftp_.open(port_);
-        }
-
-        serverThread = new Thread(this);
-        serverThread.setDaemon(true);
-        serverThread.start();
-    }
-
-    /*
-     * Allow test code to customise the TFTP instance
-     */
-    TFTP newTFTP() {
-        return new TFTP();
-    }
-
-    @Override
-    public void run()
-    {
-        try
-        {
-            while (!shutdownServer)
-            {
-                final TFTPPacket tftpPacket;
-
-                tftpPacket = serverTftp_.receive();
-
-                final TFTPTransfer tt = new TFTPTransfer(tftpPacket);
-                synchronized(transfers_)
-                {
-                    transfers_.add(tt);
-                }
-
-                final Thread thread = new Thread(tt);
-                thread.setDaemon(true);
-                thread.start();
-            }
-        }
-        catch (final Exception e)
-        {
-            if (!shutdownServer)
-            {
-                serverException = e;
-                logError_.println("Unexpected Error in TFTP Server - Server shut down! + " + e);
-            }
-        }
-        finally
-        {
-            shutdownServer = true; // set this to true, so the launching thread can check to see if it started.
-            if (serverTftp_ != null && serverTftp_.isOpen())
-            {
-                serverTftp_.close();
-            }
-        }
-    }
-
-    /*
-     * Also allow customisation of sending data/ack so can generate errors if needed
-     */
-    void sendData(final TFTP tftp, final TFTPPacket data) throws IOException {
-        tftp.bufferedSend(data);
-    }
-
-    /**
-     * Set the stream object to log debug / informational messages. By default, this is a no-op
-     *
-     * @param log the stream to use for logging
-     */
-    public void setLog(final PrintStream log)
-    {
-        this.log_ = log;
-    }
-
-    /**
-     * Set the stream object to log error messsages. By default, this is a no-op
-     *
-     * @param logError the stream to use for logging errors
-     */
-    public void setLogError(final PrintStream logError)
-    {
-        this.logError_ = logError;
-    }
-
-    /**
-     * Set the max number of retries in response to a timeout. Default 3. Min 0.
-     *
-     * @param retries number of retries, must be &gt; 0
-     */
-    public void setMaxTimeoutRetries(final int retries)
-    {
-        if (retries < 0)
-        {
-            throw new RuntimeException("Invalid Value");
-        }
-        maxTimeoutRetries_ = retries;
-    }
-
-    /**
-     * Set the socket timeout in milliseconds used in transfers. Defaults to the value here:
-     * https://commons.apache.org/net/apidocs/org/apache/commons/net/tftp/TFTP.html#DEFAULT_TIMEOUT
-     * (5000 at the time I write this) Min value of 10.
-     * @param timeout the timeout; must be larger than 10
-     */
-    public void setSocketTimeout(final int timeout)
-    {
-        if (timeout < 10)
-        {
-            throw new RuntimeException("Invalid Value");
-        }
-        socketTimeout_ = timeout;
-    }
-
-    /**
-     * Stop the tftp server (and any currently running transfers) and release all opened network
-     * resources.
-     */
-    public void shutdown()
-    {
-        shutdownServer = true;
-
-        synchronized(transfers_)
-        {
-            transfers_.forEach(TFTPTransfer::shutdown);
-        }
-
-        try
-        {
-            serverTftp_.close();
-        }
-        catch (final RuntimeException e)
-        {
-            // noop
-        }
-
-        try {
-            serverThread.join();
-        } catch (final InterruptedException e) {
-            // we've done the best we could, return
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.net.tftp;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.PrintStream;
+import java.net.InetAddress;
+import java.net.NetworkInterface;
+import java.net.SocketTimeoutException;
+import java.util.Enumeration;
+import java.util.HashSet;
+
+import org.apache.commons.net.io.FromNetASCIIOutputStream;
+import org.apache.commons.net.io.ToNetASCIIInputStream;
+
+/**
+ * A fully multi-threaded tftp server. Can handle multiple clients at the same time. Implements RFC
+ * 1350 and wrapping block numbers for large file support.
+ *
+ * To launch, just create an instance of the class. An IOException will be thrown if the server
+ * fails to start for reasons such as port in use, port denied, etc.
+ *
+ * To stop, use the shutdown method.
+ *
+ * To check to see if the server is still running (or if it stopped because of an error), call the
+ * isRunning() method.
+ *
+ * By default, events are not logged to stdout/stderr. This can be changed with the
+ * setLog and setLogError methods.
+ *
+ * <p>
+ * Example usage is below:
+ *
+ * <code>
+ * public static void main(String[] args) throws Exception
+ *  {
+ *      if (args.length != 1)
+ *      {
+ *          System.out
+ *                  .println("You must provide 1 argument - the base path for the server to serve from.");
+ *          System.exit(1);
+ *      }
+ *
+ *      TFTPServer ts = new TFTPServer(new File(args[0]), new File(args[0]), GET_AND_PUT);
+ *      ts.setSocketTimeout(2000);
+ *
+ *      System.out.println("TFTP Server running.  Press enter to stop.");
+ *      new InputStreamReader(System.in).read();
+ *
+ *      ts.shutdown();
+ *      System.out.println("Server shut down.");
+ *      System.exit(0);
+ *  }
+ *
+ * </code>
+ *
+ * @since 2.0
+ */
+
+public class TFTPServer implements Runnable
+{
+    public enum ServerMode { GET_ONLY, PUT_ONLY, GET_AND_PUT}
+    /*
+     * An instance of an ongoing transfer.
+     */
+    private class TFTPTransfer implements Runnable
+    {
+        private final TFTPPacket tftpPacket_;
+
+        private boolean shutdownTransfer;
+
+        TFTP transferTftp_;
+
+        public TFTPTransfer(final TFTPPacket tftpPacket)
+        {
+            tftpPacket_ = tftpPacket;
+        }
+
+        /*
+         * Utility method to make sure that paths provided by tftp clients do not get outside of the
+         * serverRoot directory.
+         */
+        private File buildSafeFile(final File serverDirectory, final String fileName, final boolean createSubDirs)
+                throws IOException
+        {
+            File temp = new File(serverDirectory, fileName);
+            temp = temp.getCanonicalFile();
+
+            if (!isSubdirectoryOf(serverDirectory, temp))
+            {
+                throw new IOException("Cannot access files outside of tftp server root.");
+            }
+
+            // ensure directory exists (if requested)
+            if (createSubDirs)
+            {
+                createDirectory(temp.getParentFile());
+            }
+
+            return temp;
+        }
+
+        /*
+         * recursively create subdirectories
+         */
+        private void createDirectory(final File file) throws IOException
+        {
+            final File parent = file.getParentFile();
+            if (parent == null)
+            {
+                throw new IOException("Unexpected error creating requested directory");
+            }
+            if (!parent.exists())
+            {
+                // recurse...
+                createDirectory(parent);
+            }
+
+            if (!parent.isDirectory()) {
+                throw new IOException(
+                        "Invalid directory path - file in the way of requested folder");
+            }
+            if (file.isDirectory())
+            {
+                return;
+            }
+            final boolean result = file.mkdir();
+            if (!result)
+            {
+                throw new IOException("Couldn't create requested directory");
+            }
+        }
+
+        /*
+         * Handle a tftp read request.
+         */
+        private void handleRead(final TFTPReadRequestPacket trrp) throws IOException, TFTPPacketException
+        {
+            InputStream is = null;
+            try
+            {
+                if (mode_ == ServerMode.PUT_ONLY)
+                {
+                    transferTftp_.bufferedSend(new TFTPErrorPacket(trrp.getAddress(), trrp
+                            .getPort(), TFTPErrorPacket.ILLEGAL_OPERATION,
+                            "Read not allowed by server."));
+                    return;
+                }
+
+                try
+                {
+                    is = new BufferedInputStream(new FileInputStream(buildSafeFile(
+                            serverReadDirectory_, trrp.getFilename(), false)));
+                }
+                catch (final FileNotFoundException e)
+                {
+                    transferTftp_.bufferedSend(new TFTPErrorPacket(trrp.getAddress(), trrp
+                            .getPort(), TFTPErrorPacket.FILE_NOT_FOUND, e.getMessage()));
+                    return;
+                }
+                catch (final Exception e)
+                {
+                    transferTftp_.bufferedSend(new TFTPErrorPacket(trrp.getAddress(), trrp
+                            .getPort(), TFTPErrorPacket.UNDEFINED, e.getMessage()));
+                    return;
+                }
+
+                if (trrp.getMode() == TFTP.NETASCII_MODE)
+                {
+                    is = new ToNetASCIIInputStream(is);
+                }
+
+                final byte[] temp = new byte[TFTPDataPacket.MAX_DATA_LENGTH];
+
+                TFTPPacket answer;
+
+                int block = 1;
+                boolean sendNext = true;
+
+                int readLength = TFTPDataPacket.MAX_DATA_LENGTH;
+
+                TFTPDataPacket lastSentData = null;
+
+                // We are reading a file, so when we read less than the
+                // requested bytes, we know that we are at the end of the file.
+                while (readLength == TFTPDataPacket.MAX_DATA_LENGTH && !shutdownTransfer)
+                {
+                    if (sendNext)
+                    {
+                        readLength = is.read(temp);
+                        if (readLength == -1)
+                        {
+                            readLength = 0;
+                        }
+
+                        lastSentData = new TFTPDataPacket(trrp.getAddress(), trrp.getPort(), block,
+                                temp, 0, readLength);
+                        sendData(transferTftp_, lastSentData); // send the data
+                    }
+
+                    answer = null;
+
+                    int timeoutCount = 0;
+
+                    while (!shutdownTransfer
+                            && (answer == null || !answer.getAddress().equals(trrp.getAddress()) || answer
+                                    .getPort() != trrp.getPort()))
+                    {
+                        // listen for an answer.
+                        if (answer != null)
+                        {
+                            // The answer that we got didn't come from the
+                            // expected source, fire back an error, and continue
+                            // listening.
+                            log_.println("TFTP Server ignoring message from unexpected source.");
+                            transferTftp_.bufferedSend(new TFTPErrorPacket(answer.getAddress(),
+                                    answer.getPort(), TFTPErrorPacket.UNKNOWN_TID,
+                                    "Unexpected Host or Port"));
+                        }
+                        try
+                        {
+                            answer = transferTftp_.bufferedReceive();
+                        }
+                        catch (final SocketTimeoutException e)
+                        {
+                            if (timeoutCount >= maxTimeoutRetries_)
+                            {
+                                throw e;
+                            }
+                            // didn't get an ack for this data. need to resend
+                            // it.
+                            timeoutCount++;
+                            transferTftp_.bufferedSend(lastSentData);
+                            continue;
+                        }
+                    }
+
+                    if (answer == null || !(answer instanceof TFTPAckPacket))
+                    {
+                        if (!shutdownTransfer)
+                        {
+                            logError_
+                                    .println("Unexpected response from tftp client during transfer ("
+                                            + answer + ").  Transfer aborted.");
+                        }
+                        break;
+                    }
+                    // once we get here, we know we have an answer packet
+                    // from the correct host.
+                    final TFTPAckPacket ack = (TFTPAckPacket) answer;
+                    if (ack.getBlockNumber() != block)
+                    {
+                        /*
+                         * The origional tftp spec would have called on us to resend the
+                         * previous data here, however, that causes the SAS Syndrome.
+                         * http://www.faqs.org/rfcs/rfc1123.html section 4.2.3.1 The modified
+                         * spec says that we ignore a duplicate ack. If the packet was really
+                         * lost, we will time out on receive, and resend the previous data at
+                         * that point.
+                         */
+                        sendNext = false;
+                    }
+                    else
+                    {
+                        // send the next block
+                        block++;
+                        if (block > 65535)
+                        {
+                            // wrap the block number
+                            block = 0;
+                        }
+                        sendNext = true;
+                    }
+                }
+            }
+            finally
+            {
+                try
+                {
+                    if (is != null)
+                    {
+                        is.close();
+                    }
+                }
+                catch (final IOException e)
+                {
+                    // noop
+                }
+            }
+        }
+
+        /*
+         * handle a tftp write request.
+         */
+        private void handleWrite(final TFTPWriteRequestPacket twrp) throws IOException,
+                TFTPPacketException
+        {
+            OutputStream bos = null;
+            try
+            {
+                if (mode_ == ServerMode.GET_ONLY)
+                {
+                    transferTftp_.bufferedSend(new TFTPErrorPacket(twrp.getAddress(), twrp
+                            .getPort(), TFTPErrorPacket.ILLEGAL_OPERATION,
+                            "Write not allowed by server."));
+                    return;
+                }
+
+                int lastBlock = 0;
+                final String fileName = twrp.getFilename();
+
+                try
+                {
+                    final File temp = buildSafeFile(serverWriteDirectory_, fileName, true);
+                    if (temp.exists())
+                    {
+                        transferTftp_.bufferedSend(new TFTPErrorPacket(twrp.getAddress(), twrp
+                                .getPort(), TFTPErrorPacket.FILE_EXISTS, "File already exists"));
+                        return;
+                    }
+                    bos = new BufferedOutputStream(new FileOutputStream(temp));
+
+                    if (twrp.getMode() == TFTP.NETASCII_MODE)
+                    {
+                        bos = new FromNetASCIIOutputStream(bos);
+                    }
+                }
+                catch (final Exception e)
+                {
+                    transferTftp_.bufferedSend(new TFTPErrorPacket(twrp.getAddress(), twrp
+                            .getPort(), TFTPErrorPacket.UNDEFINED, e.getMessage()));
+                    return;
+                }
+
+                TFTPAckPacket lastSentAck = new TFTPAckPacket(twrp.getAddress(), twrp.getPort(), 0);
+                sendData(transferTftp_, lastSentAck); // send the data
+
+                while (true)
+                {
+                    // get the response - ensure it is from the right place.
+                    TFTPPacket dataPacket = null;
+
+                    int timeoutCount = 0;
+
+                    while (!shutdownTransfer
+                            && (dataPacket == null
+                                    || !dataPacket.getAddress().equals(twrp.getAddress()) || dataPacket
+                                    .getPort() != twrp.getPort()))
+                    {
+                        // listen for an answer.
+                        if (dataPacket != null)
+                        {
+                            // The data that we got didn't come from the
+                            // expected source, fire back an error, and continue
+                            // listening.
+                            log_.println("TFTP Server ignoring message from unexpected source.");
+                            transferTftp_.bufferedSend(new TFTPErrorPacket(dataPacket.getAddress(),
+                                    dataPacket.getPort(), TFTPErrorPacket.UNKNOWN_TID,
+                                    "Unexpected Host or Port"));
+                        }
+
+                        try
+                        {
+                            dataPacket = transferTftp_.bufferedReceive();
+                        }
+                        catch (final SocketTimeoutException e)
+                        {
+                            if (timeoutCount >= maxTimeoutRetries_)
+                            {
+                                throw e;
+                            }
+                            // It didn't get our ack. Resend it.
+                            transferTftp_.bufferedSend(lastSentAck);
+                            timeoutCount++;
+                            continue;
+                        }
+                    }
+
+                    if (dataPacket instanceof TFTPWriteRequestPacket)
+                    {
+                        // it must have missed our initial ack. Send another.
+                        lastSentAck = new TFTPAckPacket(twrp.getAddress(), twrp.getPort(), 0);
+                        transferTftp_.bufferedSend(lastSentAck);
+                    }
+                    else if (dataPacket == null || !(dataPacket instanceof TFTPDataPacket))
+                    {
+                        if (!shutdownTransfer)
+                        {
+                            logError_
+                                    .println("Unexpected response from tftp client during transfer ("
+                                            + dataPacket + ").  Transfer aborted.");
+                        }
+                        break;
+                    }
+                    else
+                    {
+                        final int block = ((TFTPDataPacket) dataPacket).getBlockNumber();
+                        final byte[] data = ((TFTPDataPacket) dataPacket).getData();
+                        final int dataLength = ((TFTPDataPacket) dataPacket).getDataLength();
+                        final int dataOffset = ((TFTPDataPacket) dataPacket).getDataOffset();
+
+                        if (block > lastBlock || lastBlock == 65535 && block == 0)
+                        {
+                            // it might resend a data block if it missed our ack
+                            // - don't rewrite the block.
+                            bos.write(data, dataOffset, dataLength);
+                            lastBlock = block;
+                        }
+
+                        lastSentAck = new TFTPAckPacket(twrp.getAddress(), twrp.getPort(), block);
+                        sendData(transferTftp_, lastSentAck); // send the data
+                        if (dataLength < TFTPDataPacket.MAX_DATA_LENGTH)
+                        {
+                            // end of stream signal - The tranfer is complete.
+                            bos.close();
+
+                            // But my ack may be lost - so listen to see if I
+                            // need to resend the ack.
+                            for (int i = 0; i < maxTimeoutRetries_; i++)
+                            {
+                                try
+                                {
+                                    dataPacket = transferTftp_.bufferedReceive();
+                                }
+                                catch (final SocketTimeoutException e)
+                                {
+                                    // this is the expected route - the client
+                                    // shouldn't be sending any more packets.
+                                    break;
+                                }
+
+                                if (dataPacket != null
+                                        && (!dataPacket.getAddress().equals(twrp.getAddress()) || dataPacket
+                                                .getPort() != twrp.getPort()))
+                                {
+                                    // make sure it was from the right client...
+                                    transferTftp_
+                                            .bufferedSend(new TFTPErrorPacket(dataPacket
+                                                    .getAddress(), dataPacket.getPort(),
+                                                    TFTPErrorPacket.UNKNOWN_TID,
+                                                    "Unexpected Host or Port"));
+                                }
+                                else
+                                {
+                                    // This means they sent us the last
+                                    // datapacket again, must have missed our
+                                    // ack. resend it.
+                                    transferTftp_.bufferedSend(lastSentAck);
+                                }
+                            }
+
+                            // all done.
+                            break;
+                        }
+                    }
+                }
+            }
+            finally
+            {
+                if (bos != null)
+                {
+                    bos.close();
+                }
+            }
+        }
+
+        /*
+         * recursively check to see if one directory is a parent of another.
+         */
+        private boolean isSubdirectoryOf(final File parent, final File child)
+        {
+            final File childsParent = child.getParentFile();
+            if (childsParent == null)
+            {
+                return false;
+            }
+            if (childsParent.equals(parent))
+            {
+                return true;
+            }
+            return isSubdirectoryOf(parent, childsParent);
+        }
+
+        @Override
+        public void run()
+        {
+            try
+            {
+                transferTftp_ = newTFTP();
+
+                transferTftp_.beginBufferedOps();
+                transferTftp_.setDefaultTimeout(socketTimeout_);
+
+                transferTftp_.open();
+
+                if (tftpPacket_ instanceof TFTPReadRequestPacket)
+                {
+                    handleRead((TFTPReadRequestPacket) tftpPacket_);
+                }
+                else if (tftpPacket_ instanceof TFTPWriteRequestPacket)
+                {
+                    handleWrite((TFTPWriteRequestPacket) tftpPacket_);
+                }
+                else
+                {
+                    log_.println("Unsupported TFTP request (" + tftpPacket_ + ") - ignored.");
+                }
+            }
+            catch (final Exception e)
+            {
+                if (!shutdownTransfer)
+                {
+                    logError_
+                            .println("Unexpected Error in during TFTP file transfer.  Transfer aborted. "
+                                    + e);
+                }
+            }
+            finally
+            {
+                try
+                {
+                    if (transferTftp_ != null && transferTftp_.isOpen())
+                    {
+                        transferTftp_.endBufferedOps();
+                        transferTftp_.close();
+                    }
+                }
+                catch (final Exception e)
+                {
+                    // noop
+                }
+                synchronized(transfers_)
+                {
+                    transfers_.remove(this);
+                }
+            }
+        }
+
+        public void shutdown()
+        {
+            shutdownTransfer = true;
+            try
+            {
+                transferTftp_.close();
+            }
+            catch (final RuntimeException e)
+            {
+                // noop
+            }
+        }
+    }
+
+    private static final int DEFAULT_TFTP_PORT = 69;
+    /* /dev/null output stream (default) */
+    private static final PrintStream nullStream = new PrintStream(
+            new OutputStream() {
+                @Override
+                public void write(final byte[] b) throws IOException {}
+                @Override
+                public void write(final int b){}
+                }
+            );
+    private final HashSet<TFTPTransfer> transfers_ = new HashSet<>();
+    private volatile boolean shutdownServer;
+    private TFTP serverTftp_;
+    private File serverReadDirectory_;
+    private File serverWriteDirectory_;
+    private final int port_;
+    private final InetAddress laddr_;
+
+    private Exception serverException;
+
+    private final ServerMode mode_;
+    // don't have access to a logger api, so we will log to these streams, which
+    // by default are set to a no-op logger
+    private PrintStream log_;
+
+    private PrintStream logError_;
+    private int maxTimeoutRetries_ = 3;
+    private int socketTimeout_;
+
+
+    private Thread serverThread;
+
+    /**
+     * Start a TFTP Server on the specified port. Gets and Puts occur in the specified directory.
+     *
+     * The server will start in another thread, allowing this constructor to return immediately.
+     *
+     * If a get or a put comes in with a relative path that tries to get outside of the
+     * serverDirectory, then the get or put will be denied.
+     *
+     * GET_ONLY mode only allows gets, PUT_ONLY mode only allows puts, and GET_AND_PUT allows both.
+     * Modes are defined as int constants in this class.
+     *
+     * @param serverReadDirectory directory for GET requests
+     * @param serverWriteDirectory directory for PUT requests
+     * @param port The local port to bind to.
+     * @param localaddr The local address to bind to.
+     * @param mode A value as specified above.
+     * @param log Stream to write log message to. If not provided, uses System.out
+     * @param errorLog Stream to write error messages to. If not provided, uses System.err.
+     * @throws IOException if the server directory is invalid or does not exist.
+     */
+    public TFTPServer(final File serverReadDirectory, final File serverWriteDirectory, final int port,
+        final InetAddress localaddr, final ServerMode mode, final PrintStream log, final PrintStream errorLog)
+        throws IOException
+    {
+        port_ = port;
+        mode_ = mode;
+        laddr_ = localaddr;
+        log_ = log == null ? nullStream: log;
+        logError_ = errorLog == null ? nullStream : errorLog;
+        launch(serverReadDirectory, serverWriteDirectory);
+    }
+
+    /**
+     * Start a TFTP Server on the specified port. Gets and Puts occur in the specified directory.
+     *
+     * The server will start in another thread, allowing this constructor to return immediately.
+     *
+     * If a get or a put comes in with a relative path that tries to get outside of the
+     * serverDirectory, then the get or put will be denied.
+     *
+     * GET_ONLY mode only allows gets, PUT_ONLY mode only allows puts, and GET_AND_PUT allows both.
+     * Modes are defined as int constants in this class.
+     *
+     * @param serverReadDirectory directory for GET requests
+     * @param serverWriteDirectory directory for PUT requests
+     * @param port the port to use
+     * @param localiface The local network interface to bind to.
+     *  The interface's first address wil be used.
+     * @param mode A value as specified above.
+     * @param log Stream to write log message to. If not provided, uses System.out
+     * @param errorLog Stream to write error messages to. If not provided, uses System.err.
+     * @throws IOException if the server directory is invalid or does not exist.
+     */
+    public TFTPServer(final File serverReadDirectory, final File serverWriteDirectory, final int port,
+        final NetworkInterface localiface, final ServerMode mode, final PrintStream log, final PrintStream errorLog)
+        throws IOException
+    {
+        mode_ = mode;
+        port_= port;
+        InetAddress iaddr = null;
+        if (localiface != null)
+        {
+            final Enumeration<InetAddress> ifaddrs = localiface.getInetAddresses();
+            if ((ifaddrs != null) && ifaddrs.hasMoreElements()) {
+                iaddr = ifaddrs.nextElement();
+            }
+        }
+        log_ = log == null ? nullStream: log;
+        logError_ = errorLog == null ? nullStream : errorLog;
+        laddr_ = iaddr;
+        launch(serverReadDirectory, serverWriteDirectory);
+    }
+
+    /**
+     * Start a TFTP Server on the specified port. Gets and Puts occur in the specified directory.
+     *
+     * The server will start in another thread, allowing this constructor to return immediately.
+     *
+     * If a get or a put comes in with a relative path that tries to get outside of the
+     * serverDirectory, then the get or put will be denied.
+     *
+     * GET_ONLY mode only allows gets, PUT_ONLY mode only allows puts, and GET_AND_PUT allows both.
+     * Modes are defined as int constants in this class.
+     *
+     * @param serverReadDirectory directory for GET requests
+     * @param serverWriteDirectory directory for PUT requests
+     * @param port the port to use
+     * @param mode A value as specified above.
+     * @param log Stream to write log message to. If not provided, uses System.out
+     * @param errorLog Stream to write error messages to. If not provided, uses System.err.
+     * @throws IOException if the server directory is invalid or does not exist.
+     */
+    public TFTPServer(final File serverReadDirectory, final File serverWriteDirectory, final int port, final ServerMode mode,
+            final PrintStream log, final PrintStream errorLog) throws IOException
+    {
+        port_ = port;
+        mode_ = mode;
+        log_ = log == null ? nullStream: log;
+        logError_ = errorLog == null ? nullStream : errorLog;
+        laddr_ = null;
+        launch(serverReadDirectory, serverWriteDirectory);
+    }
+
+    /**
+     * Start a TFTP Server on the default port (69). Gets and Puts occur in the specified
+     * directories.
+     *
+     * The server will start in another thread, allowing this constructor to return immediately.
+     *
+     * If a get or a put comes in with a relative path that tries to get outside of the
+     * serverDirectory, then the get or put will be denied.
+     *
+     * GET_ONLY mode only allows gets, PUT_ONLY mode only allows puts, and GET_AND_PUT allows both.
+     * Modes are defined as int constants in this class.
+     *
+     * @param serverReadDirectory directory for GET requests
+     * @param serverWriteDirectory directory for PUT requests
+     * @param mode A value as specified above.
+     * @throws IOException if the server directory is invalid or does not exist.
+     */
+    public TFTPServer(final File serverReadDirectory, final File serverWriteDirectory, final ServerMode mode)
+            throws IOException
+    {
+        this(serverReadDirectory, serverWriteDirectory, DEFAULT_TFTP_PORT, mode, null, null);
+    }
+
+    @Override
+    protected void finalize() throws Throwable
+    {
+        shutdown();
+    }
+
+    /**
+     * Get the current value for maxTimeoutRetries
+     * @return the max allowed number of retries
+     */
+    public int getMaxTimeoutRetries()
+    {
+        return maxTimeoutRetries_;
+    }
+
+    /**
+     * The current socket timeout used during transfers in milliseconds.
+     * @return the timeout value
+     */
+    public int getSocketTimeout()
+    {
+        return socketTimeout_;
+    }
+
+    /**
+     * check if the server thread is still running.
+     *
+     * @return true if running, false if stopped.
+     * @throws Exception throws the exception that stopped the server if the server is stopped from
+     *             an exception.
+     */
+    public boolean isRunning() throws Exception
+    {
+        if (shutdownServer && serverException != null)
+        {
+            throw serverException;
+        }
+        return !shutdownServer;
+    }
+
+    /*
+     * start the server, throw an error if it can't start.
+     */
+    private void launch(final File serverReadDirectory, final File serverWriteDirectory) throws IOException
+    {
+        log_.println("Starting TFTP Server on port " + port_ + ".  Read directory: "
+                + serverReadDirectory + " Write directory: " + serverWriteDirectory
+                + " Server Mode is " + mode_);
+
+        serverReadDirectory_ = serverReadDirectory.getCanonicalFile();
+        if (!serverReadDirectory_.exists() || !serverReadDirectory.isDirectory())
+        {
+            throw new IOException("The server read directory " + serverReadDirectory_
+                    + " does not exist");
+        }
+
+        serverWriteDirectory_ = serverWriteDirectory.getCanonicalFile();
+        if (!serverWriteDirectory_.exists() || !serverWriteDirectory.isDirectory())
+        {
+            throw new IOException("The server write directory " + serverWriteDirectory_
+                    + " does not exist");
+        }
+
+        serverTftp_ = new TFTP();
+
+        // This is the value used in response to each client.
+        socketTimeout_ = serverTftp_.getDefaultTimeout();
+
+        // we want the server thread to listen forever.
+        serverTftp_.setDefaultTimeout(0);
+
+        if (laddr_ != null) {
+            serverTftp_.open(port_, laddr_);
+        } else {
+            serverTftp_.open(port_);
+        }
+
+        serverThread = new Thread(this);
+        serverThread.setDaemon(true);
+        serverThread.start();
+    }
+
+    /*
+     * Allow test code to customise the TFTP instance
+     */
+    TFTP newTFTP() {
+        return new TFTP();
+    }
+
+    @Override
+    public void run()
+    {
+        try
+        {
+            while (!shutdownServer)
+            {
+                final TFTPPacket tftpPacket;
+
+                tftpPacket = serverTftp_.receive();
+
+                final TFTPTransfer tt = new TFTPTransfer(tftpPacket);
+                synchronized(transfers_)
+                {
+                    transfers_.add(tt);
+                }
+
+                final Thread thread = new Thread(tt);
+                thread.setDaemon(true);
+                thread.start();
+            }
+        }
+        catch (final Exception e)
+        {
+            if (!shutdownServer)
+            {
+                serverException = e;
+                logError_.println("Unexpected Error in TFTP Server - Server shut down! + " + e);
+            }
+        }
+        finally
+        {
+            shutdownServer = true; // set this to true, so the launching thread can check to see if it started.
+            if (serverTftp_ != null && serverTftp_.isOpen())
+            {
+                serverTftp_.close();
+            }
+        }
+    }
+
+    /*
+     * Also allow customisation of sending data/ack so can generate errors if needed
+     */
+    void sendData(final TFTP tftp, final TFTPPacket data) throws IOException {
+        tftp.bufferedSend(data);
+    }
+
+    /**
+     * Set the stream object to log debug / informational messages. By default, this is a no-op
+     *
+     * @param log the stream to use for logging
+     */
+    public void setLog(final PrintStream log)
+    {
+        this.log_ = log;
+    }
+
+    /**
+     * Set the stream object to log error messsages. By default, this is a no-op
+     *
+     * @param logError the stream to use for logging errors
+     */
+    public void setLogError(final PrintStream logError)
+    {
+        this.logError_ = logError;
+    }
+
+    /**
+     * Set the max number of retries in response to a timeout. Default 3. Min 0.
+     *
+     * @param retries number of retries, must be &gt; 0
+     */
+    public void setMaxTimeoutRetries(final int retries)
+    {
+        if (retries < 0)
+        {
+            throw new RuntimeException("Invalid Value");
+        }
+        maxTimeoutRetries_ = retries;
+    }
+
+    /**
+     * Set the socket timeout in milliseconds used in transfers. Defaults to the value here:
+     * https://commons.apache.org/net/apidocs/org/apache/commons/net/tftp/TFTP.html#DEFAULT_TIMEOUT
+     * (5000 at the time I write this) Min value of 10.
+     * @param timeout the timeout; must be larger than 10
+     */
+    public void setSocketTimeout(final int timeout)
+    {
+        if (timeout < 10)
+        {
+            throw new RuntimeException("Invalid Value");
+        }
+        socketTimeout_ = timeout;
+    }
+
+    /**
+     * Stop the tftp server (and any currently running transfers) and release all opened network
+     * resources.
+     */
+    public void shutdown()
+    {
+        shutdownServer = true;
+
+        synchronized(transfers_)
+        {
+            transfers_.forEach(TFTPTransfer::shutdown);
+        }
+
+        try
+        {
+            serverTftp_.close();
+        }
+        catch (final RuntimeException e)
+        {
+            // noop
+        }
+
+        try {
+            serverThread.join();
+        } catch (final InterruptedException e) {
+            // we've done the best we could, return
+        }
+    }
+}
diff --git a/src/test/java/org/apache/commons/net/time/TimeTestSimpleServer.java b/src/test/java/org/apache/commons/net/time/TimeTestSimpleServer.java
index f9a197acc..59777fb87 100644
--- a/src/test/java/org/apache/commons/net/time/TimeTestSimpleServer.java
+++ b/src/test/java/org/apache/commons/net/time/TimeTestSimpleServer.java
@@ -1,160 +1,160 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.net.time;
-
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.net.ServerSocket;
-import java.net.Socket;
-
-/**
- * The TimetSimpleServer class is a simple TCP implementation of a server
- * for the Time Protocol described in RFC 868.
- * <p>
- * Listens for TCP socket connections on the time protocol port and writes
- * the local time to socket outputStream as 32-bit integer of seconds
- * since midnight on 1 January 1900 GMT.
- * See <A HREF="ftp://ftp.rfc-editor.org/in-notes/rfc868.txt"> the spec </A> for
- * details.
- * <p>
- * Note this is for <B>debugging purposes only</B> and not meant to be run as a realiable time service.
- *
- */
-public class TimeTestSimpleServer implements Runnable
-{
-
-    /**
-     * baseline time 1900-01-01T00:00:00 UTC
-     */
-    public static final long SECONDS_1900_TO_1970 = 2208988800L;
-
-    /** The default time port.  It is set to 37 according to RFC 868. */
-    public static final int DEFAULT_PORT = 37;
-
-    public static void main(final String[] args)
-    {
-        final TimeTestSimpleServer server = new TimeTestSimpleServer();
-        try
-        {
-            server.start();
-        } catch (final IOException e)
-        {
-            // ignored
-        }
-    }
-    private ServerSocket server;
-    private final int port;
-
-    private boolean running;
-
-    public TimeTestSimpleServer()
-    {
-        port = DEFAULT_PORT;
-    }
-
-    public TimeTestSimpleServer(final int port)
-    {
-        this.port = port;
-    }
-
-    public void connect() throws IOException
-    {
-        if (server == null)
-        {
-            server = new ServerSocket(port);
-        }
-    }
-
-    public int getPort()
-    {
-        return server == null ? port : server.getLocalPort();
-    }
-
-    public boolean isRunning()
-    {
-        return running;
-    }
-
-    @Override
-    public void run()
-    {
-        Socket socket = null;
-        while (running)
-        {
-            try
-            {
-                socket = server.accept();
-                final DataOutputStream os = new DataOutputStream(socket.getOutputStream());
-                // add 500 ms to round off to nearest second
-                final int time = (int) ((System.currentTimeMillis() + 500) / 1000 + SECONDS_1900_TO_1970);
-                os.writeInt(time);
-                os.flush();
-            } catch (final IOException e)
-            {
-                // ignored
-            } finally
-            {
-                if (socket != null) {
-                    try
-                    {
-                        socket.close();  // force closing of the socket
-                    } catch (final IOException e)
-                    {
-                        System.err.println("close socket error: " + e);
-                    }
-                }
-            }
-        }
-    }
-
-    /*
-     * Start time service and provide time to client connections.
-     */
-    public void start() throws IOException
-    {
-        if (server == null)
-    {
-            connect();
-    }
-    if (!running)
-    {
-        running = true;
-        new Thread(this).start();
-    }
-    }
-
-    /*
-     * Close server socket.
-     */
-    public void stop()
-    {
-        running = false;
-        if (server != null)
-        {
-            try
-            {
-                server.close();  // force closing of the socket
-            } catch (final IOException e)
-            {
-                System.err.println("close socket error: " + e);
-            }
-            server = null;
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.net.time;
+
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.net.ServerSocket;
+import java.net.Socket;
+
+/**
+ * The TimetSimpleServer class is a simple TCP implementation of a server
+ * for the Time Protocol described in RFC 868.
+ * <p>
+ * Listens for TCP socket connections on the time protocol port and writes
+ * the local time to socket outputStream as 32-bit integer of seconds
+ * since midnight on 1 January 1900 GMT.
+ * See <A HREF="ftp://ftp.rfc-editor.org/in-notes/rfc868.txt"> the spec </A> for
+ * details.
+ * <p>
+ * Note this is for <B>debugging purposes only</B> and not meant to be run as a realiable time service.
+ *
+ */
+public class TimeTestSimpleServer implements Runnable
+{
+
+    /**
+     * baseline time 1900-01-01T00:00:00 UTC
+     */
+    public static final long SECONDS_1900_TO_1970 = 2208988800L;
+
+    /** The default time port.  It is set to 37 according to RFC 868. */
+    public static final int DEFAULT_PORT = 37;
+
+    public static void main(final String[] args)
+    {
+        final TimeTestSimpleServer server = new TimeTestSimpleServer();
+        try
+        {
+            server.start();
+        } catch (final IOException e)
+        {
+            // ignored
+        }
+    }
+    private ServerSocket server;
+    private final int port;
+
+    private boolean running;
+
+    public TimeTestSimpleServer()
+    {
+        port = DEFAULT_PORT;
+    }
+
+    public TimeTestSimpleServer(final int port)
+    {
+        this.port = port;
+    }
+
+    public void connect() throws IOException
+    {
+        if (server == null)
+        {
+            server = new ServerSocket(port);
+        }
+    }
+
+    public int getPort()
+    {
+        return server == null ? port : server.getLocalPort();
+    }
+
+    public boolean isRunning()
+    {
+        return running;
+    }
+
+    @Override
+    public void run()
+    {
+        Socket socket = null;
+        while (running)
+        {
+            try
+            {
+                socket = server.accept();
+                final DataOutputStream os = new DataOutputStream(socket.getOutputStream());
+                // add 500 ms to round off to nearest second
+                final int time = (int) ((System.currentTimeMillis() + 500) / 1000 + SECONDS_1900_TO_1970);
+                os.writeInt(time);
+                os.flush();
+            } catch (final IOException e)
+            {
+                // ignored
+            } finally
+            {
+                if (socket != null) {
+                    try
+                    {
+                        socket.close();  // force closing of the socket
+                    } catch (final IOException e)
+                    {
+                        System.err.println("close socket error: " + e);
+                    }
+                }
+            }
+        }
+    }
+
+    /*
+     * Start time service and provide time to client connections.
+     */
+    public void start() throws IOException
+    {
+        if (server == null)
+    {
+            connect();
+    }
+    if (!running)
+    {
+        running = true;
+        new Thread(this).start();
+    }
+    }
+
+    /*
+     * Close server socket.
+     */
+    public void stop()
+    {
+        running = false;
+        if (server != null)
+        {
+            try
+            {
+                server.close();  // force closing of the socket
+            } catch (final IOException e)
+            {
+                System.err.println("close socket error: " + e);
+            }
+            server = null;
+        }
+    }
+
+}
