diff --git a/src/main/java/org/apache/commons/net/examples/ntp/NTPClient.java b/src/main/java/org/apache/commons/net/examples/ntp/NTPClient.java
index 8b2ff648a..2c753c43b 100644
--- a/src/main/java/org/apache/commons/net/examples/ntp/NTPClient.java
+++ b/src/main/java/org/apache/commons/net/examples/ntp/NTPClient.java
@@ -1,181 +1,181 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.net.examples.ntp;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.SocketException;
-import java.net.UnknownHostException;
-import java.text.NumberFormat;
-
-import org.apache.commons.net.ntp.NTPUDPClient;
-import org.apache.commons.net.ntp.NtpUtils;
-import org.apache.commons.net.ntp.NtpV3Packet;
-import org.apache.commons.net.ntp.TimeInfo;
-import org.apache.commons.net.ntp.TimeStamp;
-
-/**
- * This is an example program demonstrating how to use the NTPUDPClient
- * class. This program sends a Datagram client request packet to a
- * Network time Protocol (NTP) service port on a specified server,
- * retrieves the time, and prints it to standard output along with
- * the fields from the NTP message header (e.g. stratum level, reference id,
- * poll interval, root delay, mode, ...)
- * See <A HREF="ftp://ftp.rfc-editor.org/in-notes/rfc868.txt"> the spec </A>
- * for details.
- * <p>
- * Usage: NTPClient <hostname-or-address-list>
- * </p>
- * <p>
- * Example: NTPClient clock.psu.edu
- * </p>
- */
-public final class NTPClient
-{
-
-    private static final NumberFormat numberFormat = new java.text.DecimalFormat("0.00");
-
-    public static void main(final String[] args)
-    {
-        if (args.length == 0) {
-            System.err.println("Usage: NTPClient <hostname-or-address-list>");
-            System.exit(1);
-        }
-
-        final NTPUDPClient client = new NTPUDPClient();
-        // We want to timeout if a response takes longer than 10 seconds
-        client.setDefaultTimeout(10000);
-        try {
-            client.open();
-            for (final String arg : args)
-            {
-                System.out.println();
-                try {
-                    final InetAddress hostAddr = InetAddress.getByName(arg);
-                    System.out.println("> " + hostAddr.getHostName() + "/" + hostAddr.getHostAddress());
-                    final TimeInfo info = client.getTime(hostAddr);
-                    processResponse(info);
-                } catch (final IOException ioe) {
-                    ioe.printStackTrace();
-                }
-            }
-        } catch (final SocketException e) {
-            e.printStackTrace();
-        }
-
-        client.close();
-    }
-
-    /**
-     * Process <code>TimeInfo</code> object and print its details.
-     * @param info <code>TimeInfo</code> object.
-     */
-    public static void processResponse(final TimeInfo info)
-    {
-        final NtpV3Packet message = info.getMessage();
-        final int stratum = message.getStratum();
-        final String refType;
-        if (stratum <= 0) {
-            refType = "(Unspecified or Unavailable)";
-        } else if (stratum == 1) {
-            refType = "(Primary Reference; e.g., GPS)"; // GPS, radio clock, etc.
-        } else {
-            refType = "(Secondary Reference; e.g. via NTP or SNTP)";
-        }
-        // stratum should be 0..15...
-        System.out.println(" Stratum: " + stratum + " " + refType);
-        final int version = message.getVersion();
-        final int li = message.getLeapIndicator();
-        System.out.println(" leap=" + li + ", version="
-                + version + ", precision=" + message.getPrecision());
-
-        System.out.println(" mode: " + message.getModeName() + " (" + message.getMode() + ")");
-        final int poll = message.getPoll();
-        // poll value typically btwn MINPOLL (4) and MAXPOLL (14)
-        System.out.println(" poll: " + (poll <= 0 ? 1 : (int) Math.pow(2, poll))
-                + " seconds" + " (2 ** " + poll + ")");
-        final double disp = message.getRootDispersionInMillisDouble();
-        System.out.println(" rootdelay=" + numberFormat.format(message.getRootDelayInMillisDouble())
-                + ", rootdispersion(ms): " + numberFormat.format(disp));
-
-        final int refId = message.getReferenceId();
-        String refAddr = NtpUtils.getHostAddress(refId);
-        String refName = null;
-        if (refId != 0) {
-            if (refAddr.equals("127.127.1.0")) {
-                refName = "LOCAL"; // This is the ref address for the Local Clock
-            } else if (stratum >= 2) {
-                // If reference id has 127.127 prefix then it uses its own reference clock
-                // defined in the form 127.127.clock-type.unit-num (e.g. 127.127.8.0 mode 5
-                // for GENERIC DCF77 AM; see refclock.htm from the NTP software distribution.
-                if (!refAddr.startsWith("127.127")) {
-                    try {
-                        final InetAddress addr = InetAddress.getByName(refAddr);
-                        final String name = addr.getHostName();
-                        if (name != null && !name.equals(refAddr)) {
-                            refName = name;
-                        }
-                    } catch (final UnknownHostException e) {
-                        // some stratum-2 servers sync to ref clock device but fudge stratum level higher... (e.g. 2)
-                        // ref not valid host maybe it's a reference clock name?
-                        // otherwise just show the ref IP address.
-                        refName = NtpUtils.getReferenceClock(message);
-                    }
-                }
-            } else if (version >= 3 && (stratum == 0 || stratum == 1)) {
-                refName = NtpUtils.getReferenceClock(message);
-                // refname usually have at least 3 characters (e.g. GPS, WWV, LCL, etc.)
-            }
-            // otherwise give up on naming the beast...
-        }
-        if (refName != null && refName.length() > 1) {
-            refAddr += " (" + refName + ")";
-        }
-        System.out.println(" Reference Identifier:\t" + refAddr);
-
-        final TimeStamp refNtpTime = message.getReferenceTimeStamp();
-        System.out.println(" Reference Timestamp:\t" + refNtpTime + "  " + refNtpTime.toDateString());
-
-        // Originate Time is time request sent by client (t1)
-        final TimeStamp origNtpTime = message.getOriginateTimeStamp();
-        System.out.println(" Originate Timestamp:\t" + origNtpTime + "  " + origNtpTime.toDateString());
-
-        final long destTimeMillis = info.getReturnTime();
-        // Receive Time is time request received by server (t2)
-        final TimeStamp rcvNtpTime = message.getReceiveTimeStamp();
-        System.out.println(" Receive Timestamp:\t" + rcvNtpTime + "  " + rcvNtpTime.toDateString());
-
-        // Transmit time is time reply sent by server (t3)
-        final TimeStamp xmitNtpTime = message.getTransmitTimeStamp();
-        System.out.println(" Transmit Timestamp:\t" + xmitNtpTime + "  " + xmitNtpTime.toDateString());
-
-        // Destination time is time reply received by client (t4)
-        final TimeStamp destNtpTime = TimeStamp.getNtpTime(destTimeMillis);
-        System.out.println(" Destination Timestamp:\t" + destNtpTime + "  " + destNtpTime.toDateString());
-
-        info.computeDetails(); // compute offset/delay if not already done
-        final Long offsetMillis = info.getOffset();
-        final Long delayMillis = info.getDelay();
-        final String delay = delayMillis == null ? "N/A" : delayMillis.toString();
-        final String offset = offsetMillis == null ? "N/A" : offsetMillis.toString();
-
-        System.out.println(" Roundtrip delay(ms)=" + delay
-                + ", clock offset(ms)=" + offset); // offset in ms
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.net.examples.ntp;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.SocketException;
+import java.net.UnknownHostException;
+import java.text.NumberFormat;
+
+import org.apache.commons.net.ntp.NTPUDPClient;
+import org.apache.commons.net.ntp.NtpUtils;
+import org.apache.commons.net.ntp.NtpV3Packet;
+import org.apache.commons.net.ntp.TimeInfo;
+import org.apache.commons.net.ntp.TimeStamp;
+
+/**
+ * This is an example program demonstrating how to use the NTPUDPClient
+ * class. This program sends a Datagram client request packet to a
+ * Network time Protocol (NTP) service port on a specified server,
+ * retrieves the time, and prints it to standard output along with
+ * the fields from the NTP message header (e.g. stratum level, reference id,
+ * poll interval, root delay, mode, ...)
+ * See <A HREF="ftp://ftp.rfc-editor.org/in-notes/rfc868.txt"> the spec </A>
+ * for details.
+ * <p>
+ * Usage: NTPClient <hostname-or-address-list>
+ * </p>
+ * <p>
+ * Example: NTPClient clock.psu.edu
+ * </p>
+ */
+public final class NTPClient
+{
+
+    private static final NumberFormat numberFormat = new java.text.DecimalFormat("0.00");
+
+    public static void main(final String[] args)
+    {
+        if (args.length == 0) {
+            System.err.println("Usage: NTPClient <hostname-or-address-list>");
+            System.exit(1);
+        }
+
+        final NTPUDPClient client = new NTPUDPClient();
+        // We want to timeout if a response takes longer than 10 seconds
+        client.setDefaultTimeout(10000);
+        try {
+            client.open();
+            for (final String arg : args)
+            {
+                System.out.println();
+                try {
+                    final InetAddress hostAddr = InetAddress.getByName(arg);
+                    System.out.println("> " + hostAddr.getHostName() + "/" + hostAddr.getHostAddress());
+                    final TimeInfo info = client.getTime(hostAddr);
+                    processResponse(info);
+                } catch (final IOException ioe) {
+                    ioe.printStackTrace();
+                }
+            }
+        } catch (final SocketException e) {
+            e.printStackTrace();
+        }
+
+        client.close();
+    }
+
+    /**
+     * Process <code>TimeInfo</code> object and print its details.
+     * @param info <code>TimeInfo</code> object.
+     */
+    public static void processResponse(final TimeInfo info)
+    {
+        final NtpV3Packet message = info.getMessage();
+        final int stratum = message.getStratum();
+        final String refType;
+        if (stratum <= 0) {
+            refType = "(Unspecified or Unavailable)";
+        } else if (stratum == 1) {
+            refType = "(Primary Reference; e.g., GPS)"; // GPS, radio clock, etc.
+        } else {
+            refType = "(Secondary Reference; e.g. via NTP or SNTP)";
+        }
+        // stratum should be 0..15...
+        System.out.println(" Stratum: " + stratum + " " + refType);
+        final int version = message.getVersion();
+        final int li = message.getLeapIndicator();
+        System.out.println(" leap=" + li + ", version="
+                + version + ", precision=" + message.getPrecision());
+
+        System.out.println(" mode: " + message.getModeName() + " (" + message.getMode() + ")");
+        final int poll = message.getPoll();
+        // poll value typically btwn MINPOLL (4) and MAXPOLL (14)
+        System.out.println(" poll: " + (poll <= 0 ? 1 : (int) Math.pow(2, poll))
+                + " seconds" + " (2 ** " + poll + ")");
+        final double disp = message.getRootDispersionInMillisDouble();
+        System.out.println(" rootdelay=" + numberFormat.format(message.getRootDelayInMillisDouble())
+                + ", rootdispersion(ms): " + numberFormat.format(disp));
+
+        final int refId = message.getReferenceId();
+        String refAddr = NtpUtils.getHostAddress(refId);
+        String refName = null;
+        if (refId != 0) {
+            if (refAddr.equals("127.127.1.0")) {
+                refName = "LOCAL"; // This is the ref address for the Local Clock
+            } else if (stratum >= 2) {
+                // If reference id has 127.127 prefix then it uses its own reference clock
+                // defined in the form 127.127.clock-type.unit-num (e.g. 127.127.8.0 mode 5
+                // for GENERIC DCF77 AM; see refclock.htm from the NTP software distribution.
+                if (!refAddr.startsWith("127.127")) {
+                    try {
+                        final InetAddress addr = InetAddress.getByName(refAddr);
+                        final String name = addr.getHostName();
+                        if (name != null && !name.equals(refAddr)) {
+                            refName = name;
+                        }
+                    } catch (final UnknownHostException e) {
+                        // some stratum-2 servers sync to ref clock device but fudge stratum level higher... (e.g. 2)
+                        // ref not valid host maybe it's a reference clock name?
+                        // otherwise just show the ref IP address.
+                        refName = NtpUtils.getReferenceClock(message);
+                    }
+                }
+            } else if (version >= 3 && (stratum == 0 || stratum == 1)) {
+                refName = NtpUtils.getReferenceClock(message);
+                // refname usually have at least 3 characters (e.g. GPS, WWV, LCL, etc.)
+            }
+            // otherwise give up on naming the beast...
+        }
+        if (refName != null && refName.length() > 1) {
+            refAddr += " (" + refName + ")";
+        }
+        System.out.println(" Reference Identifier:\t" + refAddr);
+
+        final TimeStamp refNtpTime = message.getReferenceTimeStamp();
+        System.out.println(" Reference Timestamp:\t" + refNtpTime + "  " + refNtpTime.toDateString());
+
+        // Originate Time is time request sent by client (t1)
+        final TimeStamp origNtpTime = message.getOriginateTimeStamp();
+        System.out.println(" Originate Timestamp:\t" + origNtpTime + "  " + origNtpTime.toDateString());
+
+        final long destTimeMillis = info.getReturnTime();
+        // Receive Time is time request received by server (t2)
+        final TimeStamp rcvNtpTime = message.getReceiveTimeStamp();
+        System.out.println(" Receive Timestamp:\t" + rcvNtpTime + "  " + rcvNtpTime.toDateString());
+
+        // Transmit time is time reply sent by server (t3)
+        final TimeStamp xmitNtpTime = message.getTransmitTimeStamp();
+        System.out.println(" Transmit Timestamp:\t" + xmitNtpTime + "  " + xmitNtpTime.toDateString());
+
+        // Destination time is time reply received by client (t4)
+        final TimeStamp destNtpTime = TimeStamp.getNtpTime(destTimeMillis);
+        System.out.println(" Destination Timestamp:\t" + destNtpTime + "  " + destNtpTime.toDateString());
+
+        info.computeDetails(); // compute offset/delay if not already done
+        final Long offsetMillis = info.getOffset();
+        final Long delayMillis = info.getDelay();
+        final String delay = delayMillis == null ? "N/A" : delayMillis.toString();
+        final String offset = offsetMillis == null ? "N/A" : offsetMillis.toString();
+
+        System.out.println(" Roundtrip delay(ms)=" + delay
+                + ", clock offset(ms)=" + offset); // offset in ms
+    }
+
+}
diff --git a/src/main/java/org/apache/commons/net/examples/ntp/TimeClient.java b/src/main/java/org/apache/commons/net/examples/ntp/TimeClient.java
index cfd49375b..3eb56c375 100644
--- a/src/main/java/org/apache/commons/net/examples/ntp/TimeClient.java
+++ b/src/main/java/org/apache/commons/net/examples/ntp/TimeClient.java
@@ -1,101 +1,101 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.net.examples.ntp;
-
-import java.io.IOException;
-import java.net.InetAddress;
-
-import org.apache.commons.net.time.TimeTCPClient;
-import org.apache.commons.net.time.TimeUDPClient;
-
-/**
- * This is an example program demonstrating how to use the TimeTCPClient
- * and TimeUDPClient classes.
- * This program connects to the default time service port of a
- * specified server, retrieves the time, and prints it to standard output.
- * See <A HREF="ftp://ftp.rfc-editor.org/in-notes/rfc868.txt"> the spec </A>
- * for details.  The default is to use the TCP port.  Use the -udp flag to
- * use the UDP port.
- * <p>
- * Usage: TimeClient [-udp] <hostname>
- * </p>
- */
-public final class TimeClient
-{
-
-    public static void main(final String[] args)
-    {
-
-        if (args.length == 1)
-        {
-            try
-            {
-                timeTCP(args[0]);
-            }
-            catch (final IOException e)
-            {
-                e.printStackTrace();
-                System.exit(1);
-            }
-        }
-        else if (args.length == 2 && args[0].equals("-udp"))
-        {
-            try
-            {
-                timeUDP(args[1]);
-            }
-            catch (final IOException e)
-            {
-                e.printStackTrace();
-                System.exit(1);
-            }
-        }
-        else
-        {
-            System.err.println("Usage: TimeClient [-udp] <hostname>");
-            System.exit(1);
-        }
-
-    }
-
-    public static void timeTCP(final String host) throws IOException
-    {
-        final TimeTCPClient client = new TimeTCPClient();
-    try {
-          // We want to timeout if a response takes longer than 60 seconds
-          client.setDefaultTimeout(60000);
-      client.connect(host);
-          System.out.println(client.getDate());
-    } finally {
-          client.disconnect();
-    }
-    }
-
-    public static void timeUDP(final String host) throws IOException
-    {
-        final TimeUDPClient client = new TimeUDPClient();
-
-        // We want to timeout if a response takes longer than 60 seconds
-        client.setDefaultTimeout(60000);
-        client.open();
-        System.out.println(client.getDate(InetAddress.getByName(host)));
-        client.close();
-    }
-
-}
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.net.examples.ntp;
+
+import java.io.IOException;
+import java.net.InetAddress;
+
+import org.apache.commons.net.time.TimeTCPClient;
+import org.apache.commons.net.time.TimeUDPClient;
+
+/**
+ * This is an example program demonstrating how to use the TimeTCPClient
+ * and TimeUDPClient classes.
+ * This program connects to the default time service port of a
+ * specified server, retrieves the time, and prints it to standard output.
+ * See <A HREF="ftp://ftp.rfc-editor.org/in-notes/rfc868.txt"> the spec </A>
+ * for details.  The default is to use the TCP port.  Use the -udp flag to
+ * use the UDP port.
+ * <p>
+ * Usage: TimeClient [-udp] <hostname>
+ * </p>
+ */
+public final class TimeClient
+{
+
+    public static void main(final String[] args)
+    {
+
+        if (args.length == 1)
+        {
+            try
+            {
+                timeTCP(args[0]);
+            }
+            catch (final IOException e)
+            {
+                e.printStackTrace();
+                System.exit(1);
+            }
+        }
+        else if (args.length == 2 && args[0].equals("-udp"))
+        {
+            try
+            {
+                timeUDP(args[1]);
+            }
+            catch (final IOException e)
+            {
+                e.printStackTrace();
+                System.exit(1);
+            }
+        }
+        else
+        {
+            System.err.println("Usage: TimeClient [-udp] <hostname>");
+            System.exit(1);
+        }
+
+    }
+
+    public static void timeTCP(final String host) throws IOException
+    {
+        final TimeTCPClient client = new TimeTCPClient();
+    try {
+          // We want to timeout if a response takes longer than 60 seconds
+          client.setDefaultTimeout(60000);
+      client.connect(host);
+          System.out.println(client.getDate());
+    } finally {
+          client.disconnect();
+    }
+    }
+
+    public static void timeUDP(final String host) throws IOException
+    {
+        final TimeUDPClient client = new TimeUDPClient();
+
+        // We want to timeout if a response takes longer than 60 seconds
+        client.setDefaultTimeout(60000);
+        client.open();
+        System.out.println(client.getDate(InetAddress.getByName(host)));
+        client.close();
+    }
+
+}
+
diff --git a/src/main/java/org/apache/commons/net/ftp/FTPListParseEngine.java b/src/main/java/org/apache/commons/net/ftp/FTPListParseEngine.java
index 63d504904..a55a45878 100644
--- a/src/main/java/org/apache/commons/net/ftp/FTPListParseEngine.java
+++ b/src/main/java/org/apache/commons/net/ftp/FTPListParseEngine.java
@@ -1,333 +1,333 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.net.ftp;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.ListIterator;
-import java.util.stream.Collectors;
-
-import org.apache.commons.net.util.Charsets;
-
-
-/**
- * This class handles the entire process of parsing a listing of
- * file entries from the server.
- * <p>
- * This object defines a two-part parsing mechanism.
- * <p>
- * The first part is comprised of reading the raw input into an internal
- * list of strings.  Every item in this list corresponds to an actual
- * file.  All extraneous matter emitted by the server will have been
- * removed by the end of this phase.  This is accomplished in conjunction
- * with the FTPFileEntryParser associated with this engine, by calling
- * its methods <code>readNextEntry()</code> - which handles the issue of
- * what delimits one entry from another, usually but not always a line
- * feed and <code>preParse()</code> - which handles removal of
- * extraneous matter such as the preliminary lines of a listing, removal
- * of duplicates on versioning systems, etc.
- * <p>
- * The second part is composed of the actual parsing, again in conjunction
- * with the particular parser used by this engine.  This is controlled
- * by an iterator over the internal list of strings.  This may be done
- * either in block mode, by calling the <code>getNext()</code> and
- * <code>getPrevious()</code> methods to provide "paged" output of less
- * than the whole list at one time, or by calling the
- * <code>getFiles()</code> method to return the entire list.
- * <p>
- * Examples:
- * <p>
- * Paged access:
- * <pre>
- *    FTPClient f=FTPClient();
- *    f.connect(server);
- *    f.login(username, password);
- *    FTPListParseEngine engine = f.initiateListParsing(directory);
- *
- *    while (engine.hasNext()) {
- *       FTPFile[] files = engine.getNext(25);  // "page size" you want
- *       //do whatever you want with these files, display them, etc.
- *       //expensive FTPFile objects not created until needed.
- *    }
- * </pre>
- * <p>
- * For unpaged access, simply use FTPClient.listFiles().  That method
- * uses this class transparently.
- */
-public class FTPListParseEngine {
-    /**
-     * An empty immutable {@code FTPFile} array.
-     */
-    private static final FTPFile[] EMPTY_FTP_FILE_ARRAY = new FTPFile[0];
-    private List<String> entries = new LinkedList<>();
-
-    private ListIterator<String> internalIterator = entries.listIterator();
-    private final FTPFileEntryParser parser;
-
-    // Should invalid files (parse failures) be allowed?
-    private final boolean saveUnparseableEntries;
-
-    public FTPListParseEngine(final FTPFileEntryParser parser) {
-        this(parser, null);
-    }
-
-    /**
-     * Intended for use by FTPClient only
-     * @since 3.4
-     */
-    FTPListParseEngine(final FTPFileEntryParser parser, final FTPClientConfig configuration) {
-        this.parser = parser;
-        if (configuration != null) {
-            this.saveUnparseableEntries = configuration.getUnparseableEntries();
-        } else {
-            this.saveUnparseableEntries = false;
-        }
-    }
-
-    /**
-     * Returns an array of FTPFile objects containing the whole list of
-     * files returned by the server as read by this object's parser.
-     *
-     * @return an array of FTPFile objects containing the whole list of
-     *         files returned by the server as read by this object's parser.
-     * None of the entries will be null
-     * @throws IOException - not ever thrown, may be removed in a later release
-     */
-    public FTPFile[] getFiles()
-    throws IOException // TODO remove; not actually thrown
-    {
-        return getFiles(FTPFileFilters.NON_NULL);
-    }
-
-    /**
-     * Returns an array of FTPFile objects containing the whole list of
-     * files returned by the server as read by this object's parser.
-     * The files are filtered before being added to the array.
-     *
-     * @param filter FTPFileFilter, must not be <code>null</code>.
-     *
-     * @return an array of FTPFile objects containing the whole list of
-     *         files returned by the server as read by this object's parser.
-     * <p><b>
-     * NOTE:</b> This array may contain null members if any of the
-     * individual file listings failed to parse.  The caller should
-     * check each entry for null before referencing it, or use the
-     * a filter such as {@link FTPFileFilters#NON_NULL} which does not
-     * allow null entries.
-     * @since 2.2
-     * @throws IOException - not ever thrown, may be removed in a later release
-     */
-    public FTPFile[] getFiles(final FTPFileFilter filter)
-    throws IOException // TODO remove; not actually thrown
-    {
-        return getFileList(filter).toArray(EMPTY_FTP_FILE_ARRAY);
-    }
-
-    /**
-     * Returns a list of FTPFile objects containing the whole list of
-     * files returned by the server as read by this object's parser.
-     * The files are filtered before being added to the array.
-     *
-     * @param filter FTPFileFilter, must not be <code>null</code>.
-     *
-     * @return a list of FTPFile objects containing the whole list of
-     *         files returned by the server as read by this object's parser.
-     * <p><b>
-     * NOTE:</b> This array may contain null members if any of the
-     * individual file listings failed to parse.  The caller should
-     * check each entry for null before referencing it, or use the
-     * a filter such as {@link FTPFileFilters#NON_NULL} which does not
-     * allow null entries.
-     * @since 3.9.0
-     */
-    public List<FTPFile> getFileList(final FTPFileFilter filter)
-    {
-        return entries.stream().map(e -> {
-            final FTPFile file = parser.parseFTPEntry(e);
-            return file == null && saveUnparseableEntries ? new FTPFile(e) : file;
-        }).filter(file -> filter.accept(file)).collect(Collectors.toList());
-    }
-
-    /**
-     * Returns an array of at most <code>quantityRequested</code> FTPFile
-     * objects starting at this object's internal iterator's current position.
-     * If fewer than <code>quantityRequested</code> such
-     * elements are available, the returned array will have a length equal
-     * to the number of entries at and after after the current position.
-     * If no such entries are found, this array will have a length of 0.
-     *
-     * After this method is called this object's internal iterator is advanced
-     * by a number of positions equal to the size of the array returned.
-     *
-     * @param quantityRequested
-     * the maximum number of entries we want to get.
-     *
-     * @return an array of at most <code>quantityRequested</code> FTPFile
-     * objects starting at the current position of this iterator within its
-     * list and at least the number of elements which  exist in the list at
-     * and after its current position.
-     * <p><b>
-     * NOTE:</b> This array may contain null members if any of the
-     * individual file listings failed to parse.  The caller should
-     * check each entry for null before referencing it.
-     */
-    public FTPFile[] getNext(final int quantityRequested) {
-        final List<FTPFile> tmpResults = new LinkedList<>();
-        int count = quantityRequested;
-        while (count > 0 && this.internalIterator.hasNext()) {
-            final String entry = this.internalIterator.next();
-            FTPFile temp = this.parser.parseFTPEntry(entry);
-            if (temp == null && saveUnparseableEntries) {
-                temp = new FTPFile(entry);
-            }
-            tmpResults.add(temp);
-            count--;
-        }
-        return tmpResults.toArray(EMPTY_FTP_FILE_ARRAY);
-
-    }
-
-    /**
-     * Returns an array of at most <code>quantityRequested</code> FTPFile
-     * objects starting at this object's internal iterator's current position,
-     * and working back toward the beginning.
-     *
-     * If fewer than <code>quantityRequested</code> such
-     * elements are available, the returned array will have a length equal
-     * to the number of entries at and after after the current position.
-     * If no such entries are found, this array will have a length of 0.
-     *
-     * After this method is called this object's internal iterator is moved
-     * back by a number of positions equal to the size of the array returned.
-     *
-     * @param quantityRequested
-     * the maximum number of entries we want to get.
-     *
-     * @return an array of at most <code>quantityRequested</code> FTPFile
-     * objects starting at the current position of this iterator within its
-     * list and at least the number of elements which  exist in the list at
-     * and after its current position.  This array will be in the same order
-     * as the underlying list (not reversed).
-     * <p><b>
-     * NOTE:</b> This array may contain null members if any of the
-     * individual file listings failed to parse.  The caller should
-     * check each entry for null before referencing it.
-     */
-    public FTPFile[] getPrevious(final int quantityRequested) {
-        final List<FTPFile> tmpResults = new LinkedList<>();
-        int count = quantityRequested;
-        while (count > 0 && this.internalIterator.hasPrevious()) {
-            final String entry = this.internalIterator.previous();
-            FTPFile temp = this.parser.parseFTPEntry(entry);
-            if (temp == null && saveUnparseableEntries) {
-                temp = new FTPFile(entry);
-            }
-            tmpResults.add(0,temp);
-            count--;
-        }
-        return tmpResults.toArray(EMPTY_FTP_FILE_ARRAY);
-    }
-
-    /**
-     * convenience method to allow clients to know whether this object's
-     * internal iterator's current position is at the end of the list.
-     *
-     * @return true if internal iterator is not at end of list, false
-     * otherwise.
-     */
-    public boolean hasNext() {
-        return internalIterator.hasNext();
-    }
-
-    /**
-     * convenience method to allow clients to know whether this object's
-     * internal iterator's current position is at the beginning of the list.
-     *
-     * @return true if internal iterator is not at beginning of list, false
-     * otherwise.
-     */
-    public boolean hasPrevious() {
-        return internalIterator.hasPrevious();
-    }
-
-    /**
-     * Internal method for reading (and closing) the input into the <code>entries</code> list. After this method has
-     * completed, <code>entries</code> will contain a collection of entries (as defined by
-     * <code>FTPFileEntryParser.readNextEntry()</code>), but this may contain various non-entry preliminary lines from
-     * the server output, duplicates, and other data that will not be part of the final listing.
-     *
-     * @param inputStream The socket stream on which the input will be read.
-     * @param charsetName The encoding to use.
-     *
-     * @throws IOException thrown on any failure to read the stream
-     */
-    private void read(final InputStream inputStream, final String charsetName) throws IOException {
-        try (final BufferedReader reader = new BufferedReader(
-            new InputStreamReader(inputStream, Charsets.toCharset(charsetName)))) {
-
-            String line = this.parser.readNextEntry(reader);
-
-            while (line != null) {
-                this.entries.add(line);
-                line = this.parser.readNextEntry(reader);
-            }
-        }
-    }
-
-    /**
-     * Do not use.
-     * @param inputStream the stream from which to read
-     * @throws IOException on error
-     * @deprecated use {@link #readServerList(InputStream, String)} instead
-    */
-    @Deprecated
-    public void readServerList(final InputStream inputStream) throws IOException {
-        readServerList(inputStream, null);
-    }
-
-    /**
-     * Reads (and closes) the initial reading and preparsing of the list returned by the server. After this method has
-     * completed, this object will contain a list of unparsed entries (Strings) each referring to a unique file on the
-     * server.
-     *
-     * @param inputStream input stream provided by the server socket.
-     * @param charsetName the encoding to be used for reading the stream
-     *
-     * @throws IOException thrown on any failure to read from the sever.
-     */
-    public void readServerList(final InputStream inputStream, final String charsetName) throws IOException {
-        this.entries = new LinkedList<>();
-        read(inputStream, charsetName);
-        this.parser.preParse(this.entries);
-        resetIterator();
-    }
-
-    // DEPRECATED METHODS - for API compatibility only - DO NOT USE
-
-    /**
-     * resets this object's internal iterator to the beginning of the list.
-     */
-    public void resetIterator() {
-        this.internalIterator = this.entries.listIterator();
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.net.ftp;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.stream.Collectors;
+
+import org.apache.commons.net.util.Charsets;
+
+
+/**
+ * This class handles the entire process of parsing a listing of
+ * file entries from the server.
+ * <p>
+ * This object defines a two-part parsing mechanism.
+ * <p>
+ * The first part is comprised of reading the raw input into an internal
+ * list of strings.  Every item in this list corresponds to an actual
+ * file.  All extraneous matter emitted by the server will have been
+ * removed by the end of this phase.  This is accomplished in conjunction
+ * with the FTPFileEntryParser associated with this engine, by calling
+ * its methods <code>readNextEntry()</code> - which handles the issue of
+ * what delimits one entry from another, usually but not always a line
+ * feed and <code>preParse()</code> - which handles removal of
+ * extraneous matter such as the preliminary lines of a listing, removal
+ * of duplicates on versioning systems, etc.
+ * <p>
+ * The second part is composed of the actual parsing, again in conjunction
+ * with the particular parser used by this engine.  This is controlled
+ * by an iterator over the internal list of strings.  This may be done
+ * either in block mode, by calling the <code>getNext()</code> and
+ * <code>getPrevious()</code> methods to provide "paged" output of less
+ * than the whole list at one time, or by calling the
+ * <code>getFiles()</code> method to return the entire list.
+ * <p>
+ * Examples:
+ * <p>
+ * Paged access:
+ * <pre>
+ *    FTPClient f=FTPClient();
+ *    f.connect(server);
+ *    f.login(username, password);
+ *    FTPListParseEngine engine = f.initiateListParsing(directory);
+ *
+ *    while (engine.hasNext()) {
+ *       FTPFile[] files = engine.getNext(25);  // "page size" you want
+ *       //do whatever you want with these files, display them, etc.
+ *       //expensive FTPFile objects not created until needed.
+ *    }
+ * </pre>
+ * <p>
+ * For unpaged access, simply use FTPClient.listFiles().  That method
+ * uses this class transparently.
+ */
+public class FTPListParseEngine {
+    /**
+     * An empty immutable {@code FTPFile} array.
+     */
+    private static final FTPFile[] EMPTY_FTP_FILE_ARRAY = new FTPFile[0];
+    private List<String> entries = new LinkedList<>();
+
+    private ListIterator<String> internalIterator = entries.listIterator();
+    private final FTPFileEntryParser parser;
+
+    // Should invalid files (parse failures) be allowed?
+    private final boolean saveUnparseableEntries;
+
+    public FTPListParseEngine(final FTPFileEntryParser parser) {
+        this(parser, null);
+    }
+
+    /**
+     * Intended for use by FTPClient only
+     * @since 3.4
+     */
+    FTPListParseEngine(final FTPFileEntryParser parser, final FTPClientConfig configuration) {
+        this.parser = parser;
+        if (configuration != null) {
+            this.saveUnparseableEntries = configuration.getUnparseableEntries();
+        } else {
+            this.saveUnparseableEntries = false;
+        }
+    }
+
+    /**
+     * Returns an array of FTPFile objects containing the whole list of
+     * files returned by the server as read by this object's parser.
+     *
+     * @return an array of FTPFile objects containing the whole list of
+     *         files returned by the server as read by this object's parser.
+     * None of the entries will be null
+     * @throws IOException - not ever thrown, may be removed in a later release
+     */
+    public FTPFile[] getFiles()
+    throws IOException // TODO remove; not actually thrown
+    {
+        return getFiles(FTPFileFilters.NON_NULL);
+    }
+
+    /**
+     * Returns an array of FTPFile objects containing the whole list of
+     * files returned by the server as read by this object's parser.
+     * The files are filtered before being added to the array.
+     *
+     * @param filter FTPFileFilter, must not be <code>null</code>.
+     *
+     * @return an array of FTPFile objects containing the whole list of
+     *         files returned by the server as read by this object's parser.
+     * <p><b>
+     * NOTE:</b> This array may contain null members if any of the
+     * individual file listings failed to parse.  The caller should
+     * check each entry for null before referencing it, or use the
+     * a filter such as {@link FTPFileFilters#NON_NULL} which does not
+     * allow null entries.
+     * @since 2.2
+     * @throws IOException - not ever thrown, may be removed in a later release
+     */
+    public FTPFile[] getFiles(final FTPFileFilter filter)
+    throws IOException // TODO remove; not actually thrown
+    {
+        return getFileList(filter).toArray(EMPTY_FTP_FILE_ARRAY);
+    }
+
+    /**
+     * Returns a list of FTPFile objects containing the whole list of
+     * files returned by the server as read by this object's parser.
+     * The files are filtered before being added to the array.
+     *
+     * @param filter FTPFileFilter, must not be <code>null</code>.
+     *
+     * @return a list of FTPFile objects containing the whole list of
+     *         files returned by the server as read by this object's parser.
+     * <p><b>
+     * NOTE:</b> This array may contain null members if any of the
+     * individual file listings failed to parse.  The caller should
+     * check each entry for null before referencing it, or use the
+     * a filter such as {@link FTPFileFilters#NON_NULL} which does not
+     * allow null entries.
+     * @since 3.9.0
+     */
+    public List<FTPFile> getFileList(final FTPFileFilter filter)
+    {
+        return entries.stream().map(e -> {
+            final FTPFile file = parser.parseFTPEntry(e);
+            return file == null && saveUnparseableEntries ? new FTPFile(e) : file;
+        }).filter(file -> filter.accept(file)).collect(Collectors.toList());
+    }
+
+    /**
+     * Returns an array of at most <code>quantityRequested</code> FTPFile
+     * objects starting at this object's internal iterator's current position.
+     * If fewer than <code>quantityRequested</code> such
+     * elements are available, the returned array will have a length equal
+     * to the number of entries at and after after the current position.
+     * If no such entries are found, this array will have a length of 0.
+     *
+     * After this method is called this object's internal iterator is advanced
+     * by a number of positions equal to the size of the array returned.
+     *
+     * @param quantityRequested
+     * the maximum number of entries we want to get.
+     *
+     * @return an array of at most <code>quantityRequested</code> FTPFile
+     * objects starting at the current position of this iterator within its
+     * list and at least the number of elements which  exist in the list at
+     * and after its current position.
+     * <p><b>
+     * NOTE:</b> This array may contain null members if any of the
+     * individual file listings failed to parse.  The caller should
+     * check each entry for null before referencing it.
+     */
+    public FTPFile[] getNext(final int quantityRequested) {
+        final List<FTPFile> tmpResults = new LinkedList<>();
+        int count = quantityRequested;
+        while (count > 0 && this.internalIterator.hasNext()) {
+            final String entry = this.internalIterator.next();
+            FTPFile temp = this.parser.parseFTPEntry(entry);
+            if (temp == null && saveUnparseableEntries) {
+                temp = new FTPFile(entry);
+            }
+            tmpResults.add(temp);
+            count--;
+        }
+        return tmpResults.toArray(EMPTY_FTP_FILE_ARRAY);
+
+    }
+
+    /**
+     * Returns an array of at most <code>quantityRequested</code> FTPFile
+     * objects starting at this object's internal iterator's current position,
+     * and working back toward the beginning.
+     *
+     * If fewer than <code>quantityRequested</code> such
+     * elements are available, the returned array will have a length equal
+     * to the number of entries at and after after the current position.
+     * If no such entries are found, this array will have a length of 0.
+     *
+     * After this method is called this object's internal iterator is moved
+     * back by a number of positions equal to the size of the array returned.
+     *
+     * @param quantityRequested
+     * the maximum number of entries we want to get.
+     *
+     * @return an array of at most <code>quantityRequested</code> FTPFile
+     * objects starting at the current position of this iterator within its
+     * list and at least the number of elements which  exist in the list at
+     * and after its current position.  This array will be in the same order
+     * as the underlying list (not reversed).
+     * <p><b>
+     * NOTE:</b> This array may contain null members if any of the
+     * individual file listings failed to parse.  The caller should
+     * check each entry for null before referencing it.
+     */
+    public FTPFile[] getPrevious(final int quantityRequested) {
+        final List<FTPFile> tmpResults = new LinkedList<>();
+        int count = quantityRequested;
+        while (count > 0 && this.internalIterator.hasPrevious()) {
+            final String entry = this.internalIterator.previous();
+            FTPFile temp = this.parser.parseFTPEntry(entry);
+            if (temp == null && saveUnparseableEntries) {
+                temp = new FTPFile(entry);
+            }
+            tmpResults.add(0,temp);
+            count--;
+        }
+        return tmpResults.toArray(EMPTY_FTP_FILE_ARRAY);
+    }
+
+    /**
+     * convenience method to allow clients to know whether this object's
+     * internal iterator's current position is at the end of the list.
+     *
+     * @return true if internal iterator is not at end of list, false
+     * otherwise.
+     */
+    public boolean hasNext() {
+        return internalIterator.hasNext();
+    }
+
+    /**
+     * convenience method to allow clients to know whether this object's
+     * internal iterator's current position is at the beginning of the list.
+     *
+     * @return true if internal iterator is not at beginning of list, false
+     * otherwise.
+     */
+    public boolean hasPrevious() {
+        return internalIterator.hasPrevious();
+    }
+
+    /**
+     * Internal method for reading (and closing) the input into the <code>entries</code> list. After this method has
+     * completed, <code>entries</code> will contain a collection of entries (as defined by
+     * <code>FTPFileEntryParser.readNextEntry()</code>), but this may contain various non-entry preliminary lines from
+     * the server output, duplicates, and other data that will not be part of the final listing.
+     *
+     * @param inputStream The socket stream on which the input will be read.
+     * @param charsetName The encoding to use.
+     *
+     * @throws IOException thrown on any failure to read the stream
+     */
+    private void read(final InputStream inputStream, final String charsetName) throws IOException {
+        try (final BufferedReader reader = new BufferedReader(
+            new InputStreamReader(inputStream, Charsets.toCharset(charsetName)))) {
+
+            String line = this.parser.readNextEntry(reader);
+
+            while (line != null) {
+                this.entries.add(line);
+                line = this.parser.readNextEntry(reader);
+            }
+        }
+    }
+
+    /**
+     * Do not use.
+     * @param inputStream the stream from which to read
+     * @throws IOException on error
+     * @deprecated use {@link #readServerList(InputStream, String)} instead
+    */
+    @Deprecated
+    public void readServerList(final InputStream inputStream) throws IOException {
+        readServerList(inputStream, null);
+    }
+
+    /**
+     * Reads (and closes) the initial reading and preparsing of the list returned by the server. After this method has
+     * completed, this object will contain a list of unparsed entries (Strings) each referring to a unique file on the
+     * server.
+     *
+     * @param inputStream input stream provided by the server socket.
+     * @param charsetName the encoding to be used for reading the stream
+     *
+     * @throws IOException thrown on any failure to read from the sever.
+     */
+    public void readServerList(final InputStream inputStream, final String charsetName) throws IOException {
+        this.entries = new LinkedList<>();
+        read(inputStream, charsetName);
+        this.parser.preParse(this.entries);
+        resetIterator();
+    }
+
+    // DEPRECATED METHODS - for API compatibility only - DO NOT USE
+
+    /**
+     * resets this object's internal iterator to the beginning of the list.
+     */
+    public void resetIterator() {
+        this.internalIterator = this.entries.listIterator();
+    }
+
+}
diff --git a/src/main/java/org/apache/commons/net/ftp/FTPSClient.java b/src/main/java/org/apache/commons/net/ftp/FTPSClient.java
index df4de5cfa..3d864643f 100644
--- a/src/main/java/org/apache/commons/net/ftp/FTPSClient.java
+++ b/src/main/java/org/apache/commons/net/ftp/FTPSClient.java
@@ -1,914 +1,914 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.net.ftp;
-
-import java.io.BufferedReader;
-import java.io.BufferedWriter;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.io.OutputStreamWriter;
-import java.net.Socket;
-
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.KeyManager;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLException;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-
-import org.apache.commons.net.util.Base64;
-import org.apache.commons.net.util.SSLContextUtils;
-import org.apache.commons.net.util.SSLSocketUtils;
-import org.apache.commons.net.util.TrustManagerUtils;
-
-/**
- * FTP over SSL processing. If desired, the JVM property -Djavax.net.debug=all can be used to
- * see wire-level SSL details.
- *
- * Warning: the hostname is not verified against the certificate by default, use
- * {@link #setHostnameVerifier(HostnameVerifier)} or {@link #setEndpointCheckingEnabled(boolean)}
- * (on Java 1.7+) to enable verification. Verification is only performed on client mode connections.
- * @since 2.0
- */
-public class FTPSClient extends FTPClient {
-
-// From http://www.iana.org/assignments/port-numbers
-
-//    ftps-data   989/tcp    ftp protocol, data, over TLS/SSL
-//    ftps-data   989/udp    ftp protocol, data, over TLS/SSL
-//    ftps        990/tcp    ftp protocol, control, over TLS/SSL
-//    ftps        990/udp    ftp protocol, control, over TLS/SSL
-
-    public static final int DEFAULT_FTPS_DATA_PORT = 989;
-    public static final int DEFAULT_FTPS_PORT = 990;
-
-    /** The value that I can set in PROT command  (C = Clear, P = Protected) */
-    private static final String[] PROT_COMMAND_VALUE = {"C","E","S","P"};
-    /** Default PROT Command */
-    private static final String DEFAULT_PROT = "C";
-    /** Default secure socket protocol name, i.e. TLS */
-    private static final String DEFAULT_PROTOCOL = "TLS";
-
-    /** The AUTH (Authentication/Security Mechanism) command. */
-    private static final String CMD_AUTH = "AUTH";
-    /**  The ADAT (Authentication/Security Data) command. */
-    private static final String CMD_ADAT = "ADAT";
-    /**  The PROT (Data Channel Protection Level) command. */
-    private static final String CMD_PROT = "PROT";
-    /**  The PBSZ (Protection Buffer Size) command. */
-    private static final String CMD_PBSZ = "PBSZ";
-    /**  The MIC (Integrity Protected Command) command. */
-    private static final String CMD_MIC = "MIC";
-    /**  The CONF (Confidentiality Protected Command) command. */
-    private static final String CMD_CONF = "CONF";
-    /**  The ENC (Privacy Protected Command) command. */
-    private static final String CMD_ENC = "ENC";
-    /**  The CCC (Clear Command Channel) command. */
-    private static final String CMD_CCC = "CCC";
-
-    /** @deprecated - not used - may be removed in a future release */
-    @Deprecated
-    public static String KEYSTORE_ALGORITHM;
-    /** @deprecated - not used - may be removed in a future release */
-    @Deprecated
-    public static String TRUSTSTORE_ALGORITHM;
-    /** @deprecated - not used - may be removed in a future release */
-    @Deprecated
-    public static String PROVIDER;
-    /** @deprecated - not used - may be removed in a future release */
-    @Deprecated
-    public static String STORE_TYPE;
-    /** The security mode. (True - Implicit Mode / False - Explicit Mode) */
-    private final boolean isImplicit;
-    /** The secure socket protocol to be used, e.g. SSL/TLS. */
-    private final String protocol;
-    /** The AUTH Command value */
-    private String auth = DEFAULT_PROTOCOL;
-    /** The context object. */
-    private SSLContext context;
-    /** The socket object. */
-    private Socket plainSocket;
-    /** Controls whether a new SSL session may be established by this socket. Default true. */
-    private boolean isCreation = true;
-    /** The use client mode flag. */
-    private boolean isClientMode = true;
-
-    /** The need client auth flag. */
-    private boolean isNeedClientAuth;
-
-    /** The want client auth flag. */
-    private boolean isWantClientAuth;
-
-    /** The cipher suites */
-    private String[] suites;
-
-    /** The protocol versions */
-    private String[] protocols;
-
-    /** The FTPS {@link TrustManager} implementation, default validate only
-     * {@link TrustManagerUtils#getValidateServerCertificateTrustManager()}.
-     */
-    private TrustManager trustManager = TrustManagerUtils.getValidateServerCertificateTrustManager();
-
-    /** The {@link KeyManager}, default null (i.e. use system default). */
-    private KeyManager keyManager;
-
-    /** The {@link HostnameVerifier} to use post-TLS, default null (i.e. no verification). */
-    private HostnameVerifier hostnameVerifier;
-
-    /** Use Java 1.7+ HTTPS Endpoint Identification Algorithm. */
-    private boolean tlsEndpointChecking;
-
-    /**
-     * Constructor for FTPSClient, calls {@link #FTPSClient(String, boolean)}.
-     *
-     * Sets protocol to {@link #DEFAULT_PROTOCOL} - i.e. TLS - and security mode to explicit (isImplicit = false)
-     */
-    public FTPSClient() {
-        this(DEFAULT_PROTOCOL, false);
-    }
-
-    /**
-     * Constructor for FTPSClient, using {@link #DEFAULT_PROTOCOL} - i.e. TLS
-     * Calls {@link #FTPSClient(String, boolean)}
-     * @param isImplicit The security mode (Implicit/Explicit).
-     */
-    public FTPSClient(final boolean isImplicit) {
-        this(DEFAULT_PROTOCOL, isImplicit);
-    }
-
-
-    /**
-     * Constructor for FTPSClient, using {@link #DEFAULT_PROTOCOL} - i.e. TLS
-     * The default TrustManager is set from {@link TrustManagerUtils#getValidateServerCertificateTrustManager()}
-     * @param isImplicit The security mode(Implicit/Explicit).
-     * @param context A pre-configured SSL Context
-     */
-    public FTPSClient(final boolean isImplicit, final SSLContext context) {
-        this(DEFAULT_PROTOCOL, isImplicit);
-        this.context = context;
-    }
-
-    /**
-     * Constructor for FTPSClient, using {@link #DEFAULT_PROTOCOL} - i.e. TLS
-     * and isImplicit {@code false}
-     * Calls {@link #FTPSClient(boolean, SSLContext)}
-     * @param context A pre-configured SSL Context
-     */
-    public FTPSClient(final SSLContext context) {
-        this(false, context);
-    }
-
-
-    /**
-     * Constructor for FTPSClient, using explict mode, calls {@link #FTPSClient(String, boolean)}.
-     *
-     * @param protocol the protocol to use
-     */
-    public FTPSClient(final String protocol) {
-        this(protocol, false);
-    }
-
-    /**
-     * Constructor for FTPSClient allowing specification of protocol
-     * and security mode. If isImplicit is true, the port is set to
-     * {@link #DEFAULT_FTPS_PORT} i.e. 990.
-     * The default TrustManager is set from {@link TrustManagerUtils#getValidateServerCertificateTrustManager()}
-     * @param protocol the protocol
-     * @param isImplicit The security mode(Implicit/Explicit).
-     */
-    public FTPSClient(final String protocol, final boolean isImplicit) {
-        this.protocol = protocol;
-        this.isImplicit = isImplicit;
-        if (isImplicit) {
-            setDefaultPort(DEFAULT_FTPS_PORT);
-        }
-    }
-
-    /**
-     * Because there are so many connect() methods,
-     * the _connectAction_() method is provided as a means of performing
-     * some action immediately after establishing a connection,
-     * rather than reimplementing all of the connect() methods.
-     * @throws IOException If it throw by _connectAction_.
-     * @see org.apache.commons.net.SocketClient#_connectAction_()
-     */
-    @Override
-    protected void _connectAction_() throws IOException {
-        // Implicit mode.
-        if (isImplicit) {
-            applySocketAttributes();
-            sslNegotiation();
-        }
-        super._connectAction_();
-        // Explicit mode.
-        if (!isImplicit) {
-            execAUTH();
-            sslNegotiation();
-        }
-    }
-
-    /**
-     * Returns a socket of the data connection.
-     * Wrapped as an {@link SSLSocket}, which carries out handshake processing.
-     * @param command The int representation of the FTP command to send.
-     * @param arg The arguments to the FTP command.
-     * If this parameter is set to null, then the command is sent with
-     * no arguments.
-     * @return corresponding to the established data connection.
-     * Null is returned if an FTP protocol error is reported at any point
-     * during the establishment and initialization of the connection.
-     * @throws IOException If there is any problem with the connection.
-     * @see FTPClient#_openDataConnection_(int, String)
-     * @deprecated (3.3) Use {@link FTPClient#_openDataConnection_(FTPCmd, String)} instead
-     */
-    @Override
-    // Strictly speaking this is not needed, but it works round a Clirr bug
-    // So rather than invoke the parent code, we do it here
-    @Deprecated
-    protected Socket _openDataConnection_(final int command, final String arg)
-            throws IOException {
-        return _openDataConnection_(FTPCommand.getCommand(command), arg);
-    }
-
-    /**
-     * Returns a socket of the data connection. Wrapped as an {@link SSLSocket}, which carries out handshake processing.
-     *
-     * @param command The textual representation of the FTP command to send.
-     * @param arg The arguments to the FTP command. If this parameter is set to null, then the command is sent with no
-     *        arguments.
-     * @return corresponding to the established data connection. Null is returned if an FTP protocol error is reported
-     *         at any point during the establishment and initialization of the connection.
-     * @throws IOException If there is any problem with the connection.
-     * @see FTPClient#_openDataConnection_(int, String)
-     * @since 3.2
-     */
-    @Override
-    protected Socket _openDataConnection_(final String command, final String arg) throws IOException {
-        final Socket socket = super._openDataConnection_(command, arg);
-        _prepareDataSocket_(socket);
-        if (socket instanceof SSLSocket) {
-            final SSLSocket sslSocket = (SSLSocket) socket;
-
-            sslSocket.setUseClientMode(isClientMode);
-            sslSocket.setEnableSessionCreation(isCreation);
-
-            // server mode
-            if (!isClientMode) {
-                sslSocket.setNeedClientAuth(isNeedClientAuth);
-                sslSocket.setWantClientAuth(isWantClientAuth);
-            }
-            if (suites != null) {
-                sslSocket.setEnabledCipherSuites(suites);
-            }
-            if (protocols != null) {
-                sslSocket.setEnabledProtocols(protocols);
-            }
-            sslSocket.startHandshake();
-        }
-
-        return socket;
-    }
-
-        /**
-         * Performs any custom initialization for a newly created SSLSocket (before the SSL handshake happens). Called
-         * by {@link #_openDataConnection_(int, String)} immediately after creating the socket. The default
-         * implementation is a no-op
-         *
-         * @param socket the socket to set up
-         * @throws IOException on error
-         * @since 3.1
-         */
-        protected void _prepareDataSocket_(final Socket socket)
-            throws IOException {
-    }
-
-    /**
-     * Check the value that can be set in PROT Command value.
-     * @param prot Data Channel Protection Level.
-     * @return True - A set point is right / False - A set point is not right
-     */
-    private boolean checkPROTValue(final String prot) {
-        for (final String element : PROT_COMMAND_VALUE)
-        {
-            if (element.equals(prot)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Create SSL socket from plain socket.
-     *
-     * @param socket
-     * @return SSL Socket
-     * @throws IOException
-     */
-    private SSLSocket createSSLSocket(final Socket socket) throws IOException {
-        if (socket != null) {
-            final SSLSocketFactory f = context.getSocketFactory();
-            return (SSLSocket) f.createSocket(socket, _hostname_, socket.getPort(), false);
-        }
-        return null;
-    }
-
-    /**
-     * Closes the connection to the FTP server and restores
-     * connection parameters to the default values.
-     * <p>
-     * Calls {@code setSocketFactory(null)} and {@code setServerSocketFactory(null)}
-     * to reset the factories that may have been changed during the session,
-     * e.g. by {@link #execPROT(String)}
-     * @throws IOException If an error occurs while disconnecting.
-     * @since 3.0
-     */
-    @Override
-    public void disconnect() throws IOException
-    {
-        super.disconnect();
-        if (plainSocket != null) {
-            plainSocket.close();
-        }
-        setSocketFactory(null);
-        setServerSocketFactory(null);
-    }
-
-    /**
-     * Send the ADAT command with the specified authentication data.
-     * @param data The data to send with the command.
-     * @return server reply.
-     * @throws IOException If an I/O error occurs while sending
-     * the command.
-     * @since 3.0
-     */
-    public int execADAT(final byte[] data) throws IOException
-    {
-        if (data != null)
-        {
-            return sendCommand(CMD_ADAT, Base64.encodeBase64StringUnChunked(data));
-        }
-        return sendCommand(CMD_ADAT);
-    }
-
-    /**
-     * AUTH command.
-     * @throws SSLException If it server reply code not equal "234" and "334".
-     * @throws IOException If an I/O error occurs while either sending
-     * the command.
-     */
-    protected void execAUTH() throws SSLException, IOException {
-        final int replyCode = sendCommand(CMD_AUTH, auth);
-        if (FTPReply.SECURITY_MECHANISM_IS_OK == replyCode) {
-            // replyCode = 334
-            // I carry out an ADAT command.
-        } else if (FTPReply.SECURITY_DATA_EXCHANGE_COMPLETE != replyCode) {
-            throw new SSLException(getReplyString());
-        }
-    }
-
-    /**
-     * Send the AUTH command with the specified mechanism.
-     * @param mechanism The mechanism name to send with the command.
-     * @return server reply.
-     * @throws IOException If an I/O error occurs while sending
-     * the command.
-     * @since 3.0
-     */
-    public int execAUTH(final String mechanism) throws IOException
-    {
-        return sendCommand(CMD_AUTH, mechanism);
-    }
-
-    /**
-     * Send the CCC command to the server.
-     * The CCC (Clear Command Channel) command causes the underlying {@link SSLSocket} instance  to be assigned
-     * to a plain {@link Socket} instances
-     * @return server reply.
-     * @throws IOException If an I/O error occurs while sending
-     * the command.
-     * @since 3.0
-     */
-    public int execCCC() throws IOException
-    {
-        final int repCode = sendCommand(CMD_CCC);
-// This will be performed by sendCommand(String, String)
-//        if (FTPReply.isPositiveCompletion(repCode)) {
-//            _socket_.close();
-//            _socket_ = plainSocket;
-//            _controlInput_ = new BufferedReader(
-//                new InputStreamReader(
-//                    _socket_.getInputStream(), getControlEncoding()));
-//            _controlOutput_ = new BufferedWriter(
-//                new OutputStreamWriter(
-//                    _socket_.getOutputStream(), getControlEncoding()));
-//        }
-        return repCode;
-    }
-
-    /**
-     * Send the CONF command with the specified data.
-     * @param data The data to send with the command.
-     * @return server reply.
-     * @throws IOException If an I/O error occurs while sending
-     * the command.
-     * @since 3.0
-     */
-    public int execCONF(final byte[] data) throws IOException
-    {
-        if (data != null)
-        {
-            return sendCommand(CMD_CONF, Base64.encodeBase64StringUnChunked(data));
-        }
-        return sendCommand(CMD_CONF, ""); // perhaps "=" or just sendCommand(String)?
-    }
-
-    /**
-     * Send the ENC command with the specified data.
-     * @param data The data to send with the command.
-     * @return server reply.
-     * @throws IOException If an I/O error occurs while sending
-     * the command.
-     * @since 3.0
-     */
-    public int execENC(final byte[] data) throws IOException
-    {
-        if (data != null)
-        {
-            return sendCommand(CMD_ENC, Base64.encodeBase64StringUnChunked(data));
-        }
-        return sendCommand(CMD_ENC, ""); // perhaps "=" or just sendCommand(String)?
-    }
-
-    /**
-     * Send the MIC command with the specified data.
-     * @param data The data to send with the command.
-     * @return server reply.
-     * @throws IOException If an I/O error occurs while sending
-     * the command.
-     * @since 3.0
-     */
-    public int execMIC(final byte[] data) throws IOException
-    {
-        if (data != null)
-        {
-            return sendCommand(CMD_MIC, Base64.encodeBase64StringUnChunked(data));
-        }
-        return sendCommand(CMD_MIC, ""); // perhaps "=" or just sendCommand(String)?
-    }
-
-    /**
-     * PBSZ command. pbsz value: 0 to (2^32)-1 decimal integer.
-     * @param pbsz Protection Buffer Size.
-     * @throws SSLException If the server reply code does not equal "200".
-     * @throws IOException If an I/O error occurs while sending
-     * the command.
-     * @see #parsePBSZ(long)
-     */
-    public void execPBSZ(final long pbsz) throws SSLException, IOException {
-        if (pbsz < 0 || 4294967295L < pbsz) { // 32-bit unsigned number
-            throw new IllegalArgumentException();
-        }
-        final int status = sendCommand(CMD_PBSZ, String.valueOf(pbsz));
-        if (FTPReply.COMMAND_OK != status) {
-            throw new SSLException(getReplyString());
-        }
-    }
-
-    /**
-     * PROT command.
-     * <ul>
-     * <li>C - Clear</li>
-     * <li>S - Safe(SSL protocol only)</li>
-     * <li>E - Confidential(SSL protocol only)</li>
-     * <li>P - Private</li>
-     * </ul>
-     * <b>N.B.</b> the method calls
-     *  {@link #setSocketFactory(javax.net.SocketFactory)} and
-     *  {@link #setServerSocketFactory(javax.net.ServerSocketFactory)}
-     *
-     * @param prot Data Channel Protection Level, if {@code null}, use {@link #DEFAULT_PROT}.
-     * @throws SSLException If the server reply code does not equal  {@code 200}.
-     * @throws IOException If an I/O error occurs while sending
-     * the command.
-     */
-    public void execPROT(String prot) throws SSLException, IOException {
-        if (prot == null) {
-            prot = DEFAULT_PROT;
-        }
-        if (!checkPROTValue(prot)) {
-            throw new IllegalArgumentException();
-        }
-        if (FTPReply.COMMAND_OK != sendCommand(CMD_PROT, prot)) {
-            throw new SSLException(getReplyString());
-        }
-        if (DEFAULT_PROT.equals(prot)) {
-            setSocketFactory(null);
-            setServerSocketFactory(null);
-        } else {
-            setSocketFactory(new FTPSSocketFactory(context));
-            setServerSocketFactory(new FTPSServerSocketFactory(context));
-            initSslContext();
-        }
-    }
-
-    /**
-     * Extract the data from a reply with a prefix, e.g. PBSZ=1234 => 1234
-     * @param prefix the prefix to find
-     * @param reply where to find the prefix
-     * @return the remainder of the string after the prefix, or null if the prefix was not present.
-     */
-    private String extractPrefixedData(final String prefix, final String reply) {
-        final int idx = reply.indexOf(prefix);
-        if (idx == -1) {
-            return null;
-        }
-        // N.B. Cannot use trim before substring as leading space would affect the offset.
-        return reply.substring(idx+prefix.length()).trim();
-    }
-
-    /**
-     * Return AUTH command use value.
-     * @return AUTH command use value.
-     */
-    public String getAuthValue() {
-        return this.auth;
-    }
-
-    /**
-     * Returns the names of the cipher suites which could be enabled
-     * for use on this connection.
-     * When the underlying {@link Socket} is not an {@link SSLSocket} instance, returns null.
-     * @return An array of cipher suite names, or <code>null</code>
-     */
-    public String[] getEnabledCipherSuites() {
-        if (_socket_ instanceof SSLSocket) {
-            return ((SSLSocket)_socket_).getEnabledCipherSuites();
-        }
-        return null;
-    }
-
-    /**
-     * Returns the names of the protocol versions which are currently
-     * enabled for use on this connection.
-     * When the underlying {@link Socket} is not an {@link SSLSocket} instance, returns null.
-     * @return An array of protocols, or <code>null</code>
-     */
-    public String[] getEnabledProtocols() {
-        if (_socket_ instanceof SSLSocket) {
-            return ((SSLSocket)_socket_).getEnabledProtocols();
-        }
-        return null;
-    }
-
-    /**
-     * Returns true if new SSL sessions may be established by this socket.
-     * When the underlying {@link Socket} instance is not SSL-enabled (i.e. an
-     * instance of {@link SSLSocket} with {@link SSLSocket}{@link #getEnableSessionCreation()}) enabled,
-     * this returns False.
-     * @return true - Indicates that sessions may be created;
-     * this is the default.
-     * false - indicates that an existing session must be resumed.
-     */
-    public boolean getEnableSessionCreation() {
-        if (_socket_ instanceof SSLSocket) {
-            return ((SSLSocket)_socket_).getEnableSessionCreation();
-        }
-        return false;
-    }
-
-    /**
-     * Get the currently configured {@link HostnameVerifier}.
-     * The verifier is only used on client mode connections.
-     * @return A HostnameVerifier instance.
-     * @since 3.4
-     */
-    public HostnameVerifier getHostnameVerifier()
-    {
-        return hostnameVerifier;
-    }
-
-    /**
-     * Gets the {@link KeyManager} instance.
-     *
-     * @return The {@link KeyManager} instance
-     */
-    private KeyManager getKeyManager() {
-        return keyManager;
-    }
-
-    /**
-     * Returns true if the socket will require client authentication.
-     * When the underlying {@link Socket} is not an {@link SSLSocket} instance, returns false.
-     * @return true - If the server mode socket should request
-     * that the client authenticate itself.
-     */
-    public boolean getNeedClientAuth() {
-        if (_socket_ instanceof SSLSocket) {
-            return ((SSLSocket)_socket_).getNeedClientAuth();
-        }
-        return false;
-    }
-
-    /**
-     * Get the currently configured {@link TrustManager}.
-     *
-     * @return A TrustManager instance.
-     */
-    public TrustManager getTrustManager() {
-        return trustManager;
-    }
-
-    /**
-     * Returns true if the socket is set to use client mode
-     * in its first handshake.
-     * When the underlying {@link Socket} is not an {@link SSLSocket} instance, returns false.
-     * @return true - If the socket should start its first handshake
-     * in "client" mode.
-     */
-    public boolean getUseClientMode() {
-        if (_socket_ instanceof SSLSocket) {
-            return ((SSLSocket)_socket_).getUseClientMode();
-        }
-        return false;
-    }
-
-    /**
-     * Returns true if the socket will request client authentication.
-     * When the underlying {@link Socket} is not an {@link SSLSocket} instance, returns false.
-     * @return true - If the server mode socket should request
-     * that the client authenticate itself.
-     */
-    public boolean getWantClientAuth() {
-        if (_socket_ instanceof SSLSocket) {
-            return ((SSLSocket)_socket_).getWantClientAuth();
-        }
-        return false;
-    }
-
-    /**
-     * Performs a lazy init of the SSL context
-     * @throws IOException
-     */
-    private void initSslContext() throws IOException {
-        if (context == null) {
-            context = SSLContextUtils.createSSLContext(protocol, getKeyManager(), getTrustManager());
-        }
-    }
-
-    /**
-     * Return whether or not endpoint identification using the HTTPS algorithm
-     * on Java 1.7+ is enabled. The default behavior is for this to be disabled.
-     *
-     * This check is only performed on client mode connections.
-     *
-     * @return True if enabled, false if not.
-     * @since 3.4
-     */
-    public boolean isEndpointCheckingEnabled()
-    {
-        return tlsEndpointChecking;
-    }
-
-    /**
-     * Parses the given ADAT response line and base64-decodes the data.
-     * @param reply The ADAT reply to parse.
-     * @return the data in the reply, base64-decoded.
-     * @since 3.0
-     */
-    public byte[] parseADATReply(final String reply)
-    {
-        if (reply == null) {
-            return null;
-        }
-        return Base64.decodeBase64(extractPrefixedData("ADAT=", reply));
-    }
-
-    /**
-     * PBSZ command. pbsz value: 0 to (2^32)-1 decimal integer.
-     * Issues the command and parses the response to return the negotiated value.
-     *
-     * @param pbsz Protection Buffer Size.
-     * @throws SSLException If the server reply code does not equal "200".
-     * @throws IOException If an I/O error occurs while sending
-     * the command.
-     * @return the negotiated value.
-     * @see #execPBSZ(long)
-     * @since 3.0
-     */
-    public long parsePBSZ(final long pbsz) throws SSLException, IOException {
-        execPBSZ(pbsz);
-        long minvalue = pbsz;
-        final String remainder = extractPrefixedData("PBSZ=", getReplyString());
-        if (remainder != null) {
-            final long replysz = Long.parseLong(remainder);
-            if (replysz < minvalue) {
-                minvalue = replysz;
-            }
-        }
-        return minvalue;
-    }
-
-    /**
-     * Send an FTP command.
-     * A successful CCC (Clear Command Channel) command causes the underlying {@link SSLSocket}
-     * instance to be assigned to a plain {@link Socket}
-     * @param command The FTP command.
-     * @return server reply.
-     * @throws IOException If an I/O error occurs while sending the command.
-     * @throws SSLException if a CCC command fails
-     * @see org.apache.commons.net.ftp.FTP#sendCommand(String)
-     */
-    // Would like to remove this method, but that will break any existing clients that are using CCC
-    @Override
-    public int sendCommand(final String command, final String args) throws IOException {
-        final int repCode = super.sendCommand(command, args);
-        /* If CCC is issued, restore socket i/o streams to unsecured versions */
-        if (CMD_CCC.equals(command)) {
-            if (FTPReply.COMMAND_OK != repCode) {
-                throw new SSLException(getReplyString());
-            }
-            _socket_.close();
-            _socket_ = plainSocket;
-            _controlInput_ = new BufferedReader(
-                new InputStreamReader(
-                    _socket_ .getInputStream(), getControlEncoding()));
-            _controlOutput_ = new BufferedWriter(
-                new OutputStreamWriter(
-                    _socket_.getOutputStream(), getControlEncoding()));
-        }
-        return repCode;
-    }
-
-    /**
-     * Set AUTH command use value.
-     * This processing is done before connected processing.
-     * @param auth AUTH command use value.
-     */
-    public void setAuthValue(final String auth) {
-        this.auth = auth;
-    }
-
-    /**
-     * Controls which particular cipher suites are enabled for use on this
-     * connection. Called before server negotiation.
-     * @param cipherSuites The cipher suites.
-     */
-    public void setEnabledCipherSuites(final String[] cipherSuites) {
-        suites = cipherSuites.clone();
-    }
-
-    /**
-     * Controls which particular protocol versions are enabled for use on this
-     * connection. I perform setting before a server negotiation.
-     * @param protocolVersions The protocol versions.
-     */
-    public void setEnabledProtocols(final String[] protocolVersions) {
-        protocols = protocolVersions.clone();
-    }
-
-    /**
-     * Controls whether a new SSL session may be established by this socket.
-     * @param isCreation The established socket flag.
-     */
-    public void setEnabledSessionCreation(final boolean isCreation) {
-        this.isCreation = isCreation;
-    }
-
-    /**
-     * Automatic endpoint identification checking using the HTTPS algorithm
-     * is supported on Java 1.7+. The default behavior is for this to be disabled.
-     *
-     * This check is only performed on client mode connections.
-     *
-     * @param enable Enable automatic endpoint identification checking using the HTTPS algorithm on Java 1.7+.
-     * @since 3.4
-     */
-    public void setEndpointCheckingEnabled(final boolean enable)
-    {
-        tlsEndpointChecking = enable;
-    }
-
-    /**
-     * Override the default {@link HostnameVerifier} to use.
-     * The verifier is only used on client mode connections.
-     * @param newHostnameVerifier The HostnameVerifier implementation to set or <code>null</code> to disable.
-     * @since 3.4
-     */
-    public void setHostnameVerifier(final HostnameVerifier newHostnameVerifier)
-    {
-        hostnameVerifier = newHostnameVerifier;
-    }
-
-    /**
-    * Set a {@link KeyManager} to use
-    *
-    * @param keyManager The KeyManager implementation to set.
-    * @see org.apache.commons.net.util.KeyManagerUtils
-    */
-    public void setKeyManager(final KeyManager keyManager) {
-        this.keyManager = keyManager;
-    }
-
-    /**
-     * Configures the socket to require client authentication.
-     * @param isNeedClientAuth The need client auth flag.
-     */
-    public void setNeedClientAuth(final boolean isNeedClientAuth) {
-        this.isNeedClientAuth = isNeedClientAuth;
-    }
-
-    // DEPRECATED - for API compatibility only - DO NOT USE
-
-    /**
-     * Override the default {@link TrustManager} to use; if set to {@code null},
-     * the default TrustManager from the JVM will be used.
-     *
-     * @param trustManager The TrustManager implementation to set, may be {@code null}
-     * @see org.apache.commons.net.util.TrustManagerUtils
-     */
-    public void setTrustManager(final TrustManager trustManager) {
-        this.trustManager = trustManager;
-    }
-
-    /**
-     * Configures the socket to use client (or server) mode in its first
-     * handshake.
-     * @param isClientMode The use client mode flag.
-     */
-    public void setUseClientMode(final boolean isClientMode) {
-        this.isClientMode = isClientMode;
-    }
-
-    /**
-     * Configures the socket to request client authentication,
-     * but only if such a request is appropriate to the cipher
-     * suite negotiated.
-     * @param isWantClientAuth The want client auth flag.
-     */
-    public void setWantClientAuth(final boolean isWantClientAuth) {
-        this.isWantClientAuth = isWantClientAuth;
-    }
-
-    /**
-     * SSL/TLS negotiation. Acquires an SSL socket of a control
-     * connection and carries out handshake processing.
-     * @throws IOException If server negotiation fails
-     */
-    protected void sslNegotiation() throws IOException {
-        plainSocket = _socket_;
-        initSslContext();
-        final SSLSocket socket = createSSLSocket(_socket_);
-        socket.setEnableSessionCreation(isCreation);
-        socket.setUseClientMode(isClientMode);
-
-        // client mode
-        if (isClientMode) {
-            if (tlsEndpointChecking) {
-                SSLSocketUtils.enableEndpointNameVerification(socket);
-            }
-        } else { // server mode
-            socket.setNeedClientAuth(isNeedClientAuth);
-            socket.setWantClientAuth(isWantClientAuth);
-        }
-
-        if (protocols != null) {
-            socket.setEnabledProtocols(protocols);
-        }
-        if (suites != null) {
-            socket.setEnabledCipherSuites(suites);
-        }
-        socket.startHandshake();
-
-        // TODO the following setup appears to duplicate that in the super class methods
-        _socket_ = socket;
-        _controlInput_ = new BufferedReader(new InputStreamReader(
-                socket .getInputStream(), getControlEncoding()));
-        _controlOutput_ = new BufferedWriter(new OutputStreamWriter(
-                socket.getOutputStream(), getControlEncoding()));
-
-        if (isClientMode && (hostnameVerifier != null &&
-            !hostnameVerifier.verify(_hostname_, socket.getSession()))) {
-            throw new SSLHandshakeException("Hostname doesn't match certificate");
-        }
-    }
-
-}
-/* kate: indent-width 4; replace-tabs on; */
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.net.ftp;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
+import java.net.Socket;
+
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.KeyManager;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLException;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+
+import org.apache.commons.net.util.Base64;
+import org.apache.commons.net.util.SSLContextUtils;
+import org.apache.commons.net.util.SSLSocketUtils;
+import org.apache.commons.net.util.TrustManagerUtils;
+
+/**
+ * FTP over SSL processing. If desired, the JVM property -Djavax.net.debug=all can be used to
+ * see wire-level SSL details.
+ *
+ * Warning: the hostname is not verified against the certificate by default, use
+ * {@link #setHostnameVerifier(HostnameVerifier)} or {@link #setEndpointCheckingEnabled(boolean)}
+ * (on Java 1.7+) to enable verification. Verification is only performed on client mode connections.
+ * @since 2.0
+ */
+public class FTPSClient extends FTPClient {
+
+// From http://www.iana.org/assignments/port-numbers
+
+//    ftps-data   989/tcp    ftp protocol, data, over TLS/SSL
+//    ftps-data   989/udp    ftp protocol, data, over TLS/SSL
+//    ftps        990/tcp    ftp protocol, control, over TLS/SSL
+//    ftps        990/udp    ftp protocol, control, over TLS/SSL
+
+    public static final int DEFAULT_FTPS_DATA_PORT = 989;
+    public static final int DEFAULT_FTPS_PORT = 990;
+
+    /** The value that I can set in PROT command  (C = Clear, P = Protected) */
+    private static final String[] PROT_COMMAND_VALUE = {"C","E","S","P"};
+    /** Default PROT Command */
+    private static final String DEFAULT_PROT = "C";
+    /** Default secure socket protocol name, i.e. TLS */
+    private static final String DEFAULT_PROTOCOL = "TLS";
+
+    /** The AUTH (Authentication/Security Mechanism) command. */
+    private static final String CMD_AUTH = "AUTH";
+    /**  The ADAT (Authentication/Security Data) command. */
+    private static final String CMD_ADAT = "ADAT";
+    /**  The PROT (Data Channel Protection Level) command. */
+    private static final String CMD_PROT = "PROT";
+    /**  The PBSZ (Protection Buffer Size) command. */
+    private static final String CMD_PBSZ = "PBSZ";
+    /**  The MIC (Integrity Protected Command) command. */
+    private static final String CMD_MIC = "MIC";
+    /**  The CONF (Confidentiality Protected Command) command. */
+    private static final String CMD_CONF = "CONF";
+    /**  The ENC (Privacy Protected Command) command. */
+    private static final String CMD_ENC = "ENC";
+    /**  The CCC (Clear Command Channel) command. */
+    private static final String CMD_CCC = "CCC";
+
+    /** @deprecated - not used - may be removed in a future release */
+    @Deprecated
+    public static String KEYSTORE_ALGORITHM;
+    /** @deprecated - not used - may be removed in a future release */
+    @Deprecated
+    public static String TRUSTSTORE_ALGORITHM;
+    /** @deprecated - not used - may be removed in a future release */
+    @Deprecated
+    public static String PROVIDER;
+    /** @deprecated - not used - may be removed in a future release */
+    @Deprecated
+    public static String STORE_TYPE;
+    /** The security mode. (True - Implicit Mode / False - Explicit Mode) */
+    private final boolean isImplicit;
+    /** The secure socket protocol to be used, e.g. SSL/TLS. */
+    private final String protocol;
+    /** The AUTH Command value */
+    private String auth = DEFAULT_PROTOCOL;
+    /** The context object. */
+    private SSLContext context;
+    /** The socket object. */
+    private Socket plainSocket;
+    /** Controls whether a new SSL session may be established by this socket. Default true. */
+    private boolean isCreation = true;
+    /** The use client mode flag. */
+    private boolean isClientMode = true;
+
+    /** The need client auth flag. */
+    private boolean isNeedClientAuth;
+
+    /** The want client auth flag. */
+    private boolean isWantClientAuth;
+
+    /** The cipher suites */
+    private String[] suites;
+
+    /** The protocol versions */
+    private String[] protocols;
+
+    /** The FTPS {@link TrustManager} implementation, default validate only
+     * {@link TrustManagerUtils#getValidateServerCertificateTrustManager()}.
+     */
+    private TrustManager trustManager = TrustManagerUtils.getValidateServerCertificateTrustManager();
+
+    /** The {@link KeyManager}, default null (i.e. use system default). */
+    private KeyManager keyManager;
+
+    /** The {@link HostnameVerifier} to use post-TLS, default null (i.e. no verification). */
+    private HostnameVerifier hostnameVerifier;
+
+    /** Use Java 1.7+ HTTPS Endpoint Identification Algorithm. */
+    private boolean tlsEndpointChecking;
+
+    /**
+     * Constructor for FTPSClient, calls {@link #FTPSClient(String, boolean)}.
+     *
+     * Sets protocol to {@link #DEFAULT_PROTOCOL} - i.e. TLS - and security mode to explicit (isImplicit = false)
+     */
+    public FTPSClient() {
+        this(DEFAULT_PROTOCOL, false);
+    }
+
+    /**
+     * Constructor for FTPSClient, using {@link #DEFAULT_PROTOCOL} - i.e. TLS
+     * Calls {@link #FTPSClient(String, boolean)}
+     * @param isImplicit The security mode (Implicit/Explicit).
+     */
+    public FTPSClient(final boolean isImplicit) {
+        this(DEFAULT_PROTOCOL, isImplicit);
+    }
+
+
+    /**
+     * Constructor for FTPSClient, using {@link #DEFAULT_PROTOCOL} - i.e. TLS
+     * The default TrustManager is set from {@link TrustManagerUtils#getValidateServerCertificateTrustManager()}
+     * @param isImplicit The security mode(Implicit/Explicit).
+     * @param context A pre-configured SSL Context
+     */
+    public FTPSClient(final boolean isImplicit, final SSLContext context) {
+        this(DEFAULT_PROTOCOL, isImplicit);
+        this.context = context;
+    }
+
+    /**
+     * Constructor for FTPSClient, using {@link #DEFAULT_PROTOCOL} - i.e. TLS
+     * and isImplicit {@code false}
+     * Calls {@link #FTPSClient(boolean, SSLContext)}
+     * @param context A pre-configured SSL Context
+     */
+    public FTPSClient(final SSLContext context) {
+        this(false, context);
+    }
+
+
+    /**
+     * Constructor for FTPSClient, using explict mode, calls {@link #FTPSClient(String, boolean)}.
+     *
+     * @param protocol the protocol to use
+     */
+    public FTPSClient(final String protocol) {
+        this(protocol, false);
+    }
+
+    /**
+     * Constructor for FTPSClient allowing specification of protocol
+     * and security mode. If isImplicit is true, the port is set to
+     * {@link #DEFAULT_FTPS_PORT} i.e. 990.
+     * The default TrustManager is set from {@link TrustManagerUtils#getValidateServerCertificateTrustManager()}
+     * @param protocol the protocol
+     * @param isImplicit The security mode(Implicit/Explicit).
+     */
+    public FTPSClient(final String protocol, final boolean isImplicit) {
+        this.protocol = protocol;
+        this.isImplicit = isImplicit;
+        if (isImplicit) {
+            setDefaultPort(DEFAULT_FTPS_PORT);
+        }
+    }
+
+    /**
+     * Because there are so many connect() methods,
+     * the _connectAction_() method is provided as a means of performing
+     * some action immediately after establishing a connection,
+     * rather than reimplementing all of the connect() methods.
+     * @throws IOException If it throw by _connectAction_.
+     * @see org.apache.commons.net.SocketClient#_connectAction_()
+     */
+    @Override
+    protected void _connectAction_() throws IOException {
+        // Implicit mode.
+        if (isImplicit) {
+            applySocketAttributes();
+            sslNegotiation();
+        }
+        super._connectAction_();
+        // Explicit mode.
+        if (!isImplicit) {
+            execAUTH();
+            sslNegotiation();
+        }
+    }
+
+    /**
+     * Returns a socket of the data connection.
+     * Wrapped as an {@link SSLSocket}, which carries out handshake processing.
+     * @param command The int representation of the FTP command to send.
+     * @param arg The arguments to the FTP command.
+     * If this parameter is set to null, then the command is sent with
+     * no arguments.
+     * @return corresponding to the established data connection.
+     * Null is returned if an FTP protocol error is reported at any point
+     * during the establishment and initialization of the connection.
+     * @throws IOException If there is any problem with the connection.
+     * @see FTPClient#_openDataConnection_(int, String)
+     * @deprecated (3.3) Use {@link FTPClient#_openDataConnection_(FTPCmd, String)} instead
+     */
+    @Override
+    // Strictly speaking this is not needed, but it works round a Clirr bug
+    // So rather than invoke the parent code, we do it here
+    @Deprecated
+    protected Socket _openDataConnection_(final int command, final String arg)
+            throws IOException {
+        return _openDataConnection_(FTPCommand.getCommand(command), arg);
+    }
+
+    /**
+     * Returns a socket of the data connection. Wrapped as an {@link SSLSocket}, which carries out handshake processing.
+     *
+     * @param command The textual representation of the FTP command to send.
+     * @param arg The arguments to the FTP command. If this parameter is set to null, then the command is sent with no
+     *        arguments.
+     * @return corresponding to the established data connection. Null is returned if an FTP protocol error is reported
+     *         at any point during the establishment and initialization of the connection.
+     * @throws IOException If there is any problem with the connection.
+     * @see FTPClient#_openDataConnection_(int, String)
+     * @since 3.2
+     */
+    @Override
+    protected Socket _openDataConnection_(final String command, final String arg) throws IOException {
+        final Socket socket = super._openDataConnection_(command, arg);
+        _prepareDataSocket_(socket);
+        if (socket instanceof SSLSocket) {
+            final SSLSocket sslSocket = (SSLSocket) socket;
+
+            sslSocket.setUseClientMode(isClientMode);
+            sslSocket.setEnableSessionCreation(isCreation);
+
+            // server mode
+            if (!isClientMode) {
+                sslSocket.setNeedClientAuth(isNeedClientAuth);
+                sslSocket.setWantClientAuth(isWantClientAuth);
+            }
+            if (suites != null) {
+                sslSocket.setEnabledCipherSuites(suites);
+            }
+            if (protocols != null) {
+                sslSocket.setEnabledProtocols(protocols);
+            }
+            sslSocket.startHandshake();
+        }
+
+        return socket;
+    }
+
+        /**
+         * Performs any custom initialization for a newly created SSLSocket (before the SSL handshake happens). Called
+         * by {@link #_openDataConnection_(int, String)} immediately after creating the socket. The default
+         * implementation is a no-op
+         *
+         * @param socket the socket to set up
+         * @throws IOException on error
+         * @since 3.1
+         */
+        protected void _prepareDataSocket_(final Socket socket)
+            throws IOException {
+    }
+
+    /**
+     * Check the value that can be set in PROT Command value.
+     * @param prot Data Channel Protection Level.
+     * @return True - A set point is right / False - A set point is not right
+     */
+    private boolean checkPROTValue(final String prot) {
+        for (final String element : PROT_COMMAND_VALUE)
+        {
+            if (element.equals(prot)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Create SSL socket from plain socket.
+     *
+     * @param socket
+     * @return SSL Socket
+     * @throws IOException
+     */
+    private SSLSocket createSSLSocket(final Socket socket) throws IOException {
+        if (socket != null) {
+            final SSLSocketFactory f = context.getSocketFactory();
+            return (SSLSocket) f.createSocket(socket, _hostname_, socket.getPort(), false);
+        }
+        return null;
+    }
+
+    /**
+     * Closes the connection to the FTP server and restores
+     * connection parameters to the default values.
+     * <p>
+     * Calls {@code setSocketFactory(null)} and {@code setServerSocketFactory(null)}
+     * to reset the factories that may have been changed during the session,
+     * e.g. by {@link #execPROT(String)}
+     * @throws IOException If an error occurs while disconnecting.
+     * @since 3.0
+     */
+    @Override
+    public void disconnect() throws IOException
+    {
+        super.disconnect();
+        if (plainSocket != null) {
+            plainSocket.close();
+        }
+        setSocketFactory(null);
+        setServerSocketFactory(null);
+    }
+
+    /**
+     * Send the ADAT command with the specified authentication data.
+     * @param data The data to send with the command.
+     * @return server reply.
+     * @throws IOException If an I/O error occurs while sending
+     * the command.
+     * @since 3.0
+     */
+    public int execADAT(final byte[] data) throws IOException
+    {
+        if (data != null)
+        {
+            return sendCommand(CMD_ADAT, Base64.encodeBase64StringUnChunked(data));
+        }
+        return sendCommand(CMD_ADAT);
+    }
+
+    /**
+     * AUTH command.
+     * @throws SSLException If it server reply code not equal "234" and "334".
+     * @throws IOException If an I/O error occurs while either sending
+     * the command.
+     */
+    protected void execAUTH() throws SSLException, IOException {
+        final int replyCode = sendCommand(CMD_AUTH, auth);
+        if (FTPReply.SECURITY_MECHANISM_IS_OK == replyCode) {
+            // replyCode = 334
+            // I carry out an ADAT command.
+        } else if (FTPReply.SECURITY_DATA_EXCHANGE_COMPLETE != replyCode) {
+            throw new SSLException(getReplyString());
+        }
+    }
+
+    /**
+     * Send the AUTH command with the specified mechanism.
+     * @param mechanism The mechanism name to send with the command.
+     * @return server reply.
+     * @throws IOException If an I/O error occurs while sending
+     * the command.
+     * @since 3.0
+     */
+    public int execAUTH(final String mechanism) throws IOException
+    {
+        return sendCommand(CMD_AUTH, mechanism);
+    }
+
+    /**
+     * Send the CCC command to the server.
+     * The CCC (Clear Command Channel) command causes the underlying {@link SSLSocket} instance  to be assigned
+     * to a plain {@link Socket} instances
+     * @return server reply.
+     * @throws IOException If an I/O error occurs while sending
+     * the command.
+     * @since 3.0
+     */
+    public int execCCC() throws IOException
+    {
+        final int repCode = sendCommand(CMD_CCC);
+// This will be performed by sendCommand(String, String)
+//        if (FTPReply.isPositiveCompletion(repCode)) {
+//            _socket_.close();
+//            _socket_ = plainSocket;
+//            _controlInput_ = new BufferedReader(
+//                new InputStreamReader(
+//                    _socket_.getInputStream(), getControlEncoding()));
+//            _controlOutput_ = new BufferedWriter(
+//                new OutputStreamWriter(
+//                    _socket_.getOutputStream(), getControlEncoding()));
+//        }
+        return repCode;
+    }
+
+    /**
+     * Send the CONF command with the specified data.
+     * @param data The data to send with the command.
+     * @return server reply.
+     * @throws IOException If an I/O error occurs while sending
+     * the command.
+     * @since 3.0
+     */
+    public int execCONF(final byte[] data) throws IOException
+    {
+        if (data != null)
+        {
+            return sendCommand(CMD_CONF, Base64.encodeBase64StringUnChunked(data));
+        }
+        return sendCommand(CMD_CONF, ""); // perhaps "=" or just sendCommand(String)?
+    }
+
+    /**
+     * Send the ENC command with the specified data.
+     * @param data The data to send with the command.
+     * @return server reply.
+     * @throws IOException If an I/O error occurs while sending
+     * the command.
+     * @since 3.0
+     */
+    public int execENC(final byte[] data) throws IOException
+    {
+        if (data != null)
+        {
+            return sendCommand(CMD_ENC, Base64.encodeBase64StringUnChunked(data));
+        }
+        return sendCommand(CMD_ENC, ""); // perhaps "=" or just sendCommand(String)?
+    }
+
+    /**
+     * Send the MIC command with the specified data.
+     * @param data The data to send with the command.
+     * @return server reply.
+     * @throws IOException If an I/O error occurs while sending
+     * the command.
+     * @since 3.0
+     */
+    public int execMIC(final byte[] data) throws IOException
+    {
+        if (data != null)
+        {
+            return sendCommand(CMD_MIC, Base64.encodeBase64StringUnChunked(data));
+        }
+        return sendCommand(CMD_MIC, ""); // perhaps "=" or just sendCommand(String)?
+    }
+
+    /**
+     * PBSZ command. pbsz value: 0 to (2^32)-1 decimal integer.
+     * @param pbsz Protection Buffer Size.
+     * @throws SSLException If the server reply code does not equal "200".
+     * @throws IOException If an I/O error occurs while sending
+     * the command.
+     * @see #parsePBSZ(long)
+     */
+    public void execPBSZ(final long pbsz) throws SSLException, IOException {
+        if (pbsz < 0 || 4294967295L < pbsz) { // 32-bit unsigned number
+            throw new IllegalArgumentException();
+        }
+        final int status = sendCommand(CMD_PBSZ, String.valueOf(pbsz));
+        if (FTPReply.COMMAND_OK != status) {
+            throw new SSLException(getReplyString());
+        }
+    }
+
+    /**
+     * PROT command.
+     * <ul>
+     * <li>C - Clear</li>
+     * <li>S - Safe(SSL protocol only)</li>
+     * <li>E - Confidential(SSL protocol only)</li>
+     * <li>P - Private</li>
+     * </ul>
+     * <b>N.B.</b> the method calls
+     *  {@link #setSocketFactory(javax.net.SocketFactory)} and
+     *  {@link #setServerSocketFactory(javax.net.ServerSocketFactory)}
+     *
+     * @param prot Data Channel Protection Level, if {@code null}, use {@link #DEFAULT_PROT}.
+     * @throws SSLException If the server reply code does not equal  {@code 200}.
+     * @throws IOException If an I/O error occurs while sending
+     * the command.
+     */
+    public void execPROT(String prot) throws SSLException, IOException {
+        if (prot == null) {
+            prot = DEFAULT_PROT;
+        }
+        if (!checkPROTValue(prot)) {
+            throw new IllegalArgumentException();
+        }
+        if (FTPReply.COMMAND_OK != sendCommand(CMD_PROT, prot)) {
+            throw new SSLException(getReplyString());
+        }
+        if (DEFAULT_PROT.equals(prot)) {
+            setSocketFactory(null);
+            setServerSocketFactory(null);
+        } else {
+            setSocketFactory(new FTPSSocketFactory(context));
+            setServerSocketFactory(new FTPSServerSocketFactory(context));
+            initSslContext();
+        }
+    }
+
+    /**
+     * Extract the data from a reply with a prefix, e.g. PBSZ=1234 => 1234
+     * @param prefix the prefix to find
+     * @param reply where to find the prefix
+     * @return the remainder of the string after the prefix, or null if the prefix was not present.
+     */
+    private String extractPrefixedData(final String prefix, final String reply) {
+        final int idx = reply.indexOf(prefix);
+        if (idx == -1) {
+            return null;
+        }
+        // N.B. Cannot use trim before substring as leading space would affect the offset.
+        return reply.substring(idx+prefix.length()).trim();
+    }
+
+    /**
+     * Return AUTH command use value.
+     * @return AUTH command use value.
+     */
+    public String getAuthValue() {
+        return this.auth;
+    }
+
+    /**
+     * Returns the names of the cipher suites which could be enabled
+     * for use on this connection.
+     * When the underlying {@link Socket} is not an {@link SSLSocket} instance, returns null.
+     * @return An array of cipher suite names, or <code>null</code>
+     */
+    public String[] getEnabledCipherSuites() {
+        if (_socket_ instanceof SSLSocket) {
+            return ((SSLSocket)_socket_).getEnabledCipherSuites();
+        }
+        return null;
+    }
+
+    /**
+     * Returns the names of the protocol versions which are currently
+     * enabled for use on this connection.
+     * When the underlying {@link Socket} is not an {@link SSLSocket} instance, returns null.
+     * @return An array of protocols, or <code>null</code>
+     */
+    public String[] getEnabledProtocols() {
+        if (_socket_ instanceof SSLSocket) {
+            return ((SSLSocket)_socket_).getEnabledProtocols();
+        }
+        return null;
+    }
+
+    /**
+     * Returns true if new SSL sessions may be established by this socket.
+     * When the underlying {@link Socket} instance is not SSL-enabled (i.e. an
+     * instance of {@link SSLSocket} with {@link SSLSocket}{@link #getEnableSessionCreation()}) enabled,
+     * this returns False.
+     * @return true - Indicates that sessions may be created;
+     * this is the default.
+     * false - indicates that an existing session must be resumed.
+     */
+    public boolean getEnableSessionCreation() {
+        if (_socket_ instanceof SSLSocket) {
+            return ((SSLSocket)_socket_).getEnableSessionCreation();
+        }
+        return false;
+    }
+
+    /**
+     * Get the currently configured {@link HostnameVerifier}.
+     * The verifier is only used on client mode connections.
+     * @return A HostnameVerifier instance.
+     * @since 3.4
+     */
+    public HostnameVerifier getHostnameVerifier()
+    {
+        return hostnameVerifier;
+    }
+
+    /**
+     * Gets the {@link KeyManager} instance.
+     *
+     * @return The {@link KeyManager} instance
+     */
+    private KeyManager getKeyManager() {
+        return keyManager;
+    }
+
+    /**
+     * Returns true if the socket will require client authentication.
+     * When the underlying {@link Socket} is not an {@link SSLSocket} instance, returns false.
+     * @return true - If the server mode socket should request
+     * that the client authenticate itself.
+     */
+    public boolean getNeedClientAuth() {
+        if (_socket_ instanceof SSLSocket) {
+            return ((SSLSocket)_socket_).getNeedClientAuth();
+        }
+        return false;
+    }
+
+    /**
+     * Get the currently configured {@link TrustManager}.
+     *
+     * @return A TrustManager instance.
+     */
+    public TrustManager getTrustManager() {
+        return trustManager;
+    }
+
+    /**
+     * Returns true if the socket is set to use client mode
+     * in its first handshake.
+     * When the underlying {@link Socket} is not an {@link SSLSocket} instance, returns false.
+     * @return true - If the socket should start its first handshake
+     * in "client" mode.
+     */
+    public boolean getUseClientMode() {
+        if (_socket_ instanceof SSLSocket) {
+            return ((SSLSocket)_socket_).getUseClientMode();
+        }
+        return false;
+    }
+
+    /**
+     * Returns true if the socket will request client authentication.
+     * When the underlying {@link Socket} is not an {@link SSLSocket} instance, returns false.
+     * @return true - If the server mode socket should request
+     * that the client authenticate itself.
+     */
+    public boolean getWantClientAuth() {
+        if (_socket_ instanceof SSLSocket) {
+            return ((SSLSocket)_socket_).getWantClientAuth();
+        }
+        return false;
+    }
+
+    /**
+     * Performs a lazy init of the SSL context
+     * @throws IOException
+     */
+    private void initSslContext() throws IOException {
+        if (context == null) {
+            context = SSLContextUtils.createSSLContext(protocol, getKeyManager(), getTrustManager());
+        }
+    }
+
+    /**
+     * Return whether or not endpoint identification using the HTTPS algorithm
+     * on Java 1.7+ is enabled. The default behavior is for this to be disabled.
+     *
+     * This check is only performed on client mode connections.
+     *
+     * @return True if enabled, false if not.
+     * @since 3.4
+     */
+    public boolean isEndpointCheckingEnabled()
+    {
+        return tlsEndpointChecking;
+    }
+
+    /**
+     * Parses the given ADAT response line and base64-decodes the data.
+     * @param reply The ADAT reply to parse.
+     * @return the data in the reply, base64-decoded.
+     * @since 3.0
+     */
+    public byte[] parseADATReply(final String reply)
+    {
+        if (reply == null) {
+            return null;
+        }
+        return Base64.decodeBase64(extractPrefixedData("ADAT=", reply));
+    }
+
+    /**
+     * PBSZ command. pbsz value: 0 to (2^32)-1 decimal integer.
+     * Issues the command and parses the response to return the negotiated value.
+     *
+     * @param pbsz Protection Buffer Size.
+     * @throws SSLException If the server reply code does not equal "200".
+     * @throws IOException If an I/O error occurs while sending
+     * the command.
+     * @return the negotiated value.
+     * @see #execPBSZ(long)
+     * @since 3.0
+     */
+    public long parsePBSZ(final long pbsz) throws SSLException, IOException {
+        execPBSZ(pbsz);
+        long minvalue = pbsz;
+        final String remainder = extractPrefixedData("PBSZ=", getReplyString());
+        if (remainder != null) {
+            final long replysz = Long.parseLong(remainder);
+            if (replysz < minvalue) {
+                minvalue = replysz;
+            }
+        }
+        return minvalue;
+    }
+
+    /**
+     * Send an FTP command.
+     * A successful CCC (Clear Command Channel) command causes the underlying {@link SSLSocket}
+     * instance to be assigned to a plain {@link Socket}
+     * @param command The FTP command.
+     * @return server reply.
+     * @throws IOException If an I/O error occurs while sending the command.
+     * @throws SSLException if a CCC command fails
+     * @see org.apache.commons.net.ftp.FTP#sendCommand(String)
+     */
+    // Would like to remove this method, but that will break any existing clients that are using CCC
+    @Override
+    public int sendCommand(final String command, final String args) throws IOException {
+        final int repCode = super.sendCommand(command, args);
+        /* If CCC is issued, restore socket i/o streams to unsecured versions */
+        if (CMD_CCC.equals(command)) {
+            if (FTPReply.COMMAND_OK != repCode) {
+                throw new SSLException(getReplyString());
+            }
+            _socket_.close();
+            _socket_ = plainSocket;
+            _controlInput_ = new BufferedReader(
+                new InputStreamReader(
+                    _socket_ .getInputStream(), getControlEncoding()));
+            _controlOutput_ = new BufferedWriter(
+                new OutputStreamWriter(
+                    _socket_.getOutputStream(), getControlEncoding()));
+        }
+        return repCode;
+    }
+
+    /**
+     * Set AUTH command use value.
+     * This processing is done before connected processing.
+     * @param auth AUTH command use value.
+     */
+    public void setAuthValue(final String auth) {
+        this.auth = auth;
+    }
+
+    /**
+     * Controls which particular cipher suites are enabled for use on this
+     * connection. Called before server negotiation.
+     * @param cipherSuites The cipher suites.
+     */
+    public void setEnabledCipherSuites(final String[] cipherSuites) {
+        suites = cipherSuites.clone();
+    }
+
+    /**
+     * Controls which particular protocol versions are enabled for use on this
+     * connection. I perform setting before a server negotiation.
+     * @param protocolVersions The protocol versions.
+     */
+    public void setEnabledProtocols(final String[] protocolVersions) {
+        protocols = protocolVersions.clone();
+    }
+
+    /**
+     * Controls whether a new SSL session may be established by this socket.
+     * @param isCreation The established socket flag.
+     */
+    public void setEnabledSessionCreation(final boolean isCreation) {
+        this.isCreation = isCreation;
+    }
+
+    /**
+     * Automatic endpoint identification checking using the HTTPS algorithm
+     * is supported on Java 1.7+. The default behavior is for this to be disabled.
+     *
+     * This check is only performed on client mode connections.
+     *
+     * @param enable Enable automatic endpoint identification checking using the HTTPS algorithm on Java 1.7+.
+     * @since 3.4
+     */
+    public void setEndpointCheckingEnabled(final boolean enable)
+    {
+        tlsEndpointChecking = enable;
+    }
+
+    /**
+     * Override the default {@link HostnameVerifier} to use.
+     * The verifier is only used on client mode connections.
+     * @param newHostnameVerifier The HostnameVerifier implementation to set or <code>null</code> to disable.
+     * @since 3.4
+     */
+    public void setHostnameVerifier(final HostnameVerifier newHostnameVerifier)
+    {
+        hostnameVerifier = newHostnameVerifier;
+    }
+
+    /**
+    * Set a {@link KeyManager} to use
+    *
+    * @param keyManager The KeyManager implementation to set.
+    * @see org.apache.commons.net.util.KeyManagerUtils
+    */
+    public void setKeyManager(final KeyManager keyManager) {
+        this.keyManager = keyManager;
+    }
+
+    /**
+     * Configures the socket to require client authentication.
+     * @param isNeedClientAuth The need client auth flag.
+     */
+    public void setNeedClientAuth(final boolean isNeedClientAuth) {
+        this.isNeedClientAuth = isNeedClientAuth;
+    }
+
+    // DEPRECATED - for API compatibility only - DO NOT USE
+
+    /**
+     * Override the default {@link TrustManager} to use; if set to {@code null},
+     * the default TrustManager from the JVM will be used.
+     *
+     * @param trustManager The TrustManager implementation to set, may be {@code null}
+     * @see org.apache.commons.net.util.TrustManagerUtils
+     */
+    public void setTrustManager(final TrustManager trustManager) {
+        this.trustManager = trustManager;
+    }
+
+    /**
+     * Configures the socket to use client (or server) mode in its first
+     * handshake.
+     * @param isClientMode The use client mode flag.
+     */
+    public void setUseClientMode(final boolean isClientMode) {
+        this.isClientMode = isClientMode;
+    }
+
+    /**
+     * Configures the socket to request client authentication,
+     * but only if such a request is appropriate to the cipher
+     * suite negotiated.
+     * @param isWantClientAuth The want client auth flag.
+     */
+    public void setWantClientAuth(final boolean isWantClientAuth) {
+        this.isWantClientAuth = isWantClientAuth;
+    }
+
+    /**
+     * SSL/TLS negotiation. Acquires an SSL socket of a control
+     * connection and carries out handshake processing.
+     * @throws IOException If server negotiation fails
+     */
+    protected void sslNegotiation() throws IOException {
+        plainSocket = _socket_;
+        initSslContext();
+        final SSLSocket socket = createSSLSocket(_socket_);
+        socket.setEnableSessionCreation(isCreation);
+        socket.setUseClientMode(isClientMode);
+
+        // client mode
+        if (isClientMode) {
+            if (tlsEndpointChecking) {
+                SSLSocketUtils.enableEndpointNameVerification(socket);
+            }
+        } else { // server mode
+            socket.setNeedClientAuth(isNeedClientAuth);
+            socket.setWantClientAuth(isWantClientAuth);
+        }
+
+        if (protocols != null) {
+            socket.setEnabledProtocols(protocols);
+        }
+        if (suites != null) {
+            socket.setEnabledCipherSuites(suites);
+        }
+        socket.startHandshake();
+
+        // TODO the following setup appears to duplicate that in the super class methods
+        _socket_ = socket;
+        _controlInput_ = new BufferedReader(new InputStreamReader(
+                socket .getInputStream(), getControlEncoding()));
+        _controlOutput_ = new BufferedWriter(new OutputStreamWriter(
+                socket.getOutputStream(), getControlEncoding()));
+
+        if (isClientMode && (hostnameVerifier != null &&
+            !hostnameVerifier.verify(_hostname_, socket.getSession()))) {
+            throw new SSLHandshakeException("Hostname doesn't match certificate");
+        }
+    }
+
+}
+/* kate: indent-width 4; replace-tabs on; */
diff --git a/src/main/java/org/apache/commons/net/nntp/Threader.java b/src/main/java/org/apache/commons/net/nntp/Threader.java
index 481fcde09..55f476ec7 100644
--- a/src/main/java/org/apache/commons/net/nntp/Threader.java
+++ b/src/main/java/org/apache/commons/net/nntp/Threader.java
@@ -1,464 +1,464 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.commons.net.nntp;
-
-/**
- * This is an implementation of a message threading algorithm, as originally devised by Zamie Zawinski.
- * See <a href="http://www.jwz.org/doc/threading.html">http://www.jwz.org/doc/threading.html</a> for details.
- * For his Java implementation, see
- * <a href="http://lxr.mozilla.org/mozilla/source/grendel/sources/grendel/view/Threader.java">
- * http://lxr.mozilla.org/mozilla/source/grendel/sources/grendel/view/Threader.java</a>
- */
-
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-public class Threader {
-
-    /**
-     *
-     * @param threadable
-     * @param idTable
-     */
-    private void buildContainer(final Threadable threadable, final HashMap<String,ThreadContainer> idTable) {
-        String id = threadable.messageThreadId();
-        ThreadContainer container = idTable.get(id);
-        int bogusIdCount = 0;
-
-        // A ThreadContainer exists for this id already. This should be a forward reference, but may
-        // be a duplicate id, in which case we will need to generate a bogus placeholder id
-        if (container != null) {
-            if (container.threadable != null) { // oops! duplicate ids...
-                bogusIdCount++ ; // Avoid dead local store warning
-                id = "<Bogus-id:" + (bogusIdCount) + ">";
-                container = null;
-            } else {
-                // The container just contained a forward reference to this message, so let's
-                // fill in the threadable field of the container with this message
-                container.threadable = threadable;
-            }
-        }
-
-        // No container exists for that message Id. Create one and insert it into the hash table.
-        if (container == null) {
-            container = new ThreadContainer();
-            container.threadable = threadable;
-            idTable.put(id, container);
-        }
-
-        // Iterate through all of the references and create ThreadContainers for any references that
-        // don't have them.
-        ThreadContainer parentRef = null;
-        {
-            final String[] references = threadable.messageThreadReferences();
-            for (final String refString : references)
-            {
-                ThreadContainer ref = idTable.get(refString);
-
-                // if this id doesnt have a container, create one
-                if (ref == null) {
-                    ref = new ThreadContainer();
-                    idTable.put(refString, ref);
-                }
-
-                // Link references together in the order they appear in the References: header,
-                // IF they dont have a have a parent already &&
-                // IF it will not cause a circular reference
-                if ((parentRef != null)
-                    && (ref.parent == null)
-                    && (parentRef != ref)
-                    && !(ref.findChild(parentRef))) {
-                    // Link ref into the parent's child list
-                    ref.parent = parentRef;
-                    ref.next = parentRef.child;
-                    parentRef.child = ref;
-                }
-                parentRef = ref;
-            }
-        }
-
-        // parentRef is now set to the container of the last element in the references field. make that
-        // be the parent of this container, unless doing so causes a circular reference
-        if (parentRef != null
-            && (parentRef == container || container.findChild(parentRef)))
-        {
-            parentRef = null;
-        }
-
-        // if it has a parent already, its because we saw this message in a References: field, and presumed
-        // a parent based on the other entries in that field. Now that we have the actual message, we can
-        // throw away the old parent and use this new one
-        if (container.parent != null) {
-            ThreadContainer rest, prev;
-
-            for (prev = null, rest = container.parent.child;
-                rest != null;
-                prev = rest, rest = rest.next) {
-                if (rest == container) {
-                    break;
-                }
-            }
-
-            if (rest == null) {
-                throw new RuntimeException(
-                    "Didnt find "
-                        + container
-                        + " in parent"
-                        + container.parent);
-            }
-
-            // Unlink this container from the parent's child list
-            if (prev == null) {
-                container.parent.child = container.next;
-            } else {
-                prev.next = container.next;
-            }
-
-            container.next = null;
-            container.parent = null;
-        }
-
-        // If we have a parent, link container into the parents child list
-        if (parentRef != null) {
-            container.parent = parentRef;
-            container.next = parentRef.child;
-            parentRef.child = container;
-        }
-    }
-
-    /**
-     * Find the root set of all existing ThreadContainers
-     * @param idTable
-     * @return root the ThreadContainer representing the root node
-     */
-    private ThreadContainer findRootSet(final HashMap<String, ThreadContainer> idTable) {
-        final ThreadContainer root = new ThreadContainer();
-        for (final Map.Entry<String, ThreadContainer> entry : idTable.entrySet()) {
-            final ThreadContainer c = entry.getValue();
-            if (c.parent == null) {
-                if (c.next != null) {
-                    throw new RuntimeException("c.next is " + c.next.toString());
-                }
-                c.next = root.child;
-                root.child = c;
-            }
-        }
-        return root;
-    }
-
-    /**
-     *  If any two members of the root set have the same subject, merge them.
-     *  This is to attempt to accomodate messages without References: headers.
-     * @param root
-     */
-    private void gatherSubjects(final ThreadContainer root) {
-
-        int count = 0;
-
-        for (ThreadContainer c = root.child; c != null; c = c.next) {
-            count++;
-        }
-
-        // TODO verify this will avoid rehashing
-        HashMap<String, ThreadContainer> subjectTable = new HashMap<>((int) (count * 1.2), (float) 0.9);
-        count = 0;
-
-        for (ThreadContainer c = root.child; c != null; c = c.next) {
-            Threadable threadable = c.threadable;
-
-            // No threadable? If so, it is a dummy node in the root set.
-            // Only root set members may be dummies, and they alway have at least 2 kids
-            // Take the first kid as representative of the subject
-            if (threadable == null) {
-                threadable = c.child.threadable;
-            }
-
-            final String subj = threadable.simplifiedSubject();
-
-            if (subj == null || subj.isEmpty()) {
-                continue;
-            }
-
-            final ThreadContainer old = subjectTable.get(subj);
-
-            // Add this container to the table iff:
-            // - There exists no container with this subject
-            // - or this is a dummy container and the old one is not - the dummy one is
-            // more interesting as a root, so put it in the table instead
-            // - The container in the table has a "Re:" version of this subject, and
-            // this container has a non-"Re:" version of this subject. The non-"Re:" version
-            // is the more interesting of the two.
-            if (old == null
-                || (c.threadable == null && old.threadable != null)
-                || (old.threadable != null
-                    && old.threadable.subjectIsReply()
-                    && c.threadable != null
-                    && !c.threadable.subjectIsReply())) {
-                subjectTable.put(subj, c);
-                count++;
-            }
-        }
-
-        // If the table is empty, we're done
-        if (count == 0) {
-            return;
-        }
-
-        // subjectTable is now populated with one entry for each subject which occurs in the
-        // root set. Iterate over the root set, and gather together the difference.
-        ThreadContainer prev, c, rest;
-        for (prev = null, c = root.child, rest = c.next;
-            c != null;
-            prev = c, c = rest, rest = (rest == null ? null : rest.next)) {
-            Threadable threadable = c.threadable;
-
-            // is it a dummy node?
-            if (threadable == null) {
-                threadable = c.child.threadable;
-            }
-
-            final String subj = threadable.simplifiedSubject();
-
-            // Dont thread together all subjectless messages
-            if (subj == null || subj.isEmpty()) {
-                continue;
-            }
-
-            final ThreadContainer old = subjectTable.get(subj);
-
-            if (old == c) { // That's us
-                continue;
-            }
-
-            // We have now found another container in the root set with the same subject
-            // Remove the "second" message from the root set
-            if (prev == null) {
-                root.child = c.next;
-            } else {
-                prev.next = c.next;
-            }
-            c.next = null;
-
-            if (old.threadable == null && c.threadable == null) {
-                // both dummies - merge them
-                ThreadContainer tail;
-                for (tail = old.child;
-                    tail != null && tail.next != null;
-                    tail = tail.next) {
-                    // do nothing
-                }
-
-                if (tail != null) { // protect against possible NPE
-                    tail.next = c.child;
-                }
-
-                for (tail = c.child; tail != null; tail = tail.next) {
-                    tail.parent = old;
-                }
-
-                c.child = null;
-            } else if (
-                old.threadable == null
-                    || (c.threadable != null
-                        && c.threadable.subjectIsReply()
-                        && !old.threadable.subjectIsReply())) {
-                // Else if old is empty, or c has "Re:" and old does not  ==> make this message a child of old
-                c.parent = old;
-                c.next = old.child;
-                old.child = c;
-            } else {
-                // else make the old and new messages be children of a new dummy container.
-                // We create a new container object for old.msg and empty the old container
-                final ThreadContainer newc = new ThreadContainer();
-                newc.threadable = old.threadable;
-                newc.child = old.child;
-
-                for (ThreadContainer tail = newc.child;
-                    tail != null;
-                    tail = tail.next)
-                {
-                    tail.parent = newc;
-                }
-
-                old.threadable = null;
-                old.child = null;
-
-                c.parent = old;
-                newc.parent = old;
-
-                // Old is now a dummy- give it 2 kids , c and newc
-                old.child = c;
-                c.next = newc;
-            }
-            // We've done a merge, so keep the same prev
-            c = prev;
-        }
-
-        subjectTable.clear();
-        subjectTable = null;
-
-    }
-
-    /**
-     * Delete any empty or dummy ThreadContainers
-     * @param parent
-     */
-    private void pruneEmptyContainers(final ThreadContainer parent) {
-        ThreadContainer container, prev, next;
-        for (prev = null, container = parent.child, next = container.next;
-            container != null;
-            prev = container,
-                container = next,
-                next = (container == null ? null : container.next)) {
-
-            // Is it empty and without any children? If so,delete it
-            if (container.threadable == null && container.child == null) {
-                if (prev == null) {
-                    parent.child = container.next;
-                } else {
-                    prev.next = container.next;
-                }
-
-                // Set container to prev so that prev keeps its same value the next time through the loop
-                container = prev;
-            }
-
-            // Else if empty, with kids, and (not at root or only one kid)
-            else if (
-                container.threadable == null
-                    && container.child != null
-                    && (container.parent != null
-                        || container.child.next == null)) {
-                // We have an invalid/expired message with kids. Promote the kids to this level.
-                ThreadContainer tail;
-                final ThreadContainer kids = container.child;
-
-                // Remove this container and replace with 'kids'.
-                if (prev == null) {
-                    parent.child = kids;
-                } else {
-                    prev.next = kids;
-                }
-
-                // Make each child's parent be this level's parent -> i.e. promote the children.
-                // Make the last child's next point to this container's next
-                // i.e. splice kids into the list in place of container
-                for (tail = kids; tail.next != null; tail = tail.next) {
-                    tail.parent = container.parent;
-                }
-
-                tail.parent = container.parent;
-                tail.next = container.next;
-
-                // next currently points to the item after the inserted items in the chain - reset that so we process the newly
-                // promoted items next time round
-                next = kids;
-
-                // Set container to prev so that prev keeps its same value the next time through the loop
-                container = prev;
-            } else if (container.child != null) {
-                // A real message , with kids
-                // Iterate over the children
-                pruneEmptyContainers(container);
-            }
-        }
-    }
-
-    /**
-     * The client passes in a list of Iterable objects, and
-     * the Threader constructs a connected 'graph' of messages
-     * @param messages iterable of messages to thread, must not be empty
-     * @return null if messages == null or root.child == null or messages list is empty
-     * @since 3.0
-     */
-    public Threadable thread(final Iterable<? extends Threadable> messages) {
-        if (messages == null) {
-            return null;
-        }
-
-        HashMap<String,ThreadContainer> idTable = new HashMap<>();
-
-        // walk through each Threadable element
-        for (final Threadable t : messages) {
-            if (!t.isDummy()) {
-                buildContainer(t, idTable);
-            }
-        }
-
-        if (idTable.isEmpty()) {
-            return null;
-        }
-
-        final ThreadContainer root = findRootSet(idTable);
-        idTable.clear();
-        idTable = null;
-
-        pruneEmptyContainers(root);
-
-        root.reverseChildren();
-        gatherSubjects(root);
-
-        if (root.next != null) {
-            throw new RuntimeException("root node has a next:" + root);
-        }
-
-        for (ThreadContainer r = root.child; r != null; r = r.next) {
-            if (r.threadable == null) {
-                r.threadable = r.child.threadable.makeDummy();
-            }
-        }
-
-        final Threadable result = (root.child == null ? null : root.child.threadable);
-        root.flush();
-
-        return result;
-    }
-
-    /**
-     * The client passes in a list of Threadable objects, and
-     * the Threader constructs a connected 'graph' of messages
-     * @param messages list of messages to thread, must not be empty
-     * @return null if messages == null or root.child == null or messages list is empty
-     * @since 2.2
-     */
-    public Threadable thread(final List<? extends Threadable> messages) {
-        return thread((Iterable<? extends Threadable>)messages);
-    }
-
-
-    // DEPRECATED METHODS - for API compatibility only - DO NOT USE
-
-    /**
-     * The client passes in an array of Threadable objects, and
-     * the Threader constructs a connected 'graph' of messages
-     * @param messages array of messages to thread, must not be empty
-     * @return null if messages == null or root.child == null or messages array is empty
-     * @deprecated (2.2) prefer {@link #thread(List)}
-     */
-    @Deprecated
-    public Threadable thread(final Threadable[] messages) {
-        if (messages == null) {
-            return null;
-        }
-        return thread(Arrays.asList(messages));
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.commons.net.nntp;
+
+/**
+ * This is an implementation of a message threading algorithm, as originally devised by Zamie Zawinski.
+ * See <a href="http://www.jwz.org/doc/threading.html">http://www.jwz.org/doc/threading.html</a> for details.
+ * For his Java implementation, see
+ * <a href="http://lxr.mozilla.org/mozilla/source/grendel/sources/grendel/view/Threader.java">
+ * http://lxr.mozilla.org/mozilla/source/grendel/sources/grendel/view/Threader.java</a>
+ */
+
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class Threader {
+
+    /**
+     *
+     * @param threadable
+     * @param idTable
+     */
+    private void buildContainer(final Threadable threadable, final HashMap<String,ThreadContainer> idTable) {
+        String id = threadable.messageThreadId();
+        ThreadContainer container = idTable.get(id);
+        int bogusIdCount = 0;
+
+        // A ThreadContainer exists for this id already. This should be a forward reference, but may
+        // be a duplicate id, in which case we will need to generate a bogus placeholder id
+        if (container != null) {
+            if (container.threadable != null) { // oops! duplicate ids...
+                bogusIdCount++ ; // Avoid dead local store warning
+                id = "<Bogus-id:" + (bogusIdCount) + ">";
+                container = null;
+            } else {
+                // The container just contained a forward reference to this message, so let's
+                // fill in the threadable field of the container with this message
+                container.threadable = threadable;
+            }
+        }
+
+        // No container exists for that message Id. Create one and insert it into the hash table.
+        if (container == null) {
+            container = new ThreadContainer();
+            container.threadable = threadable;
+            idTable.put(id, container);
+        }
+
+        // Iterate through all of the references and create ThreadContainers for any references that
+        // don't have them.
+        ThreadContainer parentRef = null;
+        {
+            final String[] references = threadable.messageThreadReferences();
+            for (final String refString : references)
+            {
+                ThreadContainer ref = idTable.get(refString);
+
+                // if this id doesnt have a container, create one
+                if (ref == null) {
+                    ref = new ThreadContainer();
+                    idTable.put(refString, ref);
+                }
+
+                // Link references together in the order they appear in the References: header,
+                // IF they dont have a have a parent already &&
+                // IF it will not cause a circular reference
+                if ((parentRef != null)
+                    && (ref.parent == null)
+                    && (parentRef != ref)
+                    && !(ref.findChild(parentRef))) {
+                    // Link ref into the parent's child list
+                    ref.parent = parentRef;
+                    ref.next = parentRef.child;
+                    parentRef.child = ref;
+                }
+                parentRef = ref;
+            }
+        }
+
+        // parentRef is now set to the container of the last element in the references field. make that
+        // be the parent of this container, unless doing so causes a circular reference
+        if (parentRef != null
+            && (parentRef == container || container.findChild(parentRef)))
+        {
+            parentRef = null;
+        }
+
+        // if it has a parent already, its because we saw this message in a References: field, and presumed
+        // a parent based on the other entries in that field. Now that we have the actual message, we can
+        // throw away the old parent and use this new one
+        if (container.parent != null) {
+            ThreadContainer rest, prev;
+
+            for (prev = null, rest = container.parent.child;
+                rest != null;
+                prev = rest, rest = rest.next) {
+                if (rest == container) {
+                    break;
+                }
+            }
+
+            if (rest == null) {
+                throw new RuntimeException(
+                    "Didnt find "
+                        + container
+                        + " in parent"
+                        + container.parent);
+            }
+
+            // Unlink this container from the parent's child list
+            if (prev == null) {
+                container.parent.child = container.next;
+            } else {
+                prev.next = container.next;
+            }
+
+            container.next = null;
+            container.parent = null;
+        }
+
+        // If we have a parent, link container into the parents child list
+        if (parentRef != null) {
+            container.parent = parentRef;
+            container.next = parentRef.child;
+            parentRef.child = container;
+        }
+    }
+
+    /**
+     * Find the root set of all existing ThreadContainers
+     * @param idTable
+     * @return root the ThreadContainer representing the root node
+     */
+    private ThreadContainer findRootSet(final HashMap<String, ThreadContainer> idTable) {
+        final ThreadContainer root = new ThreadContainer();
+        for (final Map.Entry<String, ThreadContainer> entry : idTable.entrySet()) {
+            final ThreadContainer c = entry.getValue();
+            if (c.parent == null) {
+                if (c.next != null) {
+                    throw new RuntimeException("c.next is " + c.next.toString());
+                }
+                c.next = root.child;
+                root.child = c;
+            }
+        }
+        return root;
+    }
+
+    /**
+     *  If any two members of the root set have the same subject, merge them.
+     *  This is to attempt to accomodate messages without References: headers.
+     * @param root
+     */
+    private void gatherSubjects(final ThreadContainer root) {
+
+        int count = 0;
+
+        for (ThreadContainer c = root.child; c != null; c = c.next) {
+            count++;
+        }
+
+        // TODO verify this will avoid rehashing
+        HashMap<String, ThreadContainer> subjectTable = new HashMap<>((int) (count * 1.2), (float) 0.9);
+        count = 0;
+
+        for (ThreadContainer c = root.child; c != null; c = c.next) {
+            Threadable threadable = c.threadable;
+
+            // No threadable? If so, it is a dummy node in the root set.
+            // Only root set members may be dummies, and they alway have at least 2 kids
+            // Take the first kid as representative of the subject
+            if (threadable == null) {
+                threadable = c.child.threadable;
+            }
+
+            final String subj = threadable.simplifiedSubject();
+
+            if (subj == null || subj.isEmpty()) {
+                continue;
+            }
+
+            final ThreadContainer old = subjectTable.get(subj);
+
+            // Add this container to the table iff:
+            // - There exists no container with this subject
+            // - or this is a dummy container and the old one is not - the dummy one is
+            // more interesting as a root, so put it in the table instead
+            // - The container in the table has a "Re:" version of this subject, and
+            // this container has a non-"Re:" version of this subject. The non-"Re:" version
+            // is the more interesting of the two.
+            if (old == null
+                || (c.threadable == null && old.threadable != null)
+                || (old.threadable != null
+                    && old.threadable.subjectIsReply()
+                    && c.threadable != null
+                    && !c.threadable.subjectIsReply())) {
+                subjectTable.put(subj, c);
+                count++;
+            }
+        }
+
+        // If the table is empty, we're done
+        if (count == 0) {
+            return;
+        }
+
+        // subjectTable is now populated with one entry for each subject which occurs in the
+        // root set. Iterate over the root set, and gather together the difference.
+        ThreadContainer prev, c, rest;
+        for (prev = null, c = root.child, rest = c.next;
+            c != null;
+            prev = c, c = rest, rest = (rest == null ? null : rest.next)) {
+            Threadable threadable = c.threadable;
+
+            // is it a dummy node?
+            if (threadable == null) {
+                threadable = c.child.threadable;
+            }
+
+            final String subj = threadable.simplifiedSubject();
+
+            // Dont thread together all subjectless messages
+            if (subj == null || subj.isEmpty()) {
+                continue;
+            }
+
+            final ThreadContainer old = subjectTable.get(subj);
+
+            if (old == c) { // That's us
+                continue;
+            }
+
+            // We have now found another container in the root set with the same subject
+            // Remove the "second" message from the root set
+            if (prev == null) {
+                root.child = c.next;
+            } else {
+                prev.next = c.next;
+            }
+            c.next = null;
+
+            if (old.threadable == null && c.threadable == null) {
+                // both dummies - merge them
+                ThreadContainer tail;
+                for (tail = old.child;
+                    tail != null && tail.next != null;
+                    tail = tail.next) {
+                    // do nothing
+                }
+
+                if (tail != null) { // protect against possible NPE
+                    tail.next = c.child;
+                }
+
+                for (tail = c.child; tail != null; tail = tail.next) {
+                    tail.parent = old;
+                }
+
+                c.child = null;
+            } else if (
+                old.threadable == null
+                    || (c.threadable != null
+                        && c.threadable.subjectIsReply()
+                        && !old.threadable.subjectIsReply())) {
+                // Else if old is empty, or c has "Re:" and old does not  ==> make this message a child of old
+                c.parent = old;
+                c.next = old.child;
+                old.child = c;
+            } else {
+                // else make the old and new messages be children of a new dummy container.
+                // We create a new container object for old.msg and empty the old container
+                final ThreadContainer newc = new ThreadContainer();
+                newc.threadable = old.threadable;
+                newc.child = old.child;
+
+                for (ThreadContainer tail = newc.child;
+                    tail != null;
+                    tail = tail.next)
+                {
+                    tail.parent = newc;
+                }
+
+                old.threadable = null;
+                old.child = null;
+
+                c.parent = old;
+                newc.parent = old;
+
+                // Old is now a dummy- give it 2 kids , c and newc
+                old.child = c;
+                c.next = newc;
+            }
+            // We've done a merge, so keep the same prev
+            c = prev;
+        }
+
+        subjectTable.clear();
+        subjectTable = null;
+
+    }
+
+    /**
+     * Delete any empty or dummy ThreadContainers
+     * @param parent
+     */
+    private void pruneEmptyContainers(final ThreadContainer parent) {
+        ThreadContainer container, prev, next;
+        for (prev = null, container = parent.child, next = container.next;
+            container != null;
+            prev = container,
+                container = next,
+                next = (container == null ? null : container.next)) {
+
+            // Is it empty and without any children? If so,delete it
+            if (container.threadable == null && container.child == null) {
+                if (prev == null) {
+                    parent.child = container.next;
+                } else {
+                    prev.next = container.next;
+                }
+
+                // Set container to prev so that prev keeps its same value the next time through the loop
+                container = prev;
+            }
+
+            // Else if empty, with kids, and (not at root or only one kid)
+            else if (
+                container.threadable == null
+                    && container.child != null
+                    && (container.parent != null
+                        || container.child.next == null)) {
+                // We have an invalid/expired message with kids. Promote the kids to this level.
+                ThreadContainer tail;
+                final ThreadContainer kids = container.child;
+
+                // Remove this container and replace with 'kids'.
+                if (prev == null) {
+                    parent.child = kids;
+                } else {
+                    prev.next = kids;
+                }
+
+                // Make each child's parent be this level's parent -> i.e. promote the children.
+                // Make the last child's next point to this container's next
+                // i.e. splice kids into the list in place of container
+                for (tail = kids; tail.next != null; tail = tail.next) {
+                    tail.parent = container.parent;
+                }
+
+                tail.parent = container.parent;
+                tail.next = container.next;
+
+                // next currently points to the item after the inserted items in the chain - reset that so we process the newly
+                // promoted items next time round
+                next = kids;
+
+                // Set container to prev so that prev keeps its same value the next time through the loop
+                container = prev;
+            } else if (container.child != null) {
+                // A real message , with kids
+                // Iterate over the children
+                pruneEmptyContainers(container);
+            }
+        }
+    }
+
+    /**
+     * The client passes in a list of Iterable objects, and
+     * the Threader constructs a connected 'graph' of messages
+     * @param messages iterable of messages to thread, must not be empty
+     * @return null if messages == null or root.child == null or messages list is empty
+     * @since 3.0
+     */
+    public Threadable thread(final Iterable<? extends Threadable> messages) {
+        if (messages == null) {
+            return null;
+        }
+
+        HashMap<String,ThreadContainer> idTable = new HashMap<>();
+
+        // walk through each Threadable element
+        for (final Threadable t : messages) {
+            if (!t.isDummy()) {
+                buildContainer(t, idTable);
+            }
+        }
+
+        if (idTable.isEmpty()) {
+            return null;
+        }
+
+        final ThreadContainer root = findRootSet(idTable);
+        idTable.clear();
+        idTable = null;
+
+        pruneEmptyContainers(root);
+
+        root.reverseChildren();
+        gatherSubjects(root);
+
+        if (root.next != null) {
+            throw new RuntimeException("root node has a next:" + root);
+        }
+
+        for (ThreadContainer r = root.child; r != null; r = r.next) {
+            if (r.threadable == null) {
+                r.threadable = r.child.threadable.makeDummy();
+            }
+        }
+
+        final Threadable result = (root.child == null ? null : root.child.threadable);
+        root.flush();
+
+        return result;
+    }
+
+    /**
+     * The client passes in a list of Threadable objects, and
+     * the Threader constructs a connected 'graph' of messages
+     * @param messages list of messages to thread, must not be empty
+     * @return null if messages == null or root.child == null or messages list is empty
+     * @since 2.2
+     */
+    public Threadable thread(final List<? extends Threadable> messages) {
+        return thread((Iterable<? extends Threadable>)messages);
+    }
+
+
+    // DEPRECATED METHODS - for API compatibility only - DO NOT USE
+
+    /**
+     * The client passes in an array of Threadable objects, and
+     * the Threader constructs a connected 'graph' of messages
+     * @param messages array of messages to thread, must not be empty
+     * @return null if messages == null or root.child == null or messages array is empty
+     * @deprecated (2.2) prefer {@link #thread(List)}
+     */
+    @Deprecated
+    public Threadable thread(final Threadable[] messages) {
+        if (messages == null) {
+            return null;
+        }
+        return thread(Arrays.asList(messages));
+    }
+
+}
diff --git a/src/main/java/org/apache/commons/net/ntp/NTPUDPClient.java b/src/main/java/org/apache/commons/net/ntp/NTPUDPClient.java
index 5939a4ca4..3bce8f7da 100644
--- a/src/main/java/org/apache/commons/net/ntp/NTPUDPClient.java
+++ b/src/main/java/org/apache/commons/net/ntp/NTPUDPClient.java
@@ -1,144 +1,144 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.net.ntp;
-
-import java.io.IOException;
-import java.net.DatagramPacket;
-import java.net.InetAddress;
-
-import org.apache.commons.net.DatagramSocketClient;
-
-/**
- * The NTPUDPClient class is a UDP implementation of a client for the
- * Network Time Protocol (NTP) described in RFC 1305 as well as the
- * Simple Network Time Protocol (SNTP) in RFC-2030. To use the class,
- * merely open a local datagram socket with <a href="#open"> open </a>
- * and call <a href="#getTime"> getTime </a> to retrieve the time. Then call
- * <a href="org.apache.commons.net.DatagramSocketClient.html#close"> close </a>
- * to close the connection properly.
- * Successive calls to <a href="#getTime"> getTime </a> are permitted
- * without re-establishing a connection.  That is because UDP is a
- * connectionless protocol and the Network Time Protocol is stateless.
- *
- */
-
-public final class NTPUDPClient extends DatagramSocketClient
-{
-    /** The default NTP port.  It is set to 123 according to RFC 1305. */
-    public static final int DEFAULT_PORT = 123;
-
-    private int version = NtpV3Packet.VERSION_3;
-
-    /**
-     * Retrieves the time information from the specified server on the
-     * default NTP port and returns it. The time is the number of miliiseconds
-     * since 00:00 (midnight) 1 January 1900 UTC, as specified by RFC 1305.
-     * This method reads the raw NTP packet and constructs a <i>TimeInfo</i>
-     * object that allows access to all the fields of the NTP message header.
-     * <p>
-     * @param host The address of the server.
-     * @return The time value retrieved from the server.
-     * @throws IOException If an error occurs while retrieving the time.
-     */
-    public TimeInfo getTime(final InetAddress host) throws IOException
-    {
-        return getTime(host, NtpV3Packet.NTP_PORT);
-    }
-
-    /**
-     * Retrieves the time information from the specified server and port and
-     * returns it. The time is the number of miliiseconds since
-     * 00:00 (midnight) 1 January 1900 UTC, as specified by RFC 1305.
-     * This method reads the raw NTP packet and constructs a <i>TimeInfo</i>
-     * object that allows access to all the fields of the NTP message header.
-     * <p>
-     * @param host The address of the server.
-     * @param port The port of the service.
-     * @return The time value retrieved from the server.
-     * @throws IOException If an error occurs while retrieving the time or if
-     *                     received packet does not match the request.
-     */
-    public TimeInfo getTime(final InetAddress host, final int port) throws IOException
-    {
-        // if not connected then open to next available UDP port
-        if (!isOpen())
-        {
-            open();
-        }
-
-        final NtpV3Packet message = new NtpV3Impl();
-        message.setMode(NtpV3Packet.MODE_CLIENT);
-        message.setVersion(version);
-        final DatagramPacket sendPacket = message.getDatagramPacket();
-        sendPacket.setAddress(host);
-        sendPacket.setPort(port);
-
-        final NtpV3Packet recMessage = new NtpV3Impl();
-        final DatagramPacket receivePacket = recMessage.getDatagramPacket();
-
-        /*
-         * Must minimize the time between getting the current time,
-         * timestamping the packet, and sending it out which
-         * introduces an error in the delay time.
-         * No extraneous logging and initializations here !!!
-         */
-        final TimeStamp now = TimeStamp.getCurrentTime();
-
-        // Note that if you do not set the transmit time field then originating time
-        // in server response is all 0's which is "Thu Feb 07 01:28:16 EST 2036".
-        message.setTransmitTime(now);
-
-        _socket_.send(sendPacket);
-        _socket_.receive(receivePacket);
-
-        final long returnTimeMillis = System.currentTimeMillis();
-
-        // Prevent invalid time information if response does not match request
-        if (!now.equals(recMessage.getOriginateTimeStamp()))
-        {
-            throw new IOException("Originate time does not match the request");
-        }
-
-        // create TimeInfo message container but don't pre-compute the details yet
-        return new TimeInfo(recMessage, returnTimeMillis, false);
-    }
-
-    /**
-     * Returns the NTP protocol version number that client sets on request packet
-     * that is sent to remote host (e.g. 3=NTP v3, 4=NTP v4, etc.)
-     *
-     * @return  the NTP protocol version number that client sets on request packet.
-     * @see #setVersion(int)
-     */
-    public int getVersion()
-    {
-        return version;
-    }
-
-    /**
-     * Sets the NTP protocol version number that client sets on request packet
-     * communicate with remote host.
-     *
-     * @param version the NTP protocol version number
-     */
-    public void setVersion(final int version)
-    {
-        this.version = version;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.net.ntp;
+
+import java.io.IOException;
+import java.net.DatagramPacket;
+import java.net.InetAddress;
+
+import org.apache.commons.net.DatagramSocketClient;
+
+/**
+ * The NTPUDPClient class is a UDP implementation of a client for the
+ * Network Time Protocol (NTP) described in RFC 1305 as well as the
+ * Simple Network Time Protocol (SNTP) in RFC-2030. To use the class,
+ * merely open a local datagram socket with <a href="#open"> open </a>
+ * and call <a href="#getTime"> getTime </a> to retrieve the time. Then call
+ * <a href="org.apache.commons.net.DatagramSocketClient.html#close"> close </a>
+ * to close the connection properly.
+ * Successive calls to <a href="#getTime"> getTime </a> are permitted
+ * without re-establishing a connection.  That is because UDP is a
+ * connectionless protocol and the Network Time Protocol is stateless.
+ *
+ */
+
+public final class NTPUDPClient extends DatagramSocketClient
+{
+    /** The default NTP port.  It is set to 123 according to RFC 1305. */
+    public static final int DEFAULT_PORT = 123;
+
+    private int version = NtpV3Packet.VERSION_3;
+
+    /**
+     * Retrieves the time information from the specified server on the
+     * default NTP port and returns it. The time is the number of miliiseconds
+     * since 00:00 (midnight) 1 January 1900 UTC, as specified by RFC 1305.
+     * This method reads the raw NTP packet and constructs a <i>TimeInfo</i>
+     * object that allows access to all the fields of the NTP message header.
+     * <p>
+     * @param host The address of the server.
+     * @return The time value retrieved from the server.
+     * @throws IOException If an error occurs while retrieving the time.
+     */
+    public TimeInfo getTime(final InetAddress host) throws IOException
+    {
+        return getTime(host, NtpV3Packet.NTP_PORT);
+    }
+
+    /**
+     * Retrieves the time information from the specified server and port and
+     * returns it. The time is the number of miliiseconds since
+     * 00:00 (midnight) 1 January 1900 UTC, as specified by RFC 1305.
+     * This method reads the raw NTP packet and constructs a <i>TimeInfo</i>
+     * object that allows access to all the fields of the NTP message header.
+     * <p>
+     * @param host The address of the server.
+     * @param port The port of the service.
+     * @return The time value retrieved from the server.
+     * @throws IOException If an error occurs while retrieving the time or if
+     *                     received packet does not match the request.
+     */
+    public TimeInfo getTime(final InetAddress host, final int port) throws IOException
+    {
+        // if not connected then open to next available UDP port
+        if (!isOpen())
+        {
+            open();
+        }
+
+        final NtpV3Packet message = new NtpV3Impl();
+        message.setMode(NtpV3Packet.MODE_CLIENT);
+        message.setVersion(version);
+        final DatagramPacket sendPacket = message.getDatagramPacket();
+        sendPacket.setAddress(host);
+        sendPacket.setPort(port);
+
+        final NtpV3Packet recMessage = new NtpV3Impl();
+        final DatagramPacket receivePacket = recMessage.getDatagramPacket();
+
+        /*
+         * Must minimize the time between getting the current time,
+         * timestamping the packet, and sending it out which
+         * introduces an error in the delay time.
+         * No extraneous logging and initializations here !!!
+         */
+        final TimeStamp now = TimeStamp.getCurrentTime();
+
+        // Note that if you do not set the transmit time field then originating time
+        // in server response is all 0's which is "Thu Feb 07 01:28:16 EST 2036".
+        message.setTransmitTime(now);
+
+        _socket_.send(sendPacket);
+        _socket_.receive(receivePacket);
+
+        final long returnTimeMillis = System.currentTimeMillis();
+
+        // Prevent invalid time information if response does not match request
+        if (!now.equals(recMessage.getOriginateTimeStamp()))
+        {
+            throw new IOException("Originate time does not match the request");
+        }
+
+        // create TimeInfo message container but don't pre-compute the details yet
+        return new TimeInfo(recMessage, returnTimeMillis, false);
+    }
+
+    /**
+     * Returns the NTP protocol version number that client sets on request packet
+     * that is sent to remote host (e.g. 3=NTP v3, 4=NTP v4, etc.)
+     *
+     * @return  the NTP protocol version number that client sets on request packet.
+     * @see #setVersion(int)
+     */
+    public int getVersion()
+    {
+        return version;
+    }
+
+    /**
+     * Sets the NTP protocol version number that client sets on request packet
+     * communicate with remote host.
+     *
+     * @param version the NTP protocol version number
+     */
+    public void setVersion(final int version)
+    {
+        this.version = version;
+    }
+
+}
diff --git a/src/main/java/org/apache/commons/net/ntp/NtpUtils.java b/src/main/java/org/apache/commons/net/ntp/NtpUtils.java
index 6164779bd..2e406c662 100644
--- a/src/main/java/org/apache/commons/net/ntp/NtpUtils.java
+++ b/src/main/java/org/apache/commons/net/ntp/NtpUtils.java
@@ -1,115 +1,115 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.net.ntp;
-
-/**
- * Common NtpUtils Helper class.
- *
- */
-public final class NtpUtils {
-
-    /**
-      * Returns 32-bit integer address to IPv4 address string "%d.%d.%d.%d" format.
-      *
-      * @param address  the 32-bit address
-      * @return  the raw IP address in a string format.
-      */
-     public static String getHostAddress(final int address)
-     {
-          return ((address >>> 24) & 0xFF) + "." +
-                 ((address >>> 16) & 0xFF) + "." +
-                 ((address >>>  8) & 0xFF) + "." +
-                 ((address >>>  0) & 0xFF);
-     }
-
-    /**
-     * Return human-readable name of message mode type (RFC 1305).
-     *
-     * @param mode the mode type
-     * @return mode name
-     */
-    public static String getModeName(final int mode)
-    {
-        switch (mode) {
-            case NtpV3Packet.MODE_RESERVED:
-                return "Reserved";
-            case NtpV3Packet.MODE_SYMMETRIC_ACTIVE:
-                return "Symmetric Active";
-            case NtpV3Packet.MODE_SYMMETRIC_PASSIVE:
-                return "Symmetric Passive";
-            case NtpV3Packet.MODE_CLIENT:
-                return "Client";
-            case NtpV3Packet.MODE_SERVER:
-                return "Server";
-            case NtpV3Packet.MODE_BROADCAST:
-                return "Broadcast";
-            case NtpV3Packet.MODE_CONTROL_MESSAGE:
-                return "Control";
-            case NtpV3Packet.MODE_PRIVATE:
-                return "Private";
-            default:
-                return "Unknown";
-        }
-    }
-
-    /**
-     * Returns NTP packet reference identifier as IP address.
-     *
-     * @param packet  NTP packet
-     * @return  the packet reference id (as IP address) in "%d.%d.%d.%d" format.
-     */
-     public static String getRefAddress(final NtpV3Packet packet)
-     {
-         final int address = (packet == null) ? 0 : packet.getReferenceId();
-         return getHostAddress(address);
-     }
-
-    /**
-     * Get refId as reference clock string (e.g. GPS, WWV, LCL). If string is
-     * invalid (non-ASCII character) then returns empty string "".
-     * For details refer to the <A HREF="http://www.eecis.udel.edu/~mills/ntp/html/refclock.html#list">Comprehensive
-     * List of Clock Drivers</A>.
-     *
-     * @param message the message to check
-     * @return reference clock string if primary NTP server
-     */
-    public static String getReferenceClock(final NtpV3Packet message) {
-        if (message == null) {
-            return "";
-        }
-        final int refId = message.getReferenceId();
-        if (refId == 0) {
-            return "";
-        }
-        final StringBuilder buf = new StringBuilder(4);
-        // start at highest-order byte (0x4c434c00 -> LCL)
-        for (int shiftBits = 24; shiftBits >= 0; shiftBits -= 8)
-        {
-            final char c = (char) ((refId >>> shiftBits) & 0xff);
-            if (c == 0) { // 0-terminated ASCII string
-                break;
-            }
-            if (!Character.isLetterOrDigit(c)) {
-                return "";
-            }
-            buf.append(c);
-        }
-        return buf.toString();
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.net.ntp;
+
+/**
+ * Common NtpUtils Helper class.
+ *
+ */
+public final class NtpUtils {
+
+    /**
+      * Returns 32-bit integer address to IPv4 address string "%d.%d.%d.%d" format.
+      *
+      * @param address  the 32-bit address
+      * @return  the raw IP address in a string format.
+      */
+     public static String getHostAddress(final int address)
+     {
+          return ((address >>> 24) & 0xFF) + "." +
+                 ((address >>> 16) & 0xFF) + "." +
+                 ((address >>>  8) & 0xFF) + "." +
+                 ((address >>>  0) & 0xFF);
+     }
+
+    /**
+     * Return human-readable name of message mode type (RFC 1305).
+     *
+     * @param mode the mode type
+     * @return mode name
+     */
+    public static String getModeName(final int mode)
+    {
+        switch (mode) {
+            case NtpV3Packet.MODE_RESERVED:
+                return "Reserved";
+            case NtpV3Packet.MODE_SYMMETRIC_ACTIVE:
+                return "Symmetric Active";
+            case NtpV3Packet.MODE_SYMMETRIC_PASSIVE:
+                return "Symmetric Passive";
+            case NtpV3Packet.MODE_CLIENT:
+                return "Client";
+            case NtpV3Packet.MODE_SERVER:
+                return "Server";
+            case NtpV3Packet.MODE_BROADCAST:
+                return "Broadcast";
+            case NtpV3Packet.MODE_CONTROL_MESSAGE:
+                return "Control";
+            case NtpV3Packet.MODE_PRIVATE:
+                return "Private";
+            default:
+                return "Unknown";
+        }
+    }
+
+    /**
+     * Returns NTP packet reference identifier as IP address.
+     *
+     * @param packet  NTP packet
+     * @return  the packet reference id (as IP address) in "%d.%d.%d.%d" format.
+     */
+     public static String getRefAddress(final NtpV3Packet packet)
+     {
+         final int address = (packet == null) ? 0 : packet.getReferenceId();
+         return getHostAddress(address);
+     }
+
+    /**
+     * Get refId as reference clock string (e.g. GPS, WWV, LCL). If string is
+     * invalid (non-ASCII character) then returns empty string "".
+     * For details refer to the <A HREF="http://www.eecis.udel.edu/~mills/ntp/html/refclock.html#list">Comprehensive
+     * List of Clock Drivers</A>.
+     *
+     * @param message the message to check
+     * @return reference clock string if primary NTP server
+     */
+    public static String getReferenceClock(final NtpV3Packet message) {
+        if (message == null) {
+            return "";
+        }
+        final int refId = message.getReferenceId();
+        if (refId == 0) {
+            return "";
+        }
+        final StringBuilder buf = new StringBuilder(4);
+        // start at highest-order byte (0x4c434c00 -> LCL)
+        for (int shiftBits = 24; shiftBits >= 0; shiftBits -= 8)
+        {
+            final char c = (char) ((refId >>> shiftBits) & 0xff);
+            if (c == 0) { // 0-terminated ASCII string
+                break;
+            }
+            if (!Character.isLetterOrDigit(c)) {
+                return "";
+            }
+            buf.append(c);
+        }
+        return buf.toString();
+    }
+
+}
diff --git a/src/main/java/org/apache/commons/net/ntp/NtpV3Impl.java b/src/main/java/org/apache/commons/net/ntp/NtpV3Impl.java
index 318a7145b..02fb0031a 100644
--- a/src/main/java/org/apache/commons/net/ntp/NtpV3Impl.java
+++ b/src/main/java/org/apache/commons/net/ntp/NtpV3Impl.java
@@ -1,699 +1,699 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.net.ntp;
-
-import java.net.DatagramPacket;
-
-/**
- * Implementation of NtpV3Packet with methods converting Java objects to/from
- * the Network Time Protocol (NTP) data message header format described in RFC-1305.
- *
- */
-public class NtpV3Impl implements NtpV3Packet
-{
-
-    private static final int MODE_INDEX = 0;
-    private static final int MODE_SHIFT = 0;
-
-    private static final int VERSION_INDEX = 0;
-    private static final int VERSION_SHIFT = 3;
-
-    private static final int LI_INDEX = 0;
-    private static final int LI_SHIFT = 6;
-
-    private static final int STRATUM_INDEX = 1;
-    private static final int POLL_INDEX = 2;
-    private static final int PRECISION_INDEX = 3;
-
-    private static final int ROOT_DELAY_INDEX = 4;
-    private static final int ROOT_DISPERSION_INDEX = 8;
-    private static final int REFERENCE_ID_INDEX = 12;
-
-    private static final int REFERENCE_TIMESTAMP_INDEX = 16;
-    private static final int ORIGINATE_TIMESTAMP_INDEX = 24;
-    private static final int RECEIVE_TIMESTAMP_INDEX = 32;
-    private static final int TRANSMIT_TIMESTAMP_INDEX = 40;
-
-//    private static final int KEY_IDENTIFIER_INDEX = 48;
-//    private static final int MESSAGE_DIGEST = 54; /* len 16 bytes */
-
-    /**
-     * Convert byte to unsigned integer.
-     * Java only has signed types so we have to do
-     * more work to get unsigned ops.
-     *
-     * @param b input byte
-     * @return unsigned int value of byte
-     */
-    protected static final int ui(final byte b)
-    {
-        final int i = b & 0xFF;
-        return i;
-    }
-
-    /**
-     * Convert byte to unsigned long.
-     * Java only has signed types so we have to do
-     * more work to get unsigned ops
-     *
-     * @param b input byte
-     * @return unsigned long value of byte
-     */
-    protected static final long ul(final byte b)
-    {
-        final long i = b & 0xFF;
-        return i;
-    }
-
-    private final byte[] buf = new byte[48];
-
-    private volatile DatagramPacket dp;
-
-    /** Creates a new instance of NtpV3Impl */
-    public NtpV3Impl()
-    {
-    }
-
-    /**
-     * Compares this object against the specified object.
-     * The result is <code>true</code> if and only if the argument is
-     * not <code>null</code> and is a <code>NtpV3Impl</code> object that
-     * contains the same values as this object.
-     *
-     * @param   obj   the object to compare with.
-     * @return  <code>true</code> if the objects are the same;
-     *          <code>false</code> otherwise.
-     * @since 3.4
-     */
-    @Override
-    public boolean equals(final Object obj)
-    {
-        if (this == obj) {
-            return true;
-        }
-        if (obj == null || getClass() != obj.getClass()) {
-            return false;
-        }
-        final NtpV3Impl other = (NtpV3Impl) obj;
-        return java.util.Arrays.equals(buf, other.buf);
-    }
-
-    /**
-     * Returns the datagram packet with the NTP details already filled in.
-     *
-     * @return a datagram packet.
-     */
-    @Override
-    public synchronized DatagramPacket getDatagramPacket()
-    {
-        if (dp == null) {
-            dp = new DatagramPacket(buf, buf.length);
-            dp.setPort(NTP_PORT);
-        }
-        return dp;
-    }
-
-    /**
-     * @return 4 bytes as 32-bit int
-     */
-    private int getInt(final int index)
-    {
-        final int i = ui(buf[index]) << 24 |
-                ui(buf[index + 1]) << 16 |
-                ui(buf[index + 2]) << 8 |
-                ui(buf[index + 3]);
-
-        return i;
-    }
-
-    /**
-     * Returns leap indicator as defined in RFC-1305 which is a two-bit code:
-     *  0=no warning
-     *  1=last minute has 61 seconds
-     *  2=last minute has 59 seconds
-     *  3=alarm condition (clock not synchronized)
-     *
-     * @return leap indicator as defined in RFC-1305.
-     */
-    @Override
-    public int getLeapIndicator()
-    {
-        return (ui(buf[LI_INDEX]) >> LI_SHIFT) & 0x3;
-    }
-
-    /**
-     * Get Long value represented by bits starting at specified index.
-     *
-     * @return 8 bytes as 64-bit long
-     */
-    private long getLong(final int index)
-    {
-        final long i = ul(buf[index]) << 56 |
-                ul(buf[index + 1]) << 48 |
-                ul(buf[index + 2]) << 40 |
-                ul(buf[index + 3]) << 32 |
-                ul(buf[index + 4]) << 24 |
-                ul(buf[index + 5]) << 16 |
-                ul(buf[index + 6]) << 8 |
-                ul(buf[index + 7]);
-        return i;
-    }
-
-    /**
-     * Returns mode as defined in RFC-1305 which is a 3-bit integer
-     * whose value is indicated by the MODE_xxx parameters.
-     *
-     * @return mode as defined in RFC-1305.
-     */
-    @Override
-    public int getMode()
-    {
-        return (ui(buf[MODE_INDEX]) >> MODE_SHIFT) & 0x7;
-    }
-
-    /**
-     * Return human-readable name of message mode type as described in
-     * RFC 1305.
-     * @return mode name as string.
-     */
-    @Override
-    public String getModeName()
-    {
-        return NtpUtils.getModeName(getMode());
-    }
-
-    /**
-     * Returns the originate time as defined in RFC-1305.
-     *
-     * @return the originate time.
-     * Never returns null.
-     */
-    @Override
-    public TimeStamp getOriginateTimeStamp()
-    {
-        return getTimestamp(ORIGINATE_TIMESTAMP_INDEX);
-    }
-
-    /**
-     * Returns poll interval as defined in RFC-1305, which is an eight-bit
-     * signed integer indicating the maximum interval between successive
-     * messages, in seconds to the nearest power of two (e.g. value of six
-     * indicates an interval of 64 seconds. The values that can appear in
-     * this field range from NTP_MINPOLL to NTP_MAXPOLL inclusive.
-     *
-     * @return poll interval as defined in RFC-1305.
-     */
-    @Override
-    public int getPoll()
-    {
-        return buf[POLL_INDEX];
-    }
-
-    /**
-     * Returns precision as defined in RFC-1305 encoded as an 8-bit signed
-     * integer (seconds to nearest power of two).
-     * Values normally range from -6 to -20.
-     *
-     * @return precision as defined in RFC-1305.
-     */
-    @Override
-    public int getPrecision()
-    {
-        return buf[PRECISION_INDEX];
-    }
-
-    /**
-     * Returns receive timestamp as defined in RFC-1305.
-     *
-     * @return the receive time.
-     * Never returns null.
-     */
-    @Override
-    public TimeStamp getReceiveTimeStamp()
-    {
-        return getTimestamp(RECEIVE_TIMESTAMP_INDEX);
-    }
-
-    /**
-     * Returns the reference id as defined in RFC-1305, which is
-     * a 32-bit integer whose value is dependent on several criteria.
-     *
-     * @return the reference id as defined in RFC-1305.
-     */
-    @Override
-    public int getReferenceId()
-    {
-        return getInt(REFERENCE_ID_INDEX);
-    }
-
-    /**
-     * Returns the reference id string. String cannot be null but
-     * value is dependent on the version of the NTP spec supported
-     * and stratum level. Value can be an empty string, clock type string,
-     * IP address, or a hex string.
-     *
-     * @return the reference id string.
-     */
-    @Override
-    public String getReferenceIdString()
-    {
-        final int version = getVersion();
-        final int stratum = getStratum();
-        if (version == VERSION_3 || version == VERSION_4) {
-            if (stratum == 0 || stratum == 1) {
-                return idAsString(); // 4-character ASCII string (e.g. GPS, USNO)
-            }
-            // in NTPv4 servers this is latest transmit timestamp of ref source
-            if (version == VERSION_4) {
-                return idAsHex();
-            }
-        }
-
-        // Stratum 2 and higher this is a four-octet IPv4 address
-        // of the primary reference host.
-        if (stratum >= 2) {
-            return idAsIPAddress();
-        }
-        return idAsHex();
-    }
-
-    /**
-     * Returns the reference time as defined in RFC-1305.
-     *
-     * @return the reference time as <code>TimeStamp</code> object.
-     * Never returns null.
-     */
-    @Override
-    public TimeStamp getReferenceTimeStamp()
-    {
-        return getTimestamp(REFERENCE_TIMESTAMP_INDEX);
-    }
-
-    /**
-     * Return root delay as defined in RFC-1305, which is the total roundtrip delay
-     * to the primary reference source, in seconds. Values can take positive and
-     * negative values, depending on clock precision and skew.
-     *
-     * @return root delay as defined in RFC-1305.
-     */
-    @Override
-    public int getRootDelay()
-    {
-        return getInt(ROOT_DELAY_INDEX);
-    }
-
-    /**
-     * Return root delay as defined in RFC-1305 in milliseconds, which is
-     * the total roundtrip delay to the primary reference source, in
-     * seconds. Values can take positive and negative values, depending
-     * on clock precision and skew.
-     *
-     * @return root delay in milliseconds
-     */
-    @Override
-    public double getRootDelayInMillisDouble()
-    {
-        final double l = getRootDelay();
-        return l / 65.536;
-    }
-
-    /**
-     * Returns root dispersion as defined in RFC-1305.
-     * @return root dispersion.
-     */
-    @Override
-    public int getRootDispersion()
-    {
-        return getInt(ROOT_DISPERSION_INDEX);
-    }
-
-    /**
-     * Returns root dispersion (as defined in RFC-1305) in milliseconds.
-     *
-     * @return root dispersion in milliseconds
-     */
-    @Override
-    public long getRootDispersionInMillis()
-    {
-        final long l = getRootDispersion();
-        return (l * 1000) / 65536L;
-    }
-
-    /**
-     * Returns root dispersion (as defined in RFC-1305) in milliseconds
-     * as double precision value.
-     *
-     * @return root dispersion in milliseconds
-     */
-    @Override
-    public double getRootDispersionInMillisDouble()
-    {
-        final double l = getRootDispersion();
-        return l / 65.536;
-    }
-
-    /**
-     * Returns Stratum as defined in RFC-1305, which indicates the stratum level
-     * of the local clock, with values defined as follows: 0=unspecified,
-     * 1=primary ref clock, and all others a secondary reference (via NTP).
-     *
-     * @return Stratum level as defined in RFC-1305.
-     */
-    @Override
-    public int getStratum()
-    {
-        return ui(buf[STRATUM_INDEX]);
-    }
-
-    /**
-     * Get NTP Timestamp at specified starting index.
-     *
-     * @param index index into data array
-     * @return TimeStamp object for 64 bits starting at index
-     */
-    private TimeStamp getTimestamp(final int index)
-    {
-        return new TimeStamp(getLong(index));
-    }
-
-    /**
-     * Returns the transmit timestamp as defined in RFC-1305.
-     *
-     * @return the transmit timestamp as defined in RFC-1305.
-     * Never returns a null object.
-     */
-    @Override
-    public TimeStamp getTransmitTimeStamp()
-    {
-        return getTimestamp(TRANSMIT_TIMESTAMP_INDEX);
-    }
-
-    /**
-     * Return type of time packet. The values (e.g. NTP, TIME, ICMP, ...)
-     * correspond to the protocol used to obtain the timing information.
-     *
-     * @return packet type string identifier which in this case is "NTP".
-     */
-    @Override
-    public String getType()
-    {
-        return "NTP";
-    }
-
-    /**
-     * Returns NTP version number as defined in RFC-1305.
-     *
-     * @return NTP version number.
-     */
-    @Override
-    public int getVersion()
-    {
-        return (ui(buf[VERSION_INDEX]) >> VERSION_SHIFT) & 0x7;
-    }
-
-    /**
-     * Computes a hashcode for this object. The result is the exclusive
-     * OR of the values of this object stored as a byte array.
-     *
-     * @return  a hash code value for this object.
-     * @since 3.4
-     */
-    @Override
-    public int hashCode()
-    {
-        return java.util.Arrays.hashCode(buf);
-    }
-
-    private String idAsHex()
-    {
-        return Integer.toHexString(getReferenceId());
-    }
-
-    /**
-     * Returns Reference id as dotted IP address.
-     * @return refId as IP address string.
-     */
-    private String idAsIPAddress()
-    {
-        return ui(buf[REFERENCE_ID_INDEX]) + "." +
-                ui(buf[REFERENCE_ID_INDEX + 1]) + "." +
-                ui(buf[REFERENCE_ID_INDEX + 2]) + "." +
-                ui(buf[REFERENCE_ID_INDEX + 3]);
-    }
-
-    private String idAsString()
-    {
-        final StringBuilder id = new StringBuilder();
-        for (int i = 0; i <= 3; i++) {
-            final char c = (char) buf[REFERENCE_ID_INDEX + i];
-            if (c == 0) {  // 0-terminated string
-                break;
-            }
-            id.append(c);
-        }
-        return id.toString();
-    }
-
-    /**
-     * Set the contents of this object from source datagram packet.
-     *
-     * @param srcDp source DatagramPacket to copy contents from, never null.
-     * @throws IllegalArgumentException if srcDp is null or byte length is less than minimum length of 48 bytes
-     */
-    @Override
-    public void setDatagramPacket(final DatagramPacket srcDp)
-    {
-        if (srcDp == null || srcDp.getLength() < buf.length) {
-            throw new IllegalArgumentException();
-        }
-        final byte[] incomingBuf = srcDp.getData();
-        int len = srcDp.getLength();
-        if (len > buf.length) {
-            len = buf.length;
-        }
-        System.arraycopy(incomingBuf, 0, buf, 0, len);
-        final DatagramPacket dp = getDatagramPacket();
-        dp.setAddress(srcDp.getAddress());
-        final int port = srcDp.getPort();
-        dp.setPort(port > 0 ? port : NTP_PORT);
-        dp.setData(buf);
-    }
-
-    /**
-     * Set integer value at index position.
-     *
-     * @param idx index position
-     * @param value 32-bit int value
-     */
-    private void setInt(final int idx, int value)
-    {
-        for (int i=3; i >= 0; i--) {
-            buf[idx + i] = (byte) (value & 0xff);
-            value >>>= 8; // shift right one-byte
-        }
-    }
-
-    /**
-     * Set leap indicator as defined in RFC-1305.
-     *
-     * @param li leap indicator.
-     */
-    @Override
-    public void setLeapIndicator(final int li)
-    {
-        buf[LI_INDEX] = (byte) (buf[LI_INDEX] & 0x3F | ((li & 0x3) << LI_SHIFT));
-    }
-
-    /**
-     * Set mode as defined in RFC-1305.
-     *
-     * @param mode the mode to set
-     */
-    @Override
-    public void setMode(final int mode)
-    {
-        buf[MODE_INDEX] = (byte) (buf[MODE_INDEX] & 0xF8 | mode & 0x7);
-    }
-
-    /**
-     * Set originate timestamp given NTP TimeStamp object.
-     * If <code>ts</code> is null then zero time is used.
-     *
-     * @param ts NTP timestamp
-     */
-    @Override
-    public void setOriginateTimeStamp(final TimeStamp ts)
-    {
-        setTimestamp(ORIGINATE_TIMESTAMP_INDEX, ts);
-    }
-
-    /**
-     * Set poll interval as defined in RFC-1305.
-     *
-     * @param poll poll interval.
-     */
-    @Override
-    public void setPoll(final int poll)
-    {
-        buf[POLL_INDEX] = (byte) (poll & 0xFF);
-    }
-
-    /**
-     * Set precision as defined in RFC-1305.
-     * @param precision the precision to set
-     * @since 3.4
-     */
-    @Override
-    public void setPrecision(final int precision)
-    {
-        buf[PRECISION_INDEX] = (byte) (precision & 0xFF);
-    }
-
-    /**
-     * Set receive timestamp given NTP TimeStamp object.
-     * If <code>ts</code> is null then zero time is used.
-     *
-     * @param ts timestamp
-     */
-    @Override
-    public void setReceiveTimeStamp(final TimeStamp ts)
-    {
-        setTimestamp(RECEIVE_TIMESTAMP_INDEX, ts);
-    }
-
-    /**
-     * Set reference clock identifier field with 32-bit unsigned integer value.
-     * See RFC-1305 for description.
-     *
-     * @param refId reference clock identifier.
-     */
-    @Override
-    public void setReferenceId(final int refId)
-    {
-        setInt(REFERENCE_ID_INDEX, refId);
-    }
-
-    /**
-     * Set Reference time with NTP timestamp. If <code>ts</code> is null
-     * then zero time is used.
-     *
-     * @param ts NTP timestamp
-     */
-    @Override
-    public void setReferenceTime(final TimeStamp ts)
-    {
-        setTimestamp(REFERENCE_TIMESTAMP_INDEX, ts);
-    }
-
-    /**
-     * Set root delay as defined in RFC-1305.
-     *
-     * @param delay root delay
-     * @since 3.4
-     */
-    @Override
-    public void setRootDelay(final int delay)
-    {
-        setInt(ROOT_DELAY_INDEX, delay);
-    }
-
-    /**
-     * Set root dispersion as defined in RFC-1305.
-     *
-     * @param dispersion root dispersion
-     * @since 3.4
-     */
-    @Override
-    public void setRootDispersion(final int dispersion)
-    {
-        setInt(ROOT_DISPERSION_INDEX, dispersion);
-    }
-
-    /**
-     * Set stratum level as defined in RFC-1305.
-     *
-     * @param stratum stratum level.
-     */
-    @Override
-    public void setStratum(final int stratum)
-    {
-        buf[STRATUM_INDEX] = (byte) (stratum & 0xFF);
-    }
-
-    /**
-     * Sets the NTP timestamp at the given array index.
-     *
-     * @param index index into the byte array.
-     * @param t TimeStamp.
-     */
-    private void setTimestamp(final int index, final TimeStamp t)
-    {
-        long ntpTime = (t == null) ? 0 : t.ntpValue();
-        // copy 64-bits from Long value into 8 x 8-bit bytes of array
-        // one byte at a time shifting 8-bits for each position.
-        for (int i = 7; i >= 0; i--) {
-            buf[index + i] = (byte) (ntpTime & 0xFF);
-            ntpTime >>>= 8; // shift to next byte
-        }
-        // buf[index] |= 0x80;  // only set if 1900 baseline....
-    }
-
-    /**
-     * Set transmit time with NTP timestamp.
-     * If <code>ts</code> is null then zero time is used.
-     *
-     * @param ts NTP timestamp
-     */
-    @Override
-    public void setTransmitTime(final TimeStamp ts)
-    {
-        setTimestamp(TRANSMIT_TIMESTAMP_INDEX, ts);
-    }
-
-    /**
-     * Set NTP version as defined in RFC-1305.
-     *
-     * @param version NTP version.
-     */
-    @Override
-    public void setVersion(final int version)
-    {
-        buf[VERSION_INDEX] = (byte) (buf[VERSION_INDEX] & 0xC7 | ((version & 0x7) << VERSION_SHIFT));
-    }
-
-    /**
-     * Returns details of NTP packet as a string.
-     *
-     * @return details of NTP packet as a string.
-     */
-    @Override
-    public String toString()
-    {
-        return "[" +
-                "version:" + getVersion() +
-                ", mode:" + getMode() +
-                ", poll:" + getPoll() +
-                ", precision:" + getPrecision() +
-                ", delay:" + getRootDelay() +
-                ", dispersion(ms):" + getRootDispersionInMillisDouble() +
-                ", id:" + getReferenceIdString() +
-                ", xmitTime:" + getTransmitTimeStamp().toDateString() +
-                " ]";
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.net.ntp;
+
+import java.net.DatagramPacket;
+
+/**
+ * Implementation of NtpV3Packet with methods converting Java objects to/from
+ * the Network Time Protocol (NTP) data message header format described in RFC-1305.
+ *
+ */
+public class NtpV3Impl implements NtpV3Packet
+{
+
+    private static final int MODE_INDEX = 0;
+    private static final int MODE_SHIFT = 0;
+
+    private static final int VERSION_INDEX = 0;
+    private static final int VERSION_SHIFT = 3;
+
+    private static final int LI_INDEX = 0;
+    private static final int LI_SHIFT = 6;
+
+    private static final int STRATUM_INDEX = 1;
+    private static final int POLL_INDEX = 2;
+    private static final int PRECISION_INDEX = 3;
+
+    private static final int ROOT_DELAY_INDEX = 4;
+    private static final int ROOT_DISPERSION_INDEX = 8;
+    private static final int REFERENCE_ID_INDEX = 12;
+
+    private static final int REFERENCE_TIMESTAMP_INDEX = 16;
+    private static final int ORIGINATE_TIMESTAMP_INDEX = 24;
+    private static final int RECEIVE_TIMESTAMP_INDEX = 32;
+    private static final int TRANSMIT_TIMESTAMP_INDEX = 40;
+
+//    private static final int KEY_IDENTIFIER_INDEX = 48;
+//    private static final int MESSAGE_DIGEST = 54; /* len 16 bytes */
+
+    /**
+     * Convert byte to unsigned integer.
+     * Java only has signed types so we have to do
+     * more work to get unsigned ops.
+     *
+     * @param b input byte
+     * @return unsigned int value of byte
+     */
+    protected static final int ui(final byte b)
+    {
+        final int i = b & 0xFF;
+        return i;
+    }
+
+    /**
+     * Convert byte to unsigned long.
+     * Java only has signed types so we have to do
+     * more work to get unsigned ops
+     *
+     * @param b input byte
+     * @return unsigned long value of byte
+     */
+    protected static final long ul(final byte b)
+    {
+        final long i = b & 0xFF;
+        return i;
+    }
+
+    private final byte[] buf = new byte[48];
+
+    private volatile DatagramPacket dp;
+
+    /** Creates a new instance of NtpV3Impl */
+    public NtpV3Impl()
+    {
+    }
+
+    /**
+     * Compares this object against the specified object.
+     * The result is <code>true</code> if and only if the argument is
+     * not <code>null</code> and is a <code>NtpV3Impl</code> object that
+     * contains the same values as this object.
+     *
+     * @param   obj   the object to compare with.
+     * @return  <code>true</code> if the objects are the same;
+     *          <code>false</code> otherwise.
+     * @since 3.4
+     */
+    @Override
+    public boolean equals(final Object obj)
+    {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null || getClass() != obj.getClass()) {
+            return false;
+        }
+        final NtpV3Impl other = (NtpV3Impl) obj;
+        return java.util.Arrays.equals(buf, other.buf);
+    }
+
+    /**
+     * Returns the datagram packet with the NTP details already filled in.
+     *
+     * @return a datagram packet.
+     */
+    @Override
+    public synchronized DatagramPacket getDatagramPacket()
+    {
+        if (dp == null) {
+            dp = new DatagramPacket(buf, buf.length);
+            dp.setPort(NTP_PORT);
+        }
+        return dp;
+    }
+
+    /**
+     * @return 4 bytes as 32-bit int
+     */
+    private int getInt(final int index)
+    {
+        final int i = ui(buf[index]) << 24 |
+                ui(buf[index + 1]) << 16 |
+                ui(buf[index + 2]) << 8 |
+                ui(buf[index + 3]);
+
+        return i;
+    }
+
+    /**
+     * Returns leap indicator as defined in RFC-1305 which is a two-bit code:
+     *  0=no warning
+     *  1=last minute has 61 seconds
+     *  2=last minute has 59 seconds
+     *  3=alarm condition (clock not synchronized)
+     *
+     * @return leap indicator as defined in RFC-1305.
+     */
+    @Override
+    public int getLeapIndicator()
+    {
+        return (ui(buf[LI_INDEX]) >> LI_SHIFT) & 0x3;
+    }
+
+    /**
+     * Get Long value represented by bits starting at specified index.
+     *
+     * @return 8 bytes as 64-bit long
+     */
+    private long getLong(final int index)
+    {
+        final long i = ul(buf[index]) << 56 |
+                ul(buf[index + 1]) << 48 |
+                ul(buf[index + 2]) << 40 |
+                ul(buf[index + 3]) << 32 |
+                ul(buf[index + 4]) << 24 |
+                ul(buf[index + 5]) << 16 |
+                ul(buf[index + 6]) << 8 |
+                ul(buf[index + 7]);
+        return i;
+    }
+
+    /**
+     * Returns mode as defined in RFC-1305 which is a 3-bit integer
+     * whose value is indicated by the MODE_xxx parameters.
+     *
+     * @return mode as defined in RFC-1305.
+     */
+    @Override
+    public int getMode()
+    {
+        return (ui(buf[MODE_INDEX]) >> MODE_SHIFT) & 0x7;
+    }
+
+    /**
+     * Return human-readable name of message mode type as described in
+     * RFC 1305.
+     * @return mode name as string.
+     */
+    @Override
+    public String getModeName()
+    {
+        return NtpUtils.getModeName(getMode());
+    }
+
+    /**
+     * Returns the originate time as defined in RFC-1305.
+     *
+     * @return the originate time.
+     * Never returns null.
+     */
+    @Override
+    public TimeStamp getOriginateTimeStamp()
+    {
+        return getTimestamp(ORIGINATE_TIMESTAMP_INDEX);
+    }
+
+    /**
+     * Returns poll interval as defined in RFC-1305, which is an eight-bit
+     * signed integer indicating the maximum interval between successive
+     * messages, in seconds to the nearest power of two (e.g. value of six
+     * indicates an interval of 64 seconds. The values that can appear in
+     * this field range from NTP_MINPOLL to NTP_MAXPOLL inclusive.
+     *
+     * @return poll interval as defined in RFC-1305.
+     */
+    @Override
+    public int getPoll()
+    {
+        return buf[POLL_INDEX];
+    }
+
+    /**
+     * Returns precision as defined in RFC-1305 encoded as an 8-bit signed
+     * integer (seconds to nearest power of two).
+     * Values normally range from -6 to -20.
+     *
+     * @return precision as defined in RFC-1305.
+     */
+    @Override
+    public int getPrecision()
+    {
+        return buf[PRECISION_INDEX];
+    }
+
+    /**
+     * Returns receive timestamp as defined in RFC-1305.
+     *
+     * @return the receive time.
+     * Never returns null.
+     */
+    @Override
+    public TimeStamp getReceiveTimeStamp()
+    {
+        return getTimestamp(RECEIVE_TIMESTAMP_INDEX);
+    }
+
+    /**
+     * Returns the reference id as defined in RFC-1305, which is
+     * a 32-bit integer whose value is dependent on several criteria.
+     *
+     * @return the reference id as defined in RFC-1305.
+     */
+    @Override
+    public int getReferenceId()
+    {
+        return getInt(REFERENCE_ID_INDEX);
+    }
+
+    /**
+     * Returns the reference id string. String cannot be null but
+     * value is dependent on the version of the NTP spec supported
+     * and stratum level. Value can be an empty string, clock type string,
+     * IP address, or a hex string.
+     *
+     * @return the reference id string.
+     */
+    @Override
+    public String getReferenceIdString()
+    {
+        final int version = getVersion();
+        final int stratum = getStratum();
+        if (version == VERSION_3 || version == VERSION_4) {
+            if (stratum == 0 || stratum == 1) {
+                return idAsString(); // 4-character ASCII string (e.g. GPS, USNO)
+            }
+            // in NTPv4 servers this is latest transmit timestamp of ref source
+            if (version == VERSION_4) {
+                return idAsHex();
+            }
+        }
+
+        // Stratum 2 and higher this is a four-octet IPv4 address
+        // of the primary reference host.
+        if (stratum >= 2) {
+            return idAsIPAddress();
+        }
+        return idAsHex();
+    }
+
+    /**
+     * Returns the reference time as defined in RFC-1305.
+     *
+     * @return the reference time as <code>TimeStamp</code> object.
+     * Never returns null.
+     */
+    @Override
+    public TimeStamp getReferenceTimeStamp()
+    {
+        return getTimestamp(REFERENCE_TIMESTAMP_INDEX);
+    }
+
+    /**
+     * Return root delay as defined in RFC-1305, which is the total roundtrip delay
+     * to the primary reference source, in seconds. Values can take positive and
+     * negative values, depending on clock precision and skew.
+     *
+     * @return root delay as defined in RFC-1305.
+     */
+    @Override
+    public int getRootDelay()
+    {
+        return getInt(ROOT_DELAY_INDEX);
+    }
+
+    /**
+     * Return root delay as defined in RFC-1305 in milliseconds, which is
+     * the total roundtrip delay to the primary reference source, in
+     * seconds. Values can take positive and negative values, depending
+     * on clock precision and skew.
+     *
+     * @return root delay in milliseconds
+     */
+    @Override
+    public double getRootDelayInMillisDouble()
+    {
+        final double l = getRootDelay();
+        return l / 65.536;
+    }
+
+    /**
+     * Returns root dispersion as defined in RFC-1305.
+     * @return root dispersion.
+     */
+    @Override
+    public int getRootDispersion()
+    {
+        return getInt(ROOT_DISPERSION_INDEX);
+    }
+
+    /**
+     * Returns root dispersion (as defined in RFC-1305) in milliseconds.
+     *
+     * @return root dispersion in milliseconds
+     */
+    @Override
+    public long getRootDispersionInMillis()
+    {
+        final long l = getRootDispersion();
+        return (l * 1000) / 65536L;
+    }
+
+    /**
+     * Returns root dispersion (as defined in RFC-1305) in milliseconds
+     * as double precision value.
+     *
+     * @return root dispersion in milliseconds
+     */
+    @Override
+    public double getRootDispersionInMillisDouble()
+    {
+        final double l = getRootDispersion();
+        return l / 65.536;
+    }
+
+    /**
+     * Returns Stratum as defined in RFC-1305, which indicates the stratum level
+     * of the local clock, with values defined as follows: 0=unspecified,
+     * 1=primary ref clock, and all others a secondary reference (via NTP).
+     *
+     * @return Stratum level as defined in RFC-1305.
+     */
+    @Override
+    public int getStratum()
+    {
+        return ui(buf[STRATUM_INDEX]);
+    }
+
+    /**
+     * Get NTP Timestamp at specified starting index.
+     *
+     * @param index index into data array
+     * @return TimeStamp object for 64 bits starting at index
+     */
+    private TimeStamp getTimestamp(final int index)
+    {
+        return new TimeStamp(getLong(index));
+    }
+
+    /**
+     * Returns the transmit timestamp as defined in RFC-1305.
+     *
+     * @return the transmit timestamp as defined in RFC-1305.
+     * Never returns a null object.
+     */
+    @Override
+    public TimeStamp getTransmitTimeStamp()
+    {
+        return getTimestamp(TRANSMIT_TIMESTAMP_INDEX);
+    }
+
+    /**
+     * Return type of time packet. The values (e.g. NTP, TIME, ICMP, ...)
+     * correspond to the protocol used to obtain the timing information.
+     *
+     * @return packet type string identifier which in this case is "NTP".
+     */
+    @Override
+    public String getType()
+    {
+        return "NTP";
+    }
+
+    /**
+     * Returns NTP version number as defined in RFC-1305.
+     *
+     * @return NTP version number.
+     */
+    @Override
+    public int getVersion()
+    {
+        return (ui(buf[VERSION_INDEX]) >> VERSION_SHIFT) & 0x7;
+    }
+
+    /**
+     * Computes a hashcode for this object. The result is the exclusive
+     * OR of the values of this object stored as a byte array.
+     *
+     * @return  a hash code value for this object.
+     * @since 3.4
+     */
+    @Override
+    public int hashCode()
+    {
+        return java.util.Arrays.hashCode(buf);
+    }
+
+    private String idAsHex()
+    {
+        return Integer.toHexString(getReferenceId());
+    }
+
+    /**
+     * Returns Reference id as dotted IP address.
+     * @return refId as IP address string.
+     */
+    private String idAsIPAddress()
+    {
+        return ui(buf[REFERENCE_ID_INDEX]) + "." +
+                ui(buf[REFERENCE_ID_INDEX + 1]) + "." +
+                ui(buf[REFERENCE_ID_INDEX + 2]) + "." +
+                ui(buf[REFERENCE_ID_INDEX + 3]);
+    }
+
+    private String idAsString()
+    {
+        final StringBuilder id = new StringBuilder();
+        for (int i = 0; i <= 3; i++) {
+            final char c = (char) buf[REFERENCE_ID_INDEX + i];
+            if (c == 0) {  // 0-terminated string
+                break;
+            }
+            id.append(c);
+        }
+        return id.toString();
+    }
+
+    /**
+     * Set the contents of this object from source datagram packet.
+     *
+     * @param srcDp source DatagramPacket to copy contents from, never null.
+     * @throws IllegalArgumentException if srcDp is null or byte length is less than minimum length of 48 bytes
+     */
+    @Override
+    public void setDatagramPacket(final DatagramPacket srcDp)
+    {
+        if (srcDp == null || srcDp.getLength() < buf.length) {
+            throw new IllegalArgumentException();
+        }
+        final byte[] incomingBuf = srcDp.getData();
+        int len = srcDp.getLength();
+        if (len > buf.length) {
+            len = buf.length;
+        }
+        System.arraycopy(incomingBuf, 0, buf, 0, len);
+        final DatagramPacket dp = getDatagramPacket();
+        dp.setAddress(srcDp.getAddress());
+        final int port = srcDp.getPort();
+        dp.setPort(port > 0 ? port : NTP_PORT);
+        dp.setData(buf);
+    }
+
+    /**
+     * Set integer value at index position.
+     *
+     * @param idx index position
+     * @param value 32-bit int value
+     */
+    private void setInt(final int idx, int value)
+    {
+        for (int i=3; i >= 0; i--) {
+            buf[idx + i] = (byte) (value & 0xff);
+            value >>>= 8; // shift right one-byte
+        }
+    }
+
+    /**
+     * Set leap indicator as defined in RFC-1305.
+     *
+     * @param li leap indicator.
+     */
+    @Override
+    public void setLeapIndicator(final int li)
+    {
+        buf[LI_INDEX] = (byte) (buf[LI_INDEX] & 0x3F | ((li & 0x3) << LI_SHIFT));
+    }
+
+    /**
+     * Set mode as defined in RFC-1305.
+     *
+     * @param mode the mode to set
+     */
+    @Override
+    public void setMode(final int mode)
+    {
+        buf[MODE_INDEX] = (byte) (buf[MODE_INDEX] & 0xF8 | mode & 0x7);
+    }
+
+    /**
+     * Set originate timestamp given NTP TimeStamp object.
+     * If <code>ts</code> is null then zero time is used.
+     *
+     * @param ts NTP timestamp
+     */
+    @Override
+    public void setOriginateTimeStamp(final TimeStamp ts)
+    {
+        setTimestamp(ORIGINATE_TIMESTAMP_INDEX, ts);
+    }
+
+    /**
+     * Set poll interval as defined in RFC-1305.
+     *
+     * @param poll poll interval.
+     */
+    @Override
+    public void setPoll(final int poll)
+    {
+        buf[POLL_INDEX] = (byte) (poll & 0xFF);
+    }
+
+    /**
+     * Set precision as defined in RFC-1305.
+     * @param precision the precision to set
+     * @since 3.4
+     */
+    @Override
+    public void setPrecision(final int precision)
+    {
+        buf[PRECISION_INDEX] = (byte) (precision & 0xFF);
+    }
+
+    /**
+     * Set receive timestamp given NTP TimeStamp object.
+     * If <code>ts</code> is null then zero time is used.
+     *
+     * @param ts timestamp
+     */
+    @Override
+    public void setReceiveTimeStamp(final TimeStamp ts)
+    {
+        setTimestamp(RECEIVE_TIMESTAMP_INDEX, ts);
+    }
+
+    /**
+     * Set reference clock identifier field with 32-bit unsigned integer value.
+     * See RFC-1305 for description.
+     *
+     * @param refId reference clock identifier.
+     */
+    @Override
+    public void setReferenceId(final int refId)
+    {
+        setInt(REFERENCE_ID_INDEX, refId);
+    }
+
+    /**
+     * Set Reference time with NTP timestamp. If <code>ts</code> is null
+     * then zero time is used.
+     *
+     * @param ts NTP timestamp
+     */
+    @Override
+    public void setReferenceTime(final TimeStamp ts)
+    {
+        setTimestamp(REFERENCE_TIMESTAMP_INDEX, ts);
+    }
+
+    /**
+     * Set root delay as defined in RFC-1305.
+     *
+     * @param delay root delay
+     * @since 3.4
+     */
+    @Override
+    public void setRootDelay(final int delay)
+    {
+        setInt(ROOT_DELAY_INDEX, delay);
+    }
+
+    /**
+     * Set root dispersion as defined in RFC-1305.
+     *
+     * @param dispersion root dispersion
+     * @since 3.4
+     */
+    @Override
+    public void setRootDispersion(final int dispersion)
+    {
+        setInt(ROOT_DISPERSION_INDEX, dispersion);
+    }
+
+    /**
+     * Set stratum level as defined in RFC-1305.
+     *
+     * @param stratum stratum level.
+     */
+    @Override
+    public void setStratum(final int stratum)
+    {
+        buf[STRATUM_INDEX] = (byte) (stratum & 0xFF);
+    }
+
+    /**
+     * Sets the NTP timestamp at the given array index.
+     *
+     * @param index index into the byte array.
+     * @param t TimeStamp.
+     */
+    private void setTimestamp(final int index, final TimeStamp t)
+    {
+        long ntpTime = (t == null) ? 0 : t.ntpValue();
+        // copy 64-bits from Long value into 8 x 8-bit bytes of array
+        // one byte at a time shifting 8-bits for each position.
+        for (int i = 7; i >= 0; i--) {
+            buf[index + i] = (byte) (ntpTime & 0xFF);
+            ntpTime >>>= 8; // shift to next byte
+        }
+        // buf[index] |= 0x80;  // only set if 1900 baseline....
+    }
+
+    /**
+     * Set transmit time with NTP timestamp.
+     * If <code>ts</code> is null then zero time is used.
+     *
+     * @param ts NTP timestamp
+     */
+    @Override
+    public void setTransmitTime(final TimeStamp ts)
+    {
+        setTimestamp(TRANSMIT_TIMESTAMP_INDEX, ts);
+    }
+
+    /**
+     * Set NTP version as defined in RFC-1305.
+     *
+     * @param version NTP version.
+     */
+    @Override
+    public void setVersion(final int version)
+    {
+        buf[VERSION_INDEX] = (byte) (buf[VERSION_INDEX] & 0xC7 | ((version & 0x7) << VERSION_SHIFT));
+    }
+
+    /**
+     * Returns details of NTP packet as a string.
+     *
+     * @return details of NTP packet as a string.
+     */
+    @Override
+    public String toString()
+    {
+        return "[" +
+                "version:" + getVersion() +
+                ", mode:" + getMode() +
+                ", poll:" + getPoll() +
+                ", precision:" + getPrecision() +
+                ", delay:" + getRootDelay() +
+                ", dispersion(ms):" + getRootDispersionInMillisDouble() +
+                ", id:" + getReferenceIdString() +
+                ", xmitTime:" + getTransmitTimeStamp().toDateString() +
+                " ]";
+    }
+
+}
diff --git a/src/main/java/org/apache/commons/net/ntp/NtpV3Packet.java b/src/main/java/org/apache/commons/net/ntp/NtpV3Packet.java
index d97128547..a1446ed15 100644
--- a/src/main/java/org/apache/commons/net/ntp/NtpV3Packet.java
+++ b/src/main/java/org/apache/commons/net/ntp/NtpV3Packet.java
@@ -1,259 +1,259 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.net.ntp;
-
-import java.net.DatagramPacket;
-
-/**
- * Interface for a NtpV3Packet with get/set methods corresponding to the fields
- * in the NTP Data Message Header described in RFC 1305.
- *
- */
-public interface NtpV3Packet
-{
-
-    /**
-     * Standard NTP UDP port
-     */
-    int NTP_PORT = 123;
-
-    int LI_NO_WARNING = 0;
-    int LI_LAST_MINUTE_HAS_61_SECONDS = 1;
-    int LI_LAST_MINUTE_HAS_59_SECONDS = 2;
-    int LI_ALARM_CONDITION = 3;
-
-    /* mode options */
-    int MODE_RESERVED = 0;
-    int MODE_SYMMETRIC_ACTIVE = 1;
-    int MODE_SYMMETRIC_PASSIVE = 2;
-    int MODE_CLIENT = 3;
-    int MODE_SERVER = 4;
-    int MODE_BROADCAST = 5;
-    int MODE_CONTROL_MESSAGE = 6;
-    int MODE_PRIVATE = 7;
-
-    int NTP_MINPOLL = 4;  // 16 seconds
-    int NTP_MAXPOLL = 14; // 16284 seconds
-
-    int NTP_MINCLOCK = 1;
-    int NTP_MAXCLOCK = 10;
-
-    int VERSION_3 = 3;
-    int VERSION_4 = 4;
-
-    /* possible getType values such that other time-related protocols can
-     * have its information represented as NTP packets
-     */
-    String TYPE_NTP = "NTP";         // RFC-1305/2030
-    String TYPE_ICMP = "ICMP";       // RFC-792
-    String TYPE_TIME = "TIME";       // RFC-868
-    String TYPE_DAYTIME = "DAYTIME"; // RFC-867
-
-    /**
-     * @return a datagram packet with the NTP parts already filled in
-     */
-    DatagramPacket getDatagramPacket();
-
-    /**
-     * @return leap indicator as defined in RFC-1305
-     */
-    int getLeapIndicator();
-
-    /**
-     * @return mode as defined in RFC-1305
-     */
-    int getMode();
-
-    /**
-     * @return mode as human readable string; e.g. 3=Client
-     */
-    String getModeName();
-
-    /**
-     * @return the originate time as defined in RFC-1305
-     */
-    TimeStamp getOriginateTimeStamp();
-
-    /**
-     * @return poll interval as defined in RFC-1305.
-     * Field range between NTP_MINPOLL and NTP_MAXPOLL.
-     */
-    int getPoll();
-
-    /**
-     * @return precision as defined in RFC-1305
-     */
-    int getPrecision();
-
-    /**
-     * @return the receive time as defined in RFC-1305
-     */
-    TimeStamp getReceiveTimeStamp();
-
-    /**
-     * @return the reference id (32-bit code) as defined in RFC-1305
-     */
-    int getReferenceId();
-
-    /**
-     * @return the reference id string
-     */
-    String getReferenceIdString();
-
-    /**
-     * @return the reference time as defined in RFC-1305
-     */
-    TimeStamp getReferenceTimeStamp();
-
-    /**
-     * @return root delay as defined in RFC-1305
-     */
-    int getRootDelay();
-
-    /**
-     * @return root delay in milliseconds
-     */
-    double getRootDelayInMillisDouble();
-
-    /**
-     * @return root dispersion as defined in RFC-1305
-     */
-    int getRootDispersion();
-
-    /**
-     * @return root dispersion in milliseconds
-     */
-    long getRootDispersionInMillis();
-
-    /**
-     * @return root dispersion in milliseconds
-     */
-    double getRootDispersionInMillisDouble();
-
-    /**
-     * @return stratum as defined in RFC-1305
-     */
-    int getStratum();
-
-    /**
-     * @return the transmit timestamp as defined in RFC-1305
-     */
-    TimeStamp getTransmitTimeStamp();
-
-    /**
-     * Return type of time packet. The values (e.g. NTP, TIME, ICMP, ...)
-     * correspond to the protocol used to obtain the timing information.
-     *
-     * @return packet type string identifier
-     */
-    String getType();
-
-    /**
-     * @return version as defined in RFC-1305
-     */
-    int getVersion();
-
-    /**
-     * Set the contents of this object from the datagram packet
-     * @param dp the packet
-     */
-    void setDatagramPacket(DatagramPacket dp);
-
-    /**
-     * Set leap indicator.
-     * @param li - leap indicator code
-     */
-    void setLeapIndicator(int li);
-
-    /**
-     * Set mode as defined in RFC-1305
-     * @param mode the mode to set
-     */
-    void setMode(int mode);
-
-    /**
-     * Set originate timestamp given NTP TimeStamp object.
-     * @param ts - timestamp
-     */
-    void setOriginateTimeStamp(TimeStamp ts);
-
-    /**
-     * Set poll interval as defined in RFC-1305.
-     * Field range between NTP_MINPOLL and NTP_MAXPOLL.
-     * @param poll the interval to set
-     */
-    void setPoll(int poll);
-
-    /**
-     * Set precision as defined in RFC-1305
-     * @param precision Precision
-     * @since 3.4
-     */
-    void setPrecision(int precision);
-
-    /**
-     * Set receive timestamp given NTP TimeStamp object.
-     * @param ts - timestamp
-     */
-    void setReceiveTimeStamp(TimeStamp ts);
-
-    /**
-     * Set reference clock identifier field.
-     * @param refId the clock id field to set
-     */
-    void setReferenceId(int refId);
-
-    /**
-     * Set the reference timestamp given NTP TimeStamp object.
-     * @param ts - timestamp
-     */
-    void setReferenceTime(TimeStamp ts);
-
-    /**
-     * Set root delay as defined in RFC-1305
-     * @param delay the delay to set
-     * @since 3.4
-    */
-    void setRootDelay(int delay);
-
-    /**
-     *
-     * @param dispersion the value to set
-     * @since 3.4
-     */
-    void setRootDispersion(int dispersion);
-
-    /**
-     * Set stratum as defined in RFC-1305
-     * @param stratum the stratum to set
-     */
-    void setStratum(int stratum);
-
-    /**
-     * Set the transmit timestamp given NTP TimeStamp object.
-     * @param ts - timestamp
-     */
-    void setTransmitTime(TimeStamp ts);
-
-    /**
-     * Set version as defined in RFC-1305
-     * @param version the version to set
-     */
-    void setVersion(int version);
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.net.ntp;
+
+import java.net.DatagramPacket;
+
+/**
+ * Interface for a NtpV3Packet with get/set methods corresponding to the fields
+ * in the NTP Data Message Header described in RFC 1305.
+ *
+ */
+public interface NtpV3Packet
+{
+
+    /**
+     * Standard NTP UDP port
+     */
+    int NTP_PORT = 123;
+
+    int LI_NO_WARNING = 0;
+    int LI_LAST_MINUTE_HAS_61_SECONDS = 1;
+    int LI_LAST_MINUTE_HAS_59_SECONDS = 2;
+    int LI_ALARM_CONDITION = 3;
+
+    /* mode options */
+    int MODE_RESERVED = 0;
+    int MODE_SYMMETRIC_ACTIVE = 1;
+    int MODE_SYMMETRIC_PASSIVE = 2;
+    int MODE_CLIENT = 3;
+    int MODE_SERVER = 4;
+    int MODE_BROADCAST = 5;
+    int MODE_CONTROL_MESSAGE = 6;
+    int MODE_PRIVATE = 7;
+
+    int NTP_MINPOLL = 4;  // 16 seconds
+    int NTP_MAXPOLL = 14; // 16284 seconds
+
+    int NTP_MINCLOCK = 1;
+    int NTP_MAXCLOCK = 10;
+
+    int VERSION_3 = 3;
+    int VERSION_4 = 4;
+
+    /* possible getType values such that other time-related protocols can
+     * have its information represented as NTP packets
+     */
+    String TYPE_NTP = "NTP";         // RFC-1305/2030
+    String TYPE_ICMP = "ICMP";       // RFC-792
+    String TYPE_TIME = "TIME";       // RFC-868
+    String TYPE_DAYTIME = "DAYTIME"; // RFC-867
+
+    /**
+     * @return a datagram packet with the NTP parts already filled in
+     */
+    DatagramPacket getDatagramPacket();
+
+    /**
+     * @return leap indicator as defined in RFC-1305
+     */
+    int getLeapIndicator();
+
+    /**
+     * @return mode as defined in RFC-1305
+     */
+    int getMode();
+
+    /**
+     * @return mode as human readable string; e.g. 3=Client
+     */
+    String getModeName();
+
+    /**
+     * @return the originate time as defined in RFC-1305
+     */
+    TimeStamp getOriginateTimeStamp();
+
+    /**
+     * @return poll interval as defined in RFC-1305.
+     * Field range between NTP_MINPOLL and NTP_MAXPOLL.
+     */
+    int getPoll();
+
+    /**
+     * @return precision as defined in RFC-1305
+     */
+    int getPrecision();
+
+    /**
+     * @return the receive time as defined in RFC-1305
+     */
+    TimeStamp getReceiveTimeStamp();
+
+    /**
+     * @return the reference id (32-bit code) as defined in RFC-1305
+     */
+    int getReferenceId();
+
+    /**
+     * @return the reference id string
+     */
+    String getReferenceIdString();
+
+    /**
+     * @return the reference time as defined in RFC-1305
+     */
+    TimeStamp getReferenceTimeStamp();
+
+    /**
+     * @return root delay as defined in RFC-1305
+     */
+    int getRootDelay();
+
+    /**
+     * @return root delay in milliseconds
+     */
+    double getRootDelayInMillisDouble();
+
+    /**
+     * @return root dispersion as defined in RFC-1305
+     */
+    int getRootDispersion();
+
+    /**
+     * @return root dispersion in milliseconds
+     */
+    long getRootDispersionInMillis();
+
+    /**
+     * @return root dispersion in milliseconds
+     */
+    double getRootDispersionInMillisDouble();
+
+    /**
+     * @return stratum as defined in RFC-1305
+     */
+    int getStratum();
+
+    /**
+     * @return the transmit timestamp as defined in RFC-1305
+     */
+    TimeStamp getTransmitTimeStamp();
+
+    /**
+     * Return type of time packet. The values (e.g. NTP, TIME, ICMP, ...)
+     * correspond to the protocol used to obtain the timing information.
+     *
+     * @return packet type string identifier
+     */
+    String getType();
+
+    /**
+     * @return version as defined in RFC-1305
+     */
+    int getVersion();
+
+    /**
+     * Set the contents of this object from the datagram packet
+     * @param dp the packet
+     */
+    void setDatagramPacket(DatagramPacket dp);
+
+    /**
+     * Set leap indicator.
+     * @param li - leap indicator code
+     */
+    void setLeapIndicator(int li);
+
+    /**
+     * Set mode as defined in RFC-1305
+     * @param mode the mode to set
+     */
+    void setMode(int mode);
+
+    /**
+     * Set originate timestamp given NTP TimeStamp object.
+     * @param ts - timestamp
+     */
+    void setOriginateTimeStamp(TimeStamp ts);
+
+    /**
+     * Set poll interval as defined in RFC-1305.
+     * Field range between NTP_MINPOLL and NTP_MAXPOLL.
+     * @param poll the interval to set
+     */
+    void setPoll(int poll);
+
+    /**
+     * Set precision as defined in RFC-1305
+     * @param precision Precision
+     * @since 3.4
+     */
+    void setPrecision(int precision);
+
+    /**
+     * Set receive timestamp given NTP TimeStamp object.
+     * @param ts - timestamp
+     */
+    void setReceiveTimeStamp(TimeStamp ts);
+
+    /**
+     * Set reference clock identifier field.
+     * @param refId the clock id field to set
+     */
+    void setReferenceId(int refId);
+
+    /**
+     * Set the reference timestamp given NTP TimeStamp object.
+     * @param ts - timestamp
+     */
+    void setReferenceTime(TimeStamp ts);
+
+    /**
+     * Set root delay as defined in RFC-1305
+     * @param delay the delay to set
+     * @since 3.4
+    */
+    void setRootDelay(int delay);
+
+    /**
+     *
+     * @param dispersion the value to set
+     * @since 3.4
+     */
+    void setRootDispersion(int dispersion);
+
+    /**
+     * Set stratum as defined in RFC-1305
+     * @param stratum the stratum to set
+     */
+    void setStratum(int stratum);
+
+    /**
+     * Set the transmit timestamp given NTP TimeStamp object.
+     * @param ts - timestamp
+     */
+    void setTransmitTime(TimeStamp ts);
+
+    /**
+     * Set version as defined in RFC-1305
+     * @param version the version to set
+     */
+    void setVersion(int version);
+
+}
diff --git a/src/main/java/org/apache/commons/net/ntp/TimeInfo.java b/src/main/java/org/apache/commons/net/ntp/TimeInfo.java
index 685419b57..e0a1d42f1 100644
--- a/src/main/java/org/apache/commons/net/ntp/TimeInfo.java
+++ b/src/main/java/org/apache/commons/net/ntp/TimeInfo.java
@@ -1,343 +1,343 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.net.ntp;
-
-import java.net.DatagramPacket;
-import java.net.InetAddress;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Wrapper class to network time packet messages (NTP, etc) that computes
- * related timing info and stats.
- */
-public class TimeInfo {
-
-    private final NtpV3Packet message;
-    private List<String> comments;
-    private Long delayMillis;
-    private Long offsetMillis;
-
-    /**
-     * time at which time message packet was received by local machine
-     */
-    private final long returnTimeMillis;
-
-    /**
-     * flag indicating that the TimeInfo details was processed and delay/offset were computed
-     */
-    private boolean detailsComputed;
-
-    /**
-     * Create TimeInfo object with raw packet message and destination time received.
-     *
-     * @param message NTP message packet
-     * @param returnTimeMillis  destination receive time
-     * @throws IllegalArgumentException if message is null
-     */
-    public TimeInfo(final NtpV3Packet message, final long returnTimeMillis) {
-        this(message, returnTimeMillis, null, true);
-    }
-
-    /**
-     * Create TimeInfo object with raw packet message and destination time received.
-     * Auto-computes details if computeDetails flag set otherwise this is delayed
-     * until computeDetails() is called. Delayed computation is for fast
-     * intialization when sub-millisecond timing is needed.
-     *
-     * @param msgPacket NTP message packet
-     * @param returnTimeMillis  destination receive time
-     * @param doComputeDetails  flag to pre-compute delay/offset values
-     * @throws IllegalArgumentException if message is null
-     */
-    public TimeInfo(final NtpV3Packet msgPacket, final long returnTimeMillis, final boolean doComputeDetails)
-    {
-            this(msgPacket, returnTimeMillis, null, doComputeDetails);
-    }
-
-    /**
-     * Create TimeInfo object with raw packet message and destination time received.
-     *
-     * @param message NTP message packet
-     * @param returnTimeMillis  destination receive time
-     * @param comments List of errors/warnings identified during processing
-     * @throws IllegalArgumentException if message is null
-     */
-    public TimeInfo(final NtpV3Packet message, final long returnTimeMillis, final List<String> comments)
-    {
-            this(message, returnTimeMillis, comments, true);
-    }
-
-    /**
-     * Create TimeInfo object with raw packet message and destination time received.
-     * Auto-computes details if computeDetails flag set otherwise this is delayed
-     * until computeDetails() is called. Delayed computation is for fast
-     * intialization when sub-millisecond timing is needed.
-     *
-     * @param message NTP message packet
-     * @param returnTimeMillis  destination receive time
-     * @param comments  list of comments used to store errors/warnings with message
-     * @param doComputeDetails  flag to pre-compute delay/offset values
-     * @throws IllegalArgumentException if message is null
-     */
-    public TimeInfo(final NtpV3Packet message, final long returnTimeMillis, final List<String> comments,
-                   final boolean doComputeDetails)
-    {
-        if (message == null) {
-            throw new IllegalArgumentException("message cannot be null");
-        }
-        this.returnTimeMillis = returnTimeMillis;
-        this.message = message;
-        this.comments = comments;
-        if (doComputeDetails) {
-            computeDetails();
-        }
-    }
-
-    /**
-     * Add comment (error/warning) to list of comments associated
-     * with processing of NTP parameters. If comment list not create
-     * then one will be created.
-     *
-     * @param comment the comment
-     */
-    public void addComment(final String comment)
-    {
-        if (comments == null) {
-            comments = new ArrayList<>();
-        }
-        comments.add(comment);
-    }
-
-    /**
-     * Compute and validate details of the NTP message packet. Computed
-     * fields include the offset and delay.
-     */
-    public void computeDetails()
-    {
-        if (detailsComputed) {
-            return; // details already computed - do nothing
-        }
-        detailsComputed = true;
-        if (comments == null) {
-            comments = new ArrayList<>();
-        }
-
-        final TimeStamp origNtpTime = message.getOriginateTimeStamp();
-        final long origTimeMillis = origNtpTime.getTime();
-
-        // Receive Time is time request received by server (t2)
-        final TimeStamp rcvNtpTime = message.getReceiveTimeStamp();
-        final long rcvTimeMillis = rcvNtpTime.getTime();
-
-        // Transmit time is time reply sent by server (t3)
-        final TimeStamp xmitNtpTime = message.getTransmitTimeStamp();
-        final long xmitTimeMillis = xmitNtpTime.getTime();
-
-        /*
-         * Round-trip network delay and local clock offset (or time drift) is calculated
-         * according to this standard NTP equation:
-         *
-         * LocalClockOffset = ((ReceiveTimestamp - OriginateTimestamp) +
-         *                     (TransmitTimestamp - DestinationTimestamp)) / 2
-         *
-         * equations from RFC-1305 (NTPv3)
-         *      roundtrip delay = (t4 - t1) - (t3 - t2)
-         *      local clock offset = ((t2 - t1) + (t3 - t4)) / 2
-         *
-         * It takes into account network delays and assumes that they are symmetrical.
-         *
-         * Note the typo in SNTP RFCs 1769/2030 which state that the delay
-         * is (T4 - T1) - (T2 - T3) with the "T2" and "T3" switched.
-         */
-        if (origNtpTime.ntpValue() == 0)
-        {
-            // without originate time cannot determine when packet went out
-            // might be via a broadcast NTP packet...
-            if (xmitNtpTime.ntpValue() != 0)
-            {
-                offsetMillis = Long.valueOf(xmitTimeMillis - returnTimeMillis);
-                comments.add("Error: zero orig time -- cannot compute delay");
-            } else {
-                comments.add("Error: zero orig time -- cannot compute delay/offset");
-            }
-        } else if (rcvNtpTime.ntpValue() == 0 || xmitNtpTime.ntpValue() == 0) {
-            comments.add("Warning: zero rcvNtpTime or xmitNtpTime");
-            // assert destTime >= origTime since network delay cannot be negative
-            if (origTimeMillis > returnTimeMillis) {
-                comments.add("Error: OrigTime > DestRcvTime");
-            } else {
-                // without receive or xmit time cannot figure out processing time
-                // so delay is simply the network travel time
-                delayMillis = Long.valueOf(returnTimeMillis - origTimeMillis);
-            }
-            // TODO: is offset still valid if rcvNtpTime=0 || xmitNtpTime=0 ???
-            // Could always hash origNtpTime (sendTime) but if host doesn't set it
-            // then it's an malformed ntp host anyway and we don't care?
-            // If server is in broadcast mode then we never send out a query in first place...
-            if (rcvNtpTime.ntpValue() != 0)
-            {
-                // xmitTime is 0 just use rcv time
-                offsetMillis = Long.valueOf(rcvTimeMillis - origTimeMillis);
-            } else if (xmitNtpTime.ntpValue() != 0)
-            {
-                // rcvTime is 0 just use xmitTime time
-                offsetMillis = Long.valueOf(xmitTimeMillis - returnTimeMillis);
-            }
-        } else
-        {
-             long delayValueMillis = returnTimeMillis - origTimeMillis;
-             // assert xmitTime >= rcvTime: difference typically < 1ms
-             if (xmitTimeMillis < rcvTimeMillis)
-             {
-                 // server cannot send out a packet before receiving it...
-                 comments.add("Error: xmitTime < rcvTime"); // time-travel not allowed
-             } else
-             {
-                 // subtract processing time from round-trip network delay
-                 final long deltaMillis = xmitTimeMillis - rcvTimeMillis;
-                 // in normal cases the processing delta is less than
-                 // the total roundtrip network travel time.
-                 if (deltaMillis <= delayValueMillis)
-                 {
-                     delayValueMillis -= deltaMillis; // delay = (t4 - t1) - (t3 - t2)
-                 } else // if delta - delayValue == 1 ms then it's a round-off error
-                 // e.g. delay=3ms, processing=4ms
-                 if (deltaMillis - delayValueMillis == 1)
-                 {
-                     // delayValue == 0 -> local clock saw no tick change but destination clock did
-                     if (delayValueMillis != 0)
-                     {
-                         comments.add("Info: processing time > total network time by 1 ms -> assume zero delay");
-                         delayValueMillis = 0;
-                     }
-                 } else {
-                    comments.add("Warning: processing time > total network time");
-                }
-             }
-             delayMillis = Long.valueOf(delayValueMillis);
-            if (origTimeMillis > returnTimeMillis) {
-                comments.add("Error: OrigTime > DestRcvTime");
-            }
-
-            offsetMillis = Long.valueOf(((rcvTimeMillis - origTimeMillis) + (xmitTimeMillis - returnTimeMillis)) / 2);
-        }
-    }
-
-    /**
-     * Compares this object against the specified object.
-     * The result is <code>true</code> if and only if the argument is
-     * not <code>null</code> and is a <code>TimeStamp</code> object that
-     * contains the same values as this object.
-     *
-     * @param   obj   the object to compare with.
-     * @return  <code>true</code> if the objects are the same;
-     *          <code>false</code> otherwise.
-     * @since 3.4
-     */
-    @Override
-    public boolean equals(final Object obj)
-    {
-        if (this == obj) {
-            return true;
-        }
-        if (obj == null || getClass() != obj.getClass()) {
-            return false;
-        }
-        final TimeInfo other = (TimeInfo) obj;
-        return returnTimeMillis == other.returnTimeMillis && message.equals(other.message);
-    }
-
-    /**
-     * Get host address from message datagram if available
-     * @return host address of available otherwise null
-     * @since 3.4
-     */
-    public InetAddress getAddress() {
-        final DatagramPacket pkt = message.getDatagramPacket();
-        return pkt == null ? null : pkt.getAddress();
-    }
-
-    /**
-     * Return list of comments (if any) during processing of NTP packet.
-     *
-     * @return List or null if not yet computed
-     */
-    public List<String> getComments()
-    {
-        return comments;
-    }
-
-    /**
-     * Get round-trip network delay. If null then could not compute the delay.
-     *
-     * @return Long or null if delay not available.
-     */
-    public Long getDelay()
-    {
-        return delayMillis;
-    }
-
-    /**
-     * Returns NTP message packet.
-     *
-     * @return NTP message packet.
-     */
-    public NtpV3Packet getMessage()
-    {
-        return message;
-    }
-
-    /**
-     * Get clock offset needed to adjust local clock to match remote clock. If null then could not
-     * compute the offset.
-     *
-     * @return Long or null if offset not available.
-     */
-    public Long getOffset()
-    {
-        return offsetMillis;
-    }
-
-    /**
-     * Returns time at which time message packet was received by local machine.
-     *
-     * @return packet return time.
-     */
-    public long getReturnTime()
-    {
-        return returnTimeMillis;
-    }
-
-    /**
-     * Computes a hashcode for this object. The result is the exclusive
-     * OR of the return time and the message hash code.
-     *
-     * @return  a hash code value for this object.
-     * @since 3.4
-     */
-    @Override
-    public int hashCode()
-    {
-        final int prime = 31;
-        int result = (int)returnTimeMillis;
-        result = prime * result + message.hashCode();
-        return result;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.net.ntp;
+
+import java.net.DatagramPacket;
+import java.net.InetAddress;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Wrapper class to network time packet messages (NTP, etc) that computes
+ * related timing info and stats.
+ */
+public class TimeInfo {
+
+    private final NtpV3Packet message;
+    private List<String> comments;
+    private Long delayMillis;
+    private Long offsetMillis;
+
+    /**
+     * time at which time message packet was received by local machine
+     */
+    private final long returnTimeMillis;
+
+    /**
+     * flag indicating that the TimeInfo details was processed and delay/offset were computed
+     */
+    private boolean detailsComputed;
+
+    /**
+     * Create TimeInfo object with raw packet message and destination time received.
+     *
+     * @param message NTP message packet
+     * @param returnTimeMillis  destination receive time
+     * @throws IllegalArgumentException if message is null
+     */
+    public TimeInfo(final NtpV3Packet message, final long returnTimeMillis) {
+        this(message, returnTimeMillis, null, true);
+    }
+
+    /**
+     * Create TimeInfo object with raw packet message and destination time received.
+     * Auto-computes details if computeDetails flag set otherwise this is delayed
+     * until computeDetails() is called. Delayed computation is for fast
+     * intialization when sub-millisecond timing is needed.
+     *
+     * @param msgPacket NTP message packet
+     * @param returnTimeMillis  destination receive time
+     * @param doComputeDetails  flag to pre-compute delay/offset values
+     * @throws IllegalArgumentException if message is null
+     */
+    public TimeInfo(final NtpV3Packet msgPacket, final long returnTimeMillis, final boolean doComputeDetails)
+    {
+            this(msgPacket, returnTimeMillis, null, doComputeDetails);
+    }
+
+    /**
+     * Create TimeInfo object with raw packet message and destination time received.
+     *
+     * @param message NTP message packet
+     * @param returnTimeMillis  destination receive time
+     * @param comments List of errors/warnings identified during processing
+     * @throws IllegalArgumentException if message is null
+     */
+    public TimeInfo(final NtpV3Packet message, final long returnTimeMillis, final List<String> comments)
+    {
+            this(message, returnTimeMillis, comments, true);
+    }
+
+    /**
+     * Create TimeInfo object with raw packet message and destination time received.
+     * Auto-computes details if computeDetails flag set otherwise this is delayed
+     * until computeDetails() is called. Delayed computation is for fast
+     * intialization when sub-millisecond timing is needed.
+     *
+     * @param message NTP message packet
+     * @param returnTimeMillis  destination receive time
+     * @param comments  list of comments used to store errors/warnings with message
+     * @param doComputeDetails  flag to pre-compute delay/offset values
+     * @throws IllegalArgumentException if message is null
+     */
+    public TimeInfo(final NtpV3Packet message, final long returnTimeMillis, final List<String> comments,
+                   final boolean doComputeDetails)
+    {
+        if (message == null) {
+            throw new IllegalArgumentException("message cannot be null");
+        }
+        this.returnTimeMillis = returnTimeMillis;
+        this.message = message;
+        this.comments = comments;
+        if (doComputeDetails) {
+            computeDetails();
+        }
+    }
+
+    /**
+     * Add comment (error/warning) to list of comments associated
+     * with processing of NTP parameters. If comment list not create
+     * then one will be created.
+     *
+     * @param comment the comment
+     */
+    public void addComment(final String comment)
+    {
+        if (comments == null) {
+            comments = new ArrayList<>();
+        }
+        comments.add(comment);
+    }
+
+    /**
+     * Compute and validate details of the NTP message packet. Computed
+     * fields include the offset and delay.
+     */
+    public void computeDetails()
+    {
+        if (detailsComputed) {
+            return; // details already computed - do nothing
+        }
+        detailsComputed = true;
+        if (comments == null) {
+            comments = new ArrayList<>();
+        }
+
+        final TimeStamp origNtpTime = message.getOriginateTimeStamp();
+        final long origTimeMillis = origNtpTime.getTime();
+
+        // Receive Time is time request received by server (t2)
+        final TimeStamp rcvNtpTime = message.getReceiveTimeStamp();
+        final long rcvTimeMillis = rcvNtpTime.getTime();
+
+        // Transmit time is time reply sent by server (t3)
+        final TimeStamp xmitNtpTime = message.getTransmitTimeStamp();
+        final long xmitTimeMillis = xmitNtpTime.getTime();
+
+        /*
+         * Round-trip network delay and local clock offset (or time drift) is calculated
+         * according to this standard NTP equation:
+         *
+         * LocalClockOffset = ((ReceiveTimestamp - OriginateTimestamp) +
+         *                     (TransmitTimestamp - DestinationTimestamp)) / 2
+         *
+         * equations from RFC-1305 (NTPv3)
+         *      roundtrip delay = (t4 - t1) - (t3 - t2)
+         *      local clock offset = ((t2 - t1) + (t3 - t4)) / 2
+         *
+         * It takes into account network delays and assumes that they are symmetrical.
+         *
+         * Note the typo in SNTP RFCs 1769/2030 which state that the delay
+         * is (T4 - T1) - (T2 - T3) with the "T2" and "T3" switched.
+         */
+        if (origNtpTime.ntpValue() == 0)
+        {
+            // without originate time cannot determine when packet went out
+            // might be via a broadcast NTP packet...
+            if (xmitNtpTime.ntpValue() != 0)
+            {
+                offsetMillis = Long.valueOf(xmitTimeMillis - returnTimeMillis);
+                comments.add("Error: zero orig time -- cannot compute delay");
+            } else {
+                comments.add("Error: zero orig time -- cannot compute delay/offset");
+            }
+        } else if (rcvNtpTime.ntpValue() == 0 || xmitNtpTime.ntpValue() == 0) {
+            comments.add("Warning: zero rcvNtpTime or xmitNtpTime");
+            // assert destTime >= origTime since network delay cannot be negative
+            if (origTimeMillis > returnTimeMillis) {
+                comments.add("Error: OrigTime > DestRcvTime");
+            } else {
+                // without receive or xmit time cannot figure out processing time
+                // so delay is simply the network travel time
+                delayMillis = Long.valueOf(returnTimeMillis - origTimeMillis);
+            }
+            // TODO: is offset still valid if rcvNtpTime=0 || xmitNtpTime=0 ???
+            // Could always hash origNtpTime (sendTime) but if host doesn't set it
+            // then it's an malformed ntp host anyway and we don't care?
+            // If server is in broadcast mode then we never send out a query in first place...
+            if (rcvNtpTime.ntpValue() != 0)
+            {
+                // xmitTime is 0 just use rcv time
+                offsetMillis = Long.valueOf(rcvTimeMillis - origTimeMillis);
+            } else if (xmitNtpTime.ntpValue() != 0)
+            {
+                // rcvTime is 0 just use xmitTime time
+                offsetMillis = Long.valueOf(xmitTimeMillis - returnTimeMillis);
+            }
+        } else
+        {
+             long delayValueMillis = returnTimeMillis - origTimeMillis;
+             // assert xmitTime >= rcvTime: difference typically < 1ms
+             if (xmitTimeMillis < rcvTimeMillis)
+             {
+                 // server cannot send out a packet before receiving it...
+                 comments.add("Error: xmitTime < rcvTime"); // time-travel not allowed
+             } else
+             {
+                 // subtract processing time from round-trip network delay
+                 final long deltaMillis = xmitTimeMillis - rcvTimeMillis;
+                 // in normal cases the processing delta is less than
+                 // the total roundtrip network travel time.
+                 if (deltaMillis <= delayValueMillis)
+                 {
+                     delayValueMillis -= deltaMillis; // delay = (t4 - t1) - (t3 - t2)
+                 } else // if delta - delayValue == 1 ms then it's a round-off error
+                 // e.g. delay=3ms, processing=4ms
+                 if (deltaMillis - delayValueMillis == 1)
+                 {
+                     // delayValue == 0 -> local clock saw no tick change but destination clock did
+                     if (delayValueMillis != 0)
+                     {
+                         comments.add("Info: processing time > total network time by 1 ms -> assume zero delay");
+                         delayValueMillis = 0;
+                     }
+                 } else {
+                    comments.add("Warning: processing time > total network time");
+                }
+             }
+             delayMillis = Long.valueOf(delayValueMillis);
+            if (origTimeMillis > returnTimeMillis) {
+                comments.add("Error: OrigTime > DestRcvTime");
+            }
+
+            offsetMillis = Long.valueOf(((rcvTimeMillis - origTimeMillis) + (xmitTimeMillis - returnTimeMillis)) / 2);
+        }
+    }
+
+    /**
+     * Compares this object against the specified object.
+     * The result is <code>true</code> if and only if the argument is
+     * not <code>null</code> and is a <code>TimeStamp</code> object that
+     * contains the same values as this object.
+     *
+     * @param   obj   the object to compare with.
+     * @return  <code>true</code> if the objects are the same;
+     *          <code>false</code> otherwise.
+     * @since 3.4
+     */
+    @Override
+    public boolean equals(final Object obj)
+    {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null || getClass() != obj.getClass()) {
+            return false;
+        }
+        final TimeInfo other = (TimeInfo) obj;
+        return returnTimeMillis == other.returnTimeMillis && message.equals(other.message);
+    }
+
+    /**
+     * Get host address from message datagram if available
+     * @return host address of available otherwise null
+     * @since 3.4
+     */
+    public InetAddress getAddress() {
+        final DatagramPacket pkt = message.getDatagramPacket();
+        return pkt == null ? null : pkt.getAddress();
+    }
+
+    /**
+     * Return list of comments (if any) during processing of NTP packet.
+     *
+     * @return List or null if not yet computed
+     */
+    public List<String> getComments()
+    {
+        return comments;
+    }
+
+    /**
+     * Get round-trip network delay. If null then could not compute the delay.
+     *
+     * @return Long or null if delay not available.
+     */
+    public Long getDelay()
+    {
+        return delayMillis;
+    }
+
+    /**
+     * Returns NTP message packet.
+     *
+     * @return NTP message packet.
+     */
+    public NtpV3Packet getMessage()
+    {
+        return message;
+    }
+
+    /**
+     * Get clock offset needed to adjust local clock to match remote clock. If null then could not
+     * compute the offset.
+     *
+     * @return Long or null if offset not available.
+     */
+    public Long getOffset()
+    {
+        return offsetMillis;
+    }
+
+    /**
+     * Returns time at which time message packet was received by local machine.
+     *
+     * @return packet return time.
+     */
+    public long getReturnTime()
+    {
+        return returnTimeMillis;
+    }
+
+    /**
+     * Computes a hashcode for this object. The result is the exclusive
+     * OR of the return time and the message hash code.
+     *
+     * @return  a hash code value for this object.
+     * @since 3.4
+     */
+    @Override
+    public int hashCode()
+    {
+        final int prime = 31;
+        int result = (int)returnTimeMillis;
+        result = prime * result + message.hashCode();
+        return result;
+    }
+
+}
diff --git a/src/main/java/org/apache/commons/net/ntp/TimeStamp.java b/src/main/java/org/apache/commons/net/ntp/TimeStamp.java
index a552a4183..9b888b762 100644
--- a/src/main/java/org/apache/commons/net/ntp/TimeStamp.java
+++ b/src/main/java/org/apache/commons/net/ntp/TimeStamp.java
@@ -1,468 +1,468 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.net.ntp;
-
-import java.io.IOException;
-import java.io.Serializable;
-import java.text.DateFormat;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.Locale;
-import java.util.TimeZone;
-
-/**
- * TimeStamp class represents the Network Time Protocol (NTP) timestamp
- * as defined in RFC-1305 and SNTP (RFC-2030). It is represented as a
- * 64-bit unsigned fixed-point number in seconds relative to 0-hour on 1-January-1900.
- * The 32-bit low-order bits are the fractional seconds whose precision is
- * about 200 picoseconds. Assumes overflow date when date passes MAX_LONG
- * and reverts back to 0 is 2036 and not 1900. Test for most significant
- * bit: if MSB=0 then 2036 basis is used otherwise 1900 if MSB=1.
- * <p>
- * Methods exist to convert NTP timestamps to and from the equivalent Java date
- * representation, which is the number of milliseconds since the standard base
- * time known as "the epoch", namely January 1, 1970, 00:00:00 GMT.
- * </p>
- *
- * @see java.util.Date
- */
-public class TimeStamp implements Serializable, Comparable<TimeStamp>
-{
-    private static final long serialVersionUID = 8139806907588338737L;
-
-    /**
-     * Baseline NTP time if bit-0=0 is 7-Feb-2036 @ 06:28:16 UTC
-     */
-    protected static final long msb0baseTime = 2085978496000L;
-
-    /**
-     * Baseline NTP time if bit-0=1 is 1-Jan-1900 @ 01:00:00 UTC
-     */
-    protected static final long msb1baseTime = -2208988800000L;
-
-    /**
-     * Default NTP date string format. E.g. Fri, Sep 12 2003 21:06:23.860.
-     * See <code>java.text.SimpleDateFormat</code> for code descriptions.
-     */
-    public static final String NTP_DATE_FORMAT = "EEE, MMM dd yyyy HH:mm:ss.SSS";
-
-    /**
-     * Left-pad 8-character hex string with 0's
-     *
-     * @param buf - StringBuilder which is appended with leading 0's.
-     * @param l - a long.
-     */
-    private static void appendHexString(final StringBuilder buf, final long l)
-    {
-        final String s = Long.toHexString(l);
-        for (int i = s.length(); i < 8; i++) {
-            buf.append('0');
-        }
-        buf.append(s);
-    }
-
-    /**
-     * Convert NTP timestamp hexstring (e.g. "c1a089bd.fc904f6d") to the NTP
-     * 64-bit unsigned fixed-point number.
-     * @param hexString the string to convert
-     *
-     * @return NTP 64-bit timestamp value.
-     * @throws NumberFormatException - if the string does not contain a parsable timestamp.
-     */
-    protected static long decodeNtpHexString(final String hexString)
-            throws NumberFormatException
-    {
-        if (hexString == null) {
-            throw new NumberFormatException("null");
-        }
-        final int ind = hexString.indexOf('.');
-        if (ind == -1) {
-            if (hexString.isEmpty()) {
-                return 0;
-            }
-            return Long.parseLong(hexString, 16) << 32; // no decimal
-        }
-
-        return Long.parseLong(hexString.substring(0, ind), 16) << 32 |
-                Long.parseLong(hexString.substring(ind + 1), 16);
-    }
-    /**
-     * Constructs a NTP timestamp object and initializes it so that
-     * it represents the time at which it was allocated, measured to the
-     * nearest millisecond.
-     * @return NTP timestamp object set to the current time.
-     * @see     System#currentTimeMillis()
-     */
-    public static TimeStamp getCurrentTime()
-    {
-        return getNtpTime(System.currentTimeMillis());
-    }
-
-    // initialization of static time bases
-    /*
-    static {
-        TimeZone utcZone = TimeZone.getTimeZone("UTC");
-        Calendar calendar = Calendar.getInstance(utcZone);
-        calendar.set(1900, Calendar.JANUARY, 1, 0, 0, 0);
-        calendar.set(Calendar.MILLISECOND, 0);
-        msb1baseTime = calendar.getTime().getTime();
-        calendar.set(2036, Calendar.FEBRUARY, 7, 6, 28, 16);
-        calendar.set(Calendar.MILLISECOND, 0);
-        msb0baseTime = calendar.getTime().getTime();
-    }
-    */
-
-    /**
-     * Helper method to convert Java time to NTP timestamp object.
-     * Note that Java time (milliseconds) by definition has less precision
-     * then NTP time (picoseconds) so converting Ntptime to Javatime and back
-     * to Ntptime loses precision. For example, Tue, Dec 17 2002 09:07:24.810
-     * is represented by a single Java-based time value of f22cd1fc8a, but its
-     * NTP equivalent are all values from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.
-     * @param   dateMillis   the milliseconds since January 1, 1970, 00:00:00 GMT.
-     * @return NTP timestamp object at the specified date.
-     */
-    public static TimeStamp getNtpTime(final long dateMillis)
-    {
-        return new TimeStamp(toNtpTime(dateMillis));
-    }
-
-    /**
-     * Converts 64-bit NTP timestamp to Java standard time.
-     *
-     * Note that java time (milliseconds) by definition has less precision
-     * then NTP time (picoseconds) so converting NTP timestamp to java time and back
-     * to NTP timestamp loses precision. For example, Tue, Dec 17 2002 09:07:24.810 EST
-     * is represented by a single Java-based time value of f22cd1fc8a, but its
-     * NTP equivalent are all values ranging from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.
-     *
-     * @param ntpTimeValue the input time
-     * @return the number of milliseconds since January 1, 1970, 00:00:00 GMT
-     * represented by this NTP timestamp value.
-     */
-    public static long getTime(final long ntpTimeValue)
-    {
-        final long seconds = (ntpTimeValue >>> 32) & 0xffffffffL;     // high-order 32-bits
-        long fraction = ntpTimeValue & 0xffffffffL;             // low-order 32-bits
-
-        // Use round-off on fractional part to preserve going to lower precision
-        fraction = Math.round(1000D * fraction / 0x100000000L);
-
-        /*
-         * If the most significant bit (MSB) on the seconds field is set we use
-         * a different time base. The following text is a quote from RFC-2030 (SNTP v4):
-         *
-         *  If bit 0 is set, the UTC time is in the range 1968-2036 and UTC time
-         *  is reckoned from 0h 0m 0s UTC on 1 January 1900. If bit 0 is not set,
-         *  the time is in the range 2036-2104 and UTC time is reckoned from
-         *  6h 28m 16s UTC on 7 February 2036.
-         */
-        final long msb = seconds & 0x80000000L;
-        if (msb == 0) {
-            // use base: 7-Feb-2036 @ 06:28:16 UTC
-            return msb0baseTime + (seconds * 1000) + fraction;
-        }
-        // use base: 1-Jan-1900 @ 01:00:00 UTC
-        return msb1baseTime + (seconds * 1000) + fraction;
-    }
-
-    /**
-     * Parses the string argument as a NTP hexidecimal timestamp representation string
-     * (e.g. "c1a089bd.fc904f6d").
-     *
-     * @param s - hexstring.
-     * @return the Timestamp represented by the argument in hexidecimal.
-     * @throws NumberFormatException - if the string does not contain a parsable timestamp.
-     */
-    public static TimeStamp parseNtpString(final String s)
-            throws NumberFormatException
-    {
-        return new TimeStamp(decodeNtpHexString(s));
-    }
-
-    /**
-     * Converts Java time to 64-bit NTP time representation.
-     *
-     * @param millis Java time
-     * @return NTP timestamp representation of Java time value.
-     */
-    protected static long toNtpTime(final long millis)
-    {
-        final boolean useBase1 = millis < msb0baseTime;    // time < Feb-2036
-        final long baseTimeMillis;
-        if (useBase1) {
-            baseTimeMillis = millis - msb1baseTime; // dates <= Feb-2036
-        } else {
-            // if base0 needed for dates >= Feb-2036
-            baseTimeMillis = millis - msb0baseTime;
-        }
-
-        long seconds = baseTimeMillis / 1000;
-        final long fraction = ((baseTimeMillis % 1000) * 0x100000000L) / 1000;
-
-        if (useBase1) {
-            seconds |= 0x80000000L; // set high-order bit if msb1baseTime 1900 used
-        }
-
-        return seconds << 32 | fraction;
-    }
-
-    /**
-     * Converts 64-bit NTP timestamp value to a <code>String</code>.
-     * The NTP timestamp value is represented as hex string with
-     * seconds separated by fractional seconds by a decimal point;
-     * e.g. c1a089bd.fc904f6d == Tue, Dec 10 2002 10:41:49.986
-     * @param ntpTime the 64 bit timestamp
-     *
-     * @return NTP timestamp 64-bit long value as hex string with seconds
-     * separated by fractional seconds.
-     */
-    public static String toString(final long ntpTime)
-    {
-        final StringBuilder buf = new StringBuilder();
-        // high-order second bits (32..63) as hexstring
-        appendHexString(buf, (ntpTime >>> 32) & 0xffffffffL);
-
-        // low-order fractional seconds bits (0..31) as hexstring
-        buf.append('.');
-        appendHexString(buf, ntpTime & 0xffffffffL);
-
-        return buf.toString();
-    }
-
-    /**
-     * NTP timestamp value: 64-bit unsigned fixed-point number as defined in RFC-1305
-     * with high-order 32 bits the seconds field and the low-order 32-bits the
-     * fractional field.
-     */
-    private final long ntpTime;
-
-    private DateFormat simpleFormatter;
-
-    private DateFormat utcFormatter;
-
-    /**
-     * Constructs a newly allocated NTP timestamp object
-     * that represents the Java Date argument.
-     *
-     * @param d - the Date to be represented by the Timestamp object.
-     */
-    public TimeStamp(final Date d)
-    {
-        ntpTime = d == null ? 0 : toNtpTime(d.getTime());
-    }
-
-    /**
-     * Constructs a newly allocated NTP timestamp object
-     * that represents the native 64-bit long argument.
-     * @param ntpTime the timestamp
-     */
-    public TimeStamp(final long ntpTime)
-    {
-        this.ntpTime = ntpTime;
-    }
-
-    /**
-     * Constructs a newly allocated NTP timestamp object
-     * that represents the value represented by the string
-     * in hexdecimal form (e.g. "c1a089bd.fc904f6d").
-     * @param hexStamp the hex timestamp
-     *
-     * @throws NumberFormatException - if the string does not contain a parsable timestamp.
-     */
-    public TimeStamp(final String hexStamp) throws NumberFormatException
-    {
-        ntpTime = decodeNtpHexString(hexStamp);
-    }
-
-    /**
-     * Compares two Timestamps numerically.
-     *
-     * @param   anotherTimeStamp - the <code>TimeStamp</code> to be compared.
-     * @return  the value <code>0</code> if the argument TimeStamp is equal to
-     *          this TimeStamp; a value less than <code>0</code> if this TimeStamp
-     *          is numerically less than the TimeStamp argument; and a
-     *          value greater than <code>0</code> if this TimeStamp is
-     *          numerically greater than the TimeStamp argument
-     *          (signed comparison).
-     */
-    @Override
-    public int compareTo(final TimeStamp anotherTimeStamp)
-    {
-        final long thisVal = this.ntpTime;
-        final long anotherVal = anotherTimeStamp.ntpTime;
-        return (Long.compare(thisVal, anotherVal));
-    }
-
-    /**
-     * Compares this object against the specified object.
-     * The result is <code>true</code> if and only if the argument is
-     * not <code>null</code> and is a <code>Long</code> object that
-     * contains the same <code>long</code> value as this object.
-     *
-     * @param   obj   the object to compare with.
-     * @return  <code>true</code> if the objects are the same;
-     *          <code>false</code> otherwise.
-     */
-    @Override
-    public boolean equals(final Object obj)
-    {
-        if (obj instanceof TimeStamp) {
-            return ntpTime == ((TimeStamp) obj).ntpValue();
-        }
-        return false;
-    }
-
-    /**
-     * Converts NTP timestamp to Java Date object.
-     *
-     * @return NTP Timestamp in Java Date
-     */
-    public Date getDate()
-    {
-        return new Date(getTime(ntpTime));
-    }
-
-    /**
-     * Returns low-order 32-bits representing the fractional seconds.
-     *
-     * @return fractional seconds represented by this NTP timestamp.
-     */
-    public long getFraction()
-    {
-        return ntpTime & 0xffffffffL;
-    }
-
-    /**
-     * Returns high-order 32-bits representing the seconds of this NTP timestamp.
-     *
-     * @return seconds represented by this NTP timestamp.
-     */
-    public long getSeconds()
-    {
-        return (ntpTime >>> 32) & 0xffffffffL;
-    }
-
-    /**
-     * Converts NTP timestamp to Java standard time.
-     *
-     * @return the number of milliseconds since January 1, 1970, 00:00:00 GMT
-     * represented by this NTP timestamp value.
-     */
-    public long getTime()
-    {
-        return getTime(ntpTime);
-    }
-
-    /**
-     * Computes a hashcode for this Timestamp. The result is the exclusive
-     * OR of the two halves of the primitive <code>long</code> value
-     * represented by this <code>TimeStamp</code> object. That is, the hashcode
-     * is the value of the expression:
-     * <blockquote><pre>
-     * {@code (int)(this.ntpValue()^(this.ntpValue() >>> 32))}
-     * </pre></blockquote>
-     *
-     * @return  a hash code value for this object.
-     */
-    @Override
-    public int hashCode()
-    {
-        return (int) (ntpTime ^ (ntpTime >>> 32));
-    }
-
-    /**
-     * Returns the value of this Timestamp as a long value.
-     *
-     * @return the 64-bit long value represented by this object.
-     */
-    public long ntpValue()
-    {
-        return ntpTime;
-    }
-
-    /**
-     * Converts this <code>TimeStamp</code> object to a <code>String</code>
-     * of the form:
-     * <blockquote><pre>
-     * EEE, MMM dd yyyy HH:mm:ss.SSS</pre></blockquote>
-     * See java.text.SimpleDataFormat for code descriptions.
-     *
-     * @return  a string representation of this date.
-     */
-    public String toDateString()
-    {
-        if (simpleFormatter == null) {
-            simpleFormatter = new SimpleDateFormat(NTP_DATE_FORMAT, Locale.US);
-            simpleFormatter.setTimeZone(TimeZone.getDefault());
-        }
-        final Date ntpDate = getDate();
-        return simpleFormatter.format(ntpDate);
-    }
-
-    /**
-     * Converts this <code>TimeStamp</code> object to a <code>String</code>.
-     * The NTP timestamp 64-bit long value is represented as hex string with
-     * seconds separated by fractional seconds by a decimal point;
-     * e.g. c1a089bd.fc904f6d == Tue, Dec 10 2002 10:41:49.986
-     *
-     * @return NTP timestamp 64-bit long value as hex string with seconds
-     * separated by fractional seconds.
-     */
-    @Override
-    public String toString()
-    {
-        return toString(ntpTime);
-    }
-
-    /**
-     * Converts this <code>TimeStamp</code> object to a <code>String</code>
-     * of the form:
-     * <blockquote><pre>
-     * EEE, MMM dd yyyy HH:mm:ss.SSS UTC</pre></blockquote>
-     * See java.text.SimpleDataFormat for code descriptions.
-     *
-     * @return  a string representation of this date in UTC.
-     */
-    public String toUTCString()
-    {
-        if (utcFormatter == null) {
-            utcFormatter = new SimpleDateFormat(NTP_DATE_FORMAT + " 'UTC'",
-                    Locale.US);
-            utcFormatter.setTimeZone(TimeZone.getTimeZone("UTC"));
-        }
-        final Date ntpDate = getDate();
-        return utcFormatter.format(ntpDate);
-    }
-
-    /*
-        Serialization is unnecessary for this class.
-        Reject attempts to do so until such time as the Serializable attribute can be dropped.
-     */
-
-    private void writeObject(final java.io.ObjectOutputStream out) throws IOException
-    {
-        throw new UnsupportedOperationException("Serialization is not supported");
-    }
-
-    private void readObject(final java.io.ObjectInputStream in) throws IOException, ClassNotFoundException
-    {
-        throw new UnsupportedOperationException("Serialization is not supported");
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.net.ntp;
+
+import java.io.IOException;
+import java.io.Serializable;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+import java.util.TimeZone;
+
+/**
+ * TimeStamp class represents the Network Time Protocol (NTP) timestamp
+ * as defined in RFC-1305 and SNTP (RFC-2030). It is represented as a
+ * 64-bit unsigned fixed-point number in seconds relative to 0-hour on 1-January-1900.
+ * The 32-bit low-order bits are the fractional seconds whose precision is
+ * about 200 picoseconds. Assumes overflow date when date passes MAX_LONG
+ * and reverts back to 0 is 2036 and not 1900. Test for most significant
+ * bit: if MSB=0 then 2036 basis is used otherwise 1900 if MSB=1.
+ * <p>
+ * Methods exist to convert NTP timestamps to and from the equivalent Java date
+ * representation, which is the number of milliseconds since the standard base
+ * time known as "the epoch", namely January 1, 1970, 00:00:00 GMT.
+ * </p>
+ *
+ * @see java.util.Date
+ */
+public class TimeStamp implements Serializable, Comparable<TimeStamp>
+{
+    private static final long serialVersionUID = 8139806907588338737L;
+
+    /**
+     * Baseline NTP time if bit-0=0 is 7-Feb-2036 @ 06:28:16 UTC
+     */
+    protected static final long msb0baseTime = 2085978496000L;
+
+    /**
+     * Baseline NTP time if bit-0=1 is 1-Jan-1900 @ 01:00:00 UTC
+     */
+    protected static final long msb1baseTime = -2208988800000L;
+
+    /**
+     * Default NTP date string format. E.g. Fri, Sep 12 2003 21:06:23.860.
+     * See <code>java.text.SimpleDateFormat</code> for code descriptions.
+     */
+    public static final String NTP_DATE_FORMAT = "EEE, MMM dd yyyy HH:mm:ss.SSS";
+
+    /**
+     * Left-pad 8-character hex string with 0's
+     *
+     * @param buf - StringBuilder which is appended with leading 0's.
+     * @param l - a long.
+     */
+    private static void appendHexString(final StringBuilder buf, final long l)
+    {
+        final String s = Long.toHexString(l);
+        for (int i = s.length(); i < 8; i++) {
+            buf.append('0');
+        }
+        buf.append(s);
+    }
+
+    /**
+     * Convert NTP timestamp hexstring (e.g. "c1a089bd.fc904f6d") to the NTP
+     * 64-bit unsigned fixed-point number.
+     * @param hexString the string to convert
+     *
+     * @return NTP 64-bit timestamp value.
+     * @throws NumberFormatException - if the string does not contain a parsable timestamp.
+     */
+    protected static long decodeNtpHexString(final String hexString)
+            throws NumberFormatException
+    {
+        if (hexString == null) {
+            throw new NumberFormatException("null");
+        }
+        final int ind = hexString.indexOf('.');
+        if (ind == -1) {
+            if (hexString.isEmpty()) {
+                return 0;
+            }
+            return Long.parseLong(hexString, 16) << 32; // no decimal
+        }
+
+        return Long.parseLong(hexString.substring(0, ind), 16) << 32 |
+                Long.parseLong(hexString.substring(ind + 1), 16);
+    }
+    /**
+     * Constructs a NTP timestamp object and initializes it so that
+     * it represents the time at which it was allocated, measured to the
+     * nearest millisecond.
+     * @return NTP timestamp object set to the current time.
+     * @see     System#currentTimeMillis()
+     */
+    public static TimeStamp getCurrentTime()
+    {
+        return getNtpTime(System.currentTimeMillis());
+    }
+
+    // initialization of static time bases
+    /*
+    static {
+        TimeZone utcZone = TimeZone.getTimeZone("UTC");
+        Calendar calendar = Calendar.getInstance(utcZone);
+        calendar.set(1900, Calendar.JANUARY, 1, 0, 0, 0);
+        calendar.set(Calendar.MILLISECOND, 0);
+        msb1baseTime = calendar.getTime().getTime();
+        calendar.set(2036, Calendar.FEBRUARY, 7, 6, 28, 16);
+        calendar.set(Calendar.MILLISECOND, 0);
+        msb0baseTime = calendar.getTime().getTime();
+    }
+    */
+
+    /**
+     * Helper method to convert Java time to NTP timestamp object.
+     * Note that Java time (milliseconds) by definition has less precision
+     * then NTP time (picoseconds) so converting Ntptime to Javatime and back
+     * to Ntptime loses precision. For example, Tue, Dec 17 2002 09:07:24.810
+     * is represented by a single Java-based time value of f22cd1fc8a, but its
+     * NTP equivalent are all values from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.
+     * @param   dateMillis   the milliseconds since January 1, 1970, 00:00:00 GMT.
+     * @return NTP timestamp object at the specified date.
+     */
+    public static TimeStamp getNtpTime(final long dateMillis)
+    {
+        return new TimeStamp(toNtpTime(dateMillis));
+    }
+
+    /**
+     * Converts 64-bit NTP timestamp to Java standard time.
+     *
+     * Note that java time (milliseconds) by definition has less precision
+     * then NTP time (picoseconds) so converting NTP timestamp to java time and back
+     * to NTP timestamp loses precision. For example, Tue, Dec 17 2002 09:07:24.810 EST
+     * is represented by a single Java-based time value of f22cd1fc8a, but its
+     * NTP equivalent are all values ranging from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.
+     *
+     * @param ntpTimeValue the input time
+     * @return the number of milliseconds since January 1, 1970, 00:00:00 GMT
+     * represented by this NTP timestamp value.
+     */
+    public static long getTime(final long ntpTimeValue)
+    {
+        final long seconds = (ntpTimeValue >>> 32) & 0xffffffffL;     // high-order 32-bits
+        long fraction = ntpTimeValue & 0xffffffffL;             // low-order 32-bits
+
+        // Use round-off on fractional part to preserve going to lower precision
+        fraction = Math.round(1000D * fraction / 0x100000000L);
+
+        /*
+         * If the most significant bit (MSB) on the seconds field is set we use
+         * a different time base. The following text is a quote from RFC-2030 (SNTP v4):
+         *
+         *  If bit 0 is set, the UTC time is in the range 1968-2036 and UTC time
+         *  is reckoned from 0h 0m 0s UTC on 1 January 1900. If bit 0 is not set,
+         *  the time is in the range 2036-2104 and UTC time is reckoned from
+         *  6h 28m 16s UTC on 7 February 2036.
+         */
+        final long msb = seconds & 0x80000000L;
+        if (msb == 0) {
+            // use base: 7-Feb-2036 @ 06:28:16 UTC
+            return msb0baseTime + (seconds * 1000) + fraction;
+        }
+        // use base: 1-Jan-1900 @ 01:00:00 UTC
+        return msb1baseTime + (seconds * 1000) + fraction;
+    }
+
+    /**
+     * Parses the string argument as a NTP hexidecimal timestamp representation string
+     * (e.g. "c1a089bd.fc904f6d").
+     *
+     * @param s - hexstring.
+     * @return the Timestamp represented by the argument in hexidecimal.
+     * @throws NumberFormatException - if the string does not contain a parsable timestamp.
+     */
+    public static TimeStamp parseNtpString(final String s)
+            throws NumberFormatException
+    {
+        return new TimeStamp(decodeNtpHexString(s));
+    }
+
+    /**
+     * Converts Java time to 64-bit NTP time representation.
+     *
+     * @param millis Java time
+     * @return NTP timestamp representation of Java time value.
+     */
+    protected static long toNtpTime(final long millis)
+    {
+        final boolean useBase1 = millis < msb0baseTime;    // time < Feb-2036
+        final long baseTimeMillis;
+        if (useBase1) {
+            baseTimeMillis = millis - msb1baseTime; // dates <= Feb-2036
+        } else {
+            // if base0 needed for dates >= Feb-2036
+            baseTimeMillis = millis - msb0baseTime;
+        }
+
+        long seconds = baseTimeMillis / 1000;
+        final long fraction = ((baseTimeMillis % 1000) * 0x100000000L) / 1000;
+
+        if (useBase1) {
+            seconds |= 0x80000000L; // set high-order bit if msb1baseTime 1900 used
+        }
+
+        return seconds << 32 | fraction;
+    }
+
+    /**
+     * Converts 64-bit NTP timestamp value to a <code>String</code>.
+     * The NTP timestamp value is represented as hex string with
+     * seconds separated by fractional seconds by a decimal point;
+     * e.g. c1a089bd.fc904f6d == Tue, Dec 10 2002 10:41:49.986
+     * @param ntpTime the 64 bit timestamp
+     *
+     * @return NTP timestamp 64-bit long value as hex string with seconds
+     * separated by fractional seconds.
+     */
+    public static String toString(final long ntpTime)
+    {
+        final StringBuilder buf = new StringBuilder();
+        // high-order second bits (32..63) as hexstring
+        appendHexString(buf, (ntpTime >>> 32) & 0xffffffffL);
+
+        // low-order fractional seconds bits (0..31) as hexstring
+        buf.append('.');
+        appendHexString(buf, ntpTime & 0xffffffffL);
+
+        return buf.toString();
+    }
+
+    /**
+     * NTP timestamp value: 64-bit unsigned fixed-point number as defined in RFC-1305
+     * with high-order 32 bits the seconds field and the low-order 32-bits the
+     * fractional field.
+     */
+    private final long ntpTime;
+
+    private DateFormat simpleFormatter;
+
+    private DateFormat utcFormatter;
+
+    /**
+     * Constructs a newly allocated NTP timestamp object
+     * that represents the Java Date argument.
+     *
+     * @param d - the Date to be represented by the Timestamp object.
+     */
+    public TimeStamp(final Date d)
+    {
+        ntpTime = d == null ? 0 : toNtpTime(d.getTime());
+    }
+
+    /**
+     * Constructs a newly allocated NTP timestamp object
+     * that represents the native 64-bit long argument.
+     * @param ntpTime the timestamp
+     */
+    public TimeStamp(final long ntpTime)
+    {
+        this.ntpTime = ntpTime;
+    }
+
+    /**
+     * Constructs a newly allocated NTP timestamp object
+     * that represents the value represented by the string
+     * in hexdecimal form (e.g. "c1a089bd.fc904f6d").
+     * @param hexStamp the hex timestamp
+     *
+     * @throws NumberFormatException - if the string does not contain a parsable timestamp.
+     */
+    public TimeStamp(final String hexStamp) throws NumberFormatException
+    {
+        ntpTime = decodeNtpHexString(hexStamp);
+    }
+
+    /**
+     * Compares two Timestamps numerically.
+     *
+     * @param   anotherTimeStamp - the <code>TimeStamp</code> to be compared.
+     * @return  the value <code>0</code> if the argument TimeStamp is equal to
+     *          this TimeStamp; a value less than <code>0</code> if this TimeStamp
+     *          is numerically less than the TimeStamp argument; and a
+     *          value greater than <code>0</code> if this TimeStamp is
+     *          numerically greater than the TimeStamp argument
+     *          (signed comparison).
+     */
+    @Override
+    public int compareTo(final TimeStamp anotherTimeStamp)
+    {
+        final long thisVal = this.ntpTime;
+        final long anotherVal = anotherTimeStamp.ntpTime;
+        return (Long.compare(thisVal, anotherVal));
+    }
+
+    /**
+     * Compares this object against the specified object.
+     * The result is <code>true</code> if and only if the argument is
+     * not <code>null</code> and is a <code>Long</code> object that
+     * contains the same <code>long</code> value as this object.
+     *
+     * @param   obj   the object to compare with.
+     * @return  <code>true</code> if the objects are the same;
+     *          <code>false</code> otherwise.
+     */
+    @Override
+    public boolean equals(final Object obj)
+    {
+        if (obj instanceof TimeStamp) {
+            return ntpTime == ((TimeStamp) obj).ntpValue();
+        }
+        return false;
+    }
+
+    /**
+     * Converts NTP timestamp to Java Date object.
+     *
+     * @return NTP Timestamp in Java Date
+     */
+    public Date getDate()
+    {
+        return new Date(getTime(ntpTime));
+    }
+
+    /**
+     * Returns low-order 32-bits representing the fractional seconds.
+     *
+     * @return fractional seconds represented by this NTP timestamp.
+     */
+    public long getFraction()
+    {
+        return ntpTime & 0xffffffffL;
+    }
+
+    /**
+     * Returns high-order 32-bits representing the seconds of this NTP timestamp.
+     *
+     * @return seconds represented by this NTP timestamp.
+     */
+    public long getSeconds()
+    {
+        return (ntpTime >>> 32) & 0xffffffffL;
+    }
+
+    /**
+     * Converts NTP timestamp to Java standard time.
+     *
+     * @return the number of milliseconds since January 1, 1970, 00:00:00 GMT
+     * represented by this NTP timestamp value.
+     */
+    public long getTime()
+    {
+        return getTime(ntpTime);
+    }
+
+    /**
+     * Computes a hashcode for this Timestamp. The result is the exclusive
+     * OR of the two halves of the primitive <code>long</code> value
+     * represented by this <code>TimeStamp</code> object. That is, the hashcode
+     * is the value of the expression:
+     * <blockquote><pre>
+     * {@code (int)(this.ntpValue()^(this.ntpValue() >>> 32))}
+     * </pre></blockquote>
+     *
+     * @return  a hash code value for this object.
+     */
+    @Override
+    public int hashCode()
+    {
+        return (int) (ntpTime ^ (ntpTime >>> 32));
+    }
+
+    /**
+     * Returns the value of this Timestamp as a long value.
+     *
+     * @return the 64-bit long value represented by this object.
+     */
+    public long ntpValue()
+    {
+        return ntpTime;
+    }
+
+    /**
+     * Converts this <code>TimeStamp</code> object to a <code>String</code>
+     * of the form:
+     * <blockquote><pre>
+     * EEE, MMM dd yyyy HH:mm:ss.SSS</pre></blockquote>
+     * See java.text.SimpleDataFormat for code descriptions.
+     *
+     * @return  a string representation of this date.
+     */
+    public String toDateString()
+    {
+        if (simpleFormatter == null) {
+            simpleFormatter = new SimpleDateFormat(NTP_DATE_FORMAT, Locale.US);
+            simpleFormatter.setTimeZone(TimeZone.getDefault());
+        }
+        final Date ntpDate = getDate();
+        return simpleFormatter.format(ntpDate);
+    }
+
+    /**
+     * Converts this <code>TimeStamp</code> object to a <code>String</code>.
+     * The NTP timestamp 64-bit long value is represented as hex string with
+     * seconds separated by fractional seconds by a decimal point;
+     * e.g. c1a089bd.fc904f6d == Tue, Dec 10 2002 10:41:49.986
+     *
+     * @return NTP timestamp 64-bit long value as hex string with seconds
+     * separated by fractional seconds.
+     */
+    @Override
+    public String toString()
+    {
+        return toString(ntpTime);
+    }
+
+    /**
+     * Converts this <code>TimeStamp</code> object to a <code>String</code>
+     * of the form:
+     * <blockquote><pre>
+     * EEE, MMM dd yyyy HH:mm:ss.SSS UTC</pre></blockquote>
+     * See java.text.SimpleDataFormat for code descriptions.
+     *
+     * @return  a string representation of this date in UTC.
+     */
+    public String toUTCString()
+    {
+        if (utcFormatter == null) {
+            utcFormatter = new SimpleDateFormat(NTP_DATE_FORMAT + " 'UTC'",
+                    Locale.US);
+            utcFormatter.setTimeZone(TimeZone.getTimeZone("UTC"));
+        }
+        final Date ntpDate = getDate();
+        return utcFormatter.format(ntpDate);
+    }
+
+    /*
+        Serialization is unnecessary for this class.
+        Reject attempts to do so until such time as the Serializable attribute can be dropped.
+     */
+
+    private void writeObject(final java.io.ObjectOutputStream out) throws IOException
+    {
+        throw new UnsupportedOperationException("Serialization is not supported");
+    }
+
+    private void readObject(final java.io.ObjectInputStream in) throws IOException, ClassNotFoundException
+    {
+        throw new UnsupportedOperationException("Serialization is not supported");
+    }
+
+}
diff --git a/src/main/java/org/apache/commons/net/pop3/POP3Client.java b/src/main/java/org/apache/commons/net/pop3/POP3Client.java
index 542026b71..112d76a8d 100644
--- a/src/main/java/org/apache/commons/net/pop3/POP3Client.java
+++ b/src/main/java/org/apache/commons/net/pop3/POP3Client.java
@@ -23,0 +24 @@ import java.security.NoSuchAlgorithmException;
+import java.util.Arrays;
@@ -221,3 +222 @@ public class POP3Client extends POP3
-        for (int line = 0; line < messages.length; line++) {
-            messages[line] = parseStatus(en.next());
-        }
+        Arrays.setAll(messages, i -> parseStatus(en.next()));
@@ -293,3 +292 @@ public class POP3Client extends POP3
-        for (int line = 0; line < messages.length; line++) {
-            messages[line] = parseUID(en.next());
-        }
+        Arrays.setAll(messages, i -> parseUID(en.next()));
diff --git a/src/main/java/org/apache/commons/net/smtp/AuthenticatingSMTPClient.java b/src/main/java/org/apache/commons/net/smtp/AuthenticatingSMTPClient.java
index 6204ccd59..7c6409b8c 100644
--- a/src/main/java/org/apache/commons/net/smtp/AuthenticatingSMTPClient.java
+++ b/src/main/java/org/apache/commons/net/smtp/AuthenticatingSMTPClient.java
@@ -24,0 +25 @@ import java.security.spec.InvalidKeySpecException;
+import java.util.Arrays;
@@ -324,4 +325 @@ public class AuthenticatingSMTPClient extends SMTPSClient
-        for (int i = 0; i < parts.length; i++)
-        {
-            res[i] = Integer.parseInt (parts[i]);
-        }
+        Arrays.setAll(res, i -> Integer.parseInt(parts[i]));
diff --git a/src/main/java/org/apache/commons/net/util/SubnetUtils.java b/src/main/java/org/apache/commons/net/util/SubnetUtils.java
index 359ee7ebd..1a18afd55 100644
--- a/src/main/java/org/apache/commons/net/util/SubnetUtils.java
+++ b/src/main/java/org/apache/commons/net/util/SubnetUtils.java
@@ -98 +98 @@ public class SubnetUtils {
-            for (int add = low(), j=0; add <= high(); ++add, ++j) {
+            for (int add = low(), j = 0; add <= high(); ++add, ++j) {
diff --git a/src/test/java/org/apache/commons/net/tftp/TFTPServer.java b/src/test/java/org/apache/commons/net/tftp/TFTPServer.java
index cddedf422..5e322954c 100644
--- a/src/test/java/org/apache/commons/net/tftp/TFTPServer.java
+++ b/src/test/java/org/apache/commons/net/tftp/TFTPServer.java
@@ -1,947 +1,947 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.net.tftp;
-
-import java.io.BufferedInputStream;
-import java.io.BufferedOutputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.io.PrintStream;
-import java.net.InetAddress;
-import java.net.NetworkInterface;
-import java.net.SocketTimeoutException;
-import java.util.Enumeration;
-import java.util.HashSet;
-
-import org.apache.commons.net.io.FromNetASCIIOutputStream;
-import org.apache.commons.net.io.ToNetASCIIInputStream;
-
-/**
- * A fully multi-threaded tftp server. Can handle multiple clients at the same time. Implements RFC
- * 1350 and wrapping block numbers for large file support.
- *
- * To launch, just create an instance of the class. An IOException will be thrown if the server
- * fails to start for reasons such as port in use, port denied, etc.
- *
- * To stop, use the shutdown method.
- *
- * To check to see if the server is still running (or if it stopped because of an error), call the
- * isRunning() method.
- *
- * By default, events are not logged to stdout/stderr. This can be changed with the
- * setLog and setLogError methods.
- *
- * <p>
- * Example usage is below:
- *
- * <code>
- * public static void main(String[] args) throws Exception
- *  {
- *      if (args.length != 1)
- *      {
- *          System.out
- *                  .println("You must provide 1 argument - the base path for the server to serve from.");
- *          System.exit(1);
- *      }
- *
- *      TFTPServer ts = new TFTPServer(new File(args[0]), new File(args[0]), GET_AND_PUT);
- *      ts.setSocketTimeout(2000);
- *
- *      System.out.println("TFTP Server running.  Press enter to stop.");
- *      new InputStreamReader(System.in).read();
- *
- *      ts.shutdown();
- *      System.out.println("Server shut down.");
- *      System.exit(0);
- *  }
- *
- * </code>
- *
- * @since 2.0
- */
-
-public class TFTPServer implements Runnable
-{
-    public enum ServerMode { GET_ONLY, PUT_ONLY, GET_AND_PUT}
-    /*
-     * An instance of an ongoing transfer.
-     */
-    private class TFTPTransfer implements Runnable
-    {
-        private final TFTPPacket tftpPacket_;
-
-        private boolean shutdownTransfer;
-
-        TFTP transferTftp_;
-
-        public TFTPTransfer(final TFTPPacket tftpPacket)
-        {
-            tftpPacket_ = tftpPacket;
-        }
-
-        /*
-         * Utility method to make sure that paths provided by tftp clients do not get outside of the
-         * serverRoot directory.
-         */
-        private File buildSafeFile(final File serverDirectory, final String fileName, final boolean createSubDirs)
-                throws IOException
-        {
-            File temp = new File(serverDirectory, fileName);
-            temp = temp.getCanonicalFile();
-
-            if (!isSubdirectoryOf(serverDirectory, temp))
-            {
-                throw new IOException("Cannot access files outside of tftp server root.");
-            }
-
-            // ensure directory exists (if requested)
-            if (createSubDirs)
-            {
-                createDirectory(temp.getParentFile());
-            }
-
-            return temp;
-        }
-
-        /*
-         * recursively create subdirectories
-         */
-        private void createDirectory(final File file) throws IOException
-        {
-            final File parent = file.getParentFile();
-            if (parent == null)
-            {
-                throw new IOException("Unexpected error creating requested directory");
-            }
-            if (!parent.exists())
-            {
-                // recurse...
-                createDirectory(parent);
-            }
-
-            if (!parent.isDirectory()) {
-                throw new IOException(
-                        "Invalid directory path - file in the way of requested folder");
-            }
-            if (file.isDirectory())
-            {
-                return;
-            }
-            final boolean result = file.mkdir();
-            if (!result)
-            {
-                throw new IOException("Couldn't create requested directory");
-            }
-        }
-
-        /*
-         * Handle a tftp read request.
-         */
-        private void handleRead(final TFTPReadRequestPacket trrp) throws IOException, TFTPPacketException
-        {
-            InputStream is = null;
-            try
-            {
-                if (mode_ == ServerMode.PUT_ONLY)
-                {
-                    transferTftp_.bufferedSend(new TFTPErrorPacket(trrp.getAddress(), trrp
-                            .getPort(), TFTPErrorPacket.ILLEGAL_OPERATION,
-                            "Read not allowed by server."));
-                    return;
-                }
-
-                try
-                {
-                    is = new BufferedInputStream(new FileInputStream(buildSafeFile(
-                            serverReadDirectory_, trrp.getFilename(), false)));
-                }
-                catch (final FileNotFoundException e)
-                {
-                    transferTftp_.bufferedSend(new TFTPErrorPacket(trrp.getAddress(), trrp
-                            .getPort(), TFTPErrorPacket.FILE_NOT_FOUND, e.getMessage()));
-                    return;
-                }
-                catch (final Exception e)
-                {
-                    transferTftp_.bufferedSend(new TFTPErrorPacket(trrp.getAddress(), trrp
-                            .getPort(), TFTPErrorPacket.UNDEFINED, e.getMessage()));
-                    return;
-                }
-
-                if (trrp.getMode() == TFTP.NETASCII_MODE)
-                {
-                    is = new ToNetASCIIInputStream(is);
-                }
-
-                final byte[] temp = new byte[TFTPDataPacket.MAX_DATA_LENGTH];
-
-                TFTPPacket answer;
-
-                int block = 1;
-                boolean sendNext = true;
-
-                int readLength = TFTPDataPacket.MAX_DATA_LENGTH;
-
-                TFTPDataPacket lastSentData = null;
-
-                // We are reading a file, so when we read less than the
-                // requested bytes, we know that we are at the end of the file.
-                while (readLength == TFTPDataPacket.MAX_DATA_LENGTH && !shutdownTransfer)
-                {
-                    if (sendNext)
-                    {
-                        readLength = is.read(temp);
-                        if (readLength == -1)
-                        {
-                            readLength = 0;
-                        }
-
-                        lastSentData = new TFTPDataPacket(trrp.getAddress(), trrp.getPort(), block,
-                                temp, 0, readLength);
-                        sendData(transferTftp_, lastSentData); // send the data
-                    }
-
-                    answer = null;
-
-                    int timeoutCount = 0;
-
-                    while (!shutdownTransfer
-                            && (answer == null || !answer.getAddress().equals(trrp.getAddress()) || answer
-                                    .getPort() != trrp.getPort()))
-                    {
-                        // listen for an answer.
-                        if (answer != null)
-                        {
-                            // The answer that we got didn't come from the
-                            // expected source, fire back an error, and continue
-                            // listening.
-                            log_.println("TFTP Server ignoring message from unexpected source.");
-                            transferTftp_.bufferedSend(new TFTPErrorPacket(answer.getAddress(),
-                                    answer.getPort(), TFTPErrorPacket.UNKNOWN_TID,
-                                    "Unexpected Host or Port"));
-                        }
-                        try
-                        {
-                            answer = transferTftp_.bufferedReceive();
-                        }
-                        catch (final SocketTimeoutException e)
-                        {
-                            if (timeoutCount >= maxTimeoutRetries_)
-                            {
-                                throw e;
-                            }
-                            // didn't get an ack for this data. need to resend
-                            // it.
-                            timeoutCount++;
-                            transferTftp_.bufferedSend(lastSentData);
-                            continue;
-                        }
-                    }
-
-                    if (answer == null || !(answer instanceof TFTPAckPacket))
-                    {
-                        if (!shutdownTransfer)
-                        {
-                            logError_
-                                    .println("Unexpected response from tftp client during transfer ("
-                                            + answer + ").  Transfer aborted.");
-                        }
-                        break;
-                    }
-                    // once we get here, we know we have an answer packet
-                    // from the correct host.
-                    final TFTPAckPacket ack = (TFTPAckPacket) answer;
-                    if (ack.getBlockNumber() != block)
-                    {
-                        /*
-                         * The origional tftp spec would have called on us to resend the
-                         * previous data here, however, that causes the SAS Syndrome.
-                         * http://www.faqs.org/rfcs/rfc1123.html section 4.2.3.1 The modified
-                         * spec says that we ignore a duplicate ack. If the packet was really
-                         * lost, we will time out on receive, and resend the previous data at
-                         * that point.
-                         */
-                        sendNext = false;
-                    }
-                    else
-                    {
-                        // send the next block
-                        block++;
-                        if (block > 65535)
-                        {
-                            // wrap the block number
-                            block = 0;
-                        }
-                        sendNext = true;
-                    }
-                }
-            }
-            finally
-            {
-                try
-                {
-                    if (is != null)
-                    {
-                        is.close();
-                    }
-                }
-                catch (final IOException e)
-                {
-                    // noop
-                }
-            }
-        }
-
-        /*
-         * handle a tftp write request.
-         */
-        private void handleWrite(final TFTPWriteRequestPacket twrp) throws IOException,
-                TFTPPacketException
-        {
-            OutputStream bos = null;
-            try
-            {
-                if (mode_ == ServerMode.GET_ONLY)
-                {
-                    transferTftp_.bufferedSend(new TFTPErrorPacket(twrp.getAddress(), twrp
-                            .getPort(), TFTPErrorPacket.ILLEGAL_OPERATION,
-                            "Write not allowed by server."));
-                    return;
-                }
-
-                int lastBlock = 0;
-                final String fileName = twrp.getFilename();
-
-                try
-                {
-                    final File temp = buildSafeFile(serverWriteDirectory_, fileName, true);
-                    if (temp.exists())
-                    {
-                        transferTftp_.bufferedSend(new TFTPErrorPacket(twrp.getAddress(), twrp
-                                .getPort(), TFTPErrorPacket.FILE_EXISTS, "File already exists"));
-                        return;
-                    }
-                    bos = new BufferedOutputStream(new FileOutputStream(temp));
-
-                    if (twrp.getMode() == TFTP.NETASCII_MODE)
-                    {
-                        bos = new FromNetASCIIOutputStream(bos);
-                    }
-                }
-                catch (final Exception e)
-                {
-                    transferTftp_.bufferedSend(new TFTPErrorPacket(twrp.getAddress(), twrp
-                            .getPort(), TFTPErrorPacket.UNDEFINED, e.getMessage()));
-                    return;
-                }
-
-                TFTPAckPacket lastSentAck = new TFTPAckPacket(twrp.getAddress(), twrp.getPort(), 0);
-                sendData(transferTftp_, lastSentAck); // send the data
-
-                while (true)
-                {
-                    // get the response - ensure it is from the right place.
-                    TFTPPacket dataPacket = null;
-
-                    int timeoutCount = 0;
-
-                    while (!shutdownTransfer
-                            && (dataPacket == null
-                                    || !dataPacket.getAddress().equals(twrp.getAddress()) || dataPacket
-                                    .getPort() != twrp.getPort()))
-                    {
-                        // listen for an answer.
-                        if (dataPacket != null)
-                        {
-                            // The data that we got didn't come from the
-                            // expected source, fire back an error, and continue
-                            // listening.
-                            log_.println("TFTP Server ignoring message from unexpected source.");
-                            transferTftp_.bufferedSend(new TFTPErrorPacket(dataPacket.getAddress(),
-                                    dataPacket.getPort(), TFTPErrorPacket.UNKNOWN_TID,
-                                    "Unexpected Host or Port"));
-                        }
-
-                        try
-                        {
-                            dataPacket = transferTftp_.bufferedReceive();
-                        }
-                        catch (final SocketTimeoutException e)
-                        {
-                            if (timeoutCount >= maxTimeoutRetries_)
-                            {
-                                throw e;
-                            }
-                            // It didn't get our ack. Resend it.
-                            transferTftp_.bufferedSend(lastSentAck);
-                            timeoutCount++;
-                            continue;
-                        }
-                    }
-
-                    if (dataPacket instanceof TFTPWriteRequestPacket)
-                    {
-                        // it must have missed our initial ack. Send another.
-                        lastSentAck = new TFTPAckPacket(twrp.getAddress(), twrp.getPort(), 0);
-                        transferTftp_.bufferedSend(lastSentAck);
-                    }
-                    else if (dataPacket == null || !(dataPacket instanceof TFTPDataPacket))
-                    {
-                        if (!shutdownTransfer)
-                        {
-                            logError_
-                                    .println("Unexpected response from tftp client during transfer ("
-                                            + dataPacket + ").  Transfer aborted.");
-                        }
-                        break;
-                    }
-                    else
-                    {
-                        final int block = ((TFTPDataPacket) dataPacket).getBlockNumber();
-                        final byte[] data = ((TFTPDataPacket) dataPacket).getData();
-                        final int dataLength = ((TFTPDataPacket) dataPacket).getDataLength();
-                        final int dataOffset = ((TFTPDataPacket) dataPacket).getDataOffset();
-
-                        if (block > lastBlock || lastBlock == 65535 && block == 0)
-                        {
-                            // it might resend a data block if it missed our ack
-                            // - don't rewrite the block.
-                            bos.write(data, dataOffset, dataLength);
-                            lastBlock = block;
-                        }
-
-                        lastSentAck = new TFTPAckPacket(twrp.getAddress(), twrp.getPort(), block);
-                        sendData(transferTftp_, lastSentAck); // send the data
-                        if (dataLength < TFTPDataPacket.MAX_DATA_LENGTH)
-                        {
-                            // end of stream signal - The tranfer is complete.
-                            bos.close();
-
-                            // But my ack may be lost - so listen to see if I
-                            // need to resend the ack.
-                            for (int i = 0; i < maxTimeoutRetries_; i++)
-                            {
-                                try
-                                {
-                                    dataPacket = transferTftp_.bufferedReceive();
-                                }
-                                catch (final SocketTimeoutException e)
-                                {
-                                    // this is the expected route - the client
-                                    // shouldn't be sending any more packets.
-                                    break;
-                                }
-
-                                if (dataPacket != null
-                                        && (!dataPacket.getAddress().equals(twrp.getAddress()) || dataPacket
-                                                .getPort() != twrp.getPort()))
-                                {
-                                    // make sure it was from the right client...
-                                    transferTftp_
-                                            .bufferedSend(new TFTPErrorPacket(dataPacket
-                                                    .getAddress(), dataPacket.getPort(),
-                                                    TFTPErrorPacket.UNKNOWN_TID,
-                                                    "Unexpected Host or Port"));
-                                }
-                                else
-                                {
-                                    // This means they sent us the last
-                                    // datapacket again, must have missed our
-                                    // ack. resend it.
-                                    transferTftp_.bufferedSend(lastSentAck);
-                                }
-                            }
-
-                            // all done.
-                            break;
-                        }
-                    }
-                }
-            }
-            finally
-            {
-                if (bos != null)
-                {
-                    bos.close();
-                }
-            }
-        }
-
-        /*
-         * recursively check to see if one directory is a parent of another.
-         */
-        private boolean isSubdirectoryOf(final File parent, final File child)
-        {
-            final File childsParent = child.getParentFile();
-            if (childsParent == null)
-            {
-                return false;
-            }
-            if (childsParent.equals(parent))
-            {
-                return true;
-            }
-            return isSubdirectoryOf(parent, childsParent);
-        }
-
-        @Override
-        public void run()
-        {
-            try
-            {
-                transferTftp_ = newTFTP();
-
-                transferTftp_.beginBufferedOps();
-                transferTftp_.setDefaultTimeout(socketTimeout_);
-
-                transferTftp_.open();
-
-                if (tftpPacket_ instanceof TFTPReadRequestPacket)
-                {
-                    handleRead((TFTPReadRequestPacket) tftpPacket_);
-                }
-                else if (tftpPacket_ instanceof TFTPWriteRequestPacket)
-                {
-                    handleWrite((TFTPWriteRequestPacket) tftpPacket_);
-                }
-                else
-                {
-                    log_.println("Unsupported TFTP request (" + tftpPacket_ + ") - ignored.");
-                }
-            }
-            catch (final Exception e)
-            {
-                if (!shutdownTransfer)
-                {
-                    logError_
-                            .println("Unexpected Error in during TFTP file transfer.  Transfer aborted. "
-                                    + e);
-                }
-            }
-            finally
-            {
-                try
-                {
-                    if (transferTftp_ != null && transferTftp_.isOpen())
-                    {
-                        transferTftp_.endBufferedOps();
-                        transferTftp_.close();
-                    }
-                }
-                catch (final Exception e)
-                {
-                    // noop
-                }
-                synchronized(transfers_)
-                {
-                    transfers_.remove(this);
-                }
-            }
-        }
-
-        public void shutdown()
-        {
-            shutdownTransfer = true;
-            try
-            {
-                transferTftp_.close();
-            }
-            catch (final RuntimeException e)
-            {
-                // noop
-            }
-        }
-    }
-
-    private static final int DEFAULT_TFTP_PORT = 69;
-    /* /dev/null output stream (default) */
-    private static final PrintStream nullStream = new PrintStream(
-            new OutputStream() {
-                @Override
-                public void write(final byte[] b) throws IOException {}
-                @Override
-                public void write(final int b){}
-                }
-            );
-    private final HashSet<TFTPTransfer> transfers_ = new HashSet<>();
-    private volatile boolean shutdownServer;
-    private TFTP serverTftp_;
-    private File serverReadDirectory_;
-    private File serverWriteDirectory_;
-    private final int port_;
-    private final InetAddress laddr_;
-
-    private Exception serverException;
-
-    private final ServerMode mode_;
-    // don't have access to a logger api, so we will log to these streams, which
-    // by default are set to a no-op logger
-    private PrintStream log_;
-
-    private PrintStream logError_;
-    private int maxTimeoutRetries_ = 3;
-    private int socketTimeout_;
-
-
-    private Thread serverThread;
-
-    /**
-     * Start a TFTP Server on the specified port. Gets and Puts occur in the specified directory.
-     *
-     * The server will start in another thread, allowing this constructor to return immediately.
-     *
-     * If a get or a put comes in with a relative path that tries to get outside of the
-     * serverDirectory, then the get or put will be denied.
-     *
-     * GET_ONLY mode only allows gets, PUT_ONLY mode only allows puts, and GET_AND_PUT allows both.
-     * Modes are defined as int constants in this class.
-     *
-     * @param serverReadDirectory directory for GET requests
-     * @param serverWriteDirectory directory for PUT requests
-     * @param port The local port to bind to.
-     * @param localaddr The local address to bind to.
-     * @param mode A value as specified above.
-     * @param log Stream to write log message to. If not provided, uses System.out
-     * @param errorLog Stream to write error messages to. If not provided, uses System.err.
-     * @throws IOException if the server directory is invalid or does not exist.
-     */
-    public TFTPServer(final File serverReadDirectory, final File serverWriteDirectory, final int port,
-        final InetAddress localaddr, final ServerMode mode, final PrintStream log, final PrintStream errorLog)
-        throws IOException
-    {
-        port_ = port;
-        mode_ = mode;
-        laddr_ = localaddr;
-        log_ = log == null ? nullStream: log;
-        logError_ = errorLog == null ? nullStream : errorLog;
-        launch(serverReadDirectory, serverWriteDirectory);
-    }
-
-    /**
-     * Start a TFTP Server on the specified port. Gets and Puts occur in the specified directory.
-     *
-     * The server will start in another thread, allowing this constructor to return immediately.
-     *
-     * If a get or a put comes in with a relative path that tries to get outside of the
-     * serverDirectory, then the get or put will be denied.
-     *
-     * GET_ONLY mode only allows gets, PUT_ONLY mode only allows puts, and GET_AND_PUT allows both.
-     * Modes are defined as int constants in this class.
-     *
-     * @param serverReadDirectory directory for GET requests
-     * @param serverWriteDirectory directory for PUT requests
-     * @param port the port to use
-     * @param localiface The local network interface to bind to.
-     *  The interface's first address wil be used.
-     * @param mode A value as specified above.
-     * @param log Stream to write log message to. If not provided, uses System.out
-     * @param errorLog Stream to write error messages to. If not provided, uses System.err.
-     * @throws IOException if the server directory is invalid or does not exist.
-     */
-    public TFTPServer(final File serverReadDirectory, final File serverWriteDirectory, final int port,
-        final NetworkInterface localiface, final ServerMode mode, final PrintStream log, final PrintStream errorLog)
-        throws IOException
-    {
-        mode_ = mode;
-        port_= port;
-        InetAddress iaddr = null;
-        if (localiface != null)
-        {
-            final Enumeration<InetAddress> ifaddrs = localiface.getInetAddresses();
-            if ((ifaddrs != null) && ifaddrs.hasMoreElements()) {
-                iaddr = ifaddrs.nextElement();
-            }
-        }
-        log_ = log == null ? nullStream: log;
-        logError_ = errorLog == null ? nullStream : errorLog;
-        laddr_ = iaddr;
-        launch(serverReadDirectory, serverWriteDirectory);
-    }
-
-    /**
-     * Start a TFTP Server on the specified port. Gets and Puts occur in the specified directory.
-     *
-     * The server will start in another thread, allowing this constructor to return immediately.
-     *
-     * If a get or a put comes in with a relative path that tries to get outside of the
-     * serverDirectory, then the get or put will be denied.
-     *
-     * GET_ONLY mode only allows gets, PUT_ONLY mode only allows puts, and GET_AND_PUT allows both.
-     * Modes are defined as int constants in this class.
-     *
-     * @param serverReadDirectory directory for GET requests
-     * @param serverWriteDirectory directory for PUT requests
-     * @param port the port to use
-     * @param mode A value as specified above.
-     * @param log Stream to write log message to. If not provided, uses System.out
-     * @param errorLog Stream to write error messages to. If not provided, uses System.err.
-     * @throws IOException if the server directory is invalid or does not exist.
-     */
-    public TFTPServer(final File serverReadDirectory, final File serverWriteDirectory, final int port, final ServerMode mode,
-            final PrintStream log, final PrintStream errorLog) throws IOException
-    {
-        port_ = port;
-        mode_ = mode;
-        log_ = log == null ? nullStream: log;
-        logError_ = errorLog == null ? nullStream : errorLog;
-        laddr_ = null;
-        launch(serverReadDirectory, serverWriteDirectory);
-    }
-
-    /**
-     * Start a TFTP Server on the default port (69). Gets and Puts occur in the specified
-     * directories.
-     *
-     * The server will start in another thread, allowing this constructor to return immediately.
-     *
-     * If a get or a put comes in with a relative path that tries to get outside of the
-     * serverDirectory, then the get or put will be denied.
-     *
-     * GET_ONLY mode only allows gets, PUT_ONLY mode only allows puts, and GET_AND_PUT allows both.
-     * Modes are defined as int constants in this class.
-     *
-     * @param serverReadDirectory directory for GET requests
-     * @param serverWriteDirectory directory for PUT requests
-     * @param mode A value as specified above.
-     * @throws IOException if the server directory is invalid or does not exist.
-     */
-    public TFTPServer(final File serverReadDirectory, final File serverWriteDirectory, final ServerMode mode)
-            throws IOException
-    {
-        this(serverReadDirectory, serverWriteDirectory, DEFAULT_TFTP_PORT, mode, null, null);
-    }
-
-    @Override
-    protected void finalize() throws Throwable
-    {
-        shutdown();
-    }
-
-    /**
-     * Get the current value for maxTimeoutRetries
-     * @return the max allowed number of retries
-     */
-    public int getMaxTimeoutRetries()
-    {
-        return maxTimeoutRetries_;
-    }
-
-    /**
-     * The current socket timeout used during transfers in milliseconds.
-     * @return the timeout value
-     */
-    public int getSocketTimeout()
-    {
-        return socketTimeout_;
-    }
-
-    /**
-     * check if the server thread is still running.
-     *
-     * @return true if running, false if stopped.
-     * @throws Exception throws the exception that stopped the server if the server is stopped from
-     *             an exception.
-     */
-    public boolean isRunning() throws Exception
-    {
-        if (shutdownServer && serverException != null)
-        {
-            throw serverException;
-        }
-        return !shutdownServer;
-    }
-
-    /*
-     * start the server, throw an error if it can't start.
-     */
-    private void launch(final File serverReadDirectory, final File serverWriteDirectory) throws IOException
-    {
-        log_.println("Starting TFTP Server on port " + port_ + ".  Read directory: "
-                + serverReadDirectory + " Write directory: " + serverWriteDirectory
-                + " Server Mode is " + mode_);
-
-        serverReadDirectory_ = serverReadDirectory.getCanonicalFile();
-        if (!serverReadDirectory_.exists() || !serverReadDirectory.isDirectory())
-        {
-            throw new IOException("The server read directory " + serverReadDirectory_
-                    + " does not exist");
-        }
-
-        serverWriteDirectory_ = serverWriteDirectory.getCanonicalFile();
-        if (!serverWriteDirectory_.exists() || !serverWriteDirectory.isDirectory())
-        {
-            throw new IOException("The server write directory " + serverWriteDirectory_
-                    + " does not exist");
-        }
-
-        serverTftp_ = new TFTP();
-
-        // This is the value used in response to each client.
-        socketTimeout_ = serverTftp_.getDefaultTimeout();
-
-        // we want the server thread to listen forever.
-        serverTftp_.setDefaultTimeout(0);
-
-        if (laddr_ != null) {
-            serverTftp_.open(port_, laddr_);
-        } else {
-            serverTftp_.open(port_);
-        }
-
-        serverThread = new Thread(this);
-        serverThread.setDaemon(true);
-        serverThread.start();
-    }
-
-    /*
-     * Allow test code to customise the TFTP instance
-     */
-    TFTP newTFTP() {
-        return new TFTP();
-    }
-
-    @Override
-    public void run()
-    {
-        try
-        {
-            while (!shutdownServer)
-            {
-                final TFTPPacket tftpPacket;
-
-                tftpPacket = serverTftp_.receive();
-
-                final TFTPTransfer tt = new TFTPTransfer(tftpPacket);
-                synchronized(transfers_)
-                {
-                    transfers_.add(tt);
-                }
-
-                final Thread thread = new Thread(tt);
-                thread.setDaemon(true);
-                thread.start();
-            }
-        }
-        catch (final Exception e)
-        {
-            if (!shutdownServer)
-            {
-                serverException = e;
-                logError_.println("Unexpected Error in TFTP Server - Server shut down! + " + e);
-            }
-        }
-        finally
-        {
-            shutdownServer = true; // set this to true, so the launching thread can check to see if it started.
-            if (serverTftp_ != null && serverTftp_.isOpen())
-            {
-                serverTftp_.close();
-            }
-        }
-    }
-
-    /*
-     * Also allow customisation of sending data/ack so can generate errors if needed
-     */
-    void sendData(final TFTP tftp, final TFTPPacket data) throws IOException {
-        tftp.bufferedSend(data);
-    }
-
-    /**
-     * Set the stream object to log debug / informational messages. By default, this is a no-op
-     *
-     * @param log the stream to use for logging
-     */
-    public void setLog(final PrintStream log)
-    {
-        this.log_ = log;
-    }
-
-    /**
-     * Set the stream object to log error messsages. By default, this is a no-op
-     *
-     * @param logError the stream to use for logging errors
-     */
-    public void setLogError(final PrintStream logError)
-    {
-        this.logError_ = logError;
-    }
-
-    /**
-     * Set the max number of retries in response to a timeout. Default 3. Min 0.
-     *
-     * @param retries number of retries, must be &gt; 0
-     */
-    public void setMaxTimeoutRetries(final int retries)
-    {
-        if (retries < 0)
-        {
-            throw new RuntimeException("Invalid Value");
-        }
-        maxTimeoutRetries_ = retries;
-    }
-
-    /**
-     * Set the socket timeout in milliseconds used in transfers. Defaults to the value here:
-     * https://commons.apache.org/net/apidocs/org/apache/commons/net/tftp/TFTP.html#DEFAULT_TIMEOUT
-     * (5000 at the time I write this) Min value of 10.
-     * @param timeout the timeout; must be larger than 10
-     */
-    public void setSocketTimeout(final int timeout)
-    {
-        if (timeout < 10)
-        {
-            throw new RuntimeException("Invalid Value");
-        }
-        socketTimeout_ = timeout;
-    }
-
-    /**
-     * Stop the tftp server (and any currently running transfers) and release all opened network
-     * resources.
-     */
-    public void shutdown()
-    {
-        shutdownServer = true;
-
-        synchronized(transfers_)
-        {
-            transfers_.forEach(TFTPTransfer::shutdown);
-        }
-
-        try
-        {
-            serverTftp_.close();
-        }
-        catch (final RuntimeException e)
-        {
-            // noop
-        }
-
-        try {
-            serverThread.join();
-        } catch (final InterruptedException e) {
-            // we've done the best we could, return
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.net.tftp;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.PrintStream;
+import java.net.InetAddress;
+import java.net.NetworkInterface;
+import java.net.SocketTimeoutException;
+import java.util.Enumeration;
+import java.util.HashSet;
+
+import org.apache.commons.net.io.FromNetASCIIOutputStream;
+import org.apache.commons.net.io.ToNetASCIIInputStream;
+
+/**
+ * A fully multi-threaded tftp server. Can handle multiple clients at the same time. Implements RFC
+ * 1350 and wrapping block numbers for large file support.
+ *
+ * To launch, just create an instance of the class. An IOException will be thrown if the server
+ * fails to start for reasons such as port in use, port denied, etc.
+ *
+ * To stop, use the shutdown method.
+ *
+ * To check to see if the server is still running (or if it stopped because of an error), call the
+ * isRunning() method.
+ *
+ * By default, events are not logged to stdout/stderr. This can be changed with the
+ * setLog and setLogError methods.
+ *
+ * <p>
+ * Example usage is below:
+ *
+ * <code>
+ * public static void main(String[] args) throws Exception
+ *  {
+ *      if (args.length != 1)
+ *      {
+ *          System.out
+ *                  .println("You must provide 1 argument - the base path for the server to serve from.");
+ *          System.exit(1);
+ *      }
+ *
+ *      TFTPServer ts = new TFTPServer(new File(args[0]), new File(args[0]), GET_AND_PUT);
+ *      ts.setSocketTimeout(2000);
+ *
+ *      System.out.println("TFTP Server running.  Press enter to stop.");
+ *      new InputStreamReader(System.in).read();
+ *
+ *      ts.shutdown();
+ *      System.out.println("Server shut down.");
+ *      System.exit(0);
+ *  }
+ *
+ * </code>
+ *
+ * @since 2.0
+ */
+
+public class TFTPServer implements Runnable
+{
+    public enum ServerMode { GET_ONLY, PUT_ONLY, GET_AND_PUT}
+    /*
+     * An instance of an ongoing transfer.
+     */
+    private class TFTPTransfer implements Runnable
+    {
+        private final TFTPPacket tftpPacket_;
+
+        private boolean shutdownTransfer;
+
+        TFTP transferTftp_;
+
+        public TFTPTransfer(final TFTPPacket tftpPacket)
+        {
+            tftpPacket_ = tftpPacket;
+        }
+
+        /*
+         * Utility method to make sure that paths provided by tftp clients do not get outside of the
+         * serverRoot directory.
+         */
+        private File buildSafeFile(final File serverDirectory, final String fileName, final boolean createSubDirs)
+                throws IOException
+        {
+            File temp = new File(serverDirectory, fileName);
+            temp = temp.getCanonicalFile();
+
+            if (!isSubdirectoryOf(serverDirectory, temp))
+            {
+                throw new IOException("Cannot access files outside of tftp server root.");
+            }
+
+            // ensure directory exists (if requested)
+            if (createSubDirs)
+            {
+                createDirectory(temp.getParentFile());
+            }
+
+            return temp;
+        }
+
+        /*
+         * recursively create subdirectories
+         */
+        private void createDirectory(final File file) throws IOException
+        {
+            final File parent = file.getParentFile();
+            if (parent == null)
+            {
+                throw new IOException("Unexpected error creating requested directory");
+            }
+            if (!parent.exists())
+            {
+                // recurse...
+                createDirectory(parent);
+            }
+
+            if (!parent.isDirectory()) {
+                throw new IOException(
+                        "Invalid directory path - file in the way of requested folder");
+            }
+            if (file.isDirectory())
+            {
+                return;
+            }
+            final boolean result = file.mkdir();
+            if (!result)
+            {
+                throw new IOException("Couldn't create requested directory");
+            }
+        }
+
+        /*
+         * Handle a tftp read request.
+         */
+        private void handleRead(final TFTPReadRequestPacket trrp) throws IOException, TFTPPacketException
+        {
+            InputStream is = null;
+            try
+            {
+                if (mode_ == ServerMode.PUT_ONLY)
+                {
+                    transferTftp_.bufferedSend(new TFTPErrorPacket(trrp.getAddress(), trrp
+                            .getPort(), TFTPErrorPacket.ILLEGAL_OPERATION,
+                            "Read not allowed by server."));
+                    return;
+                }
+
+                try
+                {
+                    is = new BufferedInputStream(new FileInputStream(buildSafeFile(
+                            serverReadDirectory_, trrp.getFilename(), false)));
+                }
+                catch (final FileNotFoundException e)
+                {
+                    transferTftp_.bufferedSend(new TFTPErrorPacket(trrp.getAddress(), trrp
+                            .getPort(), TFTPErrorPacket.FILE_NOT_FOUND, e.getMessage()));
+                    return;
+                }
+                catch (final Exception e)
+                {
+                    transferTftp_.bufferedSend(new TFTPErrorPacket(trrp.getAddress(), trrp
+                            .getPort(), TFTPErrorPacket.UNDEFINED, e.getMessage()));
+                    return;
+                }
+
+                if (trrp.getMode() == TFTP.NETASCII_MODE)
+                {
+                    is = new ToNetASCIIInputStream(is);
+                }
+
+                final byte[] temp = new byte[TFTPDataPacket.MAX_DATA_LENGTH];
+
+                TFTPPacket answer;
+
+                int block = 1;
+                boolean sendNext = true;
+
+                int readLength = TFTPDataPacket.MAX_DATA_LENGTH;
+
+                TFTPDataPacket lastSentData = null;
+
+                // We are reading a file, so when we read less than the
+                // requested bytes, we know that we are at the end of the file.
+                while (readLength == TFTPDataPacket.MAX_DATA_LENGTH && !shutdownTransfer)
+                {
+                    if (sendNext)
+                    {
+                        readLength = is.read(temp);
+                        if (readLength == -1)
+                        {
+                            readLength = 0;
+                        }
+
+                        lastSentData = new TFTPDataPacket(trrp.getAddress(), trrp.getPort(), block,
+                                temp, 0, readLength);
+                        sendData(transferTftp_, lastSentData); // send the data
+                    }
+
+                    answer = null;
+
+                    int timeoutCount = 0;
+
+                    while (!shutdownTransfer
+                            && (answer == null || !answer.getAddress().equals(trrp.getAddress()) || answer
+                                    .getPort() != trrp.getPort()))
+                    {
+                        // listen for an answer.
+                        if (answer != null)
+                        {
+                            // The answer that we got didn't come from the
+                            // expected source, fire back an error, and continue
+                            // listening.
+                            log_.println("TFTP Server ignoring message from unexpected source.");
+                            transferTftp_.bufferedSend(new TFTPErrorPacket(answer.getAddress(),
+                                    answer.getPort(), TFTPErrorPacket.UNKNOWN_TID,
+                                    "Unexpected Host or Port"));
+                        }
+                        try
+                        {
+                            answer = transferTftp_.bufferedReceive();
+                        }
+                        catch (final SocketTimeoutException e)
+                        {
+                            if (timeoutCount >= maxTimeoutRetries_)
+                            {
+                                throw e;
+                            }
+                            // didn't get an ack for this data. need to resend
+                            // it.
+                            timeoutCount++;
+                            transferTftp_.bufferedSend(lastSentData);
+                            continue;
+                        }
+                    }
+
+                    if (answer == null || !(answer instanceof TFTPAckPacket))
+                    {
+                        if (!shutdownTransfer)
+                        {
+                            logError_
+                                    .println("Unexpected response from tftp client during transfer ("
+                                            + answer + ").  Transfer aborted.");
+                        }
+                        break;
+                    }
+                    // once we get here, we know we have an answer packet
+                    // from the correct host.
+                    final TFTPAckPacket ack = (TFTPAckPacket) answer;
+                    if (ack.getBlockNumber() != block)
+                    {
+                        /*
+                         * The origional tftp spec would have called on us to resend the
+                         * previous data here, however, that causes the SAS Syndrome.
+                         * http://www.faqs.org/rfcs/rfc1123.html section 4.2.3.1 The modified
+                         * spec says that we ignore a duplicate ack. If the packet was really
+                         * lost, we will time out on receive, and resend the previous data at
+                         * that point.
+                         */
+                        sendNext = false;
+                    }
+                    else
+                    {
+                        // send the next block
+                        block++;
+                        if (block > 65535)
+                        {
+                            // wrap the block number
+                            block = 0;
+                        }
+                        sendNext = true;
+                    }
+                }
+            }
+            finally
+            {
+                try
+                {
+                    if (is != null)
+                    {
+                        is.close();
+                    }
+                }
+                catch (final IOException e)
+                {
+                    // noop
+                }
+            }
+        }
+
+        /*
+         * handle a tftp write request.
+         */
+        private void handleWrite(final TFTPWriteRequestPacket twrp) throws IOException,
+                TFTPPacketException
+        {
+            OutputStream bos = null;
+            try
+            {
+                if (mode_ == ServerMode.GET_ONLY)
+                {
+                    transferTftp_.bufferedSend(new TFTPErrorPacket(twrp.getAddress(), twrp
+                            .getPort(), TFTPErrorPacket.ILLEGAL_OPERATION,
+                            "Write not allowed by server."));
+                    return;
+                }
+
+                int lastBlock = 0;
+                final String fileName = twrp.getFilename();
+
+                try
+                {
+                    final File temp = buildSafeFile(serverWriteDirectory_, fileName, true);
+                    if (temp.exists())
+                    {
+                        transferTftp_.bufferedSend(new TFTPErrorPacket(twrp.getAddress(), twrp
+                                .getPort(), TFTPErrorPacket.FILE_EXISTS, "File already exists"));
+                        return;
+                    }
+                    bos = new BufferedOutputStream(new FileOutputStream(temp));
+
+                    if (twrp.getMode() == TFTP.NETASCII_MODE)
+                    {
+                        bos = new FromNetASCIIOutputStream(bos);
+                    }
+                }
+                catch (final Exception e)
+                {
+                    transferTftp_.bufferedSend(new TFTPErrorPacket(twrp.getAddress(), twrp
+                            .getPort(), TFTPErrorPacket.UNDEFINED, e.getMessage()));
+                    return;
+                }
+
+                TFTPAckPacket lastSentAck = new TFTPAckPacket(twrp.getAddress(), twrp.getPort(), 0);
+                sendData(transferTftp_, lastSentAck); // send the data
+
+                while (true)
+                {
+                    // get the response - ensure it is from the right place.
+                    TFTPPacket dataPacket = null;
+
+                    int timeoutCount = 0;
+
+                    while (!shutdownTransfer
+                            && (dataPacket == null
+                                    || !dataPacket.getAddress().equals(twrp.getAddress()) || dataPacket
+                                    .getPort() != twrp.getPort()))
+                    {
+                        // listen for an answer.
+                        if (dataPacket != null)
+                        {
+                            // The data that we got didn't come from the
+                            // expected source, fire back an error, and continue
+                            // listening.
+                            log_.println("TFTP Server ignoring message from unexpected source.");
+                            transferTftp_.bufferedSend(new TFTPErrorPacket(dataPacket.getAddress(),
+                                    dataPacket.getPort(), TFTPErrorPacket.UNKNOWN_TID,
+                                    "Unexpected Host or Port"));
+                        }
+
+                        try
+                        {
+                            dataPacket = transferTftp_.bufferedReceive();
+                        }
+                        catch (final SocketTimeoutException e)
+                        {
+                            if (timeoutCount >= maxTimeoutRetries_)
+                            {
+                                throw e;
+                            }
+                            // It didn't get our ack. Resend it.
+                            transferTftp_.bufferedSend(lastSentAck);
+                            timeoutCount++;
+                            continue;
+                        }
+                    }
+
+                    if (dataPacket instanceof TFTPWriteRequestPacket)
+                    {
+                        // it must have missed our initial ack. Send another.
+                        lastSentAck = new TFTPAckPacket(twrp.getAddress(), twrp.getPort(), 0);
+                        transferTftp_.bufferedSend(lastSentAck);
+                    }
+                    else if (dataPacket == null || !(dataPacket instanceof TFTPDataPacket))
+                    {
+                        if (!shutdownTransfer)
+                        {
+                            logError_
+                                    .println("Unexpected response from tftp client during transfer ("
+                                            + dataPacket + ").  Transfer aborted.");
+                        }
+                        break;
+                    }
+                    else
+                    {
+                        final int block = ((TFTPDataPacket) dataPacket).getBlockNumber();
+                        final byte[] data = ((TFTPDataPacket) dataPacket).getData();
+                        final int dataLength = ((TFTPDataPacket) dataPacket).getDataLength();
+                        final int dataOffset = ((TFTPDataPacket) dataPacket).getDataOffset();
+
+                        if (block > lastBlock || lastBlock == 65535 && block == 0)
+                        {
+                            // it might resend a data block if it missed our ack
+                            // - don't rewrite the block.
+                            bos.write(data, dataOffset, dataLength);
+                            lastBlock = block;
+                        }
+
+                        lastSentAck = new TFTPAckPacket(twrp.getAddress(), twrp.getPort(), block);
+                        sendData(transferTftp_, lastSentAck); // send the data
+                        if (dataLength < TFTPDataPacket.MAX_DATA_LENGTH)
+                        {
+                            // end of stream signal - The tranfer is complete.
+                            bos.close();
+
+                            // But my ack may be lost - so listen to see if I
+                            // need to resend the ack.
+                            for (int i = 0; i < maxTimeoutRetries_; i++)
+                            {
+                                try
+                                {
+                                    dataPacket = transferTftp_.bufferedReceive();
+                                }
+                                catch (final SocketTimeoutException e)
+                                {
+                                    // this is the expected route - the client
+                                    // shouldn't be sending any more packets.
+                                    break;
+                                }
+
+                                if (dataPacket != null
+                                        && (!dataPacket.getAddress().equals(twrp.getAddress()) || dataPacket
+                                                .getPort() != twrp.getPort()))
+                                {
+                                    // make sure it was from the right client...
+                                    transferTftp_
+                                            .bufferedSend(new TFTPErrorPacket(dataPacket
+                                                    .getAddress(), dataPacket.getPort(),
+                                                    TFTPErrorPacket.UNKNOWN_TID,
+                                                    "Unexpected Host or Port"));
+                                }
+                                else
+                                {
+                                    // This means they sent us the last
+                                    // datapacket again, must have missed our
+                                    // ack. resend it.
+                                    transferTftp_.bufferedSend(lastSentAck);
+                                }
+                            }
+
+                            // all done.
+                            break;
+                        }
+                    }
+                }
+            }
+            finally
+            {
+                if (bos != null)
+                {
+                    bos.close();
+                }
+            }
+        }
+
+        /*
+         * recursively check to see if one directory is a parent of another.
+         */
+        private boolean isSubdirectoryOf(final File parent, final File child)
+        {
+            final File childsParent = child.getParentFile();
+            if (childsParent == null)
+            {
+                return false;
+            }
+            if (childsParent.equals(parent))
+            {
+                return true;
+            }
+            return isSubdirectoryOf(parent, childsParent);
+        }
+
+        @Override
+        public void run()
+        {
+            try
+            {
+                transferTftp_ = newTFTP();
+
+                transferTftp_.beginBufferedOps();
+                transferTftp_.setDefaultTimeout(socketTimeout_);
+
+                transferTftp_.open();
+
+                if (tftpPacket_ instanceof TFTPReadRequestPacket)
+                {
+                    handleRead((TFTPReadRequestPacket) tftpPacket_);
+                }
+                else if (tftpPacket_ instanceof TFTPWriteRequestPacket)
+                {
+                    handleWrite((TFTPWriteRequestPacket) tftpPacket_);
+                }
+                else
+                {
+                    log_.println("Unsupported TFTP request (" + tftpPacket_ + ") - ignored.");
+                }
+            }
+            catch (final Exception e)
+            {
+                if (!shutdownTransfer)
+                {
+                    logError_
+                            .println("Unexpected Error in during TFTP file transfer.  Transfer aborted. "
+                                    + e);
+                }
+            }
+            finally
+            {
+                try
+                {
+                    if (transferTftp_ != null && transferTftp_.isOpen())
+                    {
+                        transferTftp_.endBufferedOps();
+                        transferTftp_.close();
+                    }
+                }
+                catch (final Exception e)
+                {
+                    // noop
+                }
+                synchronized(transfers_)
+                {
+                    transfers_.remove(this);
+                }
+            }
+        }
+
+        public void shutdown()
+        {
+            shutdownTransfer = true;
+            try
+            {
+                transferTftp_.close();
+            }
+            catch (final RuntimeException e)
+            {
+                // noop
+            }
+        }
+    }
+
+    private static final int DEFAULT_TFTP_PORT = 69;
+    /* /dev/null output stream (default) */
+    private static final PrintStream nullStream = new PrintStream(
+            new OutputStream() {
+                @Override
+                public void write(final byte[] b) throws IOException {}
+                @Override
+                public void write(final int b){}
+                }
+            );
+    private final HashSet<TFTPTransfer> transfers_ = new HashSet<>();
+    private volatile boolean shutdownServer;
+    private TFTP serverTftp_;
+    private File serverReadDirectory_;
+    private File serverWriteDirectory_;
+    private final int port_;
+    private final InetAddress laddr_;
+
+    private Exception serverException;
+
+    private final ServerMode mode_;
+    // don't have access to a logger api, so we will log to these streams, which
+    // by default are set to a no-op logger
+    private PrintStream log_;
+
+    private PrintStream logError_;
+    private int maxTimeoutRetries_ = 3;
+    private int socketTimeout_;
+
+
+    private Thread serverThread;
+
+    /**
+     * Start a TFTP Server on the specified port. Gets and Puts occur in the specified directory.
+     *
+     * The server will start in another thread, allowing this constructor to return immediately.
+     *
+     * If a get or a put comes in with a relative path that tries to get outside of the
+     * serverDirectory, then the get or put will be denied.
+     *
+     * GET_ONLY mode only allows gets, PUT_ONLY mode only allows puts, and GET_AND_PUT allows both.
+     * Modes are defined as int constants in this class.
+     *
+     * @param serverReadDirectory directory for GET requests
+     * @param serverWriteDirectory directory for PUT requests
+     * @param port The local port to bind to.
+     * @param localaddr The local address to bind to.
+     * @param mode A value as specified above.
+     * @param log Stream to write log message to. If not provided, uses System.out
+     * @param errorLog Stream to write error messages to. If not provided, uses System.err.
+     * @throws IOException if the server directory is invalid or does not exist.
+     */
+    public TFTPServer(final File serverReadDirectory, final File serverWriteDirectory, final int port,
+        final InetAddress localaddr, final ServerMode mode, final PrintStream log, final PrintStream errorLog)
+        throws IOException
+    {
+        port_ = port;
+        mode_ = mode;
+        laddr_ = localaddr;
+        log_ = log == null ? nullStream: log;
+        logError_ = errorLog == null ? nullStream : errorLog;
+        launch(serverReadDirectory, serverWriteDirectory);
+    }
+
+    /**
+     * Start a TFTP Server on the specified port. Gets and Puts occur in the specified directory.
+     *
+     * The server will start in another thread, allowing this constructor to return immediately.
+     *
+     * If a get or a put comes in with a relative path that tries to get outside of the
+     * serverDirectory, then the get or put will be denied.
+     *
+     * GET_ONLY mode only allows gets, PUT_ONLY mode only allows puts, and GET_AND_PUT allows both.
+     * Modes are defined as int constants in this class.
+     *
+     * @param serverReadDirectory directory for GET requests
+     * @param serverWriteDirectory directory for PUT requests
+     * @param port the port to use
+     * @param localiface The local network interface to bind to.
+     *  The interface's first address wil be used.
+     * @param mode A value as specified above.
+     * @param log Stream to write log message to. If not provided, uses System.out
+     * @param errorLog Stream to write error messages to. If not provided, uses System.err.
+     * @throws IOException if the server directory is invalid or does not exist.
+     */
+    public TFTPServer(final File serverReadDirectory, final File serverWriteDirectory, final int port,
+        final NetworkInterface localiface, final ServerMode mode, final PrintStream log, final PrintStream errorLog)
+        throws IOException
+    {
+        mode_ = mode;
+        port_= port;
+        InetAddress iaddr = null;
+        if (localiface != null)
+        {
+            final Enumeration<InetAddress> ifaddrs = localiface.getInetAddresses();
+            if ((ifaddrs != null) && ifaddrs.hasMoreElements()) {
+                iaddr = ifaddrs.nextElement();
+            }
+        }
+        log_ = log == null ? nullStream: log;
+        logError_ = errorLog == null ? nullStream : errorLog;
+        laddr_ = iaddr;
+        launch(serverReadDirectory, serverWriteDirectory);
+    }
+
+    /**
+     * Start a TFTP Server on the specified port. Gets and Puts occur in the specified directory.
+     *
+     * The server will start in another thread, allowing this constructor to return immediately.
+     *
+     * If a get or a put comes in with a relative path that tries to get outside of the
+     * serverDirectory, then the get or put will be denied.
+     *
+     * GET_ONLY mode only allows gets, PUT_ONLY mode only allows puts, and GET_AND_PUT allows both.
+     * Modes are defined as int constants in this class.
+     *
+     * @param serverReadDirectory directory for GET requests
+     * @param serverWriteDirectory directory for PUT requests
+     * @param port the port to use
+     * @param mode A value as specified above.
+     * @param log Stream to write log message to. If not provided, uses System.out
+     * @param errorLog Stream to write error messages to. If not provided, uses System.err.
+     * @throws IOException if the server directory is invalid or does not exist.
+     */
+    public TFTPServer(final File serverReadDirectory, final File serverWriteDirectory, final int port, final ServerMode mode,
+            final PrintStream log, final PrintStream errorLog) throws IOException
+    {
+        port_ = port;
+        mode_ = mode;
+        log_ = log == null ? nullStream: log;
+        logError_ = errorLog == null ? nullStream : errorLog;
+        laddr_ = null;
+        launch(serverReadDirectory, serverWriteDirectory);
+    }
+
+    /**
+     * Start a TFTP Server on the default port (69). Gets and Puts occur in the specified
+     * directories.
+     *
+     * The server will start in another thread, allowing this constructor to return immediately.
+     *
+     * If a get or a put comes in with a relative path that tries to get outside of the
+     * serverDirectory, then the get or put will be denied.
+     *
+     * GET_ONLY mode only allows gets, PUT_ONLY mode only allows puts, and GET_AND_PUT allows both.
+     * Modes are defined as int constants in this class.
+     *
+     * @param serverReadDirectory directory for GET requests
+     * @param serverWriteDirectory directory for PUT requests
+     * @param mode A value as specified above.
+     * @throws IOException if the server directory is invalid or does not exist.
+     */
+    public TFTPServer(final File serverReadDirectory, final File serverWriteDirectory, final ServerMode mode)
+            throws IOException
+    {
+        this(serverReadDirectory, serverWriteDirectory, DEFAULT_TFTP_PORT, mode, null, null);
+    }
+
+    @Override
+    protected void finalize() throws Throwable
+    {
+        shutdown();
+    }
+
+    /**
+     * Get the current value for maxTimeoutRetries
+     * @return the max allowed number of retries
+     */
+    public int getMaxTimeoutRetries()
+    {
+        return maxTimeoutRetries_;
+    }
+
+    /**
+     * The current socket timeout used during transfers in milliseconds.
+     * @return the timeout value
+     */
+    public int getSocketTimeout()
+    {
+        return socketTimeout_;
+    }
+
+    /**
+     * check if the server thread is still running.
+     *
+     * @return true if running, false if stopped.
+     * @throws Exception throws the exception that stopped the server if the server is stopped from
+     *             an exception.
+     */
+    public boolean isRunning() throws Exception
+    {
+        if (shutdownServer && serverException != null)
+        {
+            throw serverException;
+        }
+        return !shutdownServer;
+    }
+
+    /*
+     * start the server, throw an error if it can't start.
+     */
+    private void launch(final File serverReadDirectory, final File serverWriteDirectory) throws IOException
+    {
+        log_.println("Starting TFTP Server on port " + port_ + ".  Read directory: "
+                + serverReadDirectory + " Write directory: " + serverWriteDirectory
+                + " Server Mode is " + mode_);
+
+        serverReadDirectory_ = serverReadDirectory.getCanonicalFile();
+        if (!serverReadDirectory_.exists() || !serverReadDirectory.isDirectory())
+        {
+            throw new IOException("The server read directory " + serverReadDirectory_
+                    + " does not exist");
+        }
+
+        serverWriteDirectory_ = serverWriteDirectory.getCanonicalFile();
+        if (!serverWriteDirectory_.exists() || !serverWriteDirectory.isDirectory())
+        {
+            throw new IOException("The server write directory " + serverWriteDirectory_
+                    + " does not exist");
+        }
+
+        serverTftp_ = new TFTP();
+
+        // This is the value used in response to each client.
+        socketTimeout_ = serverTftp_.getDefaultTimeout();
+
+        // we want the server thread to listen forever.
+        serverTftp_.setDefaultTimeout(0);
+
+        if (laddr_ != null) {
+            serverTftp_.open(port_, laddr_);
+        } else {
+            serverTftp_.open(port_);
+        }
+
+        serverThread = new Thread(this);
+        serverThread.setDaemon(true);
+        serverThread.start();
+    }
+
+    /*
+     * Allow test code to customise the TFTP instance
+     */
+    TFTP newTFTP() {
+        return new TFTP();
+    }
+
+    @Override
+    public void run()
+    {
+        try
+        {
+            while (!shutdownServer)
+            {
+                final TFTPPacket tftpPacket;
+
+                tftpPacket = serverTftp_.receive();
+
+                final TFTPTransfer tt = new TFTPTransfer(tftpPacket);
+                synchronized(transfers_)
+                {
+                    transfers_.add(tt);
+                }
+
+                final Thread thread = new Thread(tt);
+                thread.setDaemon(true);
+                thread.start();
+            }
+        }
+        catch (final Exception e)
+        {
+            if (!shutdownServer)
+            {
+                serverException = e;
+                logError_.println("Unexpected Error in TFTP Server - Server shut down! + " + e);
+            }
+        }
+        finally
+        {
+            shutdownServer = true; // set this to true, so the launching thread can check to see if it started.
+            if (serverTftp_ != null && serverTftp_.isOpen())
+            {
+                serverTftp_.close();
+            }
+        }
+    }
+
+    /*
+     * Also allow customisation of sending data/ack so can generate errors if needed
+     */
+    void sendData(final TFTP tftp, final TFTPPacket data) throws IOException {
+        tftp.bufferedSend(data);
+    }
+
+    /**
+     * Set the stream object to log debug / informational messages. By default, this is a no-op
+     *
+     * @param log the stream to use for logging
+     */
+    public void setLog(final PrintStream log)
+    {
+        this.log_ = log;
+    }
+
+    /**
+     * Set the stream object to log error messsages. By default, this is a no-op
+     *
+     * @param logError the stream to use for logging errors
+     */
+    public void setLogError(final PrintStream logError)
+    {
+        this.logError_ = logError;
+    }
+
+    /**
+     * Set the max number of retries in response to a timeout. Default 3. Min 0.
+     *
+     * @param retries number of retries, must be &gt; 0
+     */
+    public void setMaxTimeoutRetries(final int retries)
+    {
+        if (retries < 0)
+        {
+            throw new RuntimeException("Invalid Value");
+        }
+        maxTimeoutRetries_ = retries;
+    }
+
+    /**
+     * Set the socket timeout in milliseconds used in transfers. Defaults to the value here:
+     * https://commons.apache.org/net/apidocs/org/apache/commons/net/tftp/TFTP.html#DEFAULT_TIMEOUT
+     * (5000 at the time I write this) Min value of 10.
+     * @param timeout the timeout; must be larger than 10
+     */
+    public void setSocketTimeout(final int timeout)
+    {
+        if (timeout < 10)
+        {
+            throw new RuntimeException("Invalid Value");
+        }
+        socketTimeout_ = timeout;
+    }
+
+    /**
+     * Stop the tftp server (and any currently running transfers) and release all opened network
+     * resources.
+     */
+    public void shutdown()
+    {
+        shutdownServer = true;
+
+        synchronized(transfers_)
+        {
+            transfers_.forEach(TFTPTransfer::shutdown);
+        }
+
+        try
+        {
+            serverTftp_.close();
+        }
+        catch (final RuntimeException e)
+        {
+            // noop
+        }
+
+        try {
+            serverThread.join();
+        } catch (final InterruptedException e) {
+            // we've done the best we could, return
+        }
+    }
+}
diff --git a/src/test/java/org/apache/commons/net/time/TimeTestSimpleServer.java b/src/test/java/org/apache/commons/net/time/TimeTestSimpleServer.java
index 59777fb87..f9a197acc 100644
--- a/src/test/java/org/apache/commons/net/time/TimeTestSimpleServer.java
+++ b/src/test/java/org/apache/commons/net/time/TimeTestSimpleServer.java
@@ -1,160 +1,160 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.net.time;
-
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.net.ServerSocket;
-import java.net.Socket;
-
-/**
- * The TimetSimpleServer class is a simple TCP implementation of a server
- * for the Time Protocol described in RFC 868.
- * <p>
- * Listens for TCP socket connections on the time protocol port and writes
- * the local time to socket outputStream as 32-bit integer of seconds
- * since midnight on 1 January 1900 GMT.
- * See <A HREF="ftp://ftp.rfc-editor.org/in-notes/rfc868.txt"> the spec </A> for
- * details.
- * <p>
- * Note this is for <B>debugging purposes only</B> and not meant to be run as a realiable time service.
- *
- */
-public class TimeTestSimpleServer implements Runnable
-{
-
-    /**
-     * baseline time 1900-01-01T00:00:00 UTC
-     */
-    public static final long SECONDS_1900_TO_1970 = 2208988800L;
-
-    /** The default time port.  It is set to 37 according to RFC 868. */
-    public static final int DEFAULT_PORT = 37;
-
-    public static void main(final String[] args)
-    {
-        final TimeTestSimpleServer server = new TimeTestSimpleServer();
-        try
-        {
-            server.start();
-        } catch (final IOException e)
-        {
-            // ignored
-        }
-    }
-    private ServerSocket server;
-    private final int port;
-
-    private boolean running;
-
-    public TimeTestSimpleServer()
-    {
-        port = DEFAULT_PORT;
-    }
-
-    public TimeTestSimpleServer(final int port)
-    {
-        this.port = port;
-    }
-
-    public void connect() throws IOException
-    {
-        if (server == null)
-        {
-            server = new ServerSocket(port);
-        }
-    }
-
-    public int getPort()
-    {
-        return server == null ? port : server.getLocalPort();
-    }
-
-    public boolean isRunning()
-    {
-        return running;
-    }
-
-    @Override
-    public void run()
-    {
-        Socket socket = null;
-        while (running)
-        {
-            try
-            {
-                socket = server.accept();
-                final DataOutputStream os = new DataOutputStream(socket.getOutputStream());
-                // add 500 ms to round off to nearest second
-                final int time = (int) ((System.currentTimeMillis() + 500) / 1000 + SECONDS_1900_TO_1970);
-                os.writeInt(time);
-                os.flush();
-            } catch (final IOException e)
-            {
-                // ignored
-            } finally
-            {
-                if (socket != null) {
-                    try
-                    {
-                        socket.close();  // force closing of the socket
-                    } catch (final IOException e)
-                    {
-                        System.err.println("close socket error: " + e);
-                    }
-                }
-            }
-        }
-    }
-
-    /*
-     * Start time service and provide time to client connections.
-     */
-    public void start() throws IOException
-    {
-        if (server == null)
-    {
-            connect();
-    }
-    if (!running)
-    {
-        running = true;
-        new Thread(this).start();
-    }
-    }
-
-    /*
-     * Close server socket.
-     */
-    public void stop()
-    {
-        running = false;
-        if (server != null)
-        {
-            try
-            {
-                server.close();  // force closing of the socket
-            } catch (final IOException e)
-            {
-                System.err.println("close socket error: " + e);
-            }
-            server = null;
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.net.time;
+
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.net.ServerSocket;
+import java.net.Socket;
+
+/**
+ * The TimetSimpleServer class is a simple TCP implementation of a server
+ * for the Time Protocol described in RFC 868.
+ * <p>
+ * Listens for TCP socket connections on the time protocol port and writes
+ * the local time to socket outputStream as 32-bit integer of seconds
+ * since midnight on 1 January 1900 GMT.
+ * See <A HREF="ftp://ftp.rfc-editor.org/in-notes/rfc868.txt"> the spec </A> for
+ * details.
+ * <p>
+ * Note this is for <B>debugging purposes only</B> and not meant to be run as a realiable time service.
+ *
+ */
+public class TimeTestSimpleServer implements Runnable
+{
+
+    /**
+     * baseline time 1900-01-01T00:00:00 UTC
+     */
+    public static final long SECONDS_1900_TO_1970 = 2208988800L;
+
+    /** The default time port.  It is set to 37 according to RFC 868. */
+    public static final int DEFAULT_PORT = 37;
+
+    public static void main(final String[] args)
+    {
+        final TimeTestSimpleServer server = new TimeTestSimpleServer();
+        try
+        {
+            server.start();
+        } catch (final IOException e)
+        {
+            // ignored
+        }
+    }
+    private ServerSocket server;
+    private final int port;
+
+    private boolean running;
+
+    public TimeTestSimpleServer()
+    {
+        port = DEFAULT_PORT;
+    }
+
+    public TimeTestSimpleServer(final int port)
+    {
+        this.port = port;
+    }
+
+    public void connect() throws IOException
+    {
+        if (server == null)
+        {
+            server = new ServerSocket(port);
+        }
+    }
+
+    public int getPort()
+    {
+        return server == null ? port : server.getLocalPort();
+    }
+
+    public boolean isRunning()
+    {
+        return running;
+    }
+
+    @Override
+    public void run()
+    {
+        Socket socket = null;
+        while (running)
+        {
+            try
+            {
+                socket = server.accept();
+                final DataOutputStream os = new DataOutputStream(socket.getOutputStream());
+                // add 500 ms to round off to nearest second
+                final int time = (int) ((System.currentTimeMillis() + 500) / 1000 + SECONDS_1900_TO_1970);
+                os.writeInt(time);
+                os.flush();
+            } catch (final IOException e)
+            {
+                // ignored
+            } finally
+            {
+                if (socket != null) {
+                    try
+                    {
+                        socket.close();  // force closing of the socket
+                    } catch (final IOException e)
+                    {
+                        System.err.println("close socket error: " + e);
+                    }
+                }
+            }
+        }
+    }
+
+    /*
+     * Start time service and provide time to client connections.
+     */
+    public void start() throws IOException
+    {
+        if (server == null)
+    {
+            connect();
+    }
+    if (!running)
+    {
+        running = true;
+        new Thread(this).start();
+    }
+    }
+
+    /*
+     * Close server socket.
+     */
+    public void stop()
+    {
+        running = false;
+        if (server != null)
+        {
+            try
+            {
+                server.close();  // force closing of the socket
+            } catch (final IOException e)
+            {
+                System.err.println("close socket error: " + e);
+            }
+            server = null;
+        }
+    }
+
+}
