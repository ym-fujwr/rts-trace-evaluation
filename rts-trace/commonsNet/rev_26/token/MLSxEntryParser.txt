package
org
.
apache
.
commons
.
net
.
ftp
.
parser
;
import
java
.
text
.
ParsePosition
;
import
java
.
text
.
SimpleDateFormat
;
import
java
.
time
.
Instant
;
import
java
.
util
.
Calendar
;
import
java
.
util
.
Date
;
import
java
.
util
.
GregorianCalendar
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
Locale
;
import
java
.
util
.
TimeZone
;
import
org
.
apache
.
commons
.
net
.
ftp
.
FTPFile
;
import
org
.
apache
.
commons
.
net
.
ftp
.
FTPFileEntryParserImpl
;
public
class
MLSxEntryParser
extends
FTPFileEntryParserImpl
{
private
static
final
MLSxEntryParser
INSTANCE
=
new
MLSxEntryParser
(
)
;
private
static
final
HashMap
<
String
,
Integer
>
TYPE_TO_INT
=
new
HashMap
<
>
(
)
;
static
{
TYPE_TO_INT
.
put
(
"file"
,
Integer
.
valueOf
(
FTPFile
.
FILE_TYPE
)
)
;
TYPE_TO_INT
.
put
(
"cdir"
,
Integer
.
valueOf
(
FTPFile
.
DIRECTORY_TYPE
)
)
;
TYPE_TO_INT
.
put
(
"pdir"
,
Integer
.
valueOf
(
FTPFile
.
DIRECTORY_TYPE
)
)
;
TYPE_TO_INT
.
put
(
"dir"
,
Integer
.
valueOf
(
FTPFile
.
DIRECTORY_TYPE
)
)
;
}
private
static
final
int
[
]
UNIX_GROUPS
=
{
FTPFile
.
USER_ACCESS
,
FTPFile
.
GROUP_ACCESS
,
FTPFile
.
WORLD_ACCESS
,
}
;
private
static
final
int
[
]
[
]
UNIX_PERMS
=
{
{
}
,
{
FTPFile
.
EXECUTE_PERMISSION
}
,
{
FTPFile
.
WRITE_PERMISSION
}
,
{
FTPFile
.
EXECUTE_PERMISSION
,
FTPFile
.
WRITE_PERMISSION
}
,
{
FTPFile
.
READ_PERMISSION
}
,
{
FTPFile
.
READ_PERMISSION
,
FTPFile
.
EXECUTE_PERMISSION
}
,
{
FTPFile
.
READ_PERMISSION
,
FTPFile
.
WRITE_PERMISSION
}
,
{
FTPFile
.
READ_PERMISSION
,
FTPFile
.
WRITE_PERMISSION
,
FTPFile
.
EXECUTE_PERMISSION
}
,
}
;
public
static
MLSxEntryParser
getInstance
(
)
{
return
INSTANCE
;
}
public
static
FTPFile
parseEntry
(
final
String
entry
)
{
return
INSTANCE
.
parseFTPEntry
(
entry
)
;
}
public
static
Calendar
parseGMTdateTime
(
final
String
timestamp
)
{
final
SimpleDateFormat
dateFormat
;
final
boolean
hasMillis
;
if
(
timestamp
.
contains
(
"."
)
)
{
dateFormat
=
new
SimpleDateFormat
(
"yyyyMMddHHmmss.SSS"
)
;
hasMillis
=
true
;
}
else
{
dateFormat
=
new
SimpleDateFormat
(
"yyyyMMddHHmmss"
)
;
hasMillis
=
false
;
}
final
TimeZone
gmtTimeZone
=
TimeZone
.
getTimeZone
(
"GMT"
)
;
dateFormat
.
setTimeZone
(
gmtTimeZone
)
;
final
GregorianCalendar
gCalendar
=
new
GregorianCalendar
(
gmtTimeZone
)
;
final
ParsePosition
pos
=
new
ParsePosition
(
0
)
;
dateFormat
.
setLenient
(
false
)
;
final
Date
parsed
=
dateFormat
.
parse
(
timestamp
,
pos
)
;
if
(
pos
.
getIndex
(
)
!=
timestamp
.
length
(
)
)
{
return
null
;
}
gCalendar
.
setTime
(
parsed
)
;
if
(
!
hasMillis
)
{
gCalendar
.
clear
(
Calendar
.
MILLISECOND
)
;
}
return
gCalendar
;
}
public
static
Instant
parseGmtInstant
(
final
String
timestamp
)
{
return
parseGMTdateTime
(
timestamp
)
.
toInstant
(
)
;
}
public
MLSxEntryParser
(
)
{
}
private
void
doUnixPerms
(
final
FTPFile
file
,
final
String
valueLowerCase
)
{
for
(
final
char
c
:
valueLowerCase
.
toCharArray
(
)
)
{
switch
(
c
)
{
case
'a'
:
file
.
setPermission
(
FTPFile
.
USER_ACCESS
,
FTPFile
.
WRITE_PERMISSION
,
true
)
;
break
;
case
'c'
:
file
.
setPermission
(
FTPFile
.
USER_ACCESS
,
FTPFile
.
WRITE_PERMISSION
,
true
)
;
break
;
case
'd'
:
file
.
setPermission
(
FTPFile
.
USER_ACCESS
,
FTPFile
.
WRITE_PERMISSION
,
true
)
;
break
;
case
'e'
:
file
.
setPermission
(
FTPFile
.
USER_ACCESS
,
FTPFile
.
READ_PERMISSION
,
true
)
;
break
;
case
'f'
:
break
;
case
'l'
:
file
.
setPermission
(
FTPFile
.
USER_ACCESS
,
FTPFile
.
EXECUTE_PERMISSION
,
true
)
;
break
;
case
'm'
:
file
.
setPermission
(
FTPFile
.
USER_ACCESS
,
FTPFile
.
WRITE_PERMISSION
,
true
)
;
break
;
case
'p'
:
file
.
setPermission
(
FTPFile
.
USER_ACCESS
,
FTPFile
.
WRITE_PERMISSION
,
true
)
;
break
;
case
'r'
:
file
.
setPermission
(
FTPFile
.
USER_ACCESS
,
FTPFile
.
READ_PERMISSION
,
true
)
;
break
;
case
'w'
:
file
.
setPermission
(
FTPFile
.
USER_ACCESS
,
FTPFile
.
WRITE_PERMISSION
,
true
)
;
break
;
default
:
break
;
}
}
}
@
Override
public
FTPFile
parseFTPEntry
(
final
String
entry
)
{
if
(
entry
.
startsWith
(
" "
)
)
{
if
(
entry
.
length
(
)
>
1
)
{
final
FTPFile
file
=
new
FTPFile
(
)
;
file
.
setRawListing
(
entry
)
;
file
.
setName
(
entry
.
substring
(
1
)
)
;
return
file
;
}
return
null
;
}
final
String
parts
[
]
=
entry
.
split
(
" "
,
2
)
;
if
(
parts
.
length
!=
2
||
parts
[
1
]
.
isEmpty
(
)
)
{
return
null
;
}
final
String
factList
=
parts
[
0
]
;
if
(
!
factList
.
endsWith
(
";"
)
)
{
return
null
;
}
final
FTPFile
file
=
new
FTPFile
(
)
;
file
.
setRawListing
(
entry
)
;
file
.
setName
(
parts
[
1
]
)
;
final
String
[
]
facts
=
factList
.
split
(
";"
)
;
final
boolean
hasUnixMode
=
parts
[
0
]
.
toLowerCase
(
Locale
.
ENGLISH
)
.
contains
(
"unix.mode="
)
;
for
(
final
String
fact
:
facts
)
{
final
String
[
]
factparts
=
fact
.
split
(
"="
,
-
1
)
;
if
(
factparts
.
length
!=
2
)
{
return
null
;
}
final
String
factname
=
factparts
[
0
]
.
toLowerCase
(
Locale
.
ENGLISH
)
;
final
String
factvalue
=
factparts
[
1
]
;
if
(
factvalue
.
isEmpty
(
)
)
{
continue
;
}
final
String
valueLowerCase
=
factvalue
.
toLowerCase
(
Locale
.
ENGLISH
)
;
if
(
"size"
.
equals
(
factname
)
||
"sizd"
.
equals
(
factname
)
)
{
file
.
setSize
(
Long
.
parseLong
(
factvalue
)
)
;
}
else
if
(
"modify"
.
equals
(
factname
)
)
{
final
Calendar
parsed
=
parseGMTdateTime
(
factvalue
)
;
if
(
parsed
==
null
)
{
return
null
;
}
file
.
setTimestamp
(
parsed
)
;
}
else
if
(
"type"
.
equals
(
factname
)
)
{
final
Integer
intType
=
TYPE_TO_INT
.
get
(
valueLowerCase
)
;
if
(
intType
==
null
)
{
file
.
setType
(
FTPFile
.
UNKNOWN_TYPE
)
;
}
else
{
file
.
setType
(
intType
.
intValue
(
)
)
;
}
}
else
if
(
factname
.
startsWith
(
"unix."
)
)
{
final
String
unixfact
=
factname
.
substring
(
"unix."
.
length
(
)
)
.
toLowerCase
(
Locale
.
ENGLISH
)
;
if
(
"group"
.
equals
(
unixfact
)
)
{
file
.
setGroup
(
factvalue
)
;
}
else
if
(
"owner"
.
equals
(
unixfact
)
)
{
file
.
setUser
(
factvalue
)
;
}
else
if
(
"mode"
.
equals
(
unixfact
)
)
{
final
int
off
=
factvalue
.
length
(
)
-
3
;
for
(
int
i
=
0
;
i
<
3
;
i
++
)
{
final
int
ch
=
factvalue
.
charAt
(
off
+
i
)
-
'0'
;
if
(
ch
>=
0
&&
ch
<=
7
)
{
for
(
final
int
p
:
UNIX_PERMS
[
ch
]
)
{
file
.
setPermission
(
UNIX_GROUPS
[
i
]
,
p
,
true
)
;
}
}
else
{
}
}
}
}
else
if
(
!
hasUnixMode
&&
"perm"
.
equals
(
factname
)
)
{
doUnixPerms
(
file
,
valueLowerCase
)
;
}
}
return
file
;
}
}
<EOF>
