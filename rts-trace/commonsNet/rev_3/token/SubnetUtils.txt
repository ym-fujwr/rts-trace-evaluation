package
org
.
apache
.
commons
.
net
.
util
;
import
java
.
util
.
regex
.
Matcher
;
import
java
.
util
.
regex
.
Pattern
;
public
class
SubnetUtils
{
public
final
class
SubnetInfo
{
private
static
final
long
UNSIGNED_INT_MASK
=
0x0FFFFFFFFL
;
private
SubnetInfo
(
)
{
}
public
int
asInteger
(
final
String
address
)
{
return
toInteger
(
address
)
;
}
private
long
broadcastLong
(
)
{
return
broadcast
&
UNSIGNED_INT_MASK
;
}
private
String
format
(
final
int
[
]
octets
)
{
final
StringBuilder
str
=
new
StringBuilder
(
)
;
for
(
int
i
=
0
;
i
<
octets
.
length
;
++
i
)
{
str
.
append
(
octets
[
i
]
)
;
if
(
i
!=
octets
.
length
-
1
)
{
str
.
append
(
"."
)
;
}
}
return
str
.
toString
(
)
;
}
public
String
getAddress
(
)
{
return
format
(
toArray
(
address
)
)
;
}
@
Deprecated
public
int
getAddressCount
(
)
{
final
long
countLong
=
getAddressCountLong
(
)
;
if
(
countLong
>
Integer
.
MAX_VALUE
)
{
throw
new
RuntimeException
(
"Count is larger than an integer: "
+
countLong
)
;
}
return
(
int
)
countLong
;
}
public
long
getAddressCountLong
(
)
{
final
long
b
=
broadcastLong
(
)
;
final
long
n
=
networkLong
(
)
;
final
long
count
=
b
-
n
+
(
isInclusiveHostCount
(
)
?
1
:
-
1
)
;
return
count
<
0
?
0
:
count
;
}
public
String
[
]
getAllAddresses
(
)
{
final
int
ct
=
getAddressCount
(
)
;
final
String
[
]
addresses
=
new
String
[
ct
]
;
if
(
ct
==
0
)
{
return
addresses
;
}
for
(
int
add
=
low
(
)
,
j
=
0
;
add
<=
high
(
)
;
++
add
,
++
j
)
{
addresses
[
j
]
=
format
(
toArray
(
add
)
)
;
}
return
addresses
;
}
public
String
getBroadcastAddress
(
)
{
return
format
(
toArray
(
broadcast
)
)
;
}
public
String
getCidrSignature
(
)
{
return
format
(
toArray
(
address
)
)
+
"/"
+
pop
(
netmask
)
;
}
public
String
getHighAddress
(
)
{
return
format
(
toArray
(
high
(
)
)
)
;
}
public
String
getLowAddress
(
)
{
return
format
(
toArray
(
low
(
)
)
)
;
}
public
String
getNetmask
(
)
{
return
format
(
toArray
(
netmask
)
)
;
}
public
String
getNetworkAddress
(
)
{
return
format
(
toArray
(
network
)
)
;
}
public
String
getNextAddress
(
)
{
return
format
(
toArray
(
address
+
1
)
)
;
}
public
String
getPreviousAddress
(
)
{
return
format
(
toArray
(
address
-
1
)
)
;
}
private
int
high
(
)
{
return
isInclusiveHostCount
(
)
?
broadcast
:
broadcastLong
(
)
-
networkLong
(
)
>
1
?
broadcast
-
1
:
0
;
}
public
boolean
isInRange
(
final
int
address
)
{
if
(
address
==
0
)
{
return
false
;
}
final
long
addLong
=
address
&
UNSIGNED_INT_MASK
;
final
long
lowLong
=
low
(
)
&
UNSIGNED_INT_MASK
;
final
long
highLong
=
high
(
)
&
UNSIGNED_INT_MASK
;
return
addLong
>=
lowLong
&&
addLong
<=
highLong
;
}
public
boolean
isInRange
(
final
String
address
)
{
return
isInRange
(
toInteger
(
address
)
)
;
}
private
int
low
(
)
{
return
isInclusiveHostCount
(
)
?
network
:
broadcastLong
(
)
-
networkLong
(
)
>
1
?
network
+
1
:
0
;
}
private
long
networkLong
(
)
{
return
network
&
UNSIGNED_INT_MASK
;
}
private
int
[
]
toArray
(
final
int
val
)
{
final
int
ret
[
]
=
new
int
[
4
]
;
for
(
int
j
=
3
;
j
>=
0
;
--
j
)
{
ret
[
j
]
|=
val
>
>
>
8
*
(
3
-
j
)
&
0xff
;
}
return
ret
;
}
@
Override
public
String
toString
(
)
{
final
StringBuilder
buf
=
new
StringBuilder
(
)
;
buf
.
append
(
"CIDR Signature:\t["
)
.
append
(
getCidrSignature
(
)
)
.
append
(
"]"
)
.
append
(
" Netmask: ["
)
.
append
(
getNetmask
(
)
)
.
append
(
"]\n"
)
.
append
(
"Network:\t["
)
.
append
(
getNetworkAddress
(
)
)
.
append
(
"]\n"
)
.
append
(
"Broadcast:\t["
)
.
append
(
getBroadcastAddress
(
)
)
.
append
(
"]\n"
)
.
append
(
"First Address:\t["
)
.
append
(
getLowAddress
(
)
)
.
append
(
"]\n"
)
.
append
(
"Last Address:\t["
)
.
append
(
getHighAddress
(
)
)
.
append
(
"]\n"
)
.
append
(
"# Addresses:\t["
)
.
append
(
getAddressCount
(
)
)
.
append
(
"]\n"
)
;
return
buf
.
toString
(
)
;
}
}
private
static
final
String
IP_ADDRESS
=
"(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})"
;
private
static
final
String
SLASH_FORMAT
=
IP_ADDRESS
+
"/(\\d{1,2})"
;
private
static
final
Pattern
addressPattern
=
Pattern
.
compile
(
IP_ADDRESS
)
;
private
static
final
Pattern
cidrPattern
=
Pattern
.
compile
(
SLASH_FORMAT
)
;
private
static
final
int
NBITS
=
32
;
private
static
final
String
PARSE_FAIL
=
"Could not parse [%s]"
;
private
static
int
matchAddress
(
final
Matcher
matcher
)
{
int
addr
=
0
;
for
(
int
i
=
1
;
i
<=
4
;
++
i
)
{
final
int
n
=
rangeCheck
(
Integer
.
parseInt
(
matcher
.
group
(
i
)
)
,
0
,
255
)
;
addr
|=
(
n
&
0xff
)
<
<
8
*
(
4
-
i
)
;
}
return
addr
;
}
private
static
int
rangeCheck
(
final
int
value
,
final
int
begin
,
final
int
end
)
{
if
(
value
>=
begin
&&
value
<=
end
)
{
return
value
;
}
throw
new
IllegalArgumentException
(
"Value ["
+
value
+
"] not in range ["
+
begin
+
","
+
end
+
"]"
)
;
}
private
static
int
toInteger
(
final
String
address
)
{
final
Matcher
matcher
=
addressPattern
.
matcher
(
address
)
;
if
(
matcher
.
matches
(
)
)
{
return
matchAddress
(
matcher
)
;
}
throw
new
IllegalArgumentException
(
String
.
format
(
PARSE_FAIL
,
address
)
)
;
}
private
final
int
netmask
;
private
final
int
address
;
private
final
int
network
;
private
final
int
broadcast
;
private
boolean
inclusiveHostCount
;
public
SubnetUtils
(
final
String
cidrNotation
)
{
final
Matcher
matcher
=
cidrPattern
.
matcher
(
cidrNotation
)
;
if
(
!
matcher
.
matches
(
)
)
{
throw
new
IllegalArgumentException
(
String
.
format
(
PARSE_FAIL
,
cidrNotation
)
)
;
}
this
.
address
=
matchAddress
(
matcher
)
;
final
int
trailingZeroes
=
NBITS
-
rangeCheck
(
Integer
.
parseInt
(
matcher
.
group
(
5
)
)
,
0
,
NBITS
)
;
this
.
netmask
=
(
int
)
(
0x0FFFFFFFFL
<
<
trailingZeroes
)
;
this
.
network
=
address
&
netmask
;
this
.
broadcast
=
network
|
~
netmask
;
}
public
SubnetUtils
(
final
String
address
,
final
String
mask
)
{
this
.
address
=
toInteger
(
address
)
;
this
.
netmask
=
toInteger
(
mask
)
;
if
(
(
this
.
netmask
&
-
this
.
netmask
)
-
1
!=
~
this
.
netmask
)
{
throw
new
IllegalArgumentException
(
String
.
format
(
PARSE_FAIL
,
mask
)
)
;
}
this
.
network
=
this
.
address
&
this
.
netmask
;
this
.
broadcast
=
this
.
network
|
~
this
.
netmask
;
}
public
final
SubnetInfo
getInfo
(
)
{
return
new
SubnetInfo
(
)
;
}
public
SubnetUtils
getNext
(
)
{
return
new
SubnetUtils
(
getInfo
(
)
.
getNextAddress
(
)
,
getInfo
(
)
.
getNetmask
(
)
)
;
}
public
SubnetUtils
getPrevious
(
)
{
return
new
SubnetUtils
(
getInfo
(
)
.
getPreviousAddress
(
)
,
getInfo
(
)
.
getNetmask
(
)
)
;
}
public
boolean
isInclusiveHostCount
(
)
{
return
inclusiveHostCount
;
}
int
pop
(
int
x
)
{
x
=
x
-
(
x
>
>
>
1
&
0x55555555
)
;
x
=
(
x
&
0x33333333
)
+
(
x
>
>
>
2
&
0x33333333
)
;
x
=
x
+
(
x
>
>
>
4
)
&
0x0F0F0F0F
;
x
=
x
+
(
x
>
>
>
8
)
;
x
=
x
+
(
x
>
>
>
16
)
;
return
x
&
0x0000003F
;
}
public
void
setInclusiveHostCount
(
final
boolean
inclusiveHostCount
)
{
this
.
inclusiveHostCount
=
inclusiveHostCount
;
}
}
<EOF>
