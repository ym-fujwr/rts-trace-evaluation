package
org
.
apache
.
commons
.
net
.
ftp
;
import
java
.
io
.
BufferedInputStream
;
import
java
.
io
.
BufferedOutputStream
;
import
java
.
io
.
BufferedReader
;
import
java
.
io
.
BufferedWriter
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
InputStreamReader
;
import
java
.
io
.
OutputStream
;
import
java
.
io
.
OutputStreamWriter
;
import
java
.
io
.
Reader
;
import
java
.
net
.
Inet6Address
;
import
java
.
net
.
InetAddress
;
import
java
.
net
.
InetSocketAddress
;
import
java
.
net
.
ServerSocket
;
import
java
.
net
.
Socket
;
import
java
.
net
.
SocketException
;
import
java
.
net
.
SocketTimeoutException
;
import
java
.
net
.
UnknownHostException
;
import
java
.
time
.
Duration
;
import
java
.
time
.
Instant
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Calendar
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
Locale
;
import
java
.
util
.
Properties
;
import
java
.
util
.
Random
;
import
java
.
util
.
Set
;
import
java
.
util
.
regex
.
Matcher
;
import
org
.
apache
.
commons
.
net
.
MalformedServerReplyException
;
import
org
.
apache
.
commons
.
net
.
ftp
.
parser
.
DefaultFTPFileEntryParserFactory
;
import
org
.
apache
.
commons
.
net
.
ftp
.
parser
.
FTPFileEntryParserFactory
;
import
org
.
apache
.
commons
.
net
.
ftp
.
parser
.
MLSxEntryParser
;
import
org
.
apache
.
commons
.
net
.
io
.
CRLFLineReader
;
import
org
.
apache
.
commons
.
net
.
io
.
CopyStreamAdapter
;
import
org
.
apache
.
commons
.
net
.
io
.
CopyStreamEvent
;
import
org
.
apache
.
commons
.
net
.
io
.
CopyStreamListener
;
import
org
.
apache
.
commons
.
net
.
io
.
FromNetASCIIInputStream
;
import
org
.
apache
.
commons
.
net
.
io
.
SocketOutputStream
;
import
org
.
apache
.
commons
.
net
.
io
.
ToNetASCIIOutputStream
;
import
org
.
apache
.
commons
.
net
.
io
.
Util
;
import
org
.
apache
.
commons
.
net
.
util
.
NetConstants
;
public
class
FTPClient
extends
FTP
implements
Configurable
{
private
static
class
CSL
implements
CopyStreamListener
{
private
final
FTPClient
parent
;
private
final
long
idleMillis
;
private
final
int
currentSoTimeoutMillis
;
private
long
lastIdleTimeMillis
=
System
.
currentTimeMillis
(
)
;
private
int
notAcked
;
private
int
acksAcked
;
private
int
ioErrors
;
CSL
(
final
FTPClient
parent
,
final
Duration
idleDuration
,
final
Duration
maxWaitDuration
)
throws
SocketException
{
this
.
idleMillis
=
idleDuration
.
toMillis
(
)
;
this
.
parent
=
parent
;
this
.
currentSoTimeoutMillis
=
parent
.
getSoTimeout
(
)
;
parent
.
setSoTimeout
(
DurationUtils
.
toMillisInt
(
maxWaitDuration
)
)
;
}
@
Override
public
void
bytesTransferred
(
final
CopyStreamEvent
event
)
{
bytesTransferred
(
event
.
getTotalBytesTransferred
(
)
,
event
.
getBytesTransferred
(
)
,
event
.
getStreamSize
(
)
)
;
}
@
Override
public
void
bytesTransferred
(
final
long
totalBytesTransferred
,
final
int
bytesTransferred
,
final
long
streamSize
)
{
final
long
nowMillis
=
System
.
currentTimeMillis
(
)
;
if
(
nowMillis
-
lastIdleTimeMillis
>
idleMillis
)
{
try
{
parent
.
__noop
(
)
;
acksAcked
++
;
}
catch
(
final
SocketTimeoutException
e
)
{
notAcked
++
;
}
catch
(
final
IOException
e
)
{
ioErrors
++
;
}
lastIdleTimeMillis
=
nowMillis
;
}
}
int
[
]
cleanUp
(
)
throws
IOException
{
final
int
remain
=
notAcked
;
try
{
while
(
notAcked
>
0
)
{
parent
.
getReply
(
)
;
notAcked
--
;
}
}
catch
(
final
SocketTimeoutException
e
)
{
}
finally
{
parent
.
setSoTimeout
(
currentSoTimeoutMillis
)
;
}
return
new
int
[
]
{
acksAcked
,
remain
,
notAcked
,
ioErrors
}
;
}
}
public
interface
HostnameResolver
{
String
resolve
(
String
hostname
)
throws
UnknownHostException
;
}
public
static
class
NatServerResolverImpl
implements
HostnameResolver
{
private
final
FTPClient
client
;
public
NatServerResolverImpl
(
final
FTPClient
client
)
{
this
.
client
=
client
;
}
@
Override
public
String
resolve
(
final
String
hostname
)
throws
UnknownHostException
{
String
newHostname
=
hostname
;
final
InetAddress
host
=
InetAddress
.
getByName
(
newHostname
)
;
if
(
host
.
isSiteLocalAddress
(
)
)
{
final
InetAddress
remote
=
this
.
client
.
getRemoteAddress
(
)
;
if
(
!
remote
.
isSiteLocalAddress
(
)
)
{
newHostname
=
remote
.
getHostAddress
(
)
;
}
}
return
newHostname
;
}
}
private
static
class
PropertiesSingleton
{
static
final
Properties
PROPERTIES
;
static
{
final
InputStream
resourceAsStream
=
FTPClient
.
class
.
getResourceAsStream
(
SYSTEM_TYPE_PROPERTIES
)
;
Properties
p
=
null
;
if
(
resourceAsStream
!=
null
)
{
p
=
new
Properties
(
)
;
try
{
p
.
load
(
resourceAsStream
)
;
}
catch
(
final
IOException
e
)
{
}
finally
{
try
{
resourceAsStream
.
close
(
)
;
}
catch
(
final
IOException
e
)
{
}
}
}
PROPERTIES
=
p
;
}
}
public
static
final
String
FTP_SYSTEM_TYPE
=
"org.apache.commons.net.ftp.systemType"
;
public
static
final
String
FTP_SYSTEM_TYPE_DEFAULT
=
"org.apache.commons.net.ftp.systemType.default"
;
public
static
final
String
FTP_IP_ADDRESS_FROM_PASV_RESPONSE
=
"org.apache.commons.net.ftp.ipAddressFromPasvResponse"
;
public
static
final
String
SYSTEM_TYPE_PROPERTIES
=
"/systemType.properties"
;
public
static
final
int
ACTIVE_LOCAL_DATA_CONNECTION_MODE
=
0
;
public
static
final
int
ACTIVE_REMOTE_DATA_CONNECTION_MODE
=
1
;
public
static
final
int
PASSIVE_LOCAL_DATA_CONNECTION_MODE
=
2
;
public
static
final
int
PASSIVE_REMOTE_DATA_CONNECTION_MODE
=
3
;
private
static
final
java
.
util
.
regex
.
Pattern
PARMS_PAT
;
static
{
PARMS_PAT
=
java
.
util
.
regex
.
Pattern
.
compile
(
"(\\d{1,3},\\d{1,3},\\d{1,3},\\d{1,3}),(\\d{1,3}),(\\d{1,3})"
)
;
}
private
static
Properties
getOverrideProperties
(
)
{
return
PropertiesSingleton
.
PROPERTIES
;
}
static
String
parsePathname
(
final
String
reply
)
{
final
String
param
=
reply
.
substring
(
REPLY_CODE_LEN
+
1
)
;
if
(
param
.
startsWith
(
"\""
)
)
{
final
StringBuilder
sb
=
new
StringBuilder
(
)
;
boolean
quoteSeen
=
false
;
for
(
int
i
=
1
;
i
<
param
.
length
(
)
;
i
++
)
{
final
char
ch
=
param
.
charAt
(
i
)
;
if
(
ch
==
'"'
)
{
if
(
quoteSeen
)
{
sb
.
append
(
ch
)
;
quoteSeen
=
false
;
}
else
{
quoteSeen
=
true
;
}
}
else
{
if
(
quoteSeen
)
{
return
sb
.
toString
(
)
;
}
sb
.
append
(
ch
)
;
}
}
if
(
quoteSeen
)
{
return
sb
.
toString
(
)
;
}
}
return
param
;
}
private
int
dataConnectionMode
;
private
Duration
dataTimeout
;
private
int
passivePort
;
private
String
passiveHost
;
private
final
Random
random
;
private
int
activeMinPort
;
private
int
activeMaxPort
;
private
InetAddress
activeExternalHost
;
private
InetAddress
reportActiveExternalHost
;
private
InetAddress
passiveLocalHost
;
private
int
fileType
;
@
SuppressWarnings
(
"unused"
)
private
int
fileFormat
;
@
SuppressWarnings
(
"unused"
)
private
int
fileStructure
;
@
SuppressWarnings
(
"unused"
)
private
int
fileTransferMode
;
private
boolean
remoteVerificationEnabled
;
private
long
restartOffset
;
private
FTPFileEntryParserFactory
parserFactory
;
private
int
bufferSize
;
private
int
sendDataSocketBufferSize
;
private
int
receiveDataSocketBufferSize
;
private
boolean
listHiddenFiles
;
private
boolean
useEPSVwithIPv4
;
private
String
systemName
;
private
FTPFileEntryParser
entryParser
;
private
String
entryParserKey
;
private
FTPClientConfig
configuration
;
private
CopyStreamListener
copyStreamListener
;
private
Duration
controlKeepAliveTimeout
=
Duration
.
ZERO
;
private
Duration
controlKeepAliveReplyTimeout
=
Duration
.
ofSeconds
(
1
)
;
private
int
[
]
cslDebug
;
private
HostnameResolver
passiveNatWorkaroundStrategy
=
new
NatServerResolverImpl
(
this
)
;
private
boolean
autodetectEncoding
;
private
HashMap
<
String
,
Set
<
String
>
>
featuresMap
;
private
boolean
ipAddressFromPasvResponse
=
Boolean
.
parseBoolean
(
System
.
getProperty
(
FTPClient
.
FTP_IP_ADDRESS_FROM_PASV_RESPONSE
)
)
;
public
FTPClient
(
)
{
initDefaults
(
)
;
dataTimeout
=
Duration
.
ofMillis
(
-
1
)
;
remoteVerificationEnabled
=
true
;
parserFactory
=
new
DefaultFTPFileEntryParserFactory
(
)
;
configuration
=
null
;
listHiddenFiles
=
false
;
useEPSVwithIPv4
=
false
;
random
=
new
Random
(
)
;
passiveLocalHost
=
null
;
}
@
Override
protected
void
_connectAction_
(
)
throws
IOException
{
_connectAction_
(
null
)
;
}
@
Override
protected
void
_connectAction_
(
final
Reader
socketIsReader
)
throws
IOException
{
super
.
_connectAction_
(
socketIsReader
)
;
initDefaults
(
)
;
if
(
autodetectEncoding
)
{
final
ArrayList
<
String
>
oldReplyLines
=
new
ArrayList
<
>
(
_replyLines
)
;
final
int
oldReplyCode
=
_replyCode
;
if
(
hasFeature
(
"UTF8"
)
||
hasFeature
(
"UTF-8"
)
)
{
setControlEncoding
(
"UTF-8"
)
;
_controlInput_
=
new
CRLFLineReader
(
new
InputStreamReader
(
_input_
,
getControlEncoding
(
)
)
)
;
_controlOutput_
=
new
BufferedWriter
(
new
OutputStreamWriter
(
_output_
,
getControlEncoding
(
)
)
)
;
}
_replyLines
.
clear
(
)
;
_replyLines
.
addAll
(
oldReplyLines
)
;
_replyCode
=
oldReplyCode
;
_newReplyString
=
true
;
}
}
protected
Socket
_openDataConnection_
(
final
FTPCmd
command
,
final
String
arg
)
throws
IOException
{
return
_openDataConnection_
(
command
.
getCommand
(
)
,
arg
)
;
}
@
Deprecated
protected
Socket
_openDataConnection_
(
final
int
command
,
final
String
arg
)
throws
IOException
{
return
_openDataConnection_
(
FTPCommand
.
getCommand
(
command
)
,
arg
)
;
}
protected
Socket
_openDataConnection_
(
final
String
command
,
final
String
arg
)
throws
IOException
{
if
(
dataConnectionMode
!=
ACTIVE_LOCAL_DATA_CONNECTION_MODE
&&
dataConnectionMode
!=
PASSIVE_LOCAL_DATA_CONNECTION_MODE
)
{
return
null
;
}
final
boolean
isInet6Address
=
getRemoteAddress
(
)
instanceof
Inet6Address
;
final
Socket
socket
;
final
int
soTimeoutMillis
=
DurationUtils
.
toMillisInt
(
dataTimeout
)
;
if
(
dataConnectionMode
==
ACTIVE_LOCAL_DATA_CONNECTION_MODE
)
{
try
(
final
ServerSocket
server
=
_serverSocketFactory_
.
createServerSocket
(
getActivePort
(
)
,
1
,
getHostAddress
(
)
)
)
{
if
(
isInet6Address
)
{
if
(
!
FTPReply
.
isPositiveCompletion
(
eprt
(
getReportHostAddress
(
)
,
server
.
getLocalPort
(
)
)
)
)
{
return
null
;
}
}
else
if
(
!
FTPReply
.
isPositiveCompletion
(
port
(
getReportHostAddress
(
)
,
server
.
getLocalPort
(
)
)
)
)
{
return
null
;
}
if
(
(
restartOffset
>
0
)
&&
!
restart
(
restartOffset
)
)
{
return
null
;
}
if
(
!
FTPReply
.
isPositivePreliminary
(
sendCommand
(
command
,
arg
)
)
)
{
return
null
;
}
if
(
soTimeoutMillis
>=
0
)
{
server
.
setSoTimeout
(
soTimeoutMillis
)
;
}
socket
=
server
.
accept
(
)
;
if
(
soTimeoutMillis
>=
0
)
{
socket
.
setSoTimeout
(
soTimeoutMillis
)
;
}
if
(
receiveDataSocketBufferSize
>
0
)
{
socket
.
setReceiveBufferSize
(
receiveDataSocketBufferSize
)
;
}
if
(
sendDataSocketBufferSize
>
0
)
{
socket
.
setSendBufferSize
(
sendDataSocketBufferSize
)
;
}
}
}
else
{
final
boolean
attemptEPSV
=
isUseEPSVwithIPv4
(
)
||
isInet6Address
;
if
(
attemptEPSV
&&
epsv
(
)
==
FTPReply
.
ENTERING_EPSV_MODE
)
{
_parseExtendedPassiveModeReply
(
_replyLines
.
get
(
0
)
)
;
}
else
{
if
(
isInet6Address
)
{
return
null
;
}
if
(
pasv
(
)
!=
FTPReply
.
ENTERING_PASSIVE_MODE
)
{
return
null
;
}
_parsePassiveModeReply
(
_replyLines
.
get
(
0
)
)
;
}
socket
=
_socketFactory_
.
createSocket
(
)
;
if
(
receiveDataSocketBufferSize
>
0
)
{
socket
.
setReceiveBufferSize
(
receiveDataSocketBufferSize
)
;
}
if
(
sendDataSocketBufferSize
>
0
)
{
socket
.
setSendBufferSize
(
sendDataSocketBufferSize
)
;
}
if
(
passiveLocalHost
!=
null
)
{
socket
.
bind
(
new
InetSocketAddress
(
passiveLocalHost
,
0
)
)
;
}
if
(
soTimeoutMillis
>=
0
)
{
socket
.
setSoTimeout
(
soTimeoutMillis
)
;
}
socket
.
connect
(
new
InetSocketAddress
(
passiveHost
,
passivePort
)
,
connectTimeout
)
;
if
(
(
restartOffset
>
0
)
&&
!
restart
(
restartOffset
)
)
{
socket
.
close
(
)
;
return
null
;
}
if
(
!
FTPReply
.
isPositivePreliminary
(
sendCommand
(
command
,
arg
)
)
)
{
socket
.
close
(
)
;
return
null
;
}
}
if
(
remoteVerificationEnabled
&&
!
verifyRemote
(
socket
)
)
{
final
InetAddress
socketHost
=
socket
.
getInetAddress
(
)
;
socket
.
close
(
)
;
throw
new
IOException
(
"Host attempting data connection "
+
socketHost
.
getHostAddress
(
)
+
" is not same as server "
+
getRemoteAddress
(
)
.
getHostAddress
(
)
)
;
}
return
socket
;
}
protected
void
_parseExtendedPassiveModeReply
(
String
reply
)
throws
MalformedServerReplyException
{
reply
=
reply
.
substring
(
reply
.
indexOf
(
'('
)
+
1
,
reply
.
indexOf
(
')'
)
)
.
trim
(
)
;
final
char
delim1
=
reply
.
charAt
(
0
)
;
final
char
delim2
=
reply
.
charAt
(
1
)
;
final
char
delim3
=
reply
.
charAt
(
2
)
;
final
char
delim4
=
reply
.
charAt
(
reply
.
length
(
)
-
1
)
;
if
(
(
delim1
!=
delim2
)
||
(
delim2
!=
delim3
)
||
(
delim3
!=
delim4
)
)
{
throw
new
MalformedServerReplyException
(
"Could not parse extended passive host information.\nServer Reply: "
+
reply
)
;
}
final
int
port
;
try
{
port
=
Integer
.
parseInt
(
reply
.
substring
(
3
,
reply
.
length
(
)
-
1
)
)
;
}
catch
(
final
NumberFormatException
e
)
{
throw
new
MalformedServerReplyException
(
"Could not parse extended passive host information.\nServer Reply: "
+
reply
)
;
}
this
.
passiveHost
=
getRemoteAddress
(
)
.
getHostAddress
(
)
;
this
.
passivePort
=
port
;
}
protected
void
_parsePassiveModeReply
(
final
String
reply
)
throws
MalformedServerReplyException
{
final
Matcher
m
=
PARMS_PAT
.
matcher
(
reply
)
;
if
(
!
m
.
find
(
)
)
{
throw
new
MalformedServerReplyException
(
"Could not parse passive host information.\nServer Reply: "
+
reply
)
;
}
int
pasvPort
;
String
pasvHost
=
"0,0,0,0"
.
equals
(
m
.
group
(
1
)
)
?
_socket_
.
getInetAddress
(
)
.
getHostAddress
(
)
:
m
.
group
(
1
)
.
replace
(
','
,
'.'
)
;
try
{
final
int
oct1
=
Integer
.
parseInt
(
m
.
group
(
2
)
)
;
final
int
oct2
=
Integer
.
parseInt
(
m
.
group
(
3
)
)
;
pasvPort
=
(
oct1
<
<
8
)
|
oct2
;
}
catch
(
final
NumberFormatException
e
)
{
throw
new
MalformedServerReplyException
(
"Could not parse passive port information.\nServer Reply: "
+
reply
)
;
}
if
(
isIpAddressFromPasvResponse
(
)
)
{
if
(
passiveNatWorkaroundStrategy
!=
null
)
{
try
{
final
String
newPassiveHost
=
passiveNatWorkaroundStrategy
.
resolve
(
pasvHost
)
;
if
(
!
pasvHost
.
equals
(
newPassiveHost
)
)
{
fireReplyReceived
(
0
,
"[Replacing PASV mode reply address "
+
this
.
passiveHost
+
" with "
+
newPassiveHost
+
"]\n"
)
;
pasvHost
=
newPassiveHost
;
}
}
catch
(
final
UnknownHostException
e
)
{
throw
new
MalformedServerReplyException
(
"Could not parse passive host information.\nServer Reply: "
+
reply
)
;
}
}
}
else
{
if
(
_socket_
==
null
)
{
pasvHost
=
null
;
}
else
{
pasvHost
=
_socket_
.
getInetAddress
(
)
.
getHostAddress
(
)
;
}
}
this
.
passiveHost
=
pasvHost
;
this
.
passivePort
=
pasvPort
;
}
protected
boolean
_retrieveFile
(
final
String
command
,
final
String
remote
,
final
OutputStream
local
)
throws
IOException
{
final
Socket
socket
=
_openDataConnection_
(
command
,
remote
)
;
if
(
socket
==
null
)
{
return
false
;
}
InputStream
input
=
null
;
CSL
csl
=
null
;
try
{
try
{
if
(
fileType
==
ASCII_FILE_TYPE
)
{
input
=
new
FromNetASCIIInputStream
(
getBufferedInputStream
(
socket
.
getInputStream
(
)
)
)
;
}
else
{
input
=
getBufferedInputStream
(
socket
.
getInputStream
(
)
)
;
}
if
(
DurationUtils
.
isPositive
(
controlKeepAliveTimeout
)
)
{
csl
=
new
CSL
(
this
,
controlKeepAliveTimeout
,
controlKeepAliveReplyTimeout
)
;
}
Util
.
copyStream
(
input
,
local
,
getBufferSize
(
)
,
CopyStreamEvent
.
UNKNOWN_STREAM_SIZE
,
mergeListeners
(
csl
)
,
false
)
;
}
finally
{
Util
.
closeQuietly
(
input
)
;
}
return
completePendingCommand
(
)
;
}
finally
{
Util
.
closeQuietly
(
socket
)
;
if
(
csl
!=
null
)
{
cslDebug
=
csl
.
cleanUp
(
)
;
}
}
}
protected
InputStream
_retrieveFileStream
(
final
String
command
,
final
String
remote
)
throws
IOException
{
final
Socket
socket
=
_openDataConnection_
(
command
,
remote
)
;
if
(
socket
==
null
)
{
return
null
;
}
final
InputStream
input
;
if
(
fileType
==
ASCII_FILE_TYPE
)
{
input
=
new
FromNetASCIIInputStream
(
getBufferedInputStream
(
socket
.
getInputStream
(
)
)
)
;
}
else
{
input
=
socket
.
getInputStream
(
)
;
}
return
new
org
.
apache
.
commons
.
net
.
io
.
SocketInputStream
(
socket
,
input
)
;
}
protected
boolean
_storeFile
(
final
String
command
,
final
String
remote
,
final
InputStream
local
)
throws
IOException
{
final
Socket
socket
=
_openDataConnection_
(
command
,
remote
)
;
if
(
socket
==
null
)
{
return
false
;
}
final
OutputStream
output
;
if
(
fileType
==
ASCII_FILE_TYPE
)
{
output
=
new
ToNetASCIIOutputStream
(
getBufferedOutputStream
(
socket
.
getOutputStream
(
)
)
)
;
}
else
{
output
=
getBufferedOutputStream
(
socket
.
getOutputStream
(
)
)
;
}
CSL
csl
=
null
;
if
(
DurationUtils
.
isPositive
(
controlKeepAliveTimeout
)
)
{
csl
=
new
CSL
(
this
,
controlKeepAliveTimeout
,
controlKeepAliveReplyTimeout
)
;
}
try
{
Util
.
copyStream
(
local
,
output
,
getBufferSize
(
)
,
CopyStreamEvent
.
UNKNOWN_STREAM_SIZE
,
mergeListeners
(
csl
)
,
false
)
;
output
.
close
(
)
;
socket
.
close
(
)
;
return
completePendingCommand
(
)
;
}
catch
(
final
IOException
e
)
{
Util
.
closeQuietly
(
output
)
;
Util
.
closeQuietly
(
socket
)
;
throw
e
;
}
finally
{
if
(
csl
!=
null
)
{
cslDebug
=
csl
.
cleanUp
(
)
;
}
}
}
protected
OutputStream
_storeFileStream
(
final
String
command
,
final
String
remote
)
throws
IOException
{
final
Socket
socket
=
_openDataConnection_
(
command
,
remote
)
;
if
(
socket
==
null
)
{
return
null
;
}
final
OutputStream
output
;
if
(
fileType
==
ASCII_FILE_TYPE
)
{
output
=
new
ToNetASCIIOutputStream
(
getBufferedOutputStream
(
socket
.
getOutputStream
(
)
)
)
;
}
else
{
output
=
socket
.
getOutputStream
(
)
;
}
return
new
SocketOutputStream
(
socket
,
output
)
;
}
public
boolean
abort
(
)
throws
IOException
{
return
FTPReply
.
isPositiveCompletion
(
abor
(
)
)
;
}
public
boolean
allocate
(
final
int
bytes
)
throws
IOException
{
return
FTPReply
.
isPositiveCompletion
(
allo
(
bytes
)
)
;
}
public
boolean
allocate
(
final
int
bytes
,
final
int
recordSize
)
throws
IOException
{
return
FTPReply
.
isPositiveCompletion
(
allo
(
bytes
,
recordSize
)
)
;
}
public
boolean
allocate
(
final
long
bytes
)
throws
IOException
{
return
FTPReply
.
isPositiveCompletion
(
allo
(
bytes
)
)
;
}
public
boolean
allocate
(
final
long
bytes
,
final
int
recordSize
)
throws
IOException
{
return
FTPReply
.
isPositiveCompletion
(
allo
(
bytes
,
recordSize
)
)
;
}
public
boolean
appendFile
(
final
String
remote
,
final
InputStream
local
)
throws
IOException
{
return
storeFile
(
FTPCmd
.
APPE
,
remote
,
local
)
;
}
public
OutputStream
appendFileStream
(
final
String
remote
)
throws
IOException
{
return
storeFileStream
(
FTPCmd
.
APPE
,
remote
)
;
}
public
boolean
changeToParentDirectory
(
)
throws
IOException
{
return
FTPReply
.
isPositiveCompletion
(
cdup
(
)
)
;
}
public
boolean
changeWorkingDirectory
(
final
String
pathname
)
throws
IOException
{
return
FTPReply
.
isPositiveCompletion
(
cwd
(
pathname
)
)
;
}
public
boolean
completePendingCommand
(
)
throws
IOException
{
return
FTPReply
.
isPositiveCompletion
(
getReply
(
)
)
;
}
@
Override
public
void
configure
(
final
FTPClientConfig
config
)
{
this
.
configuration
=
config
;
}
void
createParser
(
final
String
parserKey
)
throws
IOException
{
if
(
entryParser
==
null
||
(
parserKey
!=
null
&&
!
entryParserKey
.
equals
(
parserKey
)
)
)
{
if
(
null
!=
parserKey
)
{
entryParser
=
parserFactory
.
createFileEntryParser
(
parserKey
)
;
entryParserKey
=
parserKey
;
}
else
if
(
null
!=
configuration
&&
configuration
.
getServerSystemKey
(
)
.
length
(
)
>
0
)
{
entryParser
=
parserFactory
.
createFileEntryParser
(
configuration
)
;
entryParserKey
=
configuration
.
getServerSystemKey
(
)
;
}
else
{
String
systemType
=
System
.
getProperty
(
FTP_SYSTEM_TYPE
)
;
if
(
systemType
==
null
)
{
systemType
=
getSystemType
(
)
;
final
Properties
override
=
getOverrideProperties
(
)
;
if
(
override
!=
null
)
{
final
String
newType
=
override
.
getProperty
(
systemType
)
;
if
(
newType
!=
null
)
{
systemType
=
newType
;
}
}
}
if
(
null
!=
configuration
)
{
entryParser
=
parserFactory
.
createFileEntryParser
(
new
FTPClientConfig
(
systemType
,
configuration
)
)
;
}
else
{
entryParser
=
parserFactory
.
createFileEntryParser
(
systemType
)
;
}
entryParserKey
=
systemType
;
}
}
}
public
boolean
deleteFile
(
final
String
pathname
)
throws
IOException
{
return
FTPReply
.
isPositiveCompletion
(
dele
(
pathname
)
)
;
}
@
Override
public
void
disconnect
(
)
throws
IOException
{
super
.
disconnect
(
)
;
initDefaults
(
)
;
}
public
boolean
doCommand
(
final
String
command
,
final
String
params
)
throws
IOException
{
return
FTPReply
.
isPositiveCompletion
(
sendCommand
(
command
,
params
)
)
;
}
public
String
[
]
doCommandAsStrings
(
final
String
command
,
final
String
params
)
throws
IOException
{
final
boolean
success
=
FTPReply
.
isPositiveCompletion
(
sendCommand
(
command
,
params
)
)
;
if
(
success
)
{
return
getReplyStrings
(
)
;
}
return
null
;
}
public
void
enterLocalActiveMode
(
)
{
dataConnectionMode
=
ACTIVE_LOCAL_DATA_CONNECTION_MODE
;
passiveHost
=
null
;
passivePort
=
-
1
;
}
public
void
enterLocalPassiveMode
(
)
{
dataConnectionMode
=
PASSIVE_LOCAL_DATA_CONNECTION_MODE
;
passiveHost
=
null
;
passivePort
=
-
1
;
}
public
boolean
enterRemoteActiveMode
(
final
InetAddress
host
,
final
int
port
)
throws
IOException
{
if
(
FTPReply
.
isPositiveCompletion
(
port
(
host
,
port
)
)
)
{
dataConnectionMode
=
ACTIVE_REMOTE_DATA_CONNECTION_MODE
;
passiveHost
=
null
;
passivePort
=
-
1
;
return
true
;
}
return
false
;
}
public
boolean
enterRemotePassiveMode
(
)
throws
IOException
{
if
(
pasv
(
)
!=
FTPReply
.
ENTERING_PASSIVE_MODE
)
{
return
false
;
}
dataConnectionMode
=
PASSIVE_REMOTE_DATA_CONNECTION_MODE
;
_parsePassiveModeReply
(
_replyLines
.
get
(
0
)
)
;
return
true
;
}
public
boolean
features
(
)
throws
IOException
{
return
FTPReply
.
isPositiveCompletion
(
feat
(
)
)
;
}
public
String
featureValue
(
final
String
feature
)
throws
IOException
{
final
String
[
]
values
=
featureValues
(
feature
)
;
if
(
values
!=
null
)
{
return
values
[
0
]
;
}
return
null
;
}
public
String
[
]
featureValues
(
final
String
feature
)
throws
IOException
{
if
(
!
initFeatureMap
(
)
)
{
return
null
;
}
final
Set
<
String
>
entries
=
featuresMap
.
get
(
feature
.
toUpperCase
(
Locale
.
ENGLISH
)
)
;
if
(
entries
!=
null
)
{
return
entries
.
toArray
(
NetConstants
.
EMPTY_STRING_ARRAY
)
;
}
return
null
;
}
int
getActivePort
(
)
{
if
(
activeMinPort
>
0
&&
activeMaxPort
>=
activeMinPort
)
{
if
(
activeMaxPort
==
activeMinPort
)
{
return
activeMaxPort
;
}
return
random
.
nextInt
(
activeMaxPort
-
activeMinPort
+
1
)
+
activeMinPort
;
}
return
0
;
}
public
boolean
getAutodetectUTF8
(
)
{
return
autodetectEncoding
;
}
private
InputStream
getBufferedInputStream
(
final
InputStream
inputStream
)
{
if
(
bufferSize
>
0
)
{
return
new
BufferedInputStream
(
inputStream
,
bufferSize
)
;
}
return
new
BufferedInputStream
(
inputStream
)
;
}
private
OutputStream
getBufferedOutputStream
(
final
OutputStream
outputStream
)
{
if
(
bufferSize
>
0
)
{
return
new
BufferedOutputStream
(
outputStream
,
bufferSize
)
;
}
return
new
BufferedOutputStream
(
outputStream
)
;
}
public
int
getBufferSize
(
)
{
return
bufferSize
;
}
@
Deprecated
public
int
getControlKeepAliveReplyTimeout
(
)
{
return
DurationUtils
.
toMillisInt
(
controlKeepAliveReplyTimeout
)
;
}
public
Duration
getControlKeepAliveReplyTimeoutDuration
(
)
{
return
controlKeepAliveReplyTimeout
;
}
@
Deprecated
public
long
getControlKeepAliveTimeout
(
)
{
return
controlKeepAliveTimeout
.
getSeconds
(
)
;
}
public
Duration
getControlKeepAliveTimeoutDuration
(
)
{
return
controlKeepAliveTimeout
;
}
public
CopyStreamListener
getCopyStreamListener
(
)
{
return
copyStreamListener
;
}
@
Deprecated
public
int
[
]
getCslDebug
(
)
{
return
cslDebug
;
}
public
int
getDataConnectionMode
(
)
{
return
dataConnectionMode
;
}
public
Duration
getDataTimeout
(
)
{
return
dataTimeout
;
}
FTPFileEntryParser
getEntryParser
(
)
{
return
entryParser
;
}
InetAddress
getHostAddress
(
)
{
if
(
activeExternalHost
!=
null
)
{
return
activeExternalHost
;
}
return
getLocalAddress
(
)
;
}
protected
String
getListArguments
(
final
String
pathname
)
{
if
(
getListHiddenFiles
(
)
)
{
if
(
pathname
!=
null
)
{
final
StringBuilder
sb
=
new
StringBuilder
(
pathname
.
length
(
)
+
3
)
;
sb
.
append
(
"-a "
)
;
sb
.
append
(
pathname
)
;
return
sb
.
toString
(
)
;
}
return
"-a"
;
}
return
pathname
;
}
public
boolean
getListHiddenFiles
(
)
{
return
this
.
listHiddenFiles
;
}
public
String
getModificationTime
(
final
String
pathname
)
throws
IOException
{
if
(
FTPReply
.
isPositiveCompletion
(
mdtm
(
pathname
)
)
)
{
return
getReplyString
(
0
)
.
substring
(
4
)
;
}
return
null
;
}
public
String
getPassiveHost
(
)
{
return
passiveHost
;
}
public
InetAddress
getPassiveLocalIPAddress
(
)
{
return
this
.
passiveLocalHost
;
}
public
int
getPassivePort
(
)
{
return
passivePort
;
}
public
int
getReceiveDataSocketBufferSize
(
)
{
return
receiveDataSocketBufferSize
;
}
InetAddress
getReportHostAddress
(
)
{
if
(
reportActiveExternalHost
!=
null
)
{
return
reportActiveExternalHost
;
}
return
getHostAddress
(
)
;
}
public
long
getRestartOffset
(
)
{
return
restartOffset
;
}
public
int
getSendDataSocketBufferSize
(
)
{
return
sendDataSocketBufferSize
;
}
public
String
getSize
(
final
String
pathname
)
throws
IOException
{
if
(
FTPReply
.
isPositiveCompletion
(
size
(
pathname
)
)
)
{
return
getReplyString
(
0
)
.
substring
(
4
)
;
}
return
null
;
}
public
String
getStatus
(
)
throws
IOException
{
if
(
FTPReply
.
isPositiveCompletion
(
stat
(
)
)
)
{
return
getReplyString
(
)
;
}
return
null
;
}
public
String
getStatus
(
final
String
pathname
)
throws
IOException
{
if
(
FTPReply
.
isPositiveCompletion
(
stat
(
pathname
)
)
)
{
return
getReplyString
(
)
;
}
return
null
;
}
@
Deprecated
public
String
getSystemName
(
)
throws
IOException
{
if
(
systemName
==
null
&&
FTPReply
.
isPositiveCompletion
(
syst
(
)
)
)
{
systemName
=
_replyLines
.
get
(
_replyLines
.
size
(
)
-
1
)
.
substring
(
4
)
;
}
return
systemName
;
}
public
String
getSystemType
(
)
throws
IOException
{
if
(
systemName
==
null
)
{
if
(
FTPReply
.
isPositiveCompletion
(
syst
(
)
)
)
{
systemName
=
_replyLines
.
get
(
_replyLines
.
size
(
)
-
1
)
.
substring
(
4
)
;
}
else
{
final
String
systDefault
=
System
.
getProperty
(
FTP_SYSTEM_TYPE_DEFAULT
)
;
if
(
systDefault
==
null
)
{
throw
new
IOException
(
"Unable to determine system type - response: "
+
getReplyString
(
)
)
;
}
systemName
=
systDefault
;
}
}
return
systemName
;
}
public
boolean
hasFeature
(
final
FTPCmd
feature
)
throws
IOException
{
return
hasFeature
(
feature
.
name
(
)
)
;
}
public
boolean
hasFeature
(
final
String
feature
)
throws
IOException
{
if
(
!
initFeatureMap
(
)
)
{
return
false
;
}
return
featuresMap
.
containsKey
(
feature
.
toUpperCase
(
Locale
.
ENGLISH
)
)
;
}
public
boolean
hasFeature
(
final
String
feature
,
final
String
value
)
throws
IOException
{
if
(
!
initFeatureMap
(
)
)
{
return
false
;
}
final
Set
<
String
>
entries
=
featuresMap
.
get
(
feature
.
toUpperCase
(
Locale
.
ENGLISH
)
)
;
if
(
entries
!=
null
)
{
return
entries
.
contains
(
value
)
;
}
return
false
;
}
private
void
initDefaults
(
)
{
dataConnectionMode
=
ACTIVE_LOCAL_DATA_CONNECTION_MODE
;
passiveHost
=
null
;
passivePort
=
-
1
;
activeExternalHost
=
null
;
reportActiveExternalHost
=
null
;
activeMinPort
=
0
;
activeMaxPort
=
0
;
fileType
=
FTP
.
ASCII_FILE_TYPE
;
fileStructure
=
FTP
.
FILE_STRUCTURE
;
fileFormat
=
FTP
.
NON_PRINT_TEXT_FORMAT
;
fileTransferMode
=
FTP
.
STREAM_TRANSFER_MODE
;
restartOffset
=
0
;
systemName
=
null
;
entryParser
=
null
;
entryParserKey
=
""
;
featuresMap
=
null
;
}
private
boolean
initFeatureMap
(
)
throws
IOException
{
if
(
featuresMap
==
null
)
{
final
int
replyCode
=
feat
(
)
;
if
(
replyCode
==
FTPReply
.
NOT_LOGGED_IN
)
{
return
false
;
}
final
boolean
success
=
FTPReply
.
isPositiveCompletion
(
replyCode
)
;
featuresMap
=
new
HashMap
<
>
(
)
;
if
(
!
success
)
{
return
false
;
}
for
(
final
String
line
:
_replyLines
)
{
if
(
line
.
startsWith
(
" "
)
)
{
String
key
;
String
value
=
""
;
final
int
varsep
=
line
.
indexOf
(
' '
,
1
)
;
if
(
varsep
>
0
)
{
key
=
line
.
substring
(
1
,
varsep
)
;
value
=
line
.
substring
(
varsep
+
1
)
;
}
else
{
key
=
line
.
substring
(
1
)
;
}
key
=
key
.
toUpperCase
(
Locale
.
ENGLISH
)
;
Set
<
String
>
entries
=
featuresMap
.
computeIfAbsent
(
key
,
k
->
new
HashSet
<
>
(
)
)
;
entries
.
add
(
value
)
;
}
}
}
return
true
;
}
public
FTPListParseEngine
initiateListParsing
(
)
throws
IOException
{
return
initiateListParsing
(
(
String
)
null
)
;
}
private
FTPListParseEngine
initiateListParsing
(
final
FTPFileEntryParser
parser
,
final
String
pathname
)
throws
IOException
{
final
Socket
socket
=
_openDataConnection_
(
FTPCmd
.
LIST
,
getListArguments
(
pathname
)
)
;
final
FTPListParseEngine
engine
=
new
FTPListParseEngine
(
parser
,
configuration
)
;
if
(
socket
==
null
)
{
return
engine
;
}
try
{
engine
.
readServerList
(
socket
.
getInputStream
(
)
,
getControlEncoding
(
)
)
;
}
finally
{
Util
.
closeQuietly
(
socket
)
;
}
completePendingCommand
(
)
;
return
engine
;
}
public
FTPListParseEngine
initiateListParsing
(
final
String
pathname
)
throws
IOException
{
return
initiateListParsing
(
(
String
)
null
,
pathname
)
;
}
public
FTPListParseEngine
initiateListParsing
(
final
String
parserKey
,
final
String
pathname
)
throws
IOException
{
createParser
(
parserKey
)
;
return
initiateListParsing
(
entryParser
,
pathname
)
;
}
public
FTPListParseEngine
initiateMListParsing
(
)
throws
IOException
{
return
initiateMListParsing
(
null
)
;
}
public
FTPListParseEngine
initiateMListParsing
(
final
String
pathname
)
throws
IOException
{
final
Socket
socket
=
_openDataConnection_
(
FTPCmd
.
MLSD
,
pathname
)
;
final
FTPListParseEngine
engine
=
new
FTPListParseEngine
(
MLSxEntryParser
.
getInstance
(
)
,
configuration
)
;
if
(
socket
==
null
)
{
return
engine
;
}
try
{
engine
.
readServerList
(
socket
.
getInputStream
(
)
,
getControlEncoding
(
)
)
;
}
finally
{
Util
.
closeQuietly
(
socket
)
;
completePendingCommand
(
)
;
}
return
engine
;
}
public
boolean
isIpAddressFromPasvResponse
(
)
{
return
ipAddressFromPasvResponse
;
}
public
boolean
isRemoteVerificationEnabled
(
)
{
return
remoteVerificationEnabled
;
}
public
boolean
isUseEPSVwithIPv4
(
)
{
return
useEPSVwithIPv4
;
}
public
FTPFile
[
]
listDirectories
(
)
throws
IOException
{
return
listDirectories
(
(
String
)
null
)
;
}
public
FTPFile
[
]
listDirectories
(
final
String
parent
)
throws
IOException
{
return
listFiles
(
parent
,
FTPFileFilters
.
DIRECTORIES
)
;
}
public
FTPFile
[
]
listFiles
(
)
throws
IOException
{
return
listFiles
(
(
String
)
null
)
;
}
public
FTPFile
[
]
listFiles
(
final
String
pathname
)
throws
IOException
{
return
initiateListParsing
(
(
String
)
null
,
pathname
)
.
getFiles
(
)
;
}
public
FTPFile
[
]
listFiles
(
final
String
pathname
,
final
FTPFileFilter
filter
)
throws
IOException
{
return
initiateListParsing
(
(
String
)
null
,
pathname
)
.
getFiles
(
filter
)
;
}
public
String
listHelp
(
)
throws
IOException
{
return
FTPReply
.
isPositiveCompletion
(
help
(
)
)
?
getReplyString
(
)
:
null
;
}
public
String
listHelp
(
final
String
command
)
throws
IOException
{
return
FTPReply
.
isPositiveCompletion
(
help
(
command
)
)
?
getReplyString
(
)
:
null
;
}
public
String
[
]
listNames
(
)
throws
IOException
{
return
listNames
(
null
)
;
}
public
String
[
]
listNames
(
final
String
pathname
)
throws
IOException
{
final
ArrayList
<
String
>
results
=
new
ArrayList
<
>
(
)
;
try
(
final
Socket
socket
=
_openDataConnection_
(
FTPCmd
.
NLST
,
getListArguments
(
pathname
)
)
)
{
if
(
socket
==
null
)
{
return
null
;
}
try
(
final
BufferedReader
reader
=
new
BufferedReader
(
new
InputStreamReader
(
socket
.
getInputStream
(
)
,
getControlEncoding
(
)
)
)
)
{
String
line
;
while
(
(
line
=
reader
.
readLine
(
)
)
!=
null
)
{
results
.
add
(
line
)
;
}
}
}
if
(
completePendingCommand
(
)
)
{
return
results
.
toArray
(
NetConstants
.
EMPTY_STRING_ARRAY
)
;
}
return
null
;
}
public
boolean
login
(
final
String
username
,
final
String
password
)
throws
IOException
{
user
(
username
)
;
if
(
FTPReply
.
isPositiveCompletion
(
_replyCode
)
)
{
return
true
;
}
if
(
!
FTPReply
.
isPositiveIntermediate
(
_replyCode
)
)
{
return
false
;
}
return
FTPReply
.
isPositiveCompletion
(
pass
(
password
)
)
;
}
public
boolean
login
(
final
String
username
,
final
String
password
,
final
String
account
)
throws
IOException
{
user
(
username
)
;
if
(
FTPReply
.
isPositiveCompletion
(
_replyCode
)
)
{
return
true
;
}
if
(
!
FTPReply
.
isPositiveIntermediate
(
_replyCode
)
)
{
return
false
;
}
pass
(
password
)
;
if
(
FTPReply
.
isPositiveCompletion
(
_replyCode
)
)
{
return
true
;
}
if
(
!
FTPReply
.
isPositiveIntermediate
(
_replyCode
)
)
{
return
false
;
}
return
FTPReply
.
isPositiveCompletion
(
acct
(
account
)
)
;
}
public
boolean
logout
(
)
throws
IOException
{
return
FTPReply
.
isPositiveCompletion
(
quit
(
)
)
;
}
public
boolean
makeDirectory
(
final
String
pathname
)
throws
IOException
{
return
FTPReply
.
isPositiveCompletion
(
mkd
(
pathname
)
)
;
}
public
Calendar
mdtmCalendar
(
final
String
pathname
)
throws
IOException
{
final
String
modificationTime
=
getModificationTime
(
pathname
)
;
if
(
modificationTime
!=
null
)
{
return
MLSxEntryParser
.
parseGMTdateTime
(
modificationTime
)
;
}
return
null
;
}
public
FTPFile
mdtmFile
(
final
String
pathname
)
throws
IOException
{
final
String
modificationTime
=
getModificationTime
(
pathname
)
;
if
(
modificationTime
!=
null
)
{
final
FTPFile
file
=
new
FTPFile
(
)
;
file
.
setName
(
pathname
)
;
file
.
setRawListing
(
modificationTime
)
;
file
.
setTimestamp
(
MLSxEntryParser
.
parseGMTdateTime
(
modificationTime
)
)
;
return
file
;
}
return
null
;
}
public
Instant
mdtmInstant
(
final
String
pathname
)
throws
IOException
{
final
String
modificationTime
=
getModificationTime
(
pathname
)
;
if
(
modificationTime
!=
null
)
{
return
MLSxEntryParser
.
parseGmtInstant
(
modificationTime
)
;
}
return
null
;
}
private
CopyStreamListener
mergeListeners
(
final
CopyStreamListener
local
)
{
if
(
local
==
null
)
{
return
copyStreamListener
;
}
if
(
copyStreamListener
==
null
)
{
return
local
;
}
final
CopyStreamAdapter
merged
=
new
CopyStreamAdapter
(
)
;
merged
.
addCopyStreamListener
(
local
)
;
merged
.
addCopyStreamListener
(
copyStreamListener
)
;
return
merged
;
}
public
FTPFile
[
]
mlistDir
(
)
throws
IOException
{
return
mlistDir
(
null
)
;
}
public
FTPFile
[
]
mlistDir
(
final
String
pathname
)
throws
IOException
{
return
initiateMListParsing
(
pathname
)
.
getFiles
(
)
;
}
public
FTPFile
[
]
mlistDir
(
final
String
pathname
,
final
FTPFileFilter
filter
)
throws
IOException
{
return
initiateMListParsing
(
pathname
)
.
getFiles
(
filter
)
;
}
public
FTPFile
mlistFile
(
final
String
pathname
)
throws
IOException
{
final
boolean
success
=
FTPReply
.
isPositiveCompletion
(
sendCommand
(
FTPCmd
.
MLST
,
pathname
)
)
;
if
(
success
)
{
String
reply
=
getReplyString
(
1
)
;
if
(
reply
.
charAt
(
0
)
!=
' '
)
{
reply
=
" "
+
reply
;
}
if
(
reply
.
length
(
)
<
3
)
{
throw
new
MalformedServerReplyException
(
"Invalid server reply (MLST): '"
+
reply
+
"'"
)
;
}
final
String
entry
=
reply
.
replaceAll
(
"^\\s+"
,
""
)
;
return
MLSxEntryParser
.
parseEntry
(
entry
)
;
}
return
null
;
}
public
String
printWorkingDirectory
(
)
throws
IOException
{
if
(
pwd
(
)
!=
FTPReply
.
PATHNAME_CREATED
)
{
return
null
;
}
return
parsePathname
(
_replyLines
.
get
(
_replyLines
.
size
(
)
-
1
)
)
;
}
public
boolean
reinitialize
(
)
throws
IOException
{
rein
(
)
;
if
(
FTPReply
.
isPositiveCompletion
(
_replyCode
)
||
(
FTPReply
.
isPositivePreliminary
(
_replyCode
)
&&
FTPReply
.
isPositiveCompletion
(
getReply
(
)
)
)
)
{
initDefaults
(
)
;
return
true
;
}
return
false
;
}
public
boolean
remoteAppend
(
final
String
fileName
)
throws
IOException
{
if
(
dataConnectionMode
==
ACTIVE_REMOTE_DATA_CONNECTION_MODE
||
dataConnectionMode
==
PASSIVE_REMOTE_DATA_CONNECTION_MODE
)
{
return
FTPReply
.
isPositivePreliminary
(
appe
(
fileName
)
)
;
}
return
false
;
}
public
boolean
remoteRetrieve
(
final
String
fileName
)
throws
IOException
{
if
(
dataConnectionMode
==
ACTIVE_REMOTE_DATA_CONNECTION_MODE
||
dataConnectionMode
==
PASSIVE_REMOTE_DATA_CONNECTION_MODE
)
{
return
FTPReply
.
isPositivePreliminary
(
retr
(
fileName
)
)
;
}
return
false
;
}
public
boolean
remoteStore
(
final
String
fileName
)
throws
IOException
{
if
(
dataConnectionMode
==
ACTIVE_REMOTE_DATA_CONNECTION_MODE
||
dataConnectionMode
==
PASSIVE_REMOTE_DATA_CONNECTION_MODE
)
{
return
FTPReply
.
isPositivePreliminary
(
stor
(
fileName
)
)
;
}
return
false
;
}
public
boolean
remoteStoreUnique
(
)
throws
IOException
{
if
(
dataConnectionMode
==
ACTIVE_REMOTE_DATA_CONNECTION_MODE
||
dataConnectionMode
==
PASSIVE_REMOTE_DATA_CONNECTION_MODE
)
{
return
FTPReply
.
isPositivePreliminary
(
stou
(
)
)
;
}
return
false
;
}
public
boolean
remoteStoreUnique
(
final
String
fileName
)
throws
IOException
{
if
(
dataConnectionMode
==
ACTIVE_REMOTE_DATA_CONNECTION_MODE
||
dataConnectionMode
==
PASSIVE_REMOTE_DATA_CONNECTION_MODE
)
{
return
FTPReply
.
isPositivePreliminary
(
stou
(
fileName
)
)
;
}
return
false
;
}
public
boolean
removeDirectory
(
final
String
pathname
)
throws
IOException
{
return
FTPReply
.
isPositiveCompletion
(
rmd
(
pathname
)
)
;
}
public
boolean
rename
(
final
String
from
,
final
String
to
)
throws
IOException
{
if
(
!
FTPReply
.
isPositiveIntermediate
(
rnfr
(
from
)
)
)
{
return
false
;
}
return
FTPReply
.
isPositiveCompletion
(
rnto
(
to
)
)
;
}
protected
boolean
restart
(
final
long
offset
)
throws
IOException
{
restartOffset
=
0
;
return
FTPReply
.
isPositiveIntermediate
(
rest
(
Long
.
toString
(
offset
)
)
)
;
}
public
boolean
retrieveFile
(
final
String
remote
,
final
OutputStream
local
)
throws
IOException
{
return
_retrieveFile
(
FTPCmd
.
RETR
.
getCommand
(
)
,
remote
,
local
)
;
}
public
InputStream
retrieveFileStream
(
final
String
remote
)
throws
IOException
{
return
_retrieveFileStream
(
FTPCmd
.
RETR
.
getCommand
(
)
,
remote
)
;
}
public
boolean
sendNoOp
(
)
throws
IOException
{
return
FTPReply
.
isPositiveCompletion
(
noop
(
)
)
;
}
public
boolean
sendSiteCommand
(
final
String
arguments
)
throws
IOException
{
return
FTPReply
.
isPositiveCompletion
(
site
(
arguments
)
)
;
}
public
void
setActiveExternalIPAddress
(
final
String
ipAddress
)
throws
UnknownHostException
{
this
.
activeExternalHost
=
InetAddress
.
getByName
(
ipAddress
)
;
}
public
void
setActivePortRange
(
final
int
minPort
,
final
int
maxPort
)
{
this
.
activeMinPort
=
minPort
;
this
.
activeMaxPort
=
maxPort
;
}
public
void
setAutodetectUTF8
(
final
boolean
autodetect
)
{
autodetectEncoding
=
autodetect
;
}
public
void
setBufferSize
(
final
int
bufSize
)
{
bufferSize
=
bufSize
;
}
public
void
setControlKeepAliveReplyTimeout
(
final
Duration
timeout
)
{
controlKeepAliveReplyTimeout
=
DurationUtils
.
zeroIfNull
(
timeout
)
;
}
@
Deprecated
public
void
setControlKeepAliveReplyTimeout
(
final
int
timeoutMillis
)
{
controlKeepAliveReplyTimeout
=
Duration
.
ofMillis
(
timeoutMillis
)
;
}
public
void
setControlKeepAliveTimeout
(
final
Duration
controlIdle
)
{
controlKeepAliveTimeout
=
DurationUtils
.
zeroIfNull
(
controlIdle
)
;
}
@
Deprecated
public
void
setControlKeepAliveTimeout
(
final
long
controlIdleSeconds
)
{
controlKeepAliveTimeout
=
Duration
.
ofSeconds
(
controlIdleSeconds
)
;
}
public
void
setCopyStreamListener
(
final
CopyStreamListener
listener
)
{
copyStreamListener
=
listener
;
}
public
void
setDataTimeout
(
final
Duration
timeout
)
{
dataTimeout
=
DurationUtils
.
zeroIfNull
(
timeout
)
;
}
@
Deprecated
public
void
setDataTimeout
(
final
int
timeoutMillis
)
{
dataTimeout
=
Duration
.
ofMillis
(
timeoutMillis
)
;
}
public
boolean
setFileStructure
(
final
int
structure
)
throws
IOException
{
if
(
FTPReply
.
isPositiveCompletion
(
stru
(
structure
)
)
)
{
fileStructure
=
structure
;
return
true
;
}
return
false
;
}
public
boolean
setFileTransferMode
(
final
int
mode
)
throws
IOException
{
if
(
FTPReply
.
isPositiveCompletion
(
mode
(
mode
)
)
)
{
fileTransferMode
=
mode
;
return
true
;
}
return
false
;
}
public
boolean
setFileType
(
final
int
fileType
)
throws
IOException
{
if
(
FTPReply
.
isPositiveCompletion
(
type
(
fileType
)
)
)
{
this
.
fileType
=
fileType
;
this
.
fileFormat
=
FTP
.
NON_PRINT_TEXT_FORMAT
;
return
true
;
}
return
false
;
}
public
boolean
setFileType
(
final
int
fileType
,
final
int
formatOrByteSize
)
throws
IOException
{
if
(
FTPReply
.
isPositiveCompletion
(
type
(
fileType
,
formatOrByteSize
)
)
)
{
this
.
fileType
=
fileType
;
this
.
fileFormat
=
formatOrByteSize
;
return
true
;
}
return
false
;
}
public
void
setIpAddressFromPasvResponse
(
boolean
usingIpAddressFromPasvResponse
)
{
this
.
ipAddressFromPasvResponse
=
usingIpAddressFromPasvResponse
;
}
public
void
setListHiddenFiles
(
final
boolean
listHiddenFiles
)
{
this
.
listHiddenFiles
=
listHiddenFiles
;
}
public
boolean
setModificationTime
(
final
String
pathname
,
final
String
timeval
)
throws
IOException
{
return
(
FTPReply
.
isPositiveCompletion
(
mfmt
(
pathname
,
timeval
)
)
)
;
}
public
void
setParserFactory
(
final
FTPFileEntryParserFactory
parserFactory
)
{
this
.
parserFactory
=
parserFactory
;
}
public
void
setPassiveLocalIPAddress
(
final
InetAddress
inetAddress
)
{
this
.
passiveLocalHost
=
inetAddress
;
}
public
void
setPassiveLocalIPAddress
(
final
String
ipAddress
)
throws
UnknownHostException
{
this
.
passiveLocalHost
=
InetAddress
.
getByName
(
ipAddress
)
;
}
@
Deprecated
public
void
setPassiveNatWorkaround
(
final
boolean
enabled
)
{
this
.
passiveNatWorkaroundStrategy
=
enabled
?
new
NatServerResolverImpl
(
this
)
:
null
;
}
public
void
setPassiveNatWorkaroundStrategy
(
final
HostnameResolver
resolver
)
{
this
.
passiveNatWorkaroundStrategy
=
resolver
;
}
public
void
setReceieveDataSocketBufferSize
(
final
int
bufSize
)
{
receiveDataSocketBufferSize
=
bufSize
;
}
public
void
setRemoteVerificationEnabled
(
final
boolean
enable
)
{
remoteVerificationEnabled
=
enable
;
}
public
void
setReportActiveExternalIPAddress
(
final
String
ipAddress
)
throws
UnknownHostException
{
this
.
reportActiveExternalHost
=
InetAddress
.
getByName
(
ipAddress
)
;
}
public
void
setRestartOffset
(
final
long
offset
)
{
if
(
offset
>=
0
)
{
restartOffset
=
offset
;
}
}
public
void
setSendDataSocketBufferSize
(
final
int
bufSize
)
{
sendDataSocketBufferSize
=
bufSize
;
}
public
void
setUseEPSVwithIPv4
(
final
boolean
selected
)
{
this
.
useEPSVwithIPv4
=
selected
;
}
private
boolean
storeFile
(
final
FTPCmd
command
,
final
String
remote
,
final
InputStream
local
)
throws
IOException
{
return
_storeFile
(
command
.
getCommand
(
)
,
remote
,
local
)
;
}
public
boolean
storeFile
(
final
String
remote
,
final
InputStream
local
)
throws
IOException
{
return
storeFile
(
FTPCmd
.
STOR
,
remote
,
local
)
;
}
private
OutputStream
storeFileStream
(
final
FTPCmd
command
,
final
String
remote
)
throws
IOException
{
return
_storeFileStream
(
command
.
getCommand
(
)
,
remote
)
;
}
public
OutputStream
storeFileStream
(
final
String
remote
)
throws
IOException
{
return
storeFileStream
(
FTPCmd
.
STOR
,
remote
)
;
}
public
boolean
storeUniqueFile
(
final
InputStream
local
)
throws
IOException
{
return
storeFile
(
FTPCmd
.
STOU
,
null
,
local
)
;
}
public
boolean
storeUniqueFile
(
final
String
remote
,
final
InputStream
local
)
throws
IOException
{
return
storeFile
(
FTPCmd
.
STOU
,
remote
,
local
)
;
}
public
OutputStream
storeUniqueFileStream
(
)
throws
IOException
{
return
storeFileStream
(
FTPCmd
.
STOU
,
null
)
;
}
public
OutputStream
storeUniqueFileStream
(
final
String
remote
)
throws
IOException
{
return
storeFileStream
(
FTPCmd
.
STOU
,
remote
)
;
}
public
boolean
structureMount
(
final
String
pathname
)
throws
IOException
{
return
FTPReply
.
isPositiveCompletion
(
smnt
(
pathname
)
)
;
}
}
<EOF>
