package
org
.
apache
.
commons
.
net
.
ftp
.
parser
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
List
;
import
java
.
util
.
ListIterator
;
import
java
.
util
.
regex
.
MatchResult
;
import
java
.
util
.
regex
.
Matcher
;
import
java
.
util
.
regex
.
Pattern
;
import
java
.
util
.
regex
.
PatternSyntaxException
;
import
org
.
apache
.
commons
.
net
.
ftp
.
FTPClientConfig
;
public
class
VMSVersioningFTPEntryParser
extends
VMSFTPEntryParser
{
private
static
final
String
PRE_PARSE_REGEX
=
"(.*?);([0-9]+)\\s*.*"
;
private
final
Pattern
preparsePattern
;
public
VMSVersioningFTPEntryParser
(
)
{
this
(
null
)
;
}
public
VMSVersioningFTPEntryParser
(
final
FTPClientConfig
config
)
{
configure
(
config
)
;
try
{
preparsePattern
=
Pattern
.
compile
(
PRE_PARSE_REGEX
)
;
}
catch
(
final
PatternSyntaxException
pse
)
{
throw
new
IllegalArgumentException
(
"Unparseable regex supplied:  "
+
PRE_PARSE_REGEX
)
;
}
}
@
Override
protected
boolean
isVersioning
(
)
{
return
true
;
}
@
Override
public
List
<
String
>
preParse
(
final
List
<
String
>
original
)
{
final
HashMap
<
String
,
Integer
>
existingEntries
=
new
HashMap
<
>
(
)
;
final
ListIterator
<
String
>
iter
=
original
.
listIterator
(
)
;
while
(
iter
.
hasNext
(
)
)
{
final
String
entry
=
iter
.
next
(
)
.
trim
(
)
;
MatchResult
result
=
null
;
final
Matcher
_preparse_matcher_
=
preparsePattern
.
matcher
(
entry
)
;
if
(
_preparse_matcher_
.
matches
(
)
)
{
result
=
_preparse_matcher_
.
toMatchResult
(
)
;
final
String
name
=
result
.
group
(
1
)
;
final
String
version
=
result
.
group
(
2
)
;
final
Integer
nv
=
Integer
.
valueOf
(
version
)
;
final
Integer
existing
=
existingEntries
.
get
(
name
)
;
if
(
(
null
!=
existing
)
&&
(
nv
.
intValue
(
)
<
existing
.
intValue
(
)
)
)
{
iter
.
remove
(
)
;
continue
;
}
existingEntries
.
put
(
name
,
nv
)
;
}
}
while
(
iter
.
hasPrevious
(
)
)
{
final
String
entry
=
iter
.
previous
(
)
.
trim
(
)
;
MatchResult
result
=
null
;
final
Matcher
_preparse_matcher_
=
preparsePattern
.
matcher
(
entry
)
;
if
(
_preparse_matcher_
.
matches
(
)
)
{
result
=
_preparse_matcher_
.
toMatchResult
(
)
;
final
String
name
=
result
.
group
(
1
)
;
final
String
version
=
result
.
group
(
2
)
;
final
int
nv
=
Integer
.
parseInt
(
version
)
;
final
Integer
existing
=
existingEntries
.
get
(
name
)
;
if
(
(
null
!=
existing
)
&&
(
nv
<
existing
.
intValue
(
)
)
)
{
iter
.
remove
(
)
;
}
}
}
return
original
;
}
}
<EOF>
