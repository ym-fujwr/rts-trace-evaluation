package
com
.
zaxxer
.
nuprocess
.
linux
;
import
com
.
sun
.
jna
.
JNIEnv
;
import
com
.
sun
.
jna
.
ptr
.
IntByReference
;
import
com
.
zaxxer
.
nuprocess
.
NuProcess
;
import
com
.
zaxxer
.
nuprocess
.
NuProcessHandler
;
import
com
.
zaxxer
.
nuprocess
.
internal
.
BasePosixProcess
;
import
com
.
zaxxer
.
nuprocess
.
internal
.
LibC
;
import
java
.
nio
.
file
.
Path
;
import
java
.
util
.
List
;
import
java
.
util
.
logging
.
Level
;
import
static
com
.
zaxxer
.
nuprocess
.
internal
.
LibC
.
*
;
import
static
com
.
zaxxer
.
nuprocess
.
internal
.
Constants
.
JVM_MAJOR_VERSION
;
public
class
LinuxProcess
extends
BasePosixProcess
{
private
static
final
boolean
isAzul
;
static
{
isAzul
=
System
.
getProperty
(
"java.vm.vendor"
,
""
)
.
contains
(
"Azul"
)
;
LibEpoll
.
sigignore
(
LibEpoll
.
SIGPIPE
)
;
for
(
int
i
=
0
;
i
<
processors
.
length
;
i
++
)
{
processors
[
i
]
=
new
ProcessEpoll
(
)
;
}
}
@
SuppressWarnings
(
"unused"
)
private
enum
LaunchMechanism
{
FORK
,
POSIX_SPAWN
,
VFORK
}
LinuxProcess
(
NuProcessHandler
processListener
)
{
super
(
processListener
)
;
}
@
Override
public
NuProcess
start
(
List
<
String
>
command
,
String
[
]
environment
,
Path
cwd
)
{
callPreStart
(
)
;
String
[
]
cmdarray
=
command
.
toArray
(
new
String
[
0
]
)
;
byte
[
]
[
]
args
=
new
byte
[
cmdarray
.
length
-
1
]
[
]
;
int
size
=
args
.
length
;
for
(
int
i
=
0
;
i
<
args
.
length
;
i
++
)
{
args
[
i
]
=
cmdarray
[
i
+
1
]
.
getBytes
(
)
;
size
+=
args
[
i
]
.
length
;
}
byte
[
]
argBlock
=
new
byte
[
size
]
;
int
i
=
0
;
for
(
byte
[
]
arg
:
args
)
{
System
.
arraycopy
(
arg
,
0
,
argBlock
,
i
,
arg
.
length
)
;
i
+=
arg
.
length
+
1
;
}
byte
[
]
envBlock
=
toEnvironmentBlock
(
environment
)
;
try
{
createPipes
(
)
;
int
[
]
child_fds
=
{
stdinWidow
,
stdoutWidow
,
stderrWidow
}
;
if
(
JVM_MAJOR_VERSION
>=
10
||
isAzul
)
{
pid
=
com
.
zaxxer
.
nuprocess
.
internal
.
LibJava10
.
Java_java_lang_ProcessImpl_forkAndExec
(
JNIEnv
.
CURRENT
,
this
,
LaunchMechanism
.
VFORK
.
ordinal
(
)
+
1
,
toCString
(
System
.
getProperty
(
"java.home"
)
+
"/lib/jspawnhelper"
)
,
toCString
(
cmdarray
[
0
]
)
,
argBlock
,
args
.
length
,
envBlock
,
environment
.
length
,
(
cwd
!=
null
?
toCString
(
cwd
.
toString
(
)
)
:
null
)
,
child_fds
,
(
byte
)
0
)
;
}
else
{
pid
=
com
.
zaxxer
.
nuprocess
.
internal
.
LibJava8
.
Java_java_lang_UNIXProcess_forkAndExec
(
JNIEnv
.
CURRENT
,
this
,
LaunchMechanism
.
VFORK
.
ordinal
(
)
+
1
,
toCString
(
System
.
getProperty
(
"java.home"
)
+
"/lib/jspawnhelper"
)
,
toCString
(
cmdarray
[
0
]
)
,
argBlock
,
args
.
length
,
envBlock
,
environment
.
length
,
(
cwd
!=
null
?
toCString
(
cwd
.
toString
(
)
)
:
null
)
,
child_fds
,
(
byte
)
0
)
;
}
if
(
pid
==
-
1
)
{
return
null
;
}
LibC
.
close
(
stdinWidow
)
;
LibC
.
close
(
stdoutWidow
)
;
LibC
.
close
(
stderrWidow
)
;
initializeBuffers
(
)
;
afterStart
(
)
;
registerProcess
(
)
;
callStart
(
)
;
}
catch
(
Exception
e
)
{
LOGGER
.
log
(
Level
.
WARNING
,
"Failed to start process"
,
e
)
;
onExit
(
Integer
.
MIN_VALUE
)
;
return
null
;
}
return
this
;
}
@
Override
protected
boolean
checkLaunch
(
)
{
IntByReference
ret
=
new
IntByReference
(
)
;
int
waitpidRc
=
LibC
.
waitpid
(
pid
,
ret
,
LibC
.
WNOHANG
)
;
int
status
=
ret
.
getValue
(
)
;
boolean
cleanExit
=
waitpidRc
==
pid
&&
WIFEXITED
(
status
)
&&
WEXITSTATUS
(
status
)
==
0
;
if
(
cleanExit
)
{
cleanlyExitedBeforeProcess
.
set
(
true
)
;
}
else
if
(
waitpidRc
!=
0
)
{
if
(
WIFEXITED
(
status
)
)
{
status
=
WEXITSTATUS
(
status
)
;
if
(
status
==
127
)
{
onExit
(
Integer
.
MIN_VALUE
)
;
}
else
{
onExit
(
status
)
;
}
}
else
if
(
WIFSIGNALED
(
status
)
)
{
onExit
(
WTERMSIG
(
status
)
)
;
}
return
false
;
}
return
true
;
}
private
static
byte
[
]
toCString
(
String
s
)
{
if
(
s
==
null
)
return
null
;
byte
[
]
bytes
=
s
.
getBytes
(
)
;
byte
[
]
result
=
new
byte
[
bytes
.
length
+
1
]
;
System
.
arraycopy
(
bytes
,
0
,
result
,
0
,
bytes
.
length
)
;
result
[
result
.
length
-
1
]
=
(
byte
)
0
;
return
result
;
}
private
static
byte
[
]
toEnvironmentBlock
(
String
[
]
environment
)
{
int
count
=
environment
.
length
;
for
(
String
entry
:
environment
)
{
count
+=
entry
.
getBytes
(
)
.
length
;
}
byte
[
]
block
=
new
byte
[
count
]
;
int
i
=
0
;
for
(
String
entry
:
environment
)
{
byte
[
]
bytes
=
entry
.
getBytes
(
)
;
System
.
arraycopy
(
bytes
,
0
,
block
,
i
,
bytes
.
length
)
;
i
+=
bytes
.
length
+
1
;
}
return
block
;
}
}
<EOF>
