diff --git a/src/main/java/com/zaxxer/nuprocess/NuProcessBuilder.java b/src/main/java/com/zaxxer/nuprocess/NuProcessBuilder.java
index ee8bb76..d0276ec 100644
--- a/src/main/java/com/zaxxer/nuprocess/NuProcessBuilder.java
+++ b/src/main/java/com/zaxxer/nuprocess/NuProcessBuilder.java
@@ -254,0 +255,22 @@ public class NuProcessBuilder
+   {
+      ensureListener();
+      String[] env = prepareEnvironment();
+
+      return factory.createProcess(command, env, processListener, cwd);
+   }
+
+   /**
+    * Spawn the child process with the configured commands, environment, and {@link NuProcessHandler}
+    * and wait for it to complete running.
+    *
+    * @since 1.3
+    */
+   public void run()
+   {
+      ensureListener();
+      String[] env = prepareEnvironment();
+
+      factory.runProcess(command, env, processListener, cwd);
+   }
+
+   private void ensureListener()
@@ -258,0 +281 @@ public class NuProcessBuilder
+   }
@@ -259,0 +283,2 @@ public class NuProcessBuilder
+   private String[] prepareEnvironment()
+   {
@@ -266 +291 @@ public class NuProcessBuilder
-      return factory.createProcess(command, env, processListener, cwd);
+      return env;
diff --git a/src/main/java/com/zaxxer/nuprocess/NuProcessFactory.java b/src/main/java/com/zaxxer/nuprocess/NuProcessFactory.java
index d32434c..0c5026e 100644
--- a/src/main/java/com/zaxxer/nuprocess/NuProcessFactory.java
+++ b/src/main/java/com/zaxxer/nuprocess/NuProcessFactory.java
@@ -30,0 +31,9 @@ public interface NuProcessFactory
+
+   /**
+    * Runs the process synchronously.
+    *
+    * Pumping is done on the calling thread, and this method will not return until the process has exited.
+    *
+    * @since 1.3
+    */
+   void runProcess(List<String> commands, String[] env, NuProcessHandler processListener, Path cwd);
diff --git a/src/main/java/com/zaxxer/nuprocess/internal/BaseEventProcessor.java b/src/main/java/com/zaxxer/nuprocess/internal/BaseEventProcessor.java
index b55a56e..3797d8a 100644
--- a/src/main/java/com/zaxxer/nuprocess/internal/BaseEventProcessor.java
+++ b/src/main/java/com/zaxxer/nuprocess/internal/BaseEventProcessor.java
@@ -74 +74,4 @@ public abstract class BaseEventProcessor<T extends BasePosixProcess> implements
-         startBarrier.await();
+         // If the process is running synchronously, startBarrier will be null
+         if (startBarrier != null) {
+            startBarrier.await();
+         }
@@ -84,0 +88,7 @@ public abstract class BaseEventProcessor<T extends BasePosixProcess> implements
+      finally {
+         if (startBarrier == null) {
+            // If the process is running synchronously, when the run loop ends give the subclass
+            // an opportunity to close any descriptors it might have been using
+            close();
+         }
+      }
@@ -114,0 +125,12 @@ public abstract class BaseEventProcessor<T extends BasePosixProcess> implements
+
+   /**
+    * Closes the processor, freeing up any resources (such as file descriptors) it was using.
+    * <p>
+    * <b>Note</b>: This method is only called for processors that are used to pump <i>synchronous</i> processes.
+    * Processors used to pump <i>asynchronous</i> processes are never closed; while their threads may be stopped,
+    * when there are no processes to pump, they are restarted if a new asynchronous process is started and will
+    * reuse the same resources.
+    *
+    * @since 1.3
+    */
+   protected abstract void close();
diff --git a/src/main/java/com/zaxxer/nuprocess/internal/BasePosixProcess.java b/src/main/java/com/zaxxer/nuprocess/internal/BasePosixProcess.java
index 3f233b1..b710386 100644
--- a/src/main/java/com/zaxxer/nuprocess/internal/BasePosixProcess.java
+++ b/src/main/java/com/zaxxer/nuprocess/internal/BasePosixProcess.java
@@ -131,0 +132,9 @@ public abstract class BasePosixProcess implements NuProcess
+   /**
+    * Runs the process synchronously.
+    *
+    * Pumping is done on the calling thread, and this method will not return until the process has exited.
+    *
+    * @since 1.3
+    */
+   public abstract void run(List<String> command, String[] environment, Path cwd);
+
diff --git a/src/main/java/com/zaxxer/nuprocess/linux/LinProcessFactory.java b/src/main/java/com/zaxxer/nuprocess/linux/LinProcessFactory.java
index 6d28620..7d67edb 100644
--- a/src/main/java/com/zaxxer/nuprocess/linux/LinProcessFactory.java
+++ b/src/main/java/com/zaxxer/nuprocess/linux/LinProcessFactory.java
@@ -43,0 +44,8 @@ public class LinProcessFactory implements NuProcessFactory
+
+   /** {@inheritDoc} */
+   @Override
+   public void runProcess(List<String> commands, String[] env, NuProcessHandler processListener, Path cwd)
+   {
+      LinuxProcess process = new LinuxProcess(processListener);
+      process.run(commands, env, cwd);
+   }
diff --git a/src/main/java/com/zaxxer/nuprocess/linux/LinuxProcess.java b/src/main/java/com/zaxxer/nuprocess/linux/LinuxProcess.java
index 279ac29..203e80a 100644
--- a/src/main/java/com/zaxxer/nuprocess/linux/LinuxProcess.java
+++ b/src/main/java/com/zaxxer/nuprocess/linux/LinuxProcess.java
@@ -23,0 +24 @@ import com.zaxxer.nuprocess.internal.BasePosixProcess;
+import com.zaxxer.nuprocess.internal.IEventProcessor;
@@ -64,20 +64,0 @@ public class LinuxProcess extends BasePosixProcess
-      String[] cmdarray = command.toArray(new String[0]);
-
-      // See https://github.com/JetBrains/jdk8u_jdk/blob/master/src/solaris/classes/java/lang/ProcessImpl.java#L71-L83
-      byte[][] args = new byte[cmdarray.length - 1][];
-      int size = args.length; // For added NUL bytes
-      for (int i = 0; i < args.length; i++) {
-         args[i] = cmdarray[i + 1].getBytes();
-         size += args[i].length;
-      }
-      byte[] argBlock = new byte[size];
-      int i = 0;
-      for (byte[] arg : args) {
-         System.arraycopy(arg, 0, argBlock, i, arg.length);
-         i += arg.length + 1;
-         // No need to write NUL bytes explicitly
-      }
-
-      // See https://github.com/JetBrains/jdk8u_jdk/blob/master/src/solaris/classes/java/lang/ProcessImpl.java#L86
-      byte[] envBlock = toEnvironmentBlock(environment);
-
@@ -85,32 +66 @@ public class LinuxProcess extends BasePosixProcess
-         // See https://github.com/JetBrains/jdk8u_jdk/blob/master/src/solaris/classes/java/lang/ProcessImpl.java#L96
-         createPipes();
-         int[] child_fds = {stdinWidow, stdoutWidow, stderrWidow};
-
-         if (JVM_MAJOR_VERSION >= 10) {
-            pid = com.zaxxer.nuprocess.internal.LibJava10.Java_java_lang_ProcessImpl_forkAndExec(
-                  JNIEnv.CURRENT,
-                  this,
-                  LaunchMechanism.VFORK.ordinal() + 1,
-                  toCString(System.getProperty("java.home") + "/lib/jspawnhelper"), // used on Linux
-                  toCString(cmdarray[0]),
-                  argBlock, args.length,
-                  envBlock, environment.length,
-                  (cwd != null ? toCString(cwd.toString()) : null),
-                  child_fds,
-                  (byte) 0 /*redirectErrorStream*/);
-         }
-         else {
-            // See https://github.com/JetBrains/jdk8u_jdk/blob/master/src/solaris/classes/java/lang/UNIXProcess.java#L247
-            // Native source code: https://github.com/JetBrains/jdk8u_jdk/blob/master/src/solaris/native/java/lang/UNIXProcess_md.c#L566
-            pid = com.zaxxer.nuprocess.internal.LibJava8.Java_java_lang_UNIXProcess_forkAndExec(
-                  JNIEnv.CURRENT,
-                  this,
-                  LaunchMechanism.VFORK.ordinal() + 1,
-                  toCString(System.getProperty("java.home") + "/lib/jspawnhelper"), // used on Linux
-                  toCString(cmdarray[0]),
-                  argBlock, args.length,
-                  envBlock, environment.length,
-                  (cwd != null ? toCString(cwd.toString()) : null),
-                  child_fds,
-                  (byte) 0 /*redirectErrorStream*/);
-         }
+         prepareProcess(command, environment, cwd);
@@ -122,4 +72 @@ public class LinuxProcess extends BasePosixProcess
-         // Close the child end of the pipes in our process
-         LibC.close(stdinWidow);
-         LibC.close(stdoutWidow);
-         LibC.close(stderrWidow);
+         closePipes();
@@ -144,0 +92,94 @@ public class LinuxProcess extends BasePosixProcess
+   @Override
+   public void run(List<String> command, String[] environment, Path cwd)
+   {
+      callPreStart();
+
+      try {
+         prepareProcess(command, environment, cwd);
+
+         if (pid == -1) {
+            return;
+         }
+
+         closePipes();
+
+         initializeBuffers();
+
+         afterStart();
+
+         myProcessor = (IEventProcessor) new ProcessEpoll(this);
+
+         callStart();
+
+         myProcessor.run();
+      }
+      catch (Exception e) {
+         LOGGER.log(Level.WARNING, "Failed to start process", e);
+         onExit(Integer.MIN_VALUE);
+      }
+   }
+
+   private void prepareProcess(List<String> command, String[] environment, Path cwd)
+   {
+      String[] cmdarray = command.toArray(new String[0]);
+
+      // See https://github.com/JetBrains/jdk8u_jdk/blob/master/src/solaris/classes/java/lang/ProcessImpl.java#L71-L83
+      byte[][] args = new byte[cmdarray.length - 1][];
+      int size = args.length; // For added NUL bytes
+      for (int i = 0; i < args.length; i++) {
+         args[i] = cmdarray[i + 1].getBytes();
+         size += args[i].length;
+      }
+      byte[] argBlock = new byte[size];
+      int i = 0;
+      for (byte[] arg : args) {
+         System.arraycopy(arg, 0, argBlock, i, arg.length);
+         i += arg.length + 1;
+         // No need to write NUL bytes explicitly
+      }
+
+      // See https://github.com/JetBrains/jdk8u_jdk/blob/master/src/solaris/classes/java/lang/ProcessImpl.java#L86
+      byte[] envBlock = toEnvironmentBlock(environment);
+
+      // See https://github.com/JetBrains/jdk8u_jdk/blob/master/src/solaris/classes/java/lang/ProcessImpl.java#L96
+      createPipes();
+      int[] child_fds = {stdinWidow, stdoutWidow, stderrWidow};
+
+      if (JVM_MAJOR_VERSION >= 10) {
+         pid = com.zaxxer.nuprocess.internal.LibJava10.Java_java_lang_ProcessImpl_forkAndExec(
+               JNIEnv.CURRENT,
+               this,
+               LaunchMechanism.VFORK.ordinal() + 1,
+               toCString(System.getProperty("java.home") + "/lib/jspawnhelper"), // used on Linux
+               toCString(cmdarray[0]),
+               argBlock, args.length,
+               envBlock, environment.length,
+               (cwd != null ? toCString(cwd.toString()) : null),
+               child_fds,
+               (byte) 0 /*redirectErrorStream*/);
+      }
+      else {
+         // See https://github.com/JetBrains/jdk8u_jdk/blob/master/src/solaris/classes/java/lang/UNIXProcess.java#L247
+         // Native source code: https://github.com/JetBrains/jdk8u_jdk/blob/master/src/solaris/native/java/lang/UNIXProcess_md.c#L566
+         pid = com.zaxxer.nuprocess.internal.LibJava8.Java_java_lang_UNIXProcess_forkAndExec(
+               JNIEnv.CURRENT,
+               this,
+               LaunchMechanism.VFORK.ordinal() + 1,
+               toCString(System.getProperty("java.home") + "/lib/jspawnhelper"), // used on Linux
+               toCString(cmdarray[0]),
+               argBlock, args.length,
+               envBlock, environment.length,
+               (cwd != null ? toCString(cwd.toString()) : null),
+               child_fds,
+               (byte) 0 /*redirectErrorStream*/);
+      }
+   }
+
+   private void closePipes()
+   {
+      // Close the child end of the pipes in our process
+      LibC.close(stdinWidow);
+      LibC.close(stdoutWidow);
+      LibC.close(stderrWidow);
+   }
+
diff --git a/src/main/java/com/zaxxer/nuprocess/linux/ProcessEpoll.java b/src/main/java/com/zaxxer/nuprocess/linux/ProcessEpoll.java
index 3c68c2a..2d38606 100644
--- a/src/main/java/com/zaxxer/nuprocess/linux/ProcessEpoll.java
+++ b/src/main/java/com/zaxxer/nuprocess/linux/ProcessEpoll.java
@@ -46,0 +47 @@ class ProcessEpoll extends BaseEventProcessor<LinuxProcess>
+   private LinuxProcess process;
@@ -58,0 +60,17 @@ class ProcessEpoll extends BaseEventProcessor<LinuxProcess>
+      this(LINGER_ITERATIONS);
+   }
+
+   ProcessEpoll(LinuxProcess process)
+   {
+      this(-1);
+
+      this.process = process;
+
+      registerProcess(process);
+      checkAndSetRunning();
+   }
+
+   private ProcessEpoll(int lingerIterations)
+   {
+      super(lingerIterations);
+
@@ -166,0 +185,12 @@ class ProcessEpoll extends BaseEventProcessor<LinuxProcess>
+   @Override
+   public void run()
+   {
+      super.run();
+
+      if (process != null) {
+         // For synchronous execution, wait until the deadpool is drained. This is necessary to ensure
+         // the handler's onExit is called before LinuxProcess.run returns.
+         waitForDeadPool();
+      }
+   }
+
@@ -262,0 +293,11 @@ class ProcessEpoll extends BaseEventProcessor<LinuxProcess>
+   /**
+    * Closes the {@code eventpoll} file descriptor.
+    *
+    * @since 1.3
+    */
+   @Override
+   protected void close()
+   {
+      LibC.close(epoll);
+   }
+
@@ -339,0 +381,42 @@ class ProcessEpoll extends BaseEventProcessor<LinuxProcess>
+
+   /**
+    * Loops until the {@link #deadPool} is empty, using a backoff sleep to progressively increase the poll
+    * interval the longer the process takes to terminate.
+    * <p>
+    * {@code waitpid} does not offer a timeout variant. Callers have two options:
+    * <ul>
+    *     <li>Use {@code WNOHANG} and have the call return immediately, whether the process has terminated
+    *     or not, and use the return code to tell the difference</li>
+    *     <li>Don't use {@code WNOHANG} and have the call block until the process terminates</li>
+    * </ul>
+    * To avoid the possibility of a misbehaving process hanging the JVM indefinitely, this loop uses a Java-
+    * based sleep to wait between checks. The sleep interval ramps up each time the loop runs. The ramp-up
+    * is intended to minimize the penalty imposed on well-behaved processes, which will generally only loop
+    * once or twice before terminating.
+    * <p>
+    * This loop will wait up to the {@link #LINGER_TIME_MS configured linger timeout} for the process to
+    * terminate. At that point, if the process still hasn't terminated, it is abandoned.
+    */
+   private void waitForDeadPool()
+   {
+      long sleepInterval = 0L;
+      long timeout = System.currentTimeMillis() + LINGER_TIME_MS;
+      while (true) {
+         checkDeadPool();
+         if (deadPool.isEmpty() || System.currentTimeMillis() > timeout) {
+            break;
+         }
+
+         if (sleepInterval > 0L) { // This gives 2 checks in a row before the first sleep
+            try {
+               Thread.sleep(sleepInterval);
+            }
+            catch (InterruptedException e) {
+               Thread.currentThread().interrupt();
+               break;
+            }
+         }
+         // 0 -> 1 -> 3 -> 7 -> 15 -> 31 -> 63 -> 127, etc
+         sleepInterval = (sleepInterval * 2L) + 1L;
+      }
+   }
diff --git a/src/main/java/com/zaxxer/nuprocess/osx/OsxProcess.java b/src/main/java/com/zaxxer/nuprocess/osx/OsxProcess.java
index 3430d43..46f48d7 100644
--- a/src/main/java/com/zaxxer/nuprocess/osx/OsxProcess.java
+++ b/src/main/java/com/zaxxer/nuprocess/osx/OsxProcess.java
@@ -26,0 +27 @@ import com.zaxxer.nuprocess.internal.BasePosixProcess;
+import com.zaxxer.nuprocess.internal.IEventProcessor;
@@ -62,18 +63 @@ class OsxProcess extends BasePosixProcess
-         int rc = LibC.posix_spawnattr_init(posix_spawnattr);
-         checkReturnCode(rc, "Internal call to posix_spawnattr_init() failed");
-
-         LibC.posix_spawnattr_setflags(posix_spawnattr, (short)(LibC.POSIX_SPAWN_START_SUSPENDED | LibC.POSIX_SPAWN_CLOEXEC_DEFAULT));
-
-         IntByReference restrict_pid = new IntByReference();
-         StringArray commandsArray = new StringArray(commands);
-         StringArray environmentArray = new StringArray(environment);
-         if (cwd != null) {
-            rc = spawnWithCwd(restrict_pid, commands[0], posix_spawn_file_actions, posix_spawnattr, commandsArray, environmentArray, cwd);
-         }
-         else {
-            rc = LibC.posix_spawnp(restrict_pid, commands[0], posix_spawn_file_actions, posix_spawnattr, commandsArray, environmentArray);
-         }
-
-         pid = restrict_pid.getValue();
-
-         initializeBuffers();
+         int rc = prepareProcess(environment, cwd, commands, posix_spawn_file_actions, posix_spawnattr);
@@ -106,3 +90 @@ class OsxProcess extends BasePosixProcess
-         LibC.close(stdinWidow);
-         LibC.close(stdoutWidow);
-         LibC.close(stderrWidow);
+         closePipes();
@@ -113,0 +96,75 @@ class OsxProcess extends BasePosixProcess
+    @Override
+   public void run(List<String> command, String[] environment, Path cwd)
+   {
+      callPreStart();
+
+      String[] commands = command.toArray(new String[0]);
+
+      Pointer posix_spawn_file_actions = createPosixPipes();
+      Pointer posix_spawnattr = createPosixSpawnAttributes();
+
+      try {
+         int rc = prepareProcess(environment, cwd, commands, posix_spawn_file_actions, posix_spawnattr);
+
+         if (!checkLaunch()) {
+            return;
+         }
+
+         checkReturnCode(rc, "Invocation of posix_spawn() failed");
+
+         afterStart();
+
+         myProcessor = (IEventProcessor) new ProcessKqueue(this);
+
+         callStart();
+
+         singleProcessContinue();
+
+         myProcessor.run();
+      }
+      catch (RuntimeException e) {
+         // TODO remove from event processor pid map?
+         LOGGER.log(Level.WARNING, "Exception thrown from handler", e);
+         onExit(Integer.MIN_VALUE);
+      }
+      finally {
+         LibC.posix_spawnattr_destroy(posix_spawnattr);
+         LibC.posix_spawn_file_actions_destroy(posix_spawn_file_actions);
+
+         // After we've spawned, close the unused ends of our pipes (that were dup'd into the child process space)
+         closePipes();
+      }
+   }
+
+   private int prepareProcess(String[] environment, Path cwd, String[] commands,
+                              Pointer posix_spawn_file_actions, Pointer posix_spawnattr)
+   {
+      int rc = LibC.posix_spawnattr_init(posix_spawnattr);
+      checkReturnCode(rc, "Internal call to posix_spawnattr_init() failed");
+
+      LibC.posix_spawnattr_setflags(posix_spawnattr, (short)(LibC.POSIX_SPAWN_START_SUSPENDED | LibC.POSIX_SPAWN_CLOEXEC_DEFAULT));
+
+      IntByReference restrict_pid = new IntByReference();
+      StringArray commandsArray = new StringArray(commands);
+      StringArray environmentArray = new StringArray(environment);
+      if (cwd != null) {
+         rc = spawnWithCwd(restrict_pid, commands[0], posix_spawn_file_actions, posix_spawnattr, commandsArray, environmentArray, cwd);
+      }
+      else {
+         rc = LibC.posix_spawnp(restrict_pid, commands[0], posix_spawn_file_actions, posix_spawnattr, commandsArray, environmentArray);
+      }
+
+      pid = restrict_pid.getValue();
+
+      initializeBuffers();
+
+      return rc;
+   }
+
+   private void closePipes()
+   {
+      LibC.close(stdinWidow);
+      LibC.close(stdoutWidow);
+      LibC.close(stderrWidow);
+   }
+
diff --git a/src/main/java/com/zaxxer/nuprocess/osx/OsxProcessFactory.java b/src/main/java/com/zaxxer/nuprocess/osx/OsxProcessFactory.java
index c7eec89..23cbc36 100644
--- a/src/main/java/com/zaxxer/nuprocess/osx/OsxProcessFactory.java
+++ b/src/main/java/com/zaxxer/nuprocess/osx/OsxProcessFactory.java
@@ -36,0 +37,8 @@ public class OsxProcessFactory implements NuProcessFactory
+
+   /** {@inheritDoc} */
+   @Override
+   public void runProcess(List<String> commands, String[] env, NuProcessHandler processListener, Path cwd)
+   {
+      OsxProcess process = new OsxProcess(processListener);
+      process.run(commands, env, cwd);
+   }
diff --git a/src/main/java/com/zaxxer/nuprocess/osx/ProcessKqueue.java b/src/main/java/com/zaxxer/nuprocess/osx/ProcessKqueue.java
index b524f56..210bf23 100644
--- a/src/main/java/com/zaxxer/nuprocess/osx/ProcessKqueue.java
+++ b/src/main/java/com/zaxxer/nuprocess/osx/ProcessKqueue.java
@@ -63 +63,15 @@ final class ProcessKqueue extends BaseEventProcessor<OsxProcess>
-      super(LINGER_ITERATIONS);
+      this(LINGER_ITERATIONS);
+   }
+
+   ProcessKqueue(OsxProcess process)
+   {
+      this(-1);
+
+      registerProcess(process);
+      checkAndSetRunning();
+   }
+
+   private ProcessKqueue(int lingerIterations)
+   {
+      super(lingerIterations);
+
@@ -228,0 +243,11 @@ final class ProcessKqueue extends BaseEventProcessor<OsxProcess>
+   /**
+    * Closes the {@code kqueue} file descriptor.
+    *
+    * @since 1.3
+    */
+   @Override
+   protected void close()
+   {
+      LibC.close(kqueue);
+   }
+
diff --git a/src/main/java/com/zaxxer/nuprocess/windows/ProcessCompletions.java b/src/main/java/com/zaxxer/nuprocess/windows/ProcessCompletions.java
index f80853d..94ec1d9 100644
--- a/src/main/java/com/zaxxer/nuprocess/windows/ProcessCompletions.java
+++ b/src/main/java/com/zaxxer/nuprocess/windows/ProcessCompletions.java
@@ -46,0 +47,2 @@ public final class ProcessCompletions implements Runnable
+   private final int lingerIterations;
+
@@ -71,0 +74,19 @@ public final class ProcessCompletions implements Runnable
+      this(LINGER_ITERATIONS);
+   }
+
+   ProcessCompletions(WindowsProcess process)
+   {
+      this(-1);
+
+      if (process == null) {
+         throw new IllegalArgumentException("process");
+      }
+
+      registerProcess(process);
+      checkAndSetRunning();
+   }
+
+   private ProcessCompletions(int lingerIterations)
+   {
+      this.lingerIterations = lingerIterations;
+
@@ -92 +113,4 @@ public final class ProcessCompletions implements Runnable
-         startBarrier.await();
+         // If the process is running synchronously, startBarrier will be null
+         if (startBarrier != null) {
+            startBarrier.await();
+         }
@@ -95 +119 @@ public final class ProcessCompletions implements Runnable
-         while (!isRunning.compareAndSet(idleCount > LINGER_ITERATIONS && deadPool.isEmpty() && completionKeyToProcessMap.isEmpty(), false)) {
+         while (!isRunning.compareAndSet(idleCount > lingerIterations && completionKeyToProcessMap.isEmpty() && deadPool.isEmpty() && pendingPool.isEmpty(), false)) {
@@ -103,0 +128,7 @@ public final class ProcessCompletions implements Runnable
+      finally {
+         if (startBarrier == null) {
+            // If the process is running synchronously, when the run loop ends the I/O completion
+            // port will never be reused so it needs to be closed to avoid leaking handles
+            NuKernel32.CloseHandle(ioCompletionPort);
+         }
+      }
diff --git a/src/main/java/com/zaxxer/nuprocess/windows/WinProcessFactory.java b/src/main/java/com/zaxxer/nuprocess/windows/WinProcessFactory.java
index 7032204..e4f654e 100644
--- a/src/main/java/com/zaxxer/nuprocess/windows/WinProcessFactory.java
+++ b/src/main/java/com/zaxxer/nuprocess/windows/WinProcessFactory.java
@@ -44,0 +45,8 @@ public class WinProcessFactory implements NuProcessFactory
+
+   /** {@inheritDoc} */
+   @Override
+   public void runProcess(List<String> commands, String[] env, NuProcessHandler processListener, Path cwd)
+   {
+      WindowsProcess process = new WindowsProcess(processListener);
+      process.run(commands, env, cwd);
+   }
diff --git a/src/main/java/com/zaxxer/nuprocess/windows/WindowsProcess.java b/src/main/java/com/zaxxer/nuprocess/windows/WindowsProcess.java
index fe6109c..89422a6 100644
--- a/src/main/java/com/zaxxer/nuprocess/windows/WindowsProcess.java
+++ b/src/main/java/com/zaxxer/nuprocess/windows/WindowsProcess.java
@@ -197 +197 @@ public final class WindowsProcess implements NuProcess
-   
+
@@ -228,25 +228 @@ public final class WindowsProcess implements NuProcess
-         createPipes();
-
-         char[] block = getEnvironment(environment);
-         Memory env = new Memory(block.length * 3);
-         env.write(0, block, 0, block.length);
-
-         STARTUPINFO startupInfo = new STARTUPINFO();
-         startupInfo.clear();
-         startupInfo.cb = new DWORD(startupInfo.size());
-         startupInfo.hStdInput = hStdinWidow;
-         startupInfo.hStdError = hStderrWidow;
-         startupInfo.hStdOutput = hStdoutWidow;
-         startupInfo.dwFlags = NuWinNT.STARTF_USESTDHANDLES;
-
-         processInfo = new PROCESS_INFORMATION();
-
-         DWORD dwCreationFlags = new DWORD(NuWinNT.CREATE_NO_WINDOW | NuWinNT.CREATE_UNICODE_ENVIRONMENT | NuWinNT.CREATE_SUSPENDED);
-         char[] cwdChars = (cwd != null) ? Native.toCharArray(cwd.toAbsolutePath().toString()) : null;
-         if (!NuKernel32.CreateProcessW(null, getCommandLine(commands), null /*lpProcessAttributes*/, null /*lpThreadAttributes*/, true /*bInheritHandles*/,
-                                        dwCreationFlags, env, cwdChars, startupInfo, processInfo)) {
-            int lastError = Native.getLastError();
-            throw new RuntimeException("CreateProcessW() failed, error: " + lastError);
-         }
-
-         afterStart();
+         prepareProcess(commands, environment, cwd);
@@ -272,0 +249,58 @@ public final class WindowsProcess implements NuProcess
+   void run(List<String> commands, String[] environment, Path cwd)
+   {
+      callPreStart();
+
+      try {
+         prepareProcess(commands, environment, cwd);
+
+         myProcessor = new ProcessCompletions(this);
+
+         callStart();
+
+         NuKernel32.ResumeThread(processInfo.hThread);
+      }
+      catch (Throwable e) {
+         e.printStackTrace();
+         onExit(Integer.MIN_VALUE);
+         return;
+      }
+      finally {
+         NuKernel32.CloseHandle(hStdinWidow);
+         NuKernel32.CloseHandle(hStdoutWidow);
+         NuKernel32.CloseHandle(hStderrWidow);
+      }
+
+      // This must happen after the widow handles are closed; otherwise the process loop will
+      // never end because stderr and stdout will never be detected as closed
+      myProcessor.run();
+   }
+
+   private void prepareProcess(List<String> commands, String[] environment, Path cwd)
+   {
+      createPipes();
+
+      char[] block = getEnvironment(environment);
+      Memory env = new Memory(block.length * 3);
+      env.write(0, block, 0, block.length);
+
+      STARTUPINFO startupInfo = new STARTUPINFO();
+      startupInfo.clear();
+      startupInfo.cb = new DWORD(startupInfo.size());
+      startupInfo.hStdInput = hStdinWidow;
+      startupInfo.hStdError = hStderrWidow;
+      startupInfo.hStdOutput = hStdoutWidow;
+      startupInfo.dwFlags = NuWinNT.STARTF_USESTDHANDLES;
+
+      processInfo = new PROCESS_INFORMATION();
+
+      DWORD dwCreationFlags = new DWORD(NuWinNT.CREATE_NO_WINDOW | NuWinNT.CREATE_UNICODE_ENVIRONMENT | NuWinNT.CREATE_SUSPENDED);
+      char[] cwdChars = (cwd != null) ? Native.toCharArray(cwd.toAbsolutePath().toString()) : null;
+      if (!NuKernel32.CreateProcessW(null, getCommandLine(commands), null /*lpProcessAttributes*/, null /*lpThreadAttributes*/, true /*bInheritHandles*/,
+              dwCreationFlags, env, cwdChars, startupInfo, processInfo)) {
+         int lastError = Native.getLastError();
+         throw new RuntimeException("CreateProcessW() failed, error: " + lastError);
+      }
+
+      afterStart();
+   }
+
diff --git a/src/test/java/com/zaxxer/nuprocess/CatTest.java b/src/test/java/com/zaxxer/nuprocess/CatTest.java
index e9c9e37..0dd6354 100644
--- a/src/test/java/com/zaxxer/nuprocess/CatTest.java
+++ b/src/test/java/com/zaxxer/nuprocess/CatTest.java
@@ -43,0 +44,2 @@ import com.zaxxer.nuprocess.codec.NuAbstractCharsetHandler;
+ * Performs <i>asynchronous</i> tests using {@link NuProcessBuilder#start}.
+ *
@@ -337,0 +340 @@ public class CatTest
+         exitCode = -1;
@@ -385 +388 @@ public class CatTest
-         return readAdler32.getValue() == writeAdler32.getValue();
+         return writes == WRITES && readAdler32.getValue() == writeAdler32.getValue();
@@ -387 +390 @@ public class CatTest
-   };
+   }
@@ -461 +464 @@ public class CatTest
-   };
+   }
diff --git a/src/test/java/com/zaxxer/nuprocess/RunTest.java b/src/test/java/com/zaxxer/nuprocess/RunTest.java
new file mode 100644
index 0000000..f9cdf32
--- /dev/null
+++ b/src/test/java/com/zaxxer/nuprocess/RunTest.java
@@ -0,0 +1,468 @@
+/*
+ * Copyright (C) 2019 Brett Wooldridge
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.zaxxer.nuprocess;
+
+import com.zaxxer.nuprocess.codec.NuAbstractCharsetHandler;
+import org.junit.*;
+import org.junit.rules.TemporaryFolder;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.CharBuffer;
+import java.nio.charset.CoderResult;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.zip.Adler32;
+
+/**
+ * Performs <i>synchronous</i> tests using {@link NuProcessBuilder#run}.
+ */
+public class RunTest
+{
+   private String command;
+
+   @Rule
+   public final TemporaryFolder tmp = new TemporaryFolder();
+
+   @Before
+   public void setup()
+   {
+      command = "cat";
+      if (System.getProperty("os.name").toLowerCase().contains("win")) {
+         command = "src\\test\\java\\com\\zaxxer\\nuprocess\\cat.exe";
+      }
+   }
+
+   @Test
+   public void lotOfProcesses() throws InterruptedException
+   {
+      int cpus = Runtime.getRuntime().availableProcessors();
+      Assume.assumeTrue("Skipping lotOfProcesses(); the system only has 1 CPU", cpus > 1);
+
+      // Use at least 2 threads, to ensure concurrency, but use no more than 4 threads to avoid
+      // producing excessive system load
+      final int threadCount = Math.max(2, Math.min(4, cpus / 2));
+      System.err.println("Starting test lotOfProcesses() with " + threadCount + " threads");
+
+      // Start threadCount threads, each running several synchronous processes in a row. This parallel
+      // execution is intended to verify synchronous pumping on concurrent threads doesn't produce any
+      // unexpected interactions "between" the threads
+      final Thread[] threads = new Thread[threadCount];
+      final AssertionError[] failures = new AssertionError[threadCount];
+      for (int i = 0; i < threadCount; i++) {
+         final int threadId = i + 1;
+         Thread thread = new Thread("RunTest-lotOfProcesses-" + threadId) {
+            @Override
+            public void run()
+            {
+               for (int times = 0; times < 20; times++) {
+                  System.err.printf("Thread %d: Iteration %d\n", threadId, times + 1);
+
+                  LottaProcessListener listener = new LottaProcessListener();
+                  NuProcessBuilder pb = new NuProcessBuilder(listener, command);
+                  pb.run();
+
+                  try {
+                     Assert.assertTrue("Adler32 mismatch between written and read", listener.checkAdlers());
+                     Assert.assertEquals("Exit code mismatch", 0, listener.getExitCode());
+                  } catch (AssertionError e) {
+                     failures[threadId - 1] = e;
+                     break;
+                  }
+               }
+            }
+         };
+         thread.setDaemon(true);
+         thread.start();
+
+         threads[i] = thread;
+      }
+
+      // After all the threads are started, wait for each to finish and then check to see whether it
+      // inserted an AssertionError into the failures array
+      int failed = 0;
+      for (int i = 0; i < threadCount; i++) {
+         threads[i].join();
+         if (failures[i] != null) {
+            System.err.printf("Thread %d failed: %s", threadCount + 1, failures[i].getMessage());
+            ++failed;
+         }
+      }
+
+      // If any threads failed, the test failed
+      if (failed > 0) {
+         Assert.fail(failed + " thread(s) failed");
+      }
+
+      System.err.println("Completed test lotOfProcesses()");
+   }
+
+   @Test
+   public void lotOfData()
+   {
+      System.err.println("Starting test lotOfData()");
+      for (int i = 0; i < 100; i++) {
+         LottaProcessListener processListener = new LottaProcessListener();
+         NuProcessBuilder pb = new NuProcessBuilder(processListener, command);
+         pb.run();
+
+         Assert.assertTrue("Adler32 mismatch between written and read", processListener.checkAdlers());
+      }
+
+      System.err.println("Completed test lotOfData()");
+   }
+
+   @Test
+   public void decodingShortUtf8Data()
+   {
+      String SHORT_UNICODE_TEXT = "Hello \uD83D\uDCA9 world";
+      System.err.println("Starting test decodingShortUtf8Data()");
+      Utf8DecodingListener processListener = new Utf8DecodingListener(SHORT_UNICODE_TEXT, true);
+      NuProcessBuilder pb = new NuProcessBuilder(processListener, command);
+      pb.run();
+      Assert.assertEquals("Decoding mismatch", SHORT_UNICODE_TEXT, processListener.decodedStdout.toString());
+      Assert.assertEquals("Exit code mismatch", 0, processListener.exitCode);
+      Assert.assertFalse("Decoder stdin should not overflow", processListener.stdinOverflow);
+      System.err.println("Completed test decodingShortUtf8Data()");
+   }
+
+   @Test
+   public void decodingLongUtf8Data()
+   {
+      // We use 3 bytes to make sure at least one UTF-8 boundary goes across two byte buffers.
+      String THREE_BYTE_UTF_8 = "\u2764";
+      StringBuilder unicodeTextWhichDoesNotFitInBuffer = new StringBuilder();
+      for (int i = 0; i < NuProcess.BUFFER_CAPACITY + 1; i++) {
+         unicodeTextWhichDoesNotFitInBuffer.append(THREE_BYTE_UTF_8);
+      }
+      System.err.println("Starting test decodingLongUtf8Data()");
+      Utf8DecodingListener processListener = new Utf8DecodingListener(unicodeTextWhichDoesNotFitInBuffer.toString(), true);
+      NuProcessBuilder pb = new NuProcessBuilder(processListener, command);
+      pb.run();
+      Assert.assertEquals("Decoding mismatch", unicodeTextWhichDoesNotFitInBuffer.toString(), processListener.decodedStdout.toString());
+      Assert.assertEquals("Exit code mismatch", 0, processListener.exitCode);
+      Assert.assertTrue("Decoder stdin should overflow", processListener.stdinOverflow);
+      System.err.println("Completed test decodingLongUtf8Data()");
+   }
+
+   @Test
+   public void badExit() throws InterruptedException
+   {
+      System.err.println("Starting test badExit()");
+
+      final AtomicInteger asyncExitCode = new AtomicInteger();
+      final CountDownLatch exitLatch = new CountDownLatch(1);
+
+      NuProcessHandler processListener = new NuAbstractProcessHandler() {
+         @Override
+         public void onExit(int statusCode)
+         {
+            asyncExitCode.set(statusCode);
+            exitLatch.countDown();
+         }
+      };
+
+      NuProcessBuilder pb = new NuProcessBuilder(processListener, command, "/tmp/sdfadsf");
+      NuProcess nuProcess = pb.start();
+      int syncExitCode = nuProcess.waitFor(5, TimeUnit.SECONDS);
+      boolean countedDown = exitLatch.await(5, TimeUnit.SECONDS);
+      Assert.assertTrue("Async exit latch was not triggered", countedDown);
+
+      int expectedExitCode = System.getProperty("os.name").toLowerCase().contains("win") ? -1 : 1;
+      Assert.assertEquals("Exit code (synchronous) did not match expectation", expectedExitCode, syncExitCode);
+      Assert.assertEquals("Exit code (asynchronous) did not match expectation", expectedExitCode, asyncExitCode.get());
+
+      System.err.println("Completed test badExit()");
+   }
+
+   @Test
+   public void noExecutableFound()
+   {
+      System.err.println("Starting test noExecutableFound()");
+
+      final Semaphore semaphore = new Semaphore(0);
+      final AtomicInteger exitCode = new AtomicInteger();
+
+      NuProcessHandler processListener = new NuAbstractProcessHandler() {
+         @Override
+         public void onExit(int statusCode)
+         {
+            exitCode.set(statusCode);
+            semaphore.release();
+         }
+      };
+
+      NuProcessBuilder pb = new NuProcessBuilder(processListener, "/bin/zxczxc");
+      NuProcess process = pb.start();
+      semaphore.acquireUninterruptibly();
+      Assert.assertFalse("Process incorrectly reported running", process.isRunning());
+      Assert.assertEquals("Output did not matched expected result", Integer.MIN_VALUE, exitCode.get());
+
+      System.err.println("Completed test noExecutableFound()");
+   }
+
+   @Test
+   public void callbackOrder() throws InterruptedException
+   {
+      final List<String> callbacks = new CopyOnWriteArrayList<>();
+      final CountDownLatch latch = new CountDownLatch(1);
+
+      NuProcessHandler handler = new NuProcessHandler() {
+         private NuProcess nuProcess;
+
+         @Override
+         public void onStdout(ByteBuffer buffer, boolean closed)
+         {
+            callbacks.add("stdout");
+            nuProcess.closeStdin(true);
+         }
+
+         @Override
+         public boolean onStdinReady(ByteBuffer buffer)
+         {
+            callbacks.add("stdin");
+            buffer.put("foobar".getBytes()).flip();
+            return false;
+         }
+
+         @Override
+         public void onStderr(ByteBuffer buffer, boolean closed)
+         {
+            callbacks.add("stderr");
+         }
+
+         @Override
+         public void onStart(NuProcess nuProcess)
+         {
+            callbacks.add("start");
+            this.nuProcess = nuProcess;
+            nuProcess.wantWrite();
+         }
+
+         @Override
+         public void onPreStart(NuProcess nuProcess)
+         {
+            callbacks.add("prestart");
+         }
+
+         @Override
+         public void onExit(int exitCode)
+         {
+            callbacks.add("exit");
+            latch.countDown();
+         }
+      };
+
+      Assert.assertNotNull("process is null", new NuProcessBuilder(handler, command).start());
+      latch.await();
+
+      Assert.assertEquals("onPreStart was not called first", 0, callbacks.indexOf("prestart"));
+      Assert.assertFalse("onExit was called before onStdout", callbacks.indexOf("exit") < callbacks.lastIndexOf("stdout"));
+   }
+
+   @Test
+   public void changeCwd() throws IOException
+   {
+      Path javaCwd = Paths.get(System.getProperty("user.dir"));
+      Path tmpPath = tmp.getRoot().toPath();
+      System.err.println("Starting test changeCwd() (java cwd=" + javaCwd + ", tmp=" + tmpPath + ")");
+      Assert.assertNotEquals("java cwd should not be tmp path before process", javaCwd.toRealPath(), tmpPath.toRealPath());
+      String message = "Hello cwd-aware world\n";
+      Files.write(tmpPath.resolve("foo.txt"), message.getBytes(StandardCharsets.UTF_8));
+      Utf8DecodingListener processListener = new Utf8DecodingListener("", true);
+      NuProcessBuilder pb = new NuProcessBuilder(processListener, command, "foo.txt");
+      pb.setCwd(tmpPath);
+      pb.run();
+      Assert.assertEquals("Output mismatch", message, processListener.decodedStdout.toString());
+      Assert.assertEquals("Exit code mismatch", 0, processListener.exitCode);
+      javaCwd = Paths.get(System.getProperty("user.dir"));
+      Assert.assertNotEquals("java cwd should not be tmp path after process", javaCwd.toRealPath(), tmpPath.toRealPath());
+      System.err.println("Completed test changeCwd()");
+   }
+
+   @Test
+   public void softCloseStdinAfterWrite()
+   {
+      String text = "Hello world!";
+      System.err.println("Starting test softCloseStdinAfterWrite()");
+      Utf8DecodingListener processListener = new Utf8DecodingListener(text, false);
+      NuProcessBuilder pb = new NuProcessBuilder(processListener, command);
+      pb.run();
+      Assert.assertEquals("Decoding mismatch", text, processListener.decodedStdout.toString());
+      Assert.assertEquals("Exit code mismatch", 0, processListener.exitCode);
+      Assert.assertFalse("Decoder stdin should not overflow", processListener.stdinOverflow);
+      System.err.println("Completed test softCloseStdinAfterWrite()");
+   }
+
+   private static byte[] getLotsOfBytes()
+   {
+      StringBuilder sb = new StringBuilder();
+      for (int i = 0; i < 6000; i++) {
+         sb.append("1234567890");
+      }
+
+      return sb.toString().getBytes();
+   }
+
+   private static class LottaProcessListener extends NuAbstractProcessHandler
+   {
+      private static final int WRITES = 10;
+      private NuProcess nuProcess;
+      private int writes;
+      private int size;
+      private int exitCode;
+
+      private Adler32 readAdler32;
+      private Adler32 writeAdler32;
+      private byte[] bytes;
+
+      LottaProcessListener()
+      {
+         this.readAdler32 = new Adler32();
+         this.writeAdler32 = new Adler32();
+
+         bytes = getLotsOfBytes();
+         exitCode = -1;
+      }
+
+      @Override
+      public void onStart(NuProcess nuProcess)
+      {
+         this.nuProcess = nuProcess;
+         nuProcess.wantWrite();
+      }
+
+      @Override
+      public void onExit(int statusCode)
+      {
+         exitCode = statusCode;
+      }
+
+      @Override
+      public void onStdout(ByteBuffer buffer, boolean closed)
+      {
+         size += buffer.remaining();
+         if (size == (WRITES * bytes.length)) {
+            nuProcess.closeStdin(true);
+         }
+
+         byte[] bytes = new byte[buffer.remaining()];
+         buffer.get(bytes);
+         readAdler32.update(bytes);
+      }
+
+      @Override
+      public boolean onStdinReady(ByteBuffer buffer)
+      {
+         writeAdler32.update(bytes);
+
+         buffer.put(bytes);
+         buffer.flip();
+
+         return (++writes < WRITES);
+      }
+
+      int getExitCode()
+      {
+         return exitCode;
+      }
+
+      boolean checkAdlers()
+      {
+         return writes == WRITES && readAdler32.getValue() == writeAdler32.getValue();
+      }
+   }
+
+   private static class Utf8DecodingListener extends NuAbstractCharsetHandler
+   {
+      private final CharBuffer utf8Buffer;
+      private final boolean forceCloseStdin;
+      private int charsWritten;
+      private int charsRead;
+      private NuProcess nuProcess;
+      StringBuilder decodedStdout;
+      boolean stdinOverflow;
+      int exitCode;
+
+      Utf8DecodingListener(String utf8Text, boolean forceCloseStdin)
+      {
+         super(StandardCharsets.UTF_8);
+         this.utf8Buffer = CharBuffer.wrap(utf8Text);
+         this.forceCloseStdin = forceCloseStdin;
+         this.charsWritten = 0;
+         this.charsRead = 0;
+         this.decodedStdout = new StringBuilder();
+         this.stdinOverflow = false;
+         this.exitCode = -1;
+      }
+
+      @Override
+      public void onStart(NuProcess nuProcess)
+      {
+         this.nuProcess = nuProcess;
+         nuProcess.wantWrite();
+      }
+
+      @Override
+      public void onExit(int statusCode)
+      {
+         exitCode = statusCode;
+      }
+
+      @Override
+      public void onStdoutChars(CharBuffer buffer, boolean closed, CoderResult coderResult)
+      {
+         charsRead += buffer.remaining();
+         decodedStdout.append(buffer);
+         buffer.position(buffer.limit());
+
+         if (forceCloseStdin && charsRead == charsWritten) {
+            nuProcess.closeStdin(true);
+         }
+      }
+
+      @Override
+      public boolean onStdinCharsReady(CharBuffer buffer)
+      {
+         if (utf8Buffer.remaining() <= buffer.remaining()) {
+            charsWritten += utf8Buffer.remaining();
+            buffer.put(utf8Buffer);
+            buffer.flip();
+            if (!forceCloseStdin) {
+               nuProcess.closeStdin(false);
+            }
+            return false;
+         }
+         else {
+            charsWritten += buffer.remaining();
+            buffer.put(utf8Buffer.subSequence(0, buffer.remaining()));
+            buffer.flip();
+            utf8Buffer.position(utf8Buffer.position() + buffer.remaining());
+            stdinOverflow = true;
+            return true;
+         }
+      }
+   }
+}
