package
com
.
zaxxer
.
nuprocess
.
linux
;
import
com
.
sun
.
jna
.
JNIEnv
;
import
com
.
zaxxer
.
nuprocess
.
NuProcess
;
import
com
.
zaxxer
.
nuprocess
.
NuProcessHandler
;
import
com
.
zaxxer
.
nuprocess
.
internal
.
BasePosixProcess
;
import
com
.
zaxxer
.
nuprocess
.
internal
.
IEventProcessor
;
import
com
.
zaxxer
.
nuprocess
.
internal
.
LibC
;
import
java
.
io
.
IOException
;
import
java
.
nio
.
file
.
Path
;
import
java
.
util
.
List
;
import
java
.
util
.
logging
.
Level
;
import
static
com
.
zaxxer
.
nuprocess
.
internal
.
Constants
.
JVM_MAJOR_VERSION
;
public
class
LinuxProcess
extends
BasePosixProcess
{
private
final
EpollEvent
epollEvent
;
static
{
LibEpoll
.
sigignore
(
LibEpoll
.
SIGPIPE
)
;
for
(
int
i
=
0
;
i
<
processors
.
length
;
i
++
)
{
processors
[
i
]
=
new
ProcessEpoll
(
)
;
}
}
@
SuppressWarnings
(
"unused"
)
private
enum
LaunchMechanism
{
FORK
,
POSIX_SPAWN
,
VFORK
}
LinuxProcess
(
NuProcessHandler
processListener
)
{
super
(
processListener
)
;
epollEvent
=
new
EpollEvent
(
)
;
}
@
Override
public
NuProcess
start
(
List
<
String
>
command
,
String
[
]
environment
,
Path
cwd
)
{
callPreStart
(
)
;
try
{
prepareProcess
(
command
,
environment
,
cwd
)
;
if
(
pid
==
-
1
)
{
return
null
;
}
initializeBuffers
(
)
;
afterStart
(
)
;
registerProcess
(
)
;
callStart
(
)
;
}
catch
(
Exception
e
)
{
LOGGER
.
log
(
Level
.
WARNING
,
"Failed to start process"
,
e
)
;
onExit
(
Integer
.
MIN_VALUE
)
;
return
null
;
}
return
this
;
}
@
Override
public
void
run
(
List
<
String
>
command
,
String
[
]
environment
,
Path
cwd
)
{
callPreStart
(
)
;
try
{
prepareProcess
(
command
,
environment
,
cwd
)
;
if
(
pid
==
-
1
)
{
return
;
}
initializeBuffers
(
)
;
afterStart
(
)
;
myProcessor
=
(
IEventProcessor
)
new
ProcessEpoll
(
this
)
;
callStart
(
)
;
myProcessor
.
run
(
)
;
}
catch
(
Exception
e
)
{
LOGGER
.
log
(
Level
.
WARNING
,
"Failed to start process"
,
e
)
;
onExit
(
Integer
.
MIN_VALUE
)
;
}
}
EpollEvent
getEpollEvent
(
)
{
return
epollEvent
;
}
private
void
prepareProcess
(
List
<
String
>
command
,
String
[
]
environment
,
Path
cwd
)
throws
IOException
{
String
[
]
cmdarray
=
command
.
toArray
(
new
String
[
0
]
)
;
byte
[
]
[
]
args
=
new
byte
[
cmdarray
.
length
-
1
]
[
]
;
int
size
=
args
.
length
;
for
(
int
i
=
0
;
i
<
args
.
length
;
i
++
)
{
args
[
i
]
=
cmdarray
[
i
+
1
]
.
getBytes
(
)
;
size
+=
args
[
i
]
.
length
;
}
byte
[
]
argBlock
=
new
byte
[
size
]
;
int
i
=
0
;
for
(
byte
[
]
arg
:
args
)
{
System
.
arraycopy
(
arg
,
0
,
argBlock
,
i
,
arg
.
length
)
;
i
+=
arg
.
length
+
1
;
}
byte
[
]
envBlock
=
toEnvironmentBlock
(
environment
)
;
createPipes
(
)
;
try
{
int
[
]
child_fds
=
{
stdinWidow
,
stdoutWidow
,
stderrWidow
}
;
if
(
JVM_MAJOR_VERSION
>=
10
)
{
pid
=
com
.
zaxxer
.
nuprocess
.
internal
.
LibJava10
.
Java_java_lang_ProcessImpl_forkAndExec
(
JNIEnv
.
CURRENT
,
this
,
LaunchMechanism
.
VFORK
.
ordinal
(
)
+
1
,
toCString
(
System
.
getProperty
(
"java.home"
)
+
"/lib/jspawnhelper"
)
,
toCString
(
cmdarray
[
0
]
)
,
argBlock
,
args
.
length
,
envBlock
,
environment
.
length
,
(
cwd
!=
null
?
toCString
(
cwd
.
toString
(
)
)
:
null
)
,
child_fds
,
(
byte
)
0
)
;
}
else
{
pid
=
com
.
zaxxer
.
nuprocess
.
internal
.
LibJava8
.
Java_java_lang_UNIXProcess_forkAndExec
(
JNIEnv
.
CURRENT
,
this
,
LaunchMechanism
.
VFORK
.
ordinal
(
)
+
1
,
toCString
(
System
.
getProperty
(
"java.home"
)
+
"/lib/jspawnhelper"
)
,
toCString
(
cmdarray
[
0
]
)
,
argBlock
,
args
.
length
,
envBlock
,
environment
.
length
,
(
cwd
!=
null
?
toCString
(
cwd
.
toString
(
)
)
:
null
)
,
child_fds
,
(
byte
)
0
)
;
}
}
finally
{
closePipes
(
)
;
}
}
private
void
closePipes
(
)
{
LibC
.
close
(
stdinWidow
)
;
LibC
.
close
(
stdoutWidow
)
;
LibC
.
close
(
stderrWidow
)
;
}
private
static
byte
[
]
toCString
(
String
s
)
{
if
(
s
==
null
)
return
null
;
byte
[
]
bytes
=
s
.
getBytes
(
)
;
byte
[
]
result
=
new
byte
[
bytes
.
length
+
1
]
;
System
.
arraycopy
(
bytes
,
0
,
result
,
0
,
bytes
.
length
)
;
result
[
result
.
length
-
1
]
=
(
byte
)
0
;
return
result
;
}
private
static
byte
[
]
toEnvironmentBlock
(
String
[
]
environment
)
{
int
count
=
environment
.
length
;
for
(
String
entry
:
environment
)
{
count
+=
entry
.
getBytes
(
)
.
length
;
}
byte
[
]
block
=
new
byte
[
count
]
;
int
i
=
0
;
for
(
String
entry
:
environment
)
{
byte
[
]
bytes
=
entry
.
getBytes
(
)
;
System
.
arraycopy
(
bytes
,
0
,
block
,
i
,
bytes
.
length
)
;
i
+=
bytes
.
length
+
1
;
}
return
block
;
}
}
<EOF>
