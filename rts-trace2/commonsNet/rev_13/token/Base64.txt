package
org
.
apache
.
commons
.
net
.
util
;
import
java
.
math
.
BigInteger
;
import
java
.
nio
.
charset
.
StandardCharsets
;
import
java
.
util
.
Objects
;
public
class
Base64
{
private
static
final
int
DEFAULT_BUFFER_RESIZE_FACTOR
=
2
;
private
static
final
int
DEFAULT_BUFFER_SIZE
=
8192
;
static
final
int
CHUNK_SIZE
=
76
;
private
static
final
byte
[
]
CHUNK_SEPARATOR
=
{
'\r'
,
'\n'
}
;
private
static
final
byte
[
]
STANDARD_ENCODE_TABLE
=
{
'A'
,
'B'
,
'C'
,
'D'
,
'E'
,
'F'
,
'G'
,
'H'
,
'I'
,
'J'
,
'K'
,
'L'
,
'M'
,
'N'
,
'O'
,
'P'
,
'Q'
,
'R'
,
'S'
,
'T'
,
'U'
,
'V'
,
'W'
,
'X'
,
'Y'
,
'Z'
,
'a'
,
'b'
,
'c'
,
'd'
,
'e'
,
'f'
,
'g'
,
'h'
,
'i'
,
'j'
,
'k'
,
'l'
,
'm'
,
'n'
,
'o'
,
'p'
,
'q'
,
'r'
,
's'
,
't'
,
'u'
,
'v'
,
'w'
,
'x'
,
'y'
,
'z'
,
'0'
,
'1'
,
'2'
,
'3'
,
'4'
,
'5'
,
'6'
,
'7'
,
'8'
,
'9'
,
'+'
,
'/'
}
;
private
static
final
byte
[
]
URL_SAFE_ENCODE_TABLE
=
{
'A'
,
'B'
,
'C'
,
'D'
,
'E'
,
'F'
,
'G'
,
'H'
,
'I'
,
'J'
,
'K'
,
'L'
,
'M'
,
'N'
,
'O'
,
'P'
,
'Q'
,
'R'
,
'S'
,
'T'
,
'U'
,
'V'
,
'W'
,
'X'
,
'Y'
,
'Z'
,
'a'
,
'b'
,
'c'
,
'd'
,
'e'
,
'f'
,
'g'
,
'h'
,
'i'
,
'j'
,
'k'
,
'l'
,
'm'
,
'n'
,
'o'
,
'p'
,
'q'
,
'r'
,
's'
,
't'
,
'u'
,
'v'
,
'w'
,
'x'
,
'y'
,
'z'
,
'0'
,
'1'
,
'2'
,
'3'
,
'4'
,
'5'
,
'6'
,
'7'
,
'8'
,
'9'
,
'-'
,
'_'
}
;
private
static
final
byte
PAD
=
'='
;
private
static
final
byte
[
]
DECODE_TABLE
=
{
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
62
,
-
1
,
62
,
-
1
,
63
,
52
,
53
,
54
,
55
,
56
,
57
,
58
,
59
,
60
,
61
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
-
1
,
0
,
1
,
2
,
3
,
4
,
5
,
6
,
7
,
8
,
9
,
10
,
11
,
12
,
13
,
14
,
15
,
16
,
17
,
18
,
19
,
20
,
21
,
22
,
23
,
24
,
25
,
-
1
,
-
1
,
-
1
,
-
1
,
63
,
-
1
,
26
,
27
,
28
,
29
,
30
,
31
,
32
,
33
,
34
,
35
,
36
,
37
,
38
,
39
,
40
,
41
,
42
,
43
,
44
,
45
,
46
,
47
,
48
,
49
,
50
,
51
}
;
private
static
final
int
MASK_6BITS
=
0x3f
;
private
static
final
int
MASK_8BITS
=
0xff
;
private
static
boolean
containsBase64Byte
(
final
byte
[
]
arrayOctet
)
{
for
(
final
byte
element
:
arrayOctet
)
{
if
(
isBase64
(
element
)
)
{
return
true
;
}
}
return
false
;
}
public
static
byte
[
]
decodeBase64
(
final
byte
[
]
base64Data
)
{
return
new
Base64
(
)
.
decode
(
base64Data
)
;
}
public
static
byte
[
]
decodeBase64
(
final
String
base64String
)
{
return
new
Base64
(
)
.
decode
(
base64String
)
;
}
public
static
BigInteger
decodeInteger
(
final
byte
[
]
pArray
)
{
return
new
BigInteger
(
1
,
decodeBase64
(
pArray
)
)
;
}
public
static
byte
[
]
encodeBase64
(
final
byte
[
]
binaryData
)
{
return
encodeBase64
(
binaryData
,
false
)
;
}
public
static
byte
[
]
encodeBase64
(
final
byte
[
]
binaryData
,
final
boolean
isChunked
)
{
return
encodeBase64
(
binaryData
,
isChunked
,
false
)
;
}
public
static
byte
[
]
encodeBase64
(
final
byte
[
]
binaryData
,
final
boolean
isChunked
,
final
boolean
urlSafe
)
{
return
encodeBase64
(
binaryData
,
isChunked
,
urlSafe
,
Integer
.
MAX_VALUE
)
;
}
public
static
byte
[
]
encodeBase64
(
final
byte
[
]
binaryData
,
final
boolean
isChunked
,
final
boolean
urlSafe
,
final
int
maxResultSize
)
{
if
(
binaryData
==
null
||
binaryData
.
length
==
0
)
{
return
binaryData
;
}
final
long
len
=
getEncodeLength
(
binaryData
,
isChunked
?
CHUNK_SIZE
:
0
,
isChunked
?
CHUNK_SEPARATOR
:
NetConstants
.
EMPTY_BTYE_ARRAY
)
;
if
(
len
>
maxResultSize
)
{
throw
new
IllegalArgumentException
(
"Input array too big, the output array would be bigger ("
+
len
+
") than the specified maxium size of "
+
maxResultSize
)
;
}
final
Base64
b64
=
isChunked
?
new
Base64
(
urlSafe
)
:
new
Base64
(
0
,
CHUNK_SEPARATOR
,
urlSafe
)
;
return
b64
.
encode
(
binaryData
)
;
}
public
static
byte
[
]
encodeBase64Chunked
(
final
byte
[
]
binaryData
)
{
return
encodeBase64
(
binaryData
,
true
)
;
}
public
static
String
encodeBase64String
(
final
byte
[
]
binaryData
)
{
return
newStringUtf8
(
encodeBase64
(
binaryData
,
true
)
)
;
}
public
static
String
encodeBase64String
(
final
byte
[
]
binaryData
,
final
boolean
useChunking
)
{
return
newStringUtf8
(
encodeBase64
(
binaryData
,
useChunking
)
)
;
}
public
static
String
encodeBase64StringUnChunked
(
final
byte
[
]
binaryData
)
{
return
newStringUtf8
(
encodeBase64
(
binaryData
,
false
)
)
;
}
public
static
byte
[
]
encodeBase64URLSafe
(
final
byte
[
]
binaryData
)
{
return
encodeBase64
(
binaryData
,
false
,
true
)
;
}
public
static
String
encodeBase64URLSafeString
(
final
byte
[
]
binaryData
)
{
return
newStringUtf8
(
encodeBase64
(
binaryData
,
false
,
true
)
)
;
}
public
static
byte
[
]
encodeInteger
(
final
BigInteger
bigInt
)
{
return
encodeBase64
(
toIntegerBytes
(
bigInt
)
,
false
)
;
}
private
static
long
getEncodeLength
(
final
byte
[
]
pArray
,
int
chunkSize
,
final
byte
[
]
chunkSeparator
)
{
chunkSize
=
(
chunkSize
/
4
)
*
4
;
long
len
=
(
pArray
.
length
*
4
)
/
3
;
final
long
mod
=
len
%
4
;
if
(
mod
!=
0
)
{
len
+=
4
-
mod
;
}
if
(
chunkSize
>
0
)
{
final
boolean
lenChunksPerfectly
=
len
%
chunkSize
==
0
;
len
+=
(
len
/
chunkSize
)
*
chunkSeparator
.
length
;
if
(
!
lenChunksPerfectly
)
{
len
+=
chunkSeparator
.
length
;
}
}
return
len
;
}
public
static
boolean
isArrayByteBase64
(
final
byte
[
]
arrayOctet
)
{
for
(
final
byte
element
:
arrayOctet
)
{
if
(
!
isBase64
(
element
)
&&
!
isWhiteSpace
(
element
)
)
{
return
false
;
}
}
return
true
;
}
public
static
boolean
isBase64
(
final
byte
octet
)
{
return
octet
==
PAD
||
(
octet
>=
0
&&
octet
<
DECODE_TABLE
.
length
&&
DECODE_TABLE
[
octet
]
!=
-
1
)
;
}
private
static
boolean
isWhiteSpace
(
final
byte
byteToCheck
)
{
switch
(
byteToCheck
)
{
case
' '
:
case
'\n'
:
case
'\r'
:
case
'\t'
:
return
true
;
default
:
return
false
;
}
}
private
static
String
newStringUtf8
(
final
byte
[
]
encode
)
{
return
new
String
(
encode
,
StandardCharsets
.
UTF_8
)
;
}
static
byte
[
]
toIntegerBytes
(
final
BigInteger
bigInt
)
{
Objects
.
requireNonNull
(
bigInt
,
"bigInt"
)
;
int
bitlen
=
bigInt
.
bitLength
(
)
;
bitlen
=
(
(
bitlen
+
7
)
>
>
3
)
<
<
3
;
final
byte
[
]
bigBytes
=
bigInt
.
toByteArray
(
)
;
if
(
(
(
bigInt
.
bitLength
(
)
%
8
)
!=
0
)
&&
(
(
(
bigInt
.
bitLength
(
)
/
8
)
+
1
)
==
(
bitlen
/
8
)
)
)
{
return
bigBytes
;
}
int
startSrc
=
0
;
int
len
=
bigBytes
.
length
;
if
(
(
bigInt
.
bitLength
(
)
%
8
)
==
0
)
{
startSrc
=
1
;
len
--
;
}
final
int
startDst
=
bitlen
/
8
-
len
;
final
byte
[
]
resizedBytes
=
new
byte
[
bitlen
/
8
]
;
System
.
arraycopy
(
bigBytes
,
startSrc
,
resizedBytes
,
startDst
,
len
)
;
return
resizedBytes
;
}
private
final
byte
[
]
encodeTable
;
private
final
int
lineLength
;
private
final
byte
[
]
lineSeparator
;
private
final
int
decodeSize
;
private
final
int
encodeSize
;
private
byte
[
]
buffer
;
private
int
pos
;
private
int
readPos
;
private
int
currentLinePos
;
private
int
modulus
;
private
boolean
eof
;
private
int
x
;
public
Base64
(
)
{
this
(
false
)
;
}
public
Base64
(
final
boolean
urlSafe
)
{
this
(
CHUNK_SIZE
,
CHUNK_SEPARATOR
,
urlSafe
)
;
}
public
Base64
(
final
int
lineLength
)
{
this
(
lineLength
,
CHUNK_SEPARATOR
)
;
}
public
Base64
(
final
int
lineLength
,
final
byte
[
]
lineSeparator
)
{
this
(
lineLength
,
lineSeparator
,
false
)
;
}
public
Base64
(
int
lineLength
,
byte
[
]
lineSeparator
,
final
boolean
urlSafe
)
{
if
(
lineSeparator
==
null
)
{
lineLength
=
0
;
lineSeparator
=
NetConstants
.
EMPTY_BTYE_ARRAY
;
}
this
.
lineLength
=
lineLength
>
0
?
(
lineLength
/
4
)
*
4
:
0
;
this
.
lineSeparator
=
new
byte
[
lineSeparator
.
length
]
;
System
.
arraycopy
(
lineSeparator
,
0
,
this
.
lineSeparator
,
0
,
lineSeparator
.
length
)
;
if
(
lineLength
>
0
)
{
this
.
encodeSize
=
4
+
lineSeparator
.
length
;
}
else
{
this
.
encodeSize
=
4
;
}
this
.
decodeSize
=
this
.
encodeSize
-
1
;
if
(
containsBase64Byte
(
lineSeparator
)
)
{
final
String
sep
=
newStringUtf8
(
lineSeparator
)
;
throw
new
IllegalArgumentException
(
"lineSeperator must not contain base64 characters: ["
+
sep
+
"]"
)
;
}
this
.
encodeTable
=
urlSafe
?
URL_SAFE_ENCODE_TABLE
:
STANDARD_ENCODE_TABLE
;
}
int
avail
(
)
{
return
buffer
!=
null
?
pos
-
readPos
:
0
;
}
public
byte
[
]
decode
(
final
byte
[
]
pArray
)
{
reset
(
)
;
if
(
pArray
==
null
||
pArray
.
length
==
0
)
{
return
pArray
;
}
final
long
len
=
(
pArray
.
length
*
3
)
/
4
;
final
byte
[
]
buf
=
new
byte
[
(
int
)
len
]
;
setInitialBuffer
(
buf
,
0
,
buf
.
length
)
;
decode
(
pArray
,
0
,
pArray
.
length
)
;
decode
(
pArray
,
0
,
-
1
)
;
final
byte
[
]
result
=
new
byte
[
pos
]
;
readResults
(
result
,
0
,
result
.
length
)
;
return
result
;
}
void
decode
(
final
byte
[
]
in
,
int
inPos
,
final
int
inAvail
)
{
if
(
eof
)
{
return
;
}
if
(
inAvail
<
0
)
{
eof
=
true
;
}
for
(
int
i
=
0
;
i
<
inAvail
;
i
++
)
{
if
(
buffer
==
null
||
buffer
.
length
-
pos
<
decodeSize
)
{
resizeBuffer
(
)
;
}
final
byte
b
=
in
[
inPos
++
]
;
if
(
b
==
PAD
)
{
eof
=
true
;
break
;
}
if
(
b
>=
0
&&
b
<
DECODE_TABLE
.
length
)
{
final
int
result
=
DECODE_TABLE
[
b
]
;
if
(
result
>=
0
)
{
modulus
=
(
++
modulus
)
%
4
;
x
=
(
x
<
<
6
)
+
result
;
if
(
modulus
==
0
)
{
buffer
[
pos
++
]
=
(
byte
)
(
(
x
>
>
16
)
&
MASK_8BITS
)
;
buffer
[
pos
++
]
=
(
byte
)
(
(
x
>
>
8
)
&
MASK_8BITS
)
;
buffer
[
pos
++
]
=
(
byte
)
(
x
&
MASK_8BITS
)
;
}
}
}
}
if
(
eof
&&
modulus
!=
0
)
{
x
=
x
<
<
6
;
switch
(
modulus
)
{
case
2
:
x
=
x
<
<
6
;
buffer
[
pos
++
]
=
(
byte
)
(
(
x
>
>
16
)
&
MASK_8BITS
)
;
break
;
case
3
:
buffer
[
pos
++
]
=
(
byte
)
(
(
x
>
>
16
)
&
MASK_8BITS
)
;
buffer
[
pos
++
]
=
(
byte
)
(
(
x
>
>
8
)
&
MASK_8BITS
)
;
break
;
default
:
break
;
}
}
}
public
byte
[
]
decode
(
final
String
pArray
)
{
return
decode
(
getBytesUtf8
(
pArray
)
)
;
}
public
byte
[
]
encode
(
final
byte
[
]
pArray
)
{
reset
(
)
;
if
(
pArray
==
null
||
pArray
.
length
==
0
)
{
return
pArray
;
}
final
long
len
=
getEncodeLength
(
pArray
,
lineLength
,
lineSeparator
)
;
byte
[
]
buf
=
new
byte
[
(
int
)
len
]
;
setInitialBuffer
(
buf
,
0
,
buf
.
length
)
;
encode
(
pArray
,
0
,
pArray
.
length
)
;
encode
(
pArray
,
0
,
-
1
)
;
if
(
buffer
!=
buf
)
{
readResults
(
buf
,
0
,
buf
.
length
)
;
}
if
(
isUrlSafe
(
)
&&
pos
<
buf
.
length
)
{
final
byte
[
]
smallerBuf
=
new
byte
[
pos
]
;
System
.
arraycopy
(
buf
,
0
,
smallerBuf
,
0
,
pos
)
;
buf
=
smallerBuf
;
}
return
buf
;
}
void
encode
(
final
byte
[
]
in
,
int
inPos
,
final
int
inAvail
)
{
if
(
eof
)
{
return
;
}
if
(
inAvail
<
0
)
{
eof
=
true
;
if
(
buffer
==
null
||
buffer
.
length
-
pos
<
encodeSize
)
{
resizeBuffer
(
)
;
}
switch
(
modulus
)
{
case
1
:
buffer
[
pos
++
]
=
encodeTable
[
(
x
>
>
2
)
&
MASK_6BITS
]
;
buffer
[
pos
++
]
=
encodeTable
[
(
x
<
<
4
)
&
MASK_6BITS
]
;
if
(
encodeTable
==
STANDARD_ENCODE_TABLE
)
{
buffer
[
pos
++
]
=
PAD
;
buffer
[
pos
++
]
=
PAD
;
}
break
;
case
2
:
buffer
[
pos
++
]
=
encodeTable
[
(
x
>
>
10
)
&
MASK_6BITS
]
;
buffer
[
pos
++
]
=
encodeTable
[
(
x
>
>
4
)
&
MASK_6BITS
]
;
buffer
[
pos
++
]
=
encodeTable
[
(
x
<
<
2
)
&
MASK_6BITS
]
;
if
(
encodeTable
==
STANDARD_ENCODE_TABLE
)
{
buffer
[
pos
++
]
=
PAD
;
}
break
;
default
:
break
;
}
if
(
lineLength
>
0
&&
pos
>
0
)
{
System
.
arraycopy
(
lineSeparator
,
0
,
buffer
,
pos
,
lineSeparator
.
length
)
;
pos
+=
lineSeparator
.
length
;
}
}
else
{
for
(
int
i
=
0
;
i
<
inAvail
;
i
++
)
{
if
(
buffer
==
null
||
buffer
.
length
-
pos
<
encodeSize
)
{
resizeBuffer
(
)
;
}
modulus
=
(
++
modulus
)
%
3
;
int
b
=
in
[
inPos
++
]
;
if
(
b
<
0
)
{
b
+=
256
;
}
x
=
(
x
<
<
8
)
+
b
;
if
(
0
==
modulus
)
{
buffer
[
pos
++
]
=
encodeTable
[
(
x
>
>
18
)
&
MASK_6BITS
]
;
buffer
[
pos
++
]
=
encodeTable
[
(
x
>
>
12
)
&
MASK_6BITS
]
;
buffer
[
pos
++
]
=
encodeTable
[
(
x
>
>
6
)
&
MASK_6BITS
]
;
buffer
[
pos
++
]
=
encodeTable
[
x
&
MASK_6BITS
]
;
currentLinePos
+=
4
;
if
(
lineLength
>
0
&&
lineLength
<=
currentLinePos
)
{
System
.
arraycopy
(
lineSeparator
,
0
,
buffer
,
pos
,
lineSeparator
.
length
)
;
pos
+=
lineSeparator
.
length
;
currentLinePos
=
0
;
}
}
}
}
}
public
String
encodeToString
(
final
byte
[
]
pArray
)
{
return
newStringUtf8
(
encode
(
pArray
)
)
;
}
private
byte
[
]
getBytesUtf8
(
final
String
pArray
)
{
return
pArray
.
getBytes
(
StandardCharsets
.
UTF_8
)
;
}
int
getLineLength
(
)
{
return
lineLength
;
}
byte
[
]
getLineSeparator
(
)
{
return
lineSeparator
.
clone
(
)
;
}
boolean
hasData
(
)
{
return
this
.
buffer
!=
null
;
}
public
boolean
isUrlSafe
(
)
{
return
this
.
encodeTable
==
URL_SAFE_ENCODE_TABLE
;
}
int
readResults
(
final
byte
[
]
b
,
final
int
bPos
,
final
int
bAvail
)
{
if
(
buffer
!=
null
)
{
final
int
len
=
Math
.
min
(
avail
(
)
,
bAvail
)
;
if
(
buffer
!=
b
)
{
System
.
arraycopy
(
buffer
,
readPos
,
b
,
bPos
,
len
)
;
readPos
+=
len
;
if
(
readPos
>=
pos
)
{
buffer
=
null
;
}
}
else
{
buffer
=
null
;
}
return
len
;
}
return
eof
?
-
1
:
0
;
}
private
void
reset
(
)
{
buffer
=
null
;
pos
=
0
;
readPos
=
0
;
currentLinePos
=
0
;
modulus
=
0
;
eof
=
false
;
}
private
void
resizeBuffer
(
)
{
if
(
buffer
==
null
)
{
buffer
=
new
byte
[
DEFAULT_BUFFER_SIZE
]
;
pos
=
0
;
readPos
=
0
;
}
else
{
final
byte
[
]
b
=
new
byte
[
buffer
.
length
*
DEFAULT_BUFFER_RESIZE_FACTOR
]
;
System
.
arraycopy
(
buffer
,
0
,
b
,
0
,
buffer
.
length
)
;
buffer
=
b
;
}
}
void
setInitialBuffer
(
final
byte
[
]
out
,
final
int
outPos
,
final
int
outAvail
)
{
if
(
out
!=
null
&&
out
.
length
==
outAvail
)
{
buffer
=
out
;
pos
=
outPos
;
readPos
=
outPos
;
}
}
}
<EOF>
