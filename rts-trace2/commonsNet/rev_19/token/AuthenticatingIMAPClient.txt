package
org
.
apache
.
commons
.
net
.
imap
;
import
java
.
io
.
IOException
;
import
java
.
security
.
InvalidKeyException
;
import
java
.
security
.
NoSuchAlgorithmException
;
import
java
.
security
.
spec
.
InvalidKeySpecException
;
import
javax
.
crypto
.
Mac
;
import
javax
.
crypto
.
spec
.
SecretKeySpec
;
import
javax
.
net
.
ssl
.
SSLContext
;
import
org
.
apache
.
commons
.
net
.
util
.
Base64
;
public
class
AuthenticatingIMAPClient
extends
IMAPSClient
{
public
enum
AUTH_METHOD
{
PLAIN
(
"PLAIN"
)
,
CRAM_MD5
(
"CRAM-MD5"
)
,
LOGIN
(
"LOGIN"
)
,
XOAUTH
(
"XOAUTH"
)
,
XOAUTH2
(
"XOAUTH2"
)
;
private
final
String
authName
;
AUTH_METHOD
(
final
String
name
)
{
this
.
authName
=
name
;
}
public
final
String
getAuthName
(
)
{
return
authName
;
}
}
public
AuthenticatingIMAPClient
(
)
{
this
(
DEFAULT_PROTOCOL
,
false
)
;
}
public
AuthenticatingIMAPClient
(
final
boolean
implicit
)
{
this
(
DEFAULT_PROTOCOL
,
implicit
)
;
}
public
AuthenticatingIMAPClient
(
final
boolean
implicit
,
final
SSLContext
ctx
)
{
this
(
DEFAULT_PROTOCOL
,
implicit
,
ctx
)
;
}
public
AuthenticatingIMAPClient
(
final
SSLContext
context
)
{
this
(
false
,
context
)
;
}
public
AuthenticatingIMAPClient
(
final
String
proto
)
{
this
(
proto
,
false
)
;
}
public
AuthenticatingIMAPClient
(
final
String
proto
,
final
boolean
implicit
)
{
this
(
proto
,
implicit
,
null
)
;
}
public
AuthenticatingIMAPClient
(
final
String
proto
,
final
boolean
implicit
,
final
SSLContext
ctx
)
{
super
(
proto
,
implicit
,
ctx
)
;
}
public
boolean
auth
(
final
AuthenticatingIMAPClient
.
AUTH_METHOD
method
,
final
String
username
,
final
String
password
)
throws
IOException
,
NoSuchAlgorithmException
,
InvalidKeyException
,
InvalidKeySpecException
{
if
(
!
IMAPReply
.
isContinuation
(
sendCommand
(
IMAPCommand
.
AUTHENTICATE
,
method
.
getAuthName
(
)
)
)
)
{
return
false
;
}
switch
(
method
)
{
case
PLAIN
:
{
final
int
result
=
sendData
(
Base64
.
encodeBase64StringUnChunked
(
(
"\000"
+
username
+
"\000"
+
password
)
.
getBytes
(
getCharset
(
)
)
)
)
;
if
(
result
==
IMAPReply
.
OK
)
{
setState
(
IMAP
.
IMAPState
.
AUTH_STATE
)
;
}
return
result
==
IMAPReply
.
OK
;
}
case
CRAM_MD5
:
{
final
byte
[
]
serverChallenge
=
Base64
.
decodeBase64
(
getReplyString
(
)
.
substring
(
2
)
.
trim
(
)
)
;
final
Mac
hmac_md5
=
Mac
.
getInstance
(
"HmacMD5"
)
;
hmac_md5
.
init
(
new
SecretKeySpec
(
password
.
getBytes
(
getCharset
(
)
)
,
"HmacMD5"
)
)
;
final
byte
[
]
hmacResult
=
convertToHexString
(
hmac_md5
.
doFinal
(
serverChallenge
)
)
.
getBytes
(
getCharset
(
)
)
;
final
byte
[
]
usernameBytes
=
username
.
getBytes
(
getCharset
(
)
)
;
final
byte
[
]
toEncode
=
new
byte
[
usernameBytes
.
length
+
1
+
hmacResult
.
length
]
;
System
.
arraycopy
(
usernameBytes
,
0
,
toEncode
,
0
,
usernameBytes
.
length
)
;
toEncode
[
usernameBytes
.
length
]
=
' '
;
System
.
arraycopy
(
hmacResult
,
0
,
toEncode
,
usernameBytes
.
length
+
1
,
hmacResult
.
length
)
;
final
int
result
=
sendData
(
Base64
.
encodeBase64StringUnChunked
(
toEncode
)
)
;
if
(
result
==
IMAPReply
.
OK
)
{
setState
(
IMAP
.
IMAPState
.
AUTH_STATE
)
;
}
return
result
==
IMAPReply
.
OK
;
}
case
LOGIN
:
{
if
(
sendData
(
Base64
.
encodeBase64StringUnChunked
(
username
.
getBytes
(
getCharset
(
)
)
)
)
!=
IMAPReply
.
CONT
)
{
return
false
;
}
final
int
result
=
sendData
(
Base64
.
encodeBase64StringUnChunked
(
password
.
getBytes
(
getCharset
(
)
)
)
)
;
if
(
result
==
IMAPReply
.
OK
)
{
setState
(
IMAP
.
IMAPState
.
AUTH_STATE
)
;
}
return
result
==
IMAPReply
.
OK
;
}
case
XOAUTH
:
case
XOAUTH2
:
{
final
int
result
=
sendData
(
username
)
;
if
(
result
==
IMAPReply
.
OK
)
{
setState
(
IMAP
.
IMAPState
.
AUTH_STATE
)
;
}
return
result
==
IMAPReply
.
OK
;
}
}
return
false
;
}
public
boolean
authenticate
(
final
AuthenticatingIMAPClient
.
AUTH_METHOD
method
,
final
String
username
,
final
String
password
)
throws
IOException
,
NoSuchAlgorithmException
,
InvalidKeyException
,
InvalidKeySpecException
{
return
auth
(
method
,
username
,
password
)
;
}
private
String
convertToHexString
(
final
byte
[
]
a
)
{
final
StringBuilder
result
=
new
StringBuilder
(
a
.
length
*
2
)
;
for
(
final
byte
element
:
a
)
{
if
(
(
element
&
0x0FF
)
<=
15
)
{
result
.
append
(
"0"
)
;
}
result
.
append
(
Integer
.
toHexString
(
element
&
0x0FF
)
)
;
}
return
result
.
toString
(
)
;
}
}
<EOF>
