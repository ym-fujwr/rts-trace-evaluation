package
org
.
apache
.
commons
.
net
.
telnet
;
import
java
.
io
.
BufferedInputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
OutputStream
;
public
class
TelnetClient
extends
Telnet
{
private
static
final
int
DEFAULT_MAX_SUBNEGOTIATION_LENGTH
=
512
;
final
int
maxSubnegotiationLength
;
private
InputStream
input
;
private
OutputStream
output
;
protected
boolean
readerThread
=
true
;
private
TelnetInputListener
inputListener
;
public
TelnetClient
(
)
{
this
(
"VT100"
,
DEFAULT_MAX_SUBNEGOTIATION_LENGTH
)
;
}
public
TelnetClient
(
final
int
maxSubnegotiationLength
)
{
this
(
"VT100"
,
maxSubnegotiationLength
)
;
}
public
TelnetClient
(
final
String
termtype
)
{
this
(
termtype
,
DEFAULT_MAX_SUBNEGOTIATION_LENGTH
)
;
}
public
TelnetClient
(
final
String
termtype
,
final
int
maxSubnegotiationLength
)
{
super
(
termtype
)
;
this
.
input
=
null
;
this
.
output
=
null
;
this
.
maxSubnegotiationLength
=
maxSubnegotiationLength
;
}
@
Override
protected
void
_connectAction_
(
)
throws
IOException
{
super
.
_connectAction_
(
)
;
final
TelnetInputStream
tmp
=
new
TelnetInputStream
(
_input_
,
this
,
readerThread
)
;
if
(
readerThread
)
{
tmp
.
start
(
)
;
}
input
=
new
BufferedInputStream
(
tmp
)
;
output
=
new
TelnetOutputStream
(
this
)
;
}
@
Override
public
void
addOptionHandler
(
final
TelnetOptionHandler
opthand
)
throws
InvalidTelnetOptionException
,
IOException
{
super
.
addOptionHandler
(
opthand
)
;
}
void
closeOutputStream
(
)
throws
IOException
{
if
(
_output_
==
null
)
{
return
;
}
try
{
_output_
.
close
(
)
;
}
finally
{
_output_
=
null
;
}
}
@
Override
public
void
deleteOptionHandler
(
final
int
optcode
)
throws
InvalidTelnetOptionException
,
IOException
{
super
.
deleteOptionHandler
(
optcode
)
;
}
@
Override
public
void
disconnect
(
)
throws
IOException
{
try
{
if
(
input
!=
null
)
{
input
.
close
(
)
;
}
if
(
output
!=
null
)
{
output
.
close
(
)
;
}
}
finally
{
output
=
null
;
input
=
null
;
super
.
disconnect
(
)
;
}
}
void
flushOutputStream
(
)
throws
IOException
{
if
(
_output_
==
null
)
{
throw
new
IOException
(
"Stream closed"
)
;
}
_output_
.
flush
(
)
;
}
public
InputStream
getInputStream
(
)
{
return
input
;
}
public
boolean
getLocalOptionState
(
final
int
option
)
{
return
stateIsWill
(
option
)
&&
requestedWill
(
option
)
;
}
public
OutputStream
getOutputStream
(
)
{
return
output
;
}
public
boolean
getReaderThread
(
)
{
return
readerThread
;
}
public
boolean
getRemoteOptionState
(
final
int
option
)
{
return
stateIsDo
(
option
)
&&
requestedDo
(
option
)
;
}
void
notifyInputListener
(
)
{
final
TelnetInputListener
listener
;
synchronized
(
this
)
{
listener
=
this
.
inputListener
;
}
if
(
listener
!=
null
)
{
listener
.
telnetInputAvailable
(
)
;
}
}
public
synchronized
void
registerInputListener
(
final
TelnetInputListener
listener
)
{
this
.
inputListener
=
listener
;
}
@
Override
public
void
registerNotifHandler
(
final
TelnetNotificationHandler
notifhand
)
{
super
.
registerNotifHandler
(
notifhand
)
;
}
public
void
registerSpyStream
(
final
OutputStream
spystream
)
{
super
.
_registerSpyStream
(
spystream
)
;
}
public
boolean
sendAYT
(
final
long
timeout
)
throws
IOException
,
IllegalArgumentException
,
InterruptedException
{
return
_sendAYT
(
timeout
)
;
}
public
void
sendCommand
(
final
byte
command
)
throws
IOException
,
IllegalArgumentException
{
_sendCommand
(
command
)
;
}
public
void
sendSubnegotiation
(
final
int
[
]
message
)
throws
IOException
,
IllegalArgumentException
{
if
(
message
.
length
<
1
)
{
throw
new
IllegalArgumentException
(
"zero length message"
)
;
}
_sendSubnegotiation
(
message
)
;
}
public
void
setReaderThread
(
final
boolean
flag
)
{
readerThread
=
flag
;
}
public
void
stopSpyStream
(
)
{
super
.
_stopSpyStream
(
)
;
}
public
synchronized
void
unregisterInputListener
(
)
{
this
.
inputListener
=
null
;
}
@
Override
public
void
unregisterNotifHandler
(
)
{
super
.
unregisterNotifHandler
(
)
;
}
}
<EOF>
