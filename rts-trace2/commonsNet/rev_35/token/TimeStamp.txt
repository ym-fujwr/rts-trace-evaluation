package
org
.
apache
.
commons
.
net
.
ntp
;
import
java
.
io
.
IOException
;
import
java
.
io
.
Serializable
;
import
java
.
text
.
DateFormat
;
import
java
.
text
.
SimpleDateFormat
;
import
java
.
util
.
Date
;
import
java
.
util
.
Locale
;
import
java
.
util
.
TimeZone
;
public
class
TimeStamp
implements
Serializable
,
Comparable
<
TimeStamp
>
{
private
static
final
long
serialVersionUID
=
8139806907588338737L
;
protected
static
final
long
msb0baseTime
=
2085978496000L
;
protected
static
final
long
msb1baseTime
=
-
2208988800000L
;
public
static
final
String
NTP_DATE_FORMAT
=
"EEE, MMM dd yyyy HH:mm:ss.SSS"
;
private
static
void
appendHexString
(
final
StringBuilder
buf
,
final
long
l
)
{
final
String
s
=
Long
.
toHexString
(
l
)
;
for
(
int
i
=
s
.
length
(
)
;
i
<
8
;
i
++
)
{
buf
.
append
(
'0'
)
;
}
buf
.
append
(
s
)
;
}
protected
static
long
decodeNtpHexString
(
final
String
hexString
)
throws
NumberFormatException
{
if
(
hexString
==
null
)
{
throw
new
NumberFormatException
(
"null"
)
;
}
final
int
ind
=
hexString
.
indexOf
(
'.'
)
;
if
(
ind
==
-
1
)
{
if
(
hexString
.
isEmpty
(
)
)
{
return
0
;
}
return
Long
.
parseLong
(
hexString
,
16
)
<
<
32
;
}
return
Long
.
parseLong
(
hexString
.
substring
(
0
,
ind
)
,
16
)
<
<
32
|
Long
.
parseLong
(
hexString
.
substring
(
ind
+
1
)
,
16
)
;
}
public
static
TimeStamp
getCurrentTime
(
)
{
return
getNtpTime
(
System
.
currentTimeMillis
(
)
)
;
}
public
static
TimeStamp
getNtpTime
(
final
long
dateMillis
)
{
return
new
TimeStamp
(
toNtpTime
(
dateMillis
)
)
;
}
public
static
long
getTime
(
final
long
ntpTimeValue
)
{
final
long
seconds
=
(
ntpTimeValue
>
>
>
32
)
&
0xffffffffL
;
long
fraction
=
ntpTimeValue
&
0xffffffffL
;
fraction
=
Math
.
round
(
1000D
*
fraction
/
0x100000000L
)
;
final
long
msb
=
seconds
&
0x80000000L
;
if
(
msb
==
0
)
{
return
msb0baseTime
+
(
seconds
*
1000
)
+
fraction
;
}
return
msb1baseTime
+
(
seconds
*
1000
)
+
fraction
;
}
public
static
TimeStamp
parseNtpString
(
final
String
s
)
throws
NumberFormatException
{
return
new
TimeStamp
(
decodeNtpHexString
(
s
)
)
;
}
protected
static
long
toNtpTime
(
final
long
millis
)
{
final
boolean
useBase1
=
millis
<
msb0baseTime
;
final
long
baseTimeMillis
;
if
(
useBase1
)
{
baseTimeMillis
=
millis
-
msb1baseTime
;
}
else
{
baseTimeMillis
=
millis
-
msb0baseTime
;
}
long
seconds
=
baseTimeMillis
/
1000
;
final
long
fraction
=
(
(
baseTimeMillis
%
1000
)
*
0x100000000L
)
/
1000
;
if
(
useBase1
)
{
seconds
|=
0x80000000L
;
}
return
seconds
<
<
32
|
fraction
;
}
public
static
String
toString
(
final
long
ntpTime
)
{
final
StringBuilder
buf
=
new
StringBuilder
(
)
;
appendHexString
(
buf
,
(
ntpTime
>
>
>
32
)
&
0xffffffffL
)
;
buf
.
append
(
'.'
)
;
appendHexString
(
buf
,
ntpTime
&
0xffffffffL
)
;
return
buf
.
toString
(
)
;
}
private
final
long
ntpTime
;
private
DateFormat
simpleFormatter
;
private
DateFormat
utcFormatter
;
public
TimeStamp
(
final
Date
d
)
{
ntpTime
=
d
==
null
?
0
:
toNtpTime
(
d
.
getTime
(
)
)
;
}
public
TimeStamp
(
final
long
ntpTime
)
{
this
.
ntpTime
=
ntpTime
;
}
public
TimeStamp
(
final
String
hexStamp
)
throws
NumberFormatException
{
ntpTime
=
decodeNtpHexString
(
hexStamp
)
;
}
@
Override
public
int
compareTo
(
final
TimeStamp
anotherTimeStamp
)
{
final
long
thisVal
=
this
.
ntpTime
;
final
long
anotherVal
=
anotherTimeStamp
.
ntpTime
;
return
(
Long
.
compare
(
thisVal
,
anotherVal
)
)
;
}
@
Override
public
boolean
equals
(
final
Object
obj
)
{
if
(
obj
instanceof
TimeStamp
)
{
return
ntpTime
==
(
(
TimeStamp
)
obj
)
.
ntpValue
(
)
;
}
return
false
;
}
public
Date
getDate
(
)
{
return
new
Date
(
getTime
(
ntpTime
)
)
;
}
public
long
getFraction
(
)
{
return
ntpTime
&
0xffffffffL
;
}
public
long
getSeconds
(
)
{
return
(
ntpTime
>
>
>
32
)
&
0xffffffffL
;
}
public
long
getTime
(
)
{
return
getTime
(
ntpTime
)
;
}
@
Override
public
int
hashCode
(
)
{
return
(
int
)
(
ntpTime
^
(
ntpTime
>
>
>
32
)
)
;
}
public
long
ntpValue
(
)
{
return
ntpTime
;
}
public
String
toDateString
(
)
{
if
(
simpleFormatter
==
null
)
{
simpleFormatter
=
new
SimpleDateFormat
(
NTP_DATE_FORMAT
,
Locale
.
US
)
;
simpleFormatter
.
setTimeZone
(
TimeZone
.
getDefault
(
)
)
;
}
final
Date
ntpDate
=
getDate
(
)
;
return
simpleFormatter
.
format
(
ntpDate
)
;
}
@
Override
public
String
toString
(
)
{
return
toString
(
ntpTime
)
;
}
public
String
toUTCString
(
)
{
if
(
utcFormatter
==
null
)
{
utcFormatter
=
new
SimpleDateFormat
(
NTP_DATE_FORMAT
+
" 'UTC'"
,
Locale
.
US
)
;
utcFormatter
.
setTimeZone
(
TimeZone
.
getTimeZone
(
"UTC"
)
)
;
}
final
Date
ntpDate
=
getDate
(
)
;
return
utcFormatter
.
format
(
ntpDate
)
;
}
private
void
writeObject
(
final
java
.
io
.
ObjectOutputStream
out
)
throws
IOException
{
throw
new
UnsupportedOperationException
(
"Serialization is not supported"
)
;
}
private
void
readObject
(
final
java
.
io
.
ObjectInputStream
in
)
throws
IOException
,
ClassNotFoundException
{
throw
new
UnsupportedOperationException
(
"Serialization is not supported"
)
;
}
}
<EOF>
