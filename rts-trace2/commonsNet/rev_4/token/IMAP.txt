package
org
.
apache
.
commons
.
net
.
imap
;
import
java
.
io
.
BufferedReader
;
import
java
.
io
.
BufferedWriter
;
import
java
.
io
.
EOFException
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStreamReader
;
import
java
.
io
.
OutputStreamWriter
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
List
;
import
org
.
apache
.
commons
.
net
.
SocketClient
;
import
org
.
apache
.
commons
.
net
.
io
.
CRLFLineReader
;
import
org
.
apache
.
commons
.
net
.
util
.
NetConstants
;
public
class
IMAP
extends
SocketClient
{
public
interface
IMAPChunkListener
{
boolean
chunkReceived
(
IMAP
imap
)
;
}
public
enum
IMAPState
{
DISCONNECTED_STATE
,
NOT_AUTH_STATE
,
AUTH_STATE
,
LOGOUT_STATE
}
public
static
final
int
DEFAULT_PORT
=
143
;
protected
static
final
String
__DEFAULT_ENCODING
=
"ISO-8859-1"
;
public
static
final
IMAPChunkListener
TRUE_CHUNK_LISTENER
=
imap
->
true
;
static
String
quoteMailboxName
(
final
String
input
)
{
if
(
input
==
null
)
{
return
null
;
}
if
(
input
.
isEmpty
(
)
)
{
return
"\"\""
;
}
if
(
input
.
length
(
)
>
1
&&
input
.
startsWith
(
"\""
)
&&
input
.
endsWith
(
"\""
)
)
{
return
input
;
}
if
(
input
.
contains
(
" "
)
)
{
return
"\""
+
input
.
replaceAll
(
"([\\\\\"])"
,
"\\\\$1"
)
+
"\""
;
}
return
input
;
}
private
IMAPState
state
;
protected
BufferedWriter
__writer
;
protected
BufferedReader
_reader
;
private
int
replyCode
;
private
final
List
<
String
>
replyLines
;
private
volatile
IMAPChunkListener
chunkListener
;
private
final
char
[
]
initialID
=
{
'A'
,
'A'
,
'A'
,
'A'
}
;
public
IMAP
(
)
{
setDefaultPort
(
DEFAULT_PORT
)
;
state
=
IMAPState
.
DISCONNECTED_STATE
;
_reader
=
null
;
__writer
=
null
;
replyLines
=
new
ArrayList
<
>
(
)
;
createCommandSupport
(
)
;
}
@
Override
protected
void
_connectAction_
(
)
throws
IOException
{
super
.
_connectAction_
(
)
;
_reader
=
new
CRLFLineReader
(
new
InputStreamReader
(
_input_
,
__DEFAULT_ENCODING
)
)
;
__writer
=
new
BufferedWriter
(
new
OutputStreamWriter
(
_output_
,
__DEFAULT_ENCODING
)
)
;
final
int
tmo
=
getSoTimeout
(
)
;
if
(
tmo
<=
0
)
{
setSoTimeout
(
connectTimeout
)
;
}
getReply
(
false
)
;
if
(
tmo
<=
0
)
{
setSoTimeout
(
tmo
)
;
}
setState
(
IMAPState
.
NOT_AUTH_STATE
)
;
}
@
Override
public
void
disconnect
(
)
throws
IOException
{
super
.
disconnect
(
)
;
_reader
=
null
;
__writer
=
null
;
replyLines
.
clear
(
)
;
setState
(
IMAPState
.
DISCONNECTED_STATE
)
;
}
public
boolean
doCommand
(
final
IMAPCommand
command
)
throws
IOException
{
return
IMAPReply
.
isSuccess
(
sendCommand
(
command
)
)
;
}
public
boolean
doCommand
(
final
IMAPCommand
command
,
final
String
args
)
throws
IOException
{
return
IMAPReply
.
isSuccess
(
sendCommand
(
command
,
args
)
)
;
}
@
Override
protected
void
fireReplyReceived
(
final
int
replyCode
,
final
String
ignored
)
{
if
(
getCommandSupport
(
)
.
getListenerCount
(
)
>
0
)
{
getCommandSupport
(
)
.
fireReplyReceived
(
replyCode
,
getReplyString
(
)
)
;
}
}
protected
String
generateCommandID
(
)
{
final
String
res
=
new
String
(
initialID
)
;
boolean
carry
=
true
;
for
(
int
i
=
initialID
.
length
-
1
;
carry
&&
i
>=
0
;
i
--
)
{
if
(
initialID
[
i
]
==
'Z'
)
{
initialID
[
i
]
=
'A'
;
}
else
{
initialID
[
i
]
++
;
carry
=
false
;
}
}
return
res
;
}
private
void
getReply
(
)
throws
IOException
{
getReply
(
true
)
;
}
private
void
getReply
(
final
boolean
wantTag
)
throws
IOException
{
replyLines
.
clear
(
)
;
String
line
=
_reader
.
readLine
(
)
;
if
(
line
==
null
)
{
throw
new
EOFException
(
"Connection closed without indication."
)
;
}
replyLines
.
add
(
line
)
;
if
(
wantTag
)
{
while
(
IMAPReply
.
isUntagged
(
line
)
)
{
int
literalCount
=
IMAPReply
.
literalCount
(
line
)
;
final
boolean
isMultiLine
=
literalCount
>=
0
;
while
(
literalCount
>=
0
)
{
line
=
_reader
.
readLine
(
)
;
if
(
line
==
null
)
{
throw
new
EOFException
(
"Connection closed without indication."
)
;
}
replyLines
.
add
(
line
)
;
literalCount
-=
line
.
length
(
)
+
2
;
}
if
(
isMultiLine
)
{
final
IMAPChunkListener
il
=
chunkListener
;
if
(
il
!=
null
)
{
final
boolean
clear
=
il
.
chunkReceived
(
this
)
;
if
(
clear
)
{
fireReplyReceived
(
IMAPReply
.
PARTIAL
,
getReplyString
(
)
)
;
replyLines
.
clear
(
)
;
}
}
}
line
=
_reader
.
readLine
(
)
;
if
(
line
==
null
)
{
throw
new
EOFException
(
"Connection closed without indication."
)
;
}
replyLines
.
add
(
line
)
;
}
replyCode
=
IMAPReply
.
getReplyCode
(
line
)
;
}
else
{
replyCode
=
IMAPReply
.
getUntaggedReplyCode
(
line
)
;
}
fireReplyReceived
(
replyCode
,
getReplyString
(
)
)
;
}
public
String
getReplyString
(
)
{
final
StringBuilder
buffer
=
new
StringBuilder
(
256
)
;
for
(
final
String
s
:
replyLines
)
{
buffer
.
append
(
s
)
;
buffer
.
append
(
SocketClient
.
NETASCII_EOL
)
;
}
return
buffer
.
toString
(
)
;
}
public
String
[
]
getReplyStrings
(
)
{
return
replyLines
.
toArray
(
NetConstants
.
EMPTY_STRING_ARRAY
)
;
}
public
IMAP
.
IMAPState
getState
(
)
{
return
state
;
}
public
int
sendCommand
(
final
IMAPCommand
command
)
throws
IOException
{
return
sendCommand
(
command
,
null
)
;
}
public
int
sendCommand
(
final
IMAPCommand
command
,
final
String
args
)
throws
IOException
{
return
sendCommand
(
command
.
getIMAPCommand
(
)
,
args
)
;
}
public
int
sendCommand
(
final
String
command
)
throws
IOException
{
return
sendCommand
(
command
,
null
)
;
}
public
int
sendCommand
(
final
String
command
,
final
String
args
)
throws
IOException
{
return
sendCommandWithID
(
generateCommandID
(
)
,
command
,
args
)
;
}
private
int
sendCommandWithID
(
final
String
commandID
,
final
String
command
,
final
String
args
)
throws
IOException
{
final
StringBuilder
__commandBuffer
=
new
StringBuilder
(
)
;
if
(
commandID
!=
null
)
{
__commandBuffer
.
append
(
commandID
)
;
__commandBuffer
.
append
(
' '
)
;
}
__commandBuffer
.
append
(
command
)
;
if
(
args
!=
null
)
{
__commandBuffer
.
append
(
' '
)
;
__commandBuffer
.
append
(
args
)
;
}
__commandBuffer
.
append
(
SocketClient
.
NETASCII_EOL
)
;
final
String
message
=
__commandBuffer
.
toString
(
)
;
__writer
.
write
(
message
)
;
__writer
.
flush
(
)
;
fireCommandSent
(
command
,
message
)
;
getReply
(
)
;
return
replyCode
;
}
public
int
sendData
(
final
String
command
)
throws
IOException
{
return
sendCommandWithID
(
null
,
command
,
null
)
;
}
public
void
setChunkListener
(
final
IMAPChunkListener
listener
)
{
chunkListener
=
listener
;
}
protected
void
setState
(
final
IMAP
.
IMAPState
state
)
{
this
.
state
=
state
;
}
}
<EOF>
