package
org
.
apache
.
commons
.
net
.
telnet
;
import
java
.
io
.
IOException
;
import
java
.
io
.
OutputStream
;
final
class
TelnetOutputStream
extends
OutputStream
{
private
final
TelnetClient
client
;
private
final
boolean
convertCRtoCRLF
=
true
;
private
boolean
lastWasCR
;
TelnetOutputStream
(
final
TelnetClient
client
)
{
this
.
client
=
client
;
}
@
Override
public
void
close
(
)
throws
IOException
{
client
.
closeOutputStream
(
)
;
}
@
Override
public
void
flush
(
)
throws
IOException
{
client
.
flushOutputStream
(
)
;
}
@
Override
public
void
write
(
final
byte
buffer
[
]
)
throws
IOException
{
write
(
buffer
,
0
,
buffer
.
length
)
;
}
@
Override
public
void
write
(
final
byte
buffer
[
]
,
int
offset
,
int
length
)
throws
IOException
{
synchronized
(
client
)
{
while
(
length
--
>
0
)
{
write
(
buffer
[
offset
++
]
)
;
}
}
}
@
Override
public
void
write
(
int
ch
)
throws
IOException
{
synchronized
(
client
)
{
ch
&=
0xff
;
if
(
client
.
requestedWont
(
TelnetOption
.
BINARY
)
)
{
if
(
lastWasCR
)
{
if
(
convertCRtoCRLF
)
{
client
.
sendByte
(
'\n'
)
;
if
(
ch
==
'\n'
)
{
lastWasCR
=
false
;
return
;
}
}
else
if
(
ch
!=
'\n'
)
{
client
.
sendByte
(
'\0'
)
;
}
}
switch
(
ch
)
{
case
'\r'
:
client
.
sendByte
(
'\r'
)
;
lastWasCR
=
true
;
break
;
case
'\n'
:
if
(
!
lastWasCR
)
{
client
.
sendByte
(
'\r'
)
;
}
client
.
sendByte
(
ch
)
;
lastWasCR
=
false
;
break
;
case
TelnetCommand
.
IAC
:
client
.
sendByte
(
TelnetCommand
.
IAC
)
;
client
.
sendByte
(
TelnetCommand
.
IAC
)
;
lastWasCR
=
false
;
break
;
default
:
client
.
sendByte
(
ch
)
;
lastWasCR
=
false
;
break
;
}
}
else
if
(
ch
==
TelnetCommand
.
IAC
)
{
client
.
sendByte
(
ch
)
;
client
.
sendByte
(
TelnetCommand
.
IAC
)
;
}
else
{
client
.
sendByte
(
ch
)
;
}
}
}
}
<EOF>
