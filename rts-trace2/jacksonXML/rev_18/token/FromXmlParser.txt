package
com
.
fasterxml
.
jackson
.
dataformat
.
xml
.
deser
;
import
java
.
io
.
IOException
;
import
java
.
io
.
UncheckedIOException
;
import
java
.
io
.
Writer
;
import
java
.
math
.
BigDecimal
;
import
java
.
math
.
BigInteger
;
import
java
.
util
.
Set
;
import
javax
.
xml
.
stream
.
XMLStreamException
;
import
javax
.
xml
.
stream
.
XMLStreamReader
;
import
javax
.
xml
.
stream
.
XMLStreamWriter
;
import
com
.
fasterxml
.
jackson
.
core
.
*
;
import
com
.
fasterxml
.
jackson
.
core
.
base
.
ParserMinimalBase
;
import
com
.
fasterxml
.
jackson
.
core
.
exc
.
StreamConstraintsException
;
import
com
.
fasterxml
.
jackson
.
core
.
io
.
IOContext
;
import
com
.
fasterxml
.
jackson
.
core
.
io
.
NumberInput
;
import
com
.
fasterxml
.
jackson
.
core
.
util
.
ByteArrayBuilder
;
import
com
.
fasterxml
.
jackson
.
core
.
util
.
JacksonFeatureSet
;
import
com
.
fasterxml
.
jackson
.
dataformat
.
xml
.
PackageVersion
;
import
com
.
fasterxml
.
jackson
.
dataformat
.
xml
.
XmlMapper
;
import
com
.
fasterxml
.
jackson
.
dataformat
.
xml
.
XmlNameProcessor
;
import
com
.
fasterxml
.
jackson
.
dataformat
.
xml
.
util
.
CaseInsensitiveNameSet
;
import
com
.
fasterxml
.
jackson
.
dataformat
.
xml
.
util
.
StaxUtil
;
public
class
FromXmlParser
extends
ParserMinimalBase
implements
ElementWrappable
{
public
final
static
String
DEFAULT_UNNAMED_TEXT_PROPERTY
=
""
;
protected
final
static
JacksonFeatureSet
<
StreamReadCapability
>
XML_READ_CAPABILITIES
=
DEFAULT_READ_CAPABILITIES
.
with
(
StreamReadCapability
.
DUPLICATE_PROPERTIES
)
.
with
(
StreamReadCapability
.
SCALARS_AS_OBJECTS
)
.
with
(
StreamReadCapability
.
UNTYPED_SCALARS
)
;
public
enum
Feature
implements
FormatFeature
{
EMPTY_ELEMENT_AS_NULL
(
false
)
,
PROCESS_XSI_NIL
(
true
)
,
;
final
boolean
_defaultState
;
final
int
_mask
;
public
static
int
collectDefaults
(
)
{
int
flags
=
0
;
for
(
Feature
f
:
values
(
)
)
{
if
(
f
.
enabledByDefault
(
)
)
{
flags
|=
f
.
getMask
(
)
;
}
}
return
flags
;
}
private
Feature
(
boolean
defaultState
)
{
_defaultState
=
defaultState
;
_mask
=
(
1
<
<
ordinal
(
)
)
;
}
@
Override
public
boolean
enabledByDefault
(
)
{
return
_defaultState
;
}
@
Override
public
int
getMask
(
)
{
return
_mask
;
}
@
Override
public
boolean
enabledIn
(
int
flags
)
{
return
(
flags
&
getMask
(
)
)
!=
0
;
}
}
protected
String
_cfgNameForTextElement
=
DEFAULT_UNNAMED_TEXT_PROPERTY
;
protected
int
_formatFeatures
;
protected
ObjectCodec
_objectCodec
;
protected
final
IOContext
_ioContext
;
protected
final
StreamReadConstraints
_streamReadConstraints
;
protected
boolean
_closed
;
protected
XmlReadContext
_parsingContext
;
protected
final
XmlTokenStream
_xmlTokens
;
protected
boolean
_mayBeLeaf
;
protected
JsonToken
_nextToken
;
protected
String
_currText
;
protected
boolean
_nextIsLeadingMixed
;
protected
ByteArrayBuilder
_byteArrayBuilder
=
null
;
protected
byte
[
]
_binaryValue
;
protected
int
_numTypesValid
=
NR_UNKNOWN
;
protected
int
_numberInt
;
protected
long
_numberLong
;
protected
BigInteger
_numberBigInt
;
public
FromXmlParser
(
IOContext
ctxt
,
int
genericParserFeatures
,
int
xmlFeatures
,
ObjectCodec
codec
,
XMLStreamReader
xmlReader
,
XmlNameProcessor
tagProcessor
)
throws
IOException
{
super
(
genericParserFeatures
)
;
_formatFeatures
=
xmlFeatures
;
_ioContext
=
ctxt
;
_streamReadConstraints
=
ctxt
.
streamReadConstraints
(
)
;
_objectCodec
=
codec
;
_parsingContext
=
XmlReadContext
.
createRootContext
(
-
1
,
-
1
)
;
_xmlTokens
=
new
XmlTokenStream
(
xmlReader
,
ctxt
.
contentReference
(
)
,
_formatFeatures
,
tagProcessor
)
;
final
int
firstToken
;
try
{
firstToken
=
_xmlTokens
.
initialize
(
)
;
}
catch
(
XMLStreamException
e
)
{
StaxUtil
.
throwAsParseException
(
e
,
this
)
;
return
;
}
if
(
_xmlTokens
.
hasXsiNil
(
)
)
{
_nextToken
=
JsonToken
.
VALUE_NULL
;
}
else
{
switch
(
firstToken
)
{
case
XmlTokenStream
.
XML_START_ELEMENT
:
_nextToken
=
JsonToken
.
START_OBJECT
;
break
;
case
XmlTokenStream
.
XML_ROOT_TEXT
:
_currText
=
_xmlTokens
.
getText
(
)
;
if
(
_currText
==
null
)
{
_nextToken
=
JsonToken
.
VALUE_NULL
;
}
else
{
_nextToken
=
JsonToken
.
VALUE_STRING
;
}
break
;
default
:
_reportError
(
"Internal problem: invalid starting state (%s)"
,
_xmlTokens
.
_currentStateDesc
(
)
)
;
}
}
}
@
Override
public
Version
version
(
)
{
return
PackageVersion
.
VERSION
;
}
@
Override
public
ObjectCodec
getCodec
(
)
{
return
_objectCodec
;
}
@
Override
public
void
setCodec
(
ObjectCodec
c
)
{
_objectCodec
=
c
;
}
public
void
setXMLTextElementName
(
String
name
)
{
_cfgNameForTextElement
=
name
;
}
@
Override
public
boolean
requiresCustomCodec
(
)
{
return
true
;
}
@
Override
public
boolean
canReadObjectId
(
)
{
return
false
;
}
@
Override
public
boolean
canReadTypeId
(
)
{
return
false
;
}
@
Override
public
JacksonFeatureSet
<
StreamReadCapability
>
getReadCapabilities
(
)
{
return
XML_READ_CAPABILITIES
;
}
public
FromXmlParser
enable
(
Feature
f
)
{
_formatFeatures
|=
f
.
getMask
(
)
;
_xmlTokens
.
setFormatFeatures
(
_formatFeatures
)
;
return
this
;
}
public
FromXmlParser
disable
(
Feature
f
)
{
_formatFeatures
&=
~
f
.
getMask
(
)
;
_xmlTokens
.
setFormatFeatures
(
_formatFeatures
)
;
return
this
;
}
public
final
boolean
isEnabled
(
Feature
f
)
{
return
(
_formatFeatures
&
f
.
getMask
(
)
)
!=
0
;
}
public
FromXmlParser
configure
(
Feature
f
,
boolean
state
)
{
if
(
state
)
{
enable
(
f
)
;
}
else
{
disable
(
f
)
;
}
return
this
;
}
@
Override
public
StreamReadConstraints
streamReadConstraints
(
)
{
return
_streamReadConstraints
;
}
@
Override
public
int
getFormatFeatures
(
)
{
return
_formatFeatures
;
}
@
Override
public
JsonParser
overrideFormatFeatures
(
int
values
,
int
mask
)
{
_formatFeatures
=
(
_formatFeatures
&
~
mask
)
|
(
values
&
mask
)
;
_xmlTokens
.
setFormatFeatures
(
_formatFeatures
)
;
return
this
;
}
public
XMLStreamReader
getStaxReader
(
)
{
return
_xmlTokens
.
getXmlReader
(
)
;
}
@
Override
public
void
addVirtualWrapping
(
Set
<
String
>
namesToWrap0
,
boolean
caseInsensitive
)
{
final
Set
<
String
>
namesToWrap
=
caseInsensitive
?
CaseInsensitiveNameSet
.
construct
(
namesToWrap0
)
:
namesToWrap0
;
if
(
!
_parsingContext
.
inRoot
(
)
&&
!
_parsingContext
.
getParent
(
)
.
inRoot
(
)
)
{
String
name
=
_xmlTokens
.
getLocalName
(
)
;
if
(
(
name
!=
null
)
&&
namesToWrap
.
contains
(
name
)
)
{
_xmlTokens
.
repeatStartElement
(
)
;
}
}
_parsingContext
.
setNamesToWrap
(
namesToWrap
)
;
}
@
Override
public
String
getCurrentName
(
)
throws
IOException
{
String
name
;
if
(
_currToken
==
JsonToken
.
START_OBJECT
||
_currToken
==
JsonToken
.
START_ARRAY
)
{
XmlReadContext
parent
=
_parsingContext
.
getParent
(
)
;
name
=
parent
.
getCurrentName
(
)
;
}
else
{
name
=
_parsingContext
.
getCurrentName
(
)
;
}
if
(
name
==
null
)
{
throw
new
IllegalStateException
(
"Missing name, in state: "
+
_currToken
)
;
}
return
name
;
}
@
Override
public
void
overrideCurrentName
(
String
name
)
{
XmlReadContext
ctxt
=
_parsingContext
;
if
(
_currToken
==
JsonToken
.
START_OBJECT
||
_currToken
==
JsonToken
.
START_ARRAY
)
{
ctxt
=
ctxt
.
getParent
(
)
;
}
ctxt
.
setCurrentName
(
name
)
;
}
@
Override
public
void
close
(
)
throws
IOException
{
if
(
!
_closed
)
{
_closed
=
true
;
try
{
if
(
_ioContext
.
isResourceManaged
(
)
||
isEnabled
(
JsonParser
.
Feature
.
AUTO_CLOSE_SOURCE
)
)
{
_xmlTokens
.
closeCompletely
(
)
;
}
else
{
_xmlTokens
.
close
(
)
;
}
}
catch
(
XMLStreamException
e
)
{
StaxUtil
.
throwAsParseException
(
e
,
this
)
;
}
finally
{
_releaseBuffers
(
)
;
}
}
}
@
Override
public
boolean
isClosed
(
)
{
return
_closed
;
}
@
Override
public
XmlReadContext
getParsingContext
(
)
{
return
_parsingContext
;
}
@
Override
public
JsonLocation
getTokenLocation
(
)
{
return
_xmlTokens
.
getTokenLocation
(
)
;
}
@
Override
public
JsonLocation
getCurrentLocation
(
)
{
return
_xmlTokens
.
getCurrentLocation
(
)
;
}
@
Override
public
boolean
isExpectedStartArrayToken
(
)
{
JsonToken
t
=
_currToken
;
if
(
t
==
JsonToken
.
START_OBJECT
)
{
_currToken
=
JsonToken
.
START_ARRAY
;
_parsingContext
.
convertToArray
(
)
;
if
(
_nextToken
==
JsonToken
.
END_OBJECT
)
{
_nextToken
=
JsonToken
.
END_ARRAY
;
}
else
{
_nextToken
=
null
;
}
_xmlTokens
.
skipAttributes
(
)
;
return
true
;
}
return
(
t
==
JsonToken
.
START_ARRAY
)
;
}
@
Override
public
boolean
isExpectedNumberIntToken
(
)
{
JsonToken
t
=
_currToken
;
if
(
t
==
JsonToken
.
VALUE_STRING
)
{
final
String
text
=
_currText
.
trim
(
)
;
final
int
len
=
_isIntNumber
(
text
)
;
if
(
len
>
0
)
{
if
(
len
<=
9
)
{
_numberInt
=
NumberInput
.
parseInt
(
text
)
;
_numTypesValid
=
NR_INT
;
_currToken
=
JsonToken
.
VALUE_NUMBER_INT
;
return
true
;
}
if
(
len
<=
18
)
{
long
l
=
NumberInput
.
parseLong
(
text
)
;
if
(
len
==
10
)
{
int
asInt
=
(
int
)
l
;
long
l2
=
(
long
)
asInt
;
if
(
l
==
l2
)
{
_numberInt
=
asInt
;
_numTypesValid
=
NR_INT
;
_currToken
=
JsonToken
.
VALUE_NUMBER_INT
;
return
true
;
}
}
_numberLong
=
l
;
_numTypesValid
=
NR_LONG
;
_currToken
=
JsonToken
.
VALUE_NUMBER_INT
;
return
true
;
}
if
(
len
==
19
)
{
final
boolean
stillLong
;
if
(
text
.
charAt
(
0
)
==
'-'
)
{
stillLong
=
NumberInput
.
inLongRange
(
text
.
substring
(
1
)
,
true
)
;
}
else
{
stillLong
=
NumberInput
.
inLongRange
(
text
,
false
)
;
}
if
(
stillLong
)
{
_numberLong
=
NumberInput
.
parseLong
(
text
)
;
_numTypesValid
=
NR_LONG
;
_currToken
=
JsonToken
.
VALUE_NUMBER_INT
;
return
true
;
}
}
try
{
streamReadConstraints
(
)
.
validateIntegerLength
(
text
.
length
(
)
)
;
}
catch
(
StreamConstraintsException
e
)
{
throw
new
UncheckedIOException
(
e
)
;
}
_numberBigInt
=
NumberInput
.
parseBigInteger
(
text
,
isEnabled
(
StreamReadFeature
.
USE_FAST_BIG_NUMBER_PARSER
)
)
;
_numTypesValid
=
NR_BIGINT
;
_currToken
=
JsonToken
.
VALUE_NUMBER_INT
;
return
true
;
}
}
return
(
t
==
JsonToken
.
VALUE_NUMBER_INT
)
;
}
@
Override
public
JsonToken
nextToken
(
)
throws
IOException
{
_binaryValue
=
null
;
_numTypesValid
=
NR_UNKNOWN
;
if
(
_nextToken
!=
null
)
{
JsonToken
t
=
_nextToken
;
_currToken
=
t
;
_nextToken
=
null
;
switch
(
t
)
{
case
START_OBJECT
:
_parsingContext
=
_parsingContext
.
createChildObjectContext
(
-
1
,
-
1
)
;
break
;
case
START_ARRAY
:
_parsingContext
=
_parsingContext
.
createChildArrayContext
(
-
1
,
-
1
)
;
break
;
case
END_OBJECT
:
case
END_ARRAY
:
_parsingContext
=
_parsingContext
.
getParent
(
)
;
break
;
case
FIELD_NAME
:
if
(
_nextIsLeadingMixed
)
{
_nextIsLeadingMixed
=
false
;
_parsingContext
.
setCurrentName
(
_cfgNameForTextElement
)
;
_nextToken
=
JsonToken
.
VALUE_STRING
;
}
else
{
_parsingContext
.
setCurrentName
(
_xmlTokens
.
getLocalName
(
)
)
;
}
break
;
default
:
_parsingContext
.
valueStarted
(
)
;
}
return
t
;
}
int
token
=
_nextToken
(
)
;
while
(
token
==
XmlTokenStream
.
XML_START_ELEMENT
)
{
if
(
_mayBeLeaf
)
{
_nextToken
=
JsonToken
.
FIELD_NAME
;
_parsingContext
=
_parsingContext
.
createChildObjectContext
(
-
1
,
-
1
)
;
return
(
_currToken
=
JsonToken
.
START_OBJECT
)
;
}
if
(
_parsingContext
.
inArray
(
)
)
{
token
=
_nextToken
(
)
;
_mayBeLeaf
=
true
;
continue
;
}
String
name
=
_xmlTokens
.
getLocalName
(
)
;
_parsingContext
.
setCurrentName
(
name
)
;
if
(
_parsingContext
.
shouldWrap
(
name
)
)
{
_xmlTokens
.
repeatStartElement
(
)
;
}
_mayBeLeaf
=
true
;
return
(
_currToken
=
JsonToken
.
FIELD_NAME
)
;
}
while
(
true
)
{
switch
(
token
)
{
case
XmlTokenStream
.
XML_END_ELEMENT
:
if
(
_mayBeLeaf
)
{
_mayBeLeaf
=
false
;
if
(
_parsingContext
.
inArray
(
)
)
{
_nextToken
=
JsonToken
.
END_OBJECT
;
_parsingContext
=
_parsingContext
.
createChildObjectContext
(
-
1
,
-
1
)
;
return
(
_currToken
=
JsonToken
.
START_OBJECT
)
;
}
if
(
_currToken
!=
JsonToken
.
VALUE_NULL
)
{
_parsingContext
.
valueStarted
(
)
;
return
(
_currToken
=
JsonToken
.
VALUE_NULL
)
;
}
}
_currToken
=
_parsingContext
.
inArray
(
)
?
JsonToken
.
END_ARRAY
:
JsonToken
.
END_OBJECT
;
_parsingContext
=
_parsingContext
.
getParent
(
)
;
return
_currToken
;
case
XmlTokenStream
.
XML_ATTRIBUTE_NAME
:
if
(
_mayBeLeaf
)
{
_mayBeLeaf
=
false
;
_nextToken
=
JsonToken
.
FIELD_NAME
;
_currText
=
_xmlTokens
.
getText
(
)
;
_parsingContext
=
_parsingContext
.
createChildObjectContext
(
-
1
,
-
1
)
;
return
(
_currToken
=
JsonToken
.
START_OBJECT
)
;
}
_parsingContext
.
setCurrentName
(
_xmlTokens
.
getLocalName
(
)
)
;
return
(
_currToken
=
JsonToken
.
FIELD_NAME
)
;
case
XmlTokenStream
.
XML_ATTRIBUTE_VALUE
:
_currText
=
_xmlTokens
.
getText
(
)
;
_parsingContext
.
valueStarted
(
)
;
return
(
_currToken
=
JsonToken
.
VALUE_STRING
)
;
case
XmlTokenStream
.
XML_TEXT
:
_currText
=
_xmlTokens
.
getText
(
)
;
if
(
_mayBeLeaf
)
{
_mayBeLeaf
=
false
;
token
=
_nextToken
(
)
;
if
(
token
==
XmlTokenStream
.
XML_END_ELEMENT
)
{
if
(
_parsingContext
.
inArray
(
)
)
{
if
(
XmlTokenStream
.
_allWs
(
_currText
)
)
{
_nextToken
=
JsonToken
.
END_OBJECT
;
_parsingContext
=
_parsingContext
.
createChildObjectContext
(
-
1
,
-
1
)
;
return
(
_currToken
=
JsonToken
.
START_OBJECT
)
;
}
}
return
(
_currToken
=
JsonToken
.
VALUE_STRING
)
;
}
if
(
token
!=
XmlTokenStream
.
XML_START_ELEMENT
)
{
throw
new
JsonParseException
(
this
,
String
.
format
(
"Internal error: Expected END_ELEMENT (%d) or START_ELEMENT (%d), got event of type %d"
,
XmlTokenStream
.
XML_END_ELEMENT
,
XmlTokenStream
.
XML_START_ELEMENT
,
token
)
)
;
}
_xmlTokens
.
pushbackCurrentToken
(
)
;
_parsingContext
=
_parsingContext
.
createChildObjectContext
(
-
1
,
-
1
)
;
}
if
(
_parsingContext
.
inObject
(
)
)
{
if
(
_currToken
==
JsonToken
.
FIELD_NAME
)
{
_nextIsLeadingMixed
=
true
;
_nextToken
=
JsonToken
.
FIELD_NAME
;
return
(
_currToken
=
JsonToken
.
START_OBJECT
)
;
}
else
if
(
XmlTokenStream
.
_allWs
(
_currText
)
)
{
token
=
_nextToken
(
)
;
continue
;
}
}
else
if
(
_parsingContext
.
inArray
(
)
)
{
if
(
XmlTokenStream
.
_allWs
(
_currText
)
)
{
token
=
_nextToken
(
)
;
continue
;
}
throw
_constructError
(
"Unexpected non-whitespace text ('"
+
_currText
+
"' in Array context: should not occur (or should be handled)"
)
;
}
_parsingContext
.
setCurrentName
(
_cfgNameForTextElement
)
;
_nextToken
=
JsonToken
.
VALUE_STRING
;
return
(
_currToken
=
JsonToken
.
FIELD_NAME
)
;
case
XmlTokenStream
.
XML_END
:
return
(
_currToken
=
null
)
;
default
:
return
_internalErrorUnknownToken
(
token
)
;
}
}
}
@
Override
public
String
nextTextValue
(
)
throws
IOException
{
_binaryValue
=
null
;
if
(
_nextToken
!=
null
)
{
JsonToken
t
=
_nextToken
;
_currToken
=
t
;
_nextToken
=
null
;
if
(
t
==
JsonToken
.
VALUE_STRING
)
{
_parsingContext
.
valueStarted
(
)
;
return
_currText
;
}
_updateState
(
t
)
;
return
null
;
}
int
token
=
_nextToken
(
)
;
while
(
token
==
XmlTokenStream
.
XML_START_ELEMENT
)
{
if
(
_mayBeLeaf
)
{
_nextToken
=
JsonToken
.
FIELD_NAME
;
_parsingContext
=
_parsingContext
.
createChildObjectContext
(
-
1
,
-
1
)
;
_currToken
=
JsonToken
.
START_OBJECT
;
return
null
;
}
if
(
_parsingContext
.
inArray
(
)
)
{
token
=
_nextToken
(
)
;
_mayBeLeaf
=
true
;
continue
;
}
String
name
=
_xmlTokens
.
getLocalName
(
)
;
_parsingContext
.
setCurrentName
(
name
)
;
if
(
_parsingContext
.
shouldWrap
(
name
)
)
{
_xmlTokens
.
repeatStartElement
(
)
;
}
_mayBeLeaf
=
true
;
_currToken
=
JsonToken
.
FIELD_NAME
;
return
null
;
}
switch
(
token
)
{
case
XmlTokenStream
.
XML_END_ELEMENT
:
if
(
_mayBeLeaf
)
{
_mayBeLeaf
=
false
;
_currToken
=
JsonToken
.
VALUE_STRING
;
_parsingContext
.
valueStarted
(
)
;
return
(
_currText
=
""
)
;
}
_currToken
=
_parsingContext
.
inArray
(
)
?
JsonToken
.
END_ARRAY
:
JsonToken
.
END_OBJECT
;
_parsingContext
=
_parsingContext
.
getParent
(
)
;
break
;
case
XmlTokenStream
.
XML_ATTRIBUTE_NAME
:
if
(
_mayBeLeaf
)
{
_mayBeLeaf
=
false
;
_nextToken
=
JsonToken
.
FIELD_NAME
;
_currText
=
_xmlTokens
.
getText
(
)
;
_parsingContext
=
_parsingContext
.
createChildObjectContext
(
-
1
,
-
1
)
;
_currToken
=
JsonToken
.
START_OBJECT
;
}
else
{
_parsingContext
.
setCurrentName
(
_xmlTokens
.
getLocalName
(
)
)
;
_currToken
=
JsonToken
.
FIELD_NAME
;
}
break
;
case
XmlTokenStream
.
XML_ATTRIBUTE_VALUE
:
_currToken
=
JsonToken
.
VALUE_STRING
;
_parsingContext
.
valueStarted
(
)
;
return
(
_currText
=
_xmlTokens
.
getText
(
)
)
;
case
XmlTokenStream
.
XML_TEXT
:
_currText
=
_xmlTokens
.
getText
(
)
;
if
(
_mayBeLeaf
)
{
_mayBeLeaf
=
false
;
_skipEndElement
(
)
;
_parsingContext
.
valueStarted
(
)
;
_currToken
=
JsonToken
.
VALUE_STRING
;
return
_currText
;
}
_parsingContext
.
setCurrentName
(
_cfgNameForTextElement
)
;
_nextToken
=
JsonToken
.
VALUE_STRING
;
_currToken
=
JsonToken
.
FIELD_NAME
;
break
;
case
XmlTokenStream
.
XML_END
:
_currToken
=
null
;
default
:
return
_internalErrorUnknownToken
(
token
)
;
}
return
null
;
}
private
void
_updateState
(
JsonToken
t
)
{
switch
(
t
)
{
case
START_OBJECT
:
_parsingContext
=
_parsingContext
.
createChildObjectContext
(
-
1
,
-
1
)
;
break
;
case
START_ARRAY
:
_parsingContext
=
_parsingContext
.
createChildArrayContext
(
-
1
,
-
1
)
;
break
;
case
END_OBJECT
:
case
END_ARRAY
:
_parsingContext
=
_parsingContext
.
getParent
(
)
;
break
;
case
FIELD_NAME
:
_parsingContext
.
setCurrentName
(
_xmlTokens
.
getLocalName
(
)
)
;
break
;
default
:
_internalErrorUnknownToken
(
t
)
;
}
}
@
Override
public
String
getText
(
)
throws
IOException
{
if
(
_currToken
==
null
)
{
return
null
;
}
switch
(
_currToken
)
{
case
FIELD_NAME
:
return
getCurrentName
(
)
;
case
VALUE_STRING
:
return
_currText
;
default
:
return
_currToken
.
asString
(
)
;
}
}
@
Override
public
char
[
]
getTextCharacters
(
)
throws
IOException
{
String
text
=
getText
(
)
;
return
(
text
==
null
)
?
null
:
text
.
toCharArray
(
)
;
}
@
Override
public
int
getTextLength
(
)
throws
IOException
{
String
text
=
getText
(
)
;
return
(
text
==
null
)
?
0
:
text
.
length
(
)
;
}
@
Override
public
int
getTextOffset
(
)
throws
IOException
{
return
0
;
}
@
Override
public
boolean
hasTextCharacters
(
)
{
return
false
;
}
@
Override
public
int
getText
(
Writer
writer
)
throws
IOException
{
String
str
=
getText
(
)
;
if
(
str
==
null
)
{
return
0
;
}
writer
.
write
(
str
)
;
return
str
.
length
(
)
;
}
@
Override
public
Object
getEmbeddedObject
(
)
throws
IOException
{
return
null
;
}
@
Override
public
byte
[
]
getBinaryValue
(
Base64Variant
b64variant
)
throws
IOException
{
if
(
_currToken
!=
JsonToken
.
VALUE_STRING
&&
(
_currToken
!=
JsonToken
.
VALUE_EMBEDDED_OBJECT
||
_binaryValue
==
null
)
)
{
_reportError
(
"Current token ("
+
_currToken
+
") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary"
)
;
}
if
(
_binaryValue
==
null
)
{
try
{
_binaryValue
=
_decodeBase64
(
b64variant
)
;
}
catch
(
IllegalArgumentException
iae
)
{
throw
_constructError
(
"Failed to decode VALUE_STRING as base64 ("
+
b64variant
+
"): "
+
iae
.
getMessage
(
)
)
;
}
}
return
_binaryValue
;
}
@
SuppressWarnings
(
"resource"
)
protected
byte
[
]
_decodeBase64
(
Base64Variant
b64variant
)
throws
IOException
{
ByteArrayBuilder
builder
=
_getByteArrayBuilder
(
)
;
final
String
str
=
getText
(
)
;
_decodeBase64
(
str
,
builder
,
b64variant
)
;
return
builder
.
toByteArray
(
)
;
}
@
Override
public
boolean
isNaN
(
)
{
return
false
;
}
@
Override
public
NumberType
getNumberType
(
)
throws
IOException
{
if
(
_numTypesValid
==
NR_UNKNOWN
)
{
_checkNumericValue
(
NR_UNKNOWN
)
;
}
if
(
(
_numTypesValid
&
NR_INT
)
!=
0
)
{
return
NumberType
.
INT
;
}
if
(
(
_numTypesValid
&
NR_LONG
)
!=
0
)
{
return
NumberType
.
LONG
;
}
return
NumberType
.
BIG_INTEGER
;
}
@
Override
public
Number
getNumberValue
(
)
throws
IOException
{
if
(
_numTypesValid
==
NR_UNKNOWN
)
{
_checkNumericValue
(
NR_UNKNOWN
)
;
}
if
(
(
_numTypesValid
&
NR_INT
)
!=
0
)
{
return
_numberInt
;
}
if
(
(
_numTypesValid
&
NR_LONG
)
!=
0
)
{
return
_numberLong
;
}
if
(
(
_numTypesValid
&
NR_BIGINT
)
!=
0
)
{
return
_numberBigInt
;
}
_throwInternal
(
)
;
return
null
;
}
@
Override
public
int
getIntValue
(
)
throws
IOException
{
if
(
(
_numTypesValid
&
NR_INT
)
==
0
)
{
if
(
_numTypesValid
==
NR_UNKNOWN
)
{
_checkNumericValue
(
NR_INT
)
;
}
if
(
(
_numTypesValid
&
NR_INT
)
==
0
)
{
_convertNumberToInt
(
)
;
}
}
return
_numberInt
;
}
@
Override
public
long
getLongValue
(
)
throws
IOException
{
if
(
(
_numTypesValid
&
NR_LONG
)
==
0
)
{
if
(
_numTypesValid
==
NR_UNKNOWN
)
{
_checkNumericValue
(
NR_LONG
)
;
}
if
(
(
_numTypesValid
&
NR_LONG
)
==
0
)
{
_convertNumberToLong
(
)
;
}
}
return
_numberLong
;
}
@
Override
public
BigInteger
getBigIntegerValue
(
)
throws
IOException
{
if
(
(
_numTypesValid
&
NR_BIGINT
)
==
0
)
{
if
(
_numTypesValid
==
NR_UNKNOWN
)
{
_checkNumericValue
(
NR_BIGINT
)
;
}
if
(
(
_numTypesValid
&
NR_BIGINT
)
==
0
)
{
_convertNumberToBigInteger
(
)
;
}
}
return
_numberBigInt
;
}
@
Override
public
float
getFloatValue
(
)
throws
IOException
{
if
(
(
_numTypesValid
&
NR_FLOAT
)
==
0
)
{
if
(
_numTypesValid
==
NR_UNKNOWN
)
{
_checkNumericValue
(
NR_FLOAT
)
;
}
}
return
_convertNumberToFloat
(
)
;
}
@
Override
public
double
getDoubleValue
(
)
throws
IOException
{
if
(
(
_numTypesValid
&
NR_DOUBLE
)
==
0
)
{
if
(
_numTypesValid
==
NR_UNKNOWN
)
{
_checkNumericValue
(
NR_DOUBLE
)
;
}
}
return
_convertNumberToDouble
(
)
;
}
@
Override
public
BigDecimal
getDecimalValue
(
)
throws
IOException
{
if
(
(
_numTypesValid
&
NR_BIGDECIMAL
)
==
0
)
{
if
(
_numTypesValid
==
NR_UNKNOWN
)
{
_checkNumericValue
(
NR_BIGDECIMAL
)
;
}
}
return
_convertNumberToBigDecimal
(
)
;
}
protected
final
void
_checkNumericValue
(
int
expType
)
throws
IOException
{
if
(
_currToken
==
JsonToken
.
VALUE_NUMBER_INT
)
{
return
;
}
_reportError
(
"Current token ("
+
currentToken
(
)
+
") not numeric, can not use numeric value accessors"
)
;
}
protected
final
int
_isIntNumber
(
String
text
)
{
final
int
len
=
text
.
length
(
)
;
if
(
len
>
0
)
{
char
c
=
text
.
charAt
(
0
)
;
final
int
start
=
(
c
==
'-'
)
?
1
:
0
;
for
(
int
i
=
start
;
i
<
len
;
++
i
)
{
int
ch
=
text
.
charAt
(
i
)
;
if
(
ch
>
'9'
||
ch
<
'0'
)
{
return
-
1
;
}
}
return
len
-
start
;
}
return
0
;
}
protected
void
_convertNumberToInt
(
)
throws
IOException
{
if
(
(
_numTypesValid
&
NR_LONG
)
!=
0
)
{
int
result
=
(
int
)
_numberLong
;
if
(
(
(
long
)
result
)
!=
_numberLong
)
{
_reportError
(
"Numeric value ("
+
getText
(
)
+
") out of range of int"
)
;
}
_numberInt
=
result
;
}
else
if
(
(
_numTypesValid
&
NR_BIGINT
)
!=
0
)
{
if
(
BI_MIN_INT
.
compareTo
(
_numberBigInt
)
>
0
||
BI_MAX_INT
.
compareTo
(
_numberBigInt
)
<
0
)
{
reportOverflowInt
(
)
;
}
_numberInt
=
_numberBigInt
.
intValue
(
)
;
}
else
{
_throwInternal
(
)
;
}
_numTypesValid
|=
NR_INT
;
}
protected
void
_convertNumberToLong
(
)
throws
IOException
{
if
(
(
_numTypesValid
&
NR_INT
)
!=
0
)
{
_numberLong
=
(
long
)
_numberInt
;
}
else
if
(
(
_numTypesValid
&
NR_BIGINT
)
!=
0
)
{
if
(
BI_MIN_LONG
.
compareTo
(
_numberBigInt
)
>
0
||
BI_MAX_LONG
.
compareTo
(
_numberBigInt
)
<
0
)
{
reportOverflowLong
(
)
;
}
_numberLong
=
_numberBigInt
.
longValue
(
)
;
}
else
{
_throwInternal
(
)
;
}
_numTypesValid
|=
NR_LONG
;
}
protected
void
_convertNumberToBigInteger
(
)
throws
IOException
{
if
(
(
_numTypesValid
&
NR_LONG
)
!=
0
)
{
_numberBigInt
=
BigInteger
.
valueOf
(
_numberLong
)
;
}
else
if
(
(
_numTypesValid
&
NR_INT
)
!=
0
)
{
_numberBigInt
=
BigInteger
.
valueOf
(
_numberInt
)
;
}
else
{
_throwInternal
(
)
;
}
_numTypesValid
|=
NR_BIGINT
;
}
protected
float
_convertNumberToFloat
(
)
throws
IOException
{
if
(
(
_numTypesValid
&
NR_BIGINT
)
!=
0
)
{
return
_numberBigInt
.
floatValue
(
)
;
}
if
(
(
_numTypesValid
&
NR_LONG
)
!=
0
)
{
return
(
float
)
_numberLong
;
}
if
(
(
_numTypesValid
&
NR_INT
)
!=
0
)
{
return
(
float
)
_numberInt
;
}
_throwInternal
(
)
;
return
0.0f
;
}
protected
double
_convertNumberToDouble
(
)
throws
IOException
{
if
(
(
_numTypesValid
&
NR_BIGINT
)
!=
0
)
{
return
_numberBigInt
.
doubleValue
(
)
;
}
if
(
(
_numTypesValid
&
NR_LONG
)
!=
0
)
{
return
(
double
)
_numberLong
;
}
if
(
(
_numTypesValid
&
NR_INT
)
!=
0
)
{
return
(
double
)
_numberInt
;
}
_throwInternal
(
)
;
return
0.0
;
}
protected
BigDecimal
_convertNumberToBigDecimal
(
)
throws
IOException
{
if
(
(
_numTypesValid
&
NR_BIGINT
)
!=
0
)
{
return
new
BigDecimal
(
_numberBigInt
)
;
}
if
(
(
_numTypesValid
&
NR_LONG
)
!=
0
)
{
return
BigDecimal
.
valueOf
(
_numberLong
)
;
}
if
(
(
_numTypesValid
&
NR_INT
)
!=
0
)
{
return
BigDecimal
.
valueOf
(
_numberInt
)
;
}
_throwInternal
(
)
;
return
null
;
}
@
Override
protected
void
_handleEOF
(
)
throws
JsonParseException
{
if
(
!
_parsingContext
.
inRoot
(
)
)
{
String
marker
=
_parsingContext
.
inArray
(
)
?
"Array"
:
"Object"
;
_reportInvalidEOF
(
String
.
format
(
": expected close marker for %s (start marker at %s)"
,
marker
,
_parsingContext
.
startLocation
(
_ioContext
.
contentReference
(
)
)
)
,
null
)
;
}
}
protected
void
_releaseBuffers
(
)
throws
IOException
{
}
protected
ByteArrayBuilder
_getByteArrayBuilder
(
)
{
if
(
_byteArrayBuilder
==
null
)
{
_byteArrayBuilder
=
new
ByteArrayBuilder
(
)
;
}
else
{
_byteArrayBuilder
.
reset
(
)
;
}
return
_byteArrayBuilder
;
}
private
<
T
>
T
_internalErrorUnknownToken
(
Object
token
)
{
throw
new
IllegalStateException
(
"Internal error: unrecognized XmlTokenStream token: "
+
token
)
;
}
protected
int
_nextToken
(
)
throws
IOException
{
try
{
return
_xmlTokens
.
next
(
)
;
}
catch
(
XMLStreamException
e
)
{
return
StaxUtil
.
throwAsParseException
(
e
,
this
)
;
}
catch
(
IllegalStateException
e
)
{
throw
new
JsonParseException
(
this
,
e
.
getMessage
(
)
,
e
)
;
}
}
protected
void
_skipEndElement
(
)
throws
IOException
{
try
{
_xmlTokens
.
skipEndElement
(
)
;
}
catch
(
XMLStreamException
e
)
{
StaxUtil
.
throwAsParseException
(
e
,
this
)
;
}
catch
(
Exception
e
)
{
throw
new
JsonParseException
(
this
,
e
.
getMessage
(
)
,
e
)
;
}
}
}
<EOF>
